L 1 "C:\Keil_v5\ARM\PACK\Keil\MDR1986BExx\1.5.3\Libraries\MDR32F9Qx_StdPeriph_Driver\src\MDR32F9Qx_timer.c"
N/**
N  * FILE MDR32F9Qx_timer.c
N  */
N
N/* Includes ------------------------------------------------------------------*/
N#include "MDR32F9Qx_timer.h"
L 1 "C:\Keil_v5\ARM\PACK\Keil\MDR1986BExx\1.5.3\Libraries\MDR32F9Qx_StdPeriph_Driver\inc\MDR32F9Qx_timer.h" 1
N/**
N  * FILE MDR32F9Qx_timer.h
N  */
N
N/* Define to prevent recursive inclusion -------------------------------------*/
N#ifndef __MDR32F9QX_TIMER_H
N#define __MDR32F9QX_TIMER_H
N
N#ifdef __cplusplus
Sextern "C" {
N#endif
N
N/* Includes ------------------------------------------------------------------*/
N#include "MDR32F9Qx_config.h"
L 1 ".\RTE\Device\MDR1986BE92\MDR32F9Qx_config.h" 1
N/**
N  ******************************************************************************
N  * @file    MDR32F9Qx_Demo\Project\Demo\MDR32F9Qx_config.h
N  * @author  Milandr Application Team
N  * @version V1.2.0
N  * @date    10/07/2010
N  * @brief   Library configuration file.
N  ******************************************************************************
N  * <br><br>
N  * THE PRESENT FIRMWARE WHICH IS FOR GUIDANCE ONLY AIMS AT PROVIDING CUSTOMERS
N  * WITH CODING INFORMATION REGARDING THEIR PRODUCTS IN ORDER FOR THEM TO SAVE
N  * TIME. AS A RESULT, MILANDR SHALL NOT BE HELD LIABLE FOR ANY
N  * DIRECT, INDIRECT OR CONSEQUENTIAL DAMAGES WITH RESPECT TO ANY CLAIMS ARISING
N  * FROM THE CONTENT OF SUCH FIRMWARE AND/OR THE USE MADE BY CUSTOMERS OF THE
N  * CODING INFORMATION CONTAINED HEREIN IN CONNECTION WITH THEIR PRODUCTS.
N  *
N  * <h2><center>&copy; COPYRIGHT 2014 Milandr</center></h2>
N  */
N
N/**
N * @mainpage MDR32F9Qx Standard Peripherals Library.
N * MDR32F9Qx Standard Peripherals Library is a package consisting of
N * all standard peripheral device drivers for 1986BE9x, K1986BE9x, MDR32F9Qx,
N * 1986VE1T, 1986VE3T, 1986VE7T microcontrollers.
N * This library is a firmware package which contains a collection of routines,
N * data structures and macros covering the features of Milandr MDR32F9Qx
N * peripherals. It includes a description of the device drivers plus a set of
N * examples for each peripheral. The firmware library allows any device to be
N * used in the user application without the need for in-depth study of each
N * peripherals specifications. Using the Standard Peripherals Library has two
N * advantages: it saves significant time that would otherwise be spent in
N * coding, while simultaneously reducing application development and
N * integration costs.
N *
N * The MDR32F9Qx Standard Peripherals Library is compatible with Milandr
N * 1986BE9x evaluation boards, Milandr evaluation board for MC 1986VE1T
N * (EVAL 22.0 B) and evaluation board for MC 1986VE3T.
N *
N * The MDR32F9Qx Standard Peripherals Library is full CMSIS compliant.
N */
N
N/* Define to prevent recursive inclusion -------------------------------------*/
N#ifndef __MDR32F9Qx_CONFIG_H
N#define __MDR32F9Qx_CONFIG_H
N
N#if ((__CC_ARM == 0) || (__ARMCC_VERSION < 5000000))
X#if ((1 == 0) || (5060528 < 5000000))
S	#include "MDR32F9Qx_board.h"
N#endif
N//#include "MDR32F9Qx_lib.h"  - не компилируется если не подключено хотя бы одного драйвера, не видит пути
N#include <stdint.h>
L 1 "C:\Keil_v5\ARM\ARMCC\Bin\..\include\stdint.h" 1
N/* Copyright (C) ARM Ltd., 1999,2014 */
N/* All rights reserved */
N
N/*
N * RCS $Revision$
N * Checkin $Date$
N * Revising $Author: agrant $
N */
N
N#ifndef __stdint_h
N#define __stdint_h
N#define __ARMCLIB_VERSION 5060034
N
N  #ifdef __INT64_TYPE__
S    /* armclang predefines '__INT64_TYPE__' and '__INT64_C_SUFFIX__' */
S    #define __INT64 __INT64_TYPE__
N  #else
N    /* armcc has builtin '__int64' which can be used in --strict mode */
N    #define __INT64 __int64
N    #define __INT64_C_SUFFIX__ ll
N  #endif
N  #define __PASTE2(x, y) x ## y
N  #define __PASTE(x, y) __PASTE2(x, y)
N  #define __INT64_C(x)  __ESCAPE__(__PASTE(x, __INT64_C_SUFFIX__))
N  #define __UINT64_C(x)  __ESCAPE__(__PASTE(x ## u, __INT64_C_SUFFIX__))
N  #if defined(__clang__) || (defined(__ARMCC_VERSION) && !defined(__STRICT_ANSI__))
X  #if 0L || (1L && !0L)
N    /* armclang and non-strict armcc allow 'long long' in system headers */
N    #define __LONGLONG long long
N  #else
S    /* strict armcc has '__int64' */
S    #define __LONGLONG __int64
N  #endif
N
N  #ifndef __STDINT_DECLS
N  #define __STDINT_DECLS
N
N    #undef __CLIBNS
N
N    #ifdef __cplusplus
S      namespace std {
S          #define __CLIBNS std::
S          extern "C" {
N    #else
N      #define __CLIBNS
N    #endif  /* __cplusplus */
N
N
N/*
N * 'signed' is redundant below, except for 'signed char' and if
N * the typedef is used to declare a bitfield.
N */
N
N    /* 7.18.1.1 */
N
N    /* exact-width signed integer types */
Ntypedef   signed          char int8_t;
Ntypedef   signed short     int int16_t;
Ntypedef   signed           int int32_t;
Ntypedef   signed       __INT64 int64_t;
Xtypedef   signed       __int64 int64_t;
N
N    /* exact-width unsigned integer types */
Ntypedef unsigned          char uint8_t;
Ntypedef unsigned short     int uint16_t;
Ntypedef unsigned           int uint32_t;
Ntypedef unsigned       __INT64 uint64_t;
Xtypedef unsigned       __int64 uint64_t;
N
N    /* 7.18.1.2 */
N
N    /* smallest type of at least n bits */
N    /* minimum-width signed integer types */
Ntypedef   signed          char int_least8_t;
Ntypedef   signed short     int int_least16_t;
Ntypedef   signed           int int_least32_t;
Ntypedef   signed       __INT64 int_least64_t;
Xtypedef   signed       __int64 int_least64_t;
N
N    /* minimum-width unsigned integer types */
Ntypedef unsigned          char uint_least8_t;
Ntypedef unsigned short     int uint_least16_t;
Ntypedef unsigned           int uint_least32_t;
Ntypedef unsigned       __INT64 uint_least64_t;
Xtypedef unsigned       __int64 uint_least64_t;
N
N    /* 7.18.1.3 */
N
N    /* fastest minimum-width signed integer types */
Ntypedef   signed           int int_fast8_t;
Ntypedef   signed           int int_fast16_t;
Ntypedef   signed           int int_fast32_t;
Ntypedef   signed       __INT64 int_fast64_t;
Xtypedef   signed       __int64 int_fast64_t;
N
N    /* fastest minimum-width unsigned integer types */
Ntypedef unsigned           int uint_fast8_t;
Ntypedef unsigned           int uint_fast16_t;
Ntypedef unsigned           int uint_fast32_t;
Ntypedef unsigned       __INT64 uint_fast64_t;
Xtypedef unsigned       __int64 uint_fast64_t;
N
N    /* 7.18.1.4 integer types capable of holding object pointers */
N#if __sizeof_ptr == 8
X#if 4 == 8
Stypedef   signed       __INT64 intptr_t;
Stypedef unsigned       __INT64 uintptr_t;
N#else
Ntypedef   signed           int intptr_t;
Ntypedef unsigned           int uintptr_t;
N#endif
N
N    /* 7.18.1.5 greatest-width integer types */
Ntypedef   signed     __LONGLONG intmax_t;
Xtypedef   signed     long long intmax_t;
Ntypedef unsigned     __LONGLONG uintmax_t;
Xtypedef unsigned     long long uintmax_t;
N
N
N#if !defined(__cplusplus) || defined(__STDC_LIMIT_MACROS)
X#if !0L || 0L
N
N    /* 7.18.2.1 */
N
N    /* minimum values of exact-width signed integer types */
N#define INT8_MIN                   -128
N#define INT16_MIN                -32768
N#define INT32_MIN          (~0x7fffffff)   /* -2147483648 is unsigned */
N#define INT64_MIN  __INT64_C(~0x7fffffffffffffff) /* -9223372036854775808 is unsigned */
N
N    /* maximum values of exact-width signed integer types */
N#define INT8_MAX                    127
N#define INT16_MAX                 32767
N#define INT32_MAX            2147483647
N#define INT64_MAX  __INT64_C(9223372036854775807)
N
N    /* maximum values of exact-width unsigned integer types */
N#define UINT8_MAX                   255
N#define UINT16_MAX                65535
N#define UINT32_MAX           4294967295u
N#define UINT64_MAX __UINT64_C(18446744073709551615)
N
N    /* 7.18.2.2 */
N
N    /* minimum values of minimum-width signed integer types */
N#define INT_LEAST8_MIN                   -128
N#define INT_LEAST16_MIN                -32768
N#define INT_LEAST32_MIN          (~0x7fffffff)
N#define INT_LEAST64_MIN  __INT64_C(~0x7fffffffffffffff)
N
N    /* maximum values of minimum-width signed integer types */
N#define INT_LEAST8_MAX                    127
N#define INT_LEAST16_MAX                 32767
N#define INT_LEAST32_MAX            2147483647
N#define INT_LEAST64_MAX  __INT64_C(9223372036854775807)
N
N    /* maximum values of minimum-width unsigned integer types */
N#define UINT_LEAST8_MAX                   255
N#define UINT_LEAST16_MAX                65535
N#define UINT_LEAST32_MAX           4294967295u
N#define UINT_LEAST64_MAX __UINT64_C(18446744073709551615)
N
N    /* 7.18.2.3 */
N
N    /* minimum values of fastest minimum-width signed integer types */
N#define INT_FAST8_MIN           (~0x7fffffff)
N#define INT_FAST16_MIN          (~0x7fffffff)
N#define INT_FAST32_MIN          (~0x7fffffff)
N#define INT_FAST64_MIN  __INT64_C(~0x7fffffffffffffff)
N
N    /* maximum values of fastest minimum-width signed integer types */
N#define INT_FAST8_MAX             2147483647
N#define INT_FAST16_MAX            2147483647
N#define INT_FAST32_MAX            2147483647
N#define INT_FAST64_MAX  __INT64_C(9223372036854775807)
N
N    /* maximum values of fastest minimum-width unsigned integer types */
N#define UINT_FAST8_MAX            4294967295u
N#define UINT_FAST16_MAX           4294967295u
N#define UINT_FAST32_MAX           4294967295u
N#define UINT_FAST64_MAX __UINT64_C(18446744073709551615)
N
N    /* 7.18.2.4 */
N
N    /* minimum value of pointer-holding signed integer type */
N#if __sizeof_ptr == 8
X#if 4 == 8
S#define INTPTR_MIN INT64_MIN
N#else
N#define INTPTR_MIN INT32_MIN
N#endif
N
N    /* maximum value of pointer-holding signed integer type */
N#if __sizeof_ptr == 8
X#if 4 == 8
S#define INTPTR_MAX INT64_MAX
N#else
N#define INTPTR_MAX INT32_MAX
N#endif
N
N    /* maximum value of pointer-holding unsigned integer type */
N#if __sizeof_ptr == 8
X#if 4 == 8
S#define UINTPTR_MAX UINT64_MAX
N#else
N#define UINTPTR_MAX UINT32_MAX
N#endif
N
N    /* 7.18.2.5 */
N
N    /* minimum value of greatest-width signed integer type */
N#define INTMAX_MIN  __ESCAPE__(~0x7fffffffffffffffll)
N
N    /* maximum value of greatest-width signed integer type */
N#define INTMAX_MAX  __ESCAPE__(9223372036854775807ll)
N
N    /* maximum value of greatest-width unsigned integer type */
N#define UINTMAX_MAX __ESCAPE__(18446744073709551615ull)
N
N    /* 7.18.3 */
N
N    /* limits of ptrdiff_t */
N#if __sizeof_ptr == 8
X#if 4 == 8
S#define PTRDIFF_MIN INT64_MIN
S#define PTRDIFF_MAX INT64_MAX
N#else
N#define PTRDIFF_MIN INT32_MIN
N#define PTRDIFF_MAX INT32_MAX
N#endif
N
N    /* limits of sig_atomic_t */
N#define SIG_ATOMIC_MIN (~0x7fffffff)
N#define SIG_ATOMIC_MAX   2147483647
N
N    /* limit of size_t */
N#if __sizeof_ptr == 8
X#if 4 == 8
S#define SIZE_MAX UINT64_MAX
N#else
N#define SIZE_MAX UINT32_MAX
N#endif
N
N    /* limits of wchar_t */
N    /* NB we have to undef and redef because they're defined in both
N     * stdint.h and wchar.h */
N#undef WCHAR_MIN
N#undef WCHAR_MAX
N
N#if defined(__WCHAR32) || (defined(__ARM_SIZEOF_WCHAR_T) && __ARM_SIZEOF_WCHAR_T == 4)
X#if 0L || (0L && __ARM_SIZEOF_WCHAR_T == 4)
S  #define WCHAR_MIN   0
S  #define WCHAR_MAX   0xffffffffU
N#else
N  #define WCHAR_MIN   0
N  #define WCHAR_MAX   65535
N#endif
N
N    /* limits of wint_t */
N#define WINT_MIN (~0x7fffffff)
N#define WINT_MAX 2147483647
N
N#endif /* __STDC_LIMIT_MACROS */
N
N#if !defined(__cplusplus) || defined(__STDC_CONSTANT_MACROS)
X#if !0L || 0L
N
N    /* 7.18.4.1 macros for minimum-width integer constants */
N#define INT8_C(x)   (x)
N#define INT16_C(x)  (x)
N#define INT32_C(x)  (x)
N#define INT64_C(x)  __INT64_C(x)
N
N#define UINT8_C(x)  (x ## u)
N#define UINT16_C(x) (x ## u)
N#define UINT32_C(x) (x ## u)
N#define UINT64_C(x) __UINT64_C(x)
N
N    /* 7.18.4.2 macros for greatest-width integer constants */
N#define INTMAX_C(x)  __ESCAPE__(x ## ll)
N#define UINTMAX_C(x) __ESCAPE__(x ## ull)
N
N#endif /* __STDC_CONSTANT_MACROS */
N
N    #ifdef __cplusplus
S         }  /* extern "C" */
S      }  /* namespace std */
N    #endif /* __cplusplus */
N  #endif /* __STDINT_DECLS */
N
N  #ifdef __cplusplus
S    #ifndef __STDINT_NO_EXPORTS
S      using ::std::int8_t;
S      using ::std::int16_t;
S      using ::std::int32_t;
S      using ::std::int64_t;
S      using ::std::uint8_t;
S      using ::std::uint16_t;
S      using ::std::uint32_t;
S      using ::std::uint64_t;
S      using ::std::int_least8_t;
S      using ::std::int_least16_t;
S      using ::std::int_least32_t;
S      using ::std::int_least64_t;
S      using ::std::uint_least8_t;
S      using ::std::uint_least16_t;
S      using ::std::uint_least32_t;
S      using ::std::uint_least64_t;
S      using ::std::int_fast8_t;
S      using ::std::int_fast16_t;
S      using ::std::int_fast32_t;
S      using ::std::int_fast64_t;
S      using ::std::uint_fast8_t;
S      using ::std::uint_fast16_t;
S      using ::std::uint_fast32_t;
S      using ::std::uint_fast64_t;
S      using ::std::intptr_t;
S      using ::std::uintptr_t;
S      using ::std::intmax_t;
S      using ::std::uintmax_t;
S    #endif
N  #endif /* __cplusplus */
N
N#undef __INT64
N#undef __LONGLONG
N
N#endif /* __stdint_h */
N
N/* end of stdint.h */
L 51 ".\RTE\Device\MDR1986BE92\MDR32F9Qx_config.h" 2
N
N#if defined (USE_MDR32F9Q1_Rev0) || defined (USE_MDR32F9Q1_Rev1) ||\
N    defined (USE_MDR32F9Q2_Rev0) || defined (USE_MDR32F9Q2_Rev1) ||\
N    defined (USE_MDR32F9Q3_Rev0) || defined (USE_MDR32F9Q3_Rev1) ||\
N    defined (USE_MDR1986VE94)
X#if 0L || 0L ||    0L || 1L ||    0L || 0L ||    0L
N	#define USE_MDR1986VE9x
N#endif
N
N#if defined (USE_MDR1986BE7T)
X#if 0L
S	#define USE_MDR1986VE1T
N#endif
N
N/* Selet the header file for target microcontroller */
N#if defined ( USE_MDR1986VE9x )
X#if 1L
N	#include "MDR32Fx.h"
L 1 "C:\Keil_v5\ARM\PACK\Keil\MDR1986BExx\1.5.3\Libraries\CMSIS\CM3\DeviceSupport\MDR32F9Qx\inc\MDR32Fx.h" 1
N/**
N  * FILE MDR32Fx.h
N  */
N
N/* Define to prevent recursive inclusion -------------------------------------*/
N#ifndef __MDR32FX_H
N#define __MDR32FX_H
N
N/** @addtogroup __CMSIS CMSIS
N  * @{
N  */
N
N/** @defgroup MDR1986VE9x MDR1986VE9x
N *  @{
N */
N
N/** @defgroup __MDR32Fx_Peripheral MDR32F9Qx Peripheral
N  * @{
N  */
N
N#ifdef __cplusplus
Sextern "C" {
N#endif
N
N#if defined ( __CC_ARM   )
X#if 1L
N  #pragma anon_unions
N#endif
N
N/* MDR32Fx Interrupt Number Definition */
Ntypedef enum IRQn
N{
N/*---- Cortex-M3 Processor Exceptions Numbers --------------------------------*/
N  NonMaskableInt_IRQn     = -14,  /*!<  2 Non Maskable Interrupt              *///!< NonMaskableInt_IRQn
N  HardFault_IRQn          = -13,  /*!<  3 Hard Fault Interrupt                *///!< HardFault_IRQn
N  MemoryManagement_IRQn   = -12,  /*!<  4 Memory Management Interrupt         *///!< MemoryManagement_IRQn
N  BusFault_IRQn           = -11,  /*!<  5 Bus Fault Interrupt                 *///!< BusFault_IRQn
N  UsageFault_IRQn         = -10,  /*!<  6 Usage Fault Interrupt               *///!< UsageFault_IRQn
N  SVCall_IRQn             = -5,   /*!< 11 SV Call Interrupt                   *///!< SVCall_IRQn
N  PendSV_IRQn             = -2,   /*!< 14 Pend SV Interrupt                   *///!< PendSV_IRQn
N  SysTick_IRQn            = -1,   /*!< 15 System Tick Timer Interrupt         *///!< SysTick_IRQn
N
N/*---- MDR32Fx specific Interrupt Numbers ------------------------------------*/
N  CAN1_IRQn               =  0,   /*!< CAN1 Interrupt                         *///!< CAN1_IRQn
N  CAN2_IRQn               =  1,   /*!< CAN1 Interrupt                         *///!< CAN2_IRQn
N  USB_IRQn                =  2,   /*!< USB Host Interrupt                     *///!< USB_IRQn
N  DMA_IRQn                =  5,   /*!< DMA Interrupt                          *///!< DMA_IRQn
N  UART1_IRQn              =  6,   /*!< UART1 Interrupt                        *///!< UART1_IRQn
N  UART2_IRQn              =  7,   /*!< UART2 Interrupt                        *///!< UART2_IRQn
N  SSP1_IRQn               =  8,   /*!< SSP1 Interrupt                         *///!< SSP1_IRQn
N  I2C_IRQn                =  10,  /*!< I2C Interrupt                          *///!< I2C_IRQn
N  POWER_IRQn              =  11,  /*!< POWER Detecor Interrupt                *///!< POWER_IRQn
N  WWDG_IRQn               =  12,  /*!< Window Watchdog Interrupt              *///!< WWDG_IRQn
N  Timer1_IRQn             =  14,  /*!< Timer1 Interrupt                       *///!< Timer1_IRQn
N  Timer2_IRQn             =  15,  /*!< Timer2 Interrupt                       *///!< Timer2_IRQn
N  Timer3_IRQn             =  16,  /*!< Timer3 Interrupt                       *///!< Timer3_IRQn
N  ADC_IRQn                =  17,  /*!< ADC Interrupt                          *///!< ADC_IRQn
N  COMPARATOR_IRQn         =  19,  /*!< COMPARATOR Interrupt                   *///!< COMPARATOR_IRQn
N  SSP2_IRQn               =  20,  /*!< SSP2 Interrupt                         *///!< SSP2_IRQn
N  BACKUP_IRQn             =  27,  /*!< BACKUP Interrupt                       *///!< BACKUP_IRQn
N  EXT_INT1_IRQn           =  28,  /*!< EXT_INT1 Interrupt                     *///!< EXT_INT1_IRQn
N  EXT_INT2_IRQn           =  29,  /*!< EXT_INT2 Interrupt                     *///!< EXT_INT2_IRQn
N  EXT_INT3_IRQn           =  30,  /*!< EXT_INT3 Interrupt                     *///!< EXT_INT3_IRQn
N  EXT_INT4_IRQn           =  31   /*!< EXT_INT4 Interrupt                     *///!< EXT_INT4_IRQn
N}IRQn_Type;
N
N/** @addtogroup __Configuration_of_CMSIS Configuration of CMSIS
N  * @{
N  */
N
N/* Configuration of the Cortex-M3 Processor and Core Peripherals */
N#define __CM3_REV              0x0102   /*!< Cortex-M3 Core Revision                      */
N#define __MPU_PRESENT             1     /*!< MPU present or not                           */
N#define __NVIC_PRIO_BITS          3     /*!< Number of Bits used for Priority Levels      */
N#define __Vendor_SysTickConfig    0     /*!< Set to 1 if different SysTick Config is used */
N
N/** @} */ /* End of group __Configuration_of_CMSIS */
N
N/* Includes ------------------------------------------------------------------*/
N#include "core_cm3.h"
L 1 "C:\Keil_v5\ARM\PACK\ARM\CMSIS\5.0.1\CMSIS\Include\core_cm3.h" 1
N/**************************************************************************//**
N * @file     core_cm3.h
N * @brief    CMSIS Cortex-M3 Core Peripheral Access Layer Header File
N * @version  V5.0.1
N * @date     30. January 2017
N ******************************************************************************/
N/*
N * Copyright (c) 2009-2016 ARM Limited. All rights reserved.
N *
N * SPDX-License-Identifier: Apache-2.0
N *
N * Licensed under the Apache License, Version 2.0 (the License); you may
N * not use this file except in compliance with the License.
N * You may obtain a copy of the License at
N *
N * www.apache.org/licenses/LICENSE-2.0
N *
N * Unless required by applicable law or agreed to in writing, software
N * distributed under the License is distributed on an AS IS BASIS, WITHOUT
N * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
N * See the License for the specific language governing permissions and
N * limitations under the License.
N */
N
N#if   defined ( __ICCARM__ )
X#if   0L
S #pragma system_include         /* treat file as system include file for MISRA check */
S#elif defined (__ARMCC_VERSION) && (__ARMCC_VERSION >= 6010050)
X#elif 1L && (5060528 >= 6010050)
S  #pragma clang system_header   /* treat file as system include file */
N#endif
N
N#ifndef __CORE_CM3_H_GENERIC
N#define __CORE_CM3_H_GENERIC
N
N#include <stdint.h>
N
N#ifdef __cplusplus
S extern "C" {
N#endif
N
N/**
N  \page CMSIS_MISRA_Exceptions  MISRA-C:2004 Compliance Exceptions
N  CMSIS violates the following MISRA-C:2004 rules:
N
N   \li Required Rule 8.5, object/function definition in header file.<br>
N     Function definitions in header files are used to allow 'inlining'.
N
N   \li Required Rule 18.4, declaration of union type or object of union type: '{...}'.<br>
N     Unions are used for effective representation of core registers.
N
N   \li Advisory Rule 19.7, Function-like macro defined.<br>
N     Function-like macros are used to allow more efficient code.
N */
N
N
N/*******************************************************************************
N *                 CMSIS definitions
N ******************************************************************************/
N/**
N  \ingroup Cortex_M3
N  @{
N */
N
N/*  CMSIS CM3 definitions */
N#define __CM3_CMSIS_VERSION_MAIN  ( 5U)                                  /*!< [31:16] CMSIS HAL main version */
N#define __CM3_CMSIS_VERSION_SUB   ( 0U)                                  /*!< [15:0]  CMSIS HAL sub version */
N#define __CM3_CMSIS_VERSION       ((__CM3_CMSIS_VERSION_MAIN << 16U) | \
N                                    __CM3_CMSIS_VERSION_SUB           )  /*!< CMSIS HAL version number */
X#define __CM3_CMSIS_VERSION       ((__CM3_CMSIS_VERSION_MAIN << 16U) |                                     __CM3_CMSIS_VERSION_SUB           )   
N
N#define __CORTEX_M                (3U)                                   /*!< Cortex-M Core */
N
N/** __FPU_USED indicates whether an FPU is used or not.
N    This core does not support an FPU at all
N*/
N#define __FPU_USED       0U
N
N#if defined ( __CC_ARM )
X#if 1L
N  #if defined __TARGET_FPU_VFP
X  #if 0L
S    #error "Compiler generates FPU instructions for a device without an FPU (check __FPU_PRESENT)"
N  #endif
N
N#elif defined (__ARMCC_VERSION) && (__ARMCC_VERSION >= 6010050)
S  #if defined __ARM_PCS_VFP
S    #error "Compiler generates FPU instructions for a device without an FPU (check __FPU_PRESENT)"
S  #endif
S
S#elif defined ( __GNUC__ )
S  #if defined (__VFP_FP__) && !defined(__SOFTFP__)
S    #error "Compiler generates FPU instructions for a device without an FPU (check __FPU_PRESENT)"
S  #endif
S
S#elif defined ( __ICCARM__ )
S  #if defined __ARMVFP__
S    #error "Compiler generates FPU instructions for a device without an FPU (check __FPU_PRESENT)"
S  #endif
S
S#elif defined ( __TI_ARM__ )
S  #if defined __TI_VFP_SUPPORT__
S    #error "Compiler generates FPU instructions for a device without an FPU (check __FPU_PRESENT)"
S  #endif
S
S#elif defined ( __TASKING__ )
S  #if defined __FPU_VFP__
S    #error "Compiler generates FPU instructions for a device without an FPU (check __FPU_PRESENT)"
S  #endif
S
S#elif defined ( __CSMC__ )
S  #if ( __CSMC__ & 0x400U)
S    #error "Compiler generates FPU instructions for a device without an FPU (check __FPU_PRESENT)"
S  #endif
S
N#endif
N
N#include "cmsis_compiler.h"               /* CMSIS compiler specific defines */
L 1 "C:\Keil_v5\ARM\PACK\ARM\CMSIS\5.0.1\CMSIS\Include\cmsis_compiler.h" 1
N/**************************************************************************//**
N * @file     cmsis_compiler.h
N * @brief    CMSIS compiler generic header file
N * @version  V5.0.1
N * @date     30. January 2017
N ******************************************************************************/
N/*
N * Copyright (c) 2009-2017 ARM Limited. All rights reserved.
N *
N * SPDX-License-Identifier: Apache-2.0
N *
N * Licensed under the Apache License, Version 2.0 (the License); you may
N * not use this file except in compliance with the License.
N * You may obtain a copy of the License at
N *
N * www.apache.org/licenses/LICENSE-2.0
N *
N * Unless required by applicable law or agreed to in writing, software
N * distributed under the License is distributed on an AS IS BASIS, WITHOUT
N * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
N * See the License for the specific language governing permissions and
N * limitations under the License.
N */
N
N#ifndef __CMSIS_COMPILER_H
N#define __CMSIS_COMPILER_H
N
N#include <stdint.h>
N
N/*
N * ARM Compiler 4/5
N */
N#if   defined ( __CC_ARM )
X#if   1L
N  #include "cmsis_armcc.h"
L 1 "C:\Keil_v5\ARM\PACK\ARM\CMSIS\5.0.1\CMSIS\Include\cmsis_armcc.h" 1
N/**************************************************************************//**
N * @file     cmsis_armcc.h
N * @brief    CMSIS compiler ARMCC (ARM compiler V5) header file
N * @version  V5.0.1
N * @date     03. February 2017
N ******************************************************************************/
N/*
N * Copyright (c) 2009-2017 ARM Limited. All rights reserved.
N *
N * SPDX-License-Identifier: Apache-2.0
N *
N * Licensed under the Apache License, Version 2.0 (the License); you may
N * not use this file except in compliance with the License.
N * You may obtain a copy of the License at
N *
N * www.apache.org/licenses/LICENSE-2.0
N *
N * Unless required by applicable law or agreed to in writing, software
N * distributed under the License is distributed on an AS IS BASIS, WITHOUT
N * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
N * See the License for the specific language governing permissions and
N * limitations under the License.
N */
N
N#ifndef __CMSIS_ARMCC_H
N#define __CMSIS_ARMCC_H
N
N
N#if defined(__ARMCC_VERSION) && (__ARMCC_VERSION < 400677)
X#if 1L && (5060528 < 400677)
S  #error "Please use ARM Compiler Toolchain V4.0.677 or later!"
N#endif
N
N/* CMSIS compiler control architecture macros */
N#if ((defined (__TARGET_ARCH_6_M  ) && (__TARGET_ARCH_6_M   == 1)) || \
N     (defined (__TARGET_ARCH_6S_M ) && (__TARGET_ARCH_6S_M  == 1))   )
X#if ((0L && (__TARGET_ARCH_6_M   == 1)) ||      (0L && (__TARGET_ARCH_6S_M  == 1))   )
S  #define __ARM_ARCH_6M__           1
N#endif
N
N#if (defined (__TARGET_ARCH_7_M ) && (__TARGET_ARCH_7_M  == 1))
X#if (1L && (1  == 1))
N  #define __ARM_ARCH_7M__           1
N#endif
N
N#if (defined (__TARGET_ARCH_7E_M) && (__TARGET_ARCH_7E_M == 1))
X#if (0L && (__TARGET_ARCH_7E_M == 1))
S  #define __ARM_ARCH_7EM__          1
N#endif
N
N  /* __ARM_ARCH_8M_BASE__  not applicable */
N  /* __ARM_ARCH_8M_MAIN__  not applicable */
N
N
N/* CMSIS compiler specific defines */
N#ifndef   __ASM
N  #define __ASM                     __asm
N#endif
N#ifndef   __INLINE
N  #define __INLINE                  __inline
N#endif
N#ifndef   __STATIC_INLINE
N  #define __STATIC_INLINE           static __inline
N#endif
N#ifndef   __NO_RETURN
N  #define __NO_RETURN               __declspec(noreturn)
N#endif
N#ifndef   __USED
N  #define __USED                    __attribute__((used))
N#endif
N#ifndef   __WEAK
N  #define __WEAK                    __attribute__((weak))
N#endif
N#ifndef   __UNALIGNED_UINT32
N  #define __UNALIGNED_UINT32(x)     (*((__packed uint32_t *)(x)))
N#endif
N#ifndef   __ALIGNED
N  #define __ALIGNED(x)              __attribute__((aligned(x)))
N#endif
N#ifndef   __PACKED
N  #define __PACKED                  __attribute__((packed))
N#endif
N#ifndef   __PACKED_STRUCT
N  #define __PACKED_STRUCT           __packed struct
N#endif
N
N
N/* ###########################  Core Function Access  ########################### */
N/** \ingroup  CMSIS_Core_FunctionInterface
N    \defgroup CMSIS_Core_RegAccFunctions CMSIS Core Register Access Functions
N  @{
N */
N
N/**
N  \brief   Enable IRQ Interrupts
N  \details Enables IRQ interrupts by clearing the I-bit in the CPSR.
N           Can only be executed in Privileged modes.
N */
N/* intrinsic void __enable_irq();     */
N
N
N/**
N  \brief   Disable IRQ Interrupts
N  \details Disables IRQ interrupts by setting the I-bit in the CPSR.
N           Can only be executed in Privileged modes.
N */
N/* intrinsic void __disable_irq();    */
N
N/**
N  \brief   Get Control Register
N  \details Returns the content of the Control Register.
N  \return               Control Register value
N */
N__STATIC_INLINE uint32_t __get_CONTROL(void)
Xstatic __inline uint32_t __get_CONTROL(void)
N{
N  register uint32_t __regControl         __ASM("control");
X  register uint32_t __regControl         __asm("control");
N  return(__regControl);
N}
N
N
N/**
N  \brief   Set Control Register
N  \details Writes the given value to the Control Register.
N  \param [in]    control  Control Register value to set
N */
N__STATIC_INLINE void __set_CONTROL(uint32_t control)
Xstatic __inline void __set_CONTROL(uint32_t control)
N{
N  register uint32_t __regControl         __ASM("control");
X  register uint32_t __regControl         __asm("control");
N  __regControl = control;
N}
N
N
N/**
N  \brief   Get IPSR Register
N  \details Returns the content of the IPSR Register.
N  \return               IPSR Register value
N */
N__STATIC_INLINE uint32_t __get_IPSR(void)
Xstatic __inline uint32_t __get_IPSR(void)
N{
N  register uint32_t __regIPSR          __ASM("ipsr");
X  register uint32_t __regIPSR          __asm("ipsr");
N  return(__regIPSR);
N}
N
N
N/**
N  \brief   Get APSR Register
N  \details Returns the content of the APSR Register.
N  \return               APSR Register value
N */
N__STATIC_INLINE uint32_t __get_APSR(void)
Xstatic __inline uint32_t __get_APSR(void)
N{
N  register uint32_t __regAPSR          __ASM("apsr");
X  register uint32_t __regAPSR          __asm("apsr");
N  return(__regAPSR);
N}
N
N
N/**
N  \brief   Get xPSR Register
N  \details Returns the content of the xPSR Register.
N  \return               xPSR Register value
N */
N__STATIC_INLINE uint32_t __get_xPSR(void)
Xstatic __inline uint32_t __get_xPSR(void)
N{
N  register uint32_t __regXPSR          __ASM("xpsr");
X  register uint32_t __regXPSR          __asm("xpsr");
N  return(__regXPSR);
N}
N
N
N/**
N  \brief   Get Process Stack Pointer
N  \details Returns the current value of the Process Stack Pointer (PSP).
N  \return               PSP Register value
N */
N__STATIC_INLINE uint32_t __get_PSP(void)
Xstatic __inline uint32_t __get_PSP(void)
N{
N  register uint32_t __regProcessStackPointer  __ASM("psp");
X  register uint32_t __regProcessStackPointer  __asm("psp");
N  return(__regProcessStackPointer);
N}
N
N
N/**
N  \brief   Set Process Stack Pointer
N  \details Assigns the given value to the Process Stack Pointer (PSP).
N  \param [in]    topOfProcStack  Process Stack Pointer value to set
N */
N__STATIC_INLINE void __set_PSP(uint32_t topOfProcStack)
Xstatic __inline void __set_PSP(uint32_t topOfProcStack)
N{
N  register uint32_t __regProcessStackPointer  __ASM("psp");
X  register uint32_t __regProcessStackPointer  __asm("psp");
N  __regProcessStackPointer = topOfProcStack;
N}
N
N
N/**
N  \brief   Get Main Stack Pointer
N  \details Returns the current value of the Main Stack Pointer (MSP).
N  \return               MSP Register value
N */
N__STATIC_INLINE uint32_t __get_MSP(void)
Xstatic __inline uint32_t __get_MSP(void)
N{
N  register uint32_t __regMainStackPointer     __ASM("msp");
X  register uint32_t __regMainStackPointer     __asm("msp");
N  return(__regMainStackPointer);
N}
N
N
N/**
N  \brief   Set Main Stack Pointer
N  \details Assigns the given value to the Main Stack Pointer (MSP).
N  \param [in]    topOfMainStack  Main Stack Pointer value to set
N */
N__STATIC_INLINE void __set_MSP(uint32_t topOfMainStack)
Xstatic __inline void __set_MSP(uint32_t topOfMainStack)
N{
N  register uint32_t __regMainStackPointer     __ASM("msp");
X  register uint32_t __regMainStackPointer     __asm("msp");
N  __regMainStackPointer = topOfMainStack;
N}
N
N
N/**
N  \brief   Get Priority Mask
N  \details Returns the current state of the priority mask bit from the Priority Mask Register.
N  \return               Priority Mask value
N */
N__STATIC_INLINE uint32_t __get_PRIMASK(void)
Xstatic __inline uint32_t __get_PRIMASK(void)
N{
N  register uint32_t __regPriMask         __ASM("primask");
X  register uint32_t __regPriMask         __asm("primask");
N  return(__regPriMask);
N}
N
N
N/**
N  \brief   Set Priority Mask
N  \details Assigns the given value to the Priority Mask Register.
N  \param [in]    priMask  Priority Mask
N */
N__STATIC_INLINE void __set_PRIMASK(uint32_t priMask)
Xstatic __inline void __set_PRIMASK(uint32_t priMask)
N{
N  register uint32_t __regPriMask         __ASM("primask");
X  register uint32_t __regPriMask         __asm("primask");
N  __regPriMask = (priMask);
N}
N
N
N#if ((defined (__ARM_ARCH_7M__ ) && (__ARM_ARCH_7M__  == 1)) || \
N     (defined (__ARM_ARCH_7EM__) && (__ARM_ARCH_7EM__ == 1))     )
X#if ((1L && (1  == 1)) ||      (0L && (__ARM_ARCH_7EM__ == 1))     )
N
N/**
N  \brief   Enable FIQ
N  \details Enables FIQ interrupts by clearing the F-bit in the CPSR.
N           Can only be executed in Privileged modes.
N */
N#define __enable_fault_irq                __enable_fiq
N
N
N/**
N  \brief   Disable FIQ
N  \details Disables FIQ interrupts by setting the F-bit in the CPSR.
N           Can only be executed in Privileged modes.
N */
N#define __disable_fault_irq               __disable_fiq
N
N
N/**
N  \brief   Get Base Priority
N  \details Returns the current value of the Base Priority register.
N  \return               Base Priority register value
N */
N__STATIC_INLINE uint32_t  __get_BASEPRI(void)
Xstatic __inline uint32_t  __get_BASEPRI(void)
N{
N  register uint32_t __regBasePri         __ASM("basepri");
X  register uint32_t __regBasePri         __asm("basepri");
N  return(__regBasePri);
N}
N
N
N/**
N  \brief   Set Base Priority
N  \details Assigns the given value to the Base Priority register.
N  \param [in]    basePri  Base Priority value to set
N */
N__STATIC_INLINE void __set_BASEPRI(uint32_t basePri)
Xstatic __inline void __set_BASEPRI(uint32_t basePri)
N{
N  register uint32_t __regBasePri         __ASM("basepri");
X  register uint32_t __regBasePri         __asm("basepri");
N  __regBasePri = (basePri & 0xFFU);
N}
N
N
N/**
N  \brief   Set Base Priority with condition
N  \details Assigns the given value to the Base Priority register only if BASEPRI masking is disabled,
N           or the new value increases the BASEPRI priority level.
N  \param [in]    basePri  Base Priority value to set
N */
N__STATIC_INLINE void __set_BASEPRI_MAX(uint32_t basePri)
Xstatic __inline void __set_BASEPRI_MAX(uint32_t basePri)
N{
N  register uint32_t __regBasePriMax      __ASM("basepri_max");
X  register uint32_t __regBasePriMax      __asm("basepri_max");
N  __regBasePriMax = (basePri & 0xFFU);
N}
N
N
N/**
N  \brief   Get Fault Mask
N  \details Returns the current value of the Fault Mask register.
N  \return               Fault Mask register value
N */
N__STATIC_INLINE uint32_t __get_FAULTMASK(void)
Xstatic __inline uint32_t __get_FAULTMASK(void)
N{
N  register uint32_t __regFaultMask       __ASM("faultmask");
X  register uint32_t __regFaultMask       __asm("faultmask");
N  return(__regFaultMask);
N}
N
N
N/**
N  \brief   Set Fault Mask
N  \details Assigns the given value to the Fault Mask register.
N  \param [in]    faultMask  Fault Mask value to set
N */
N__STATIC_INLINE void __set_FAULTMASK(uint32_t faultMask)
Xstatic __inline void __set_FAULTMASK(uint32_t faultMask)
N{
N  register uint32_t __regFaultMask       __ASM("faultmask");
X  register uint32_t __regFaultMask       __asm("faultmask");
N  __regFaultMask = (faultMask & (uint32_t)1U);
N}
N
N#endif /* ((defined (__ARM_ARCH_7M__ ) && (__ARM_ARCH_7M__  == 1)) || \
N           (defined (__ARM_ARCH_7EM__) && (__ARM_ARCH_7EM__ == 1))     ) */
X#endif  
N
N
N#if ((defined (__ARM_ARCH_7EM__) && (__ARM_ARCH_7EM__ == 1))     )
X#if ((0L && (__ARM_ARCH_7EM__ == 1))     )
S
S/**
S  \brief   Get FPSCR
S  \details Returns the current value of the Floating Point Status/Control register.
S  \return               Floating Point Status/Control register value
S */
S__STATIC_INLINE uint32_t __get_FPSCR(void)
S{
S#if ((defined (__FPU_PRESENT) && (__FPU_PRESENT == 1U)) && \
S     (defined (__FPU_USED   ) && (__FPU_USED    == 1U))     )
X#if ((defined (__FPU_PRESENT) && (__FPU_PRESENT == 1U)) &&      (defined (__FPU_USED   ) && (__FPU_USED    == 1U))     )
S  register uint32_t __regfpscr         __ASM("fpscr");
S  return(__regfpscr);
S#else
S   return(0U);
S#endif
S}
S
S
S/**
S  \brief   Set FPSCR
S  \details Assigns the given value to the Floating Point Status/Control register.
S  \param [in]    fpscr  Floating Point Status/Control value to set
S */
S__STATIC_INLINE void __set_FPSCR(uint32_t fpscr)
S{
S#if ((defined (__FPU_PRESENT) && (__FPU_PRESENT == 1U)) && \
S     (defined (__FPU_USED   ) && (__FPU_USED    == 1U))     )
X#if ((defined (__FPU_PRESENT) && (__FPU_PRESENT == 1U)) &&      (defined (__FPU_USED   ) && (__FPU_USED    == 1U))     )
S  register uint32_t __regfpscr         __ASM("fpscr");
S  __regfpscr = (fpscr);
S#else
S  (void)fpscr;
S#endif
S}
S
N#endif /* ((defined (__ARM_ARCH_7EM__) && (__ARM_ARCH_7EM__ == 1))     ) */
N
N
N
N/*@} end of CMSIS_Core_RegAccFunctions */
N
N
N/* ##########################  Core Instruction Access  ######################### */
N/** \defgroup CMSIS_Core_InstructionInterface CMSIS Core Instruction Interface
N  Access to dedicated instructions
N  @{
N*/
N
N/**
N  \brief   No Operation
N  \details No Operation does nothing. This instruction can be used for code alignment purposes.
N */
N#define __NOP                             __nop
N
N
N/**
N  \brief   Wait For Interrupt
N  \details Wait For Interrupt is a hint instruction that suspends execution until one of a number of events occurs.
N */
N#define __WFI                             __wfi
N
N
N/**
N  \brief   Wait For Event
N  \details Wait For Event is a hint instruction that permits the processor to enter
N           a low-power state until one of a number of events occurs.
N */
N#define __WFE                             __wfe
N
N
N/**
N  \brief   Send Event
N  \details Send Event is a hint instruction. It causes an event to be signaled to the CPU.
N */
N#define __SEV                             __sev
N
N
N/**
N  \brief   Instruction Synchronization Barrier
N  \details Instruction Synchronization Barrier flushes the pipeline in the processor,
N           so that all instructions following the ISB are fetched from cache or memory,
N           after the instruction has been completed.
N */
N#define __ISB() do {\
N                   __schedule_barrier();\
N                   __isb(0xF);\
N                   __schedule_barrier();\
N                } while (0U)
X#define __ISB() do {                   __schedule_barrier();                   __isb(0xF);                   __schedule_barrier();                } while (0U)
N
N/**
N  \brief   Data Synchronization Barrier
N  \details Acts as a special kind of Data Memory Barrier.
N           It completes when all explicit memory accesses before this instruction complete.
N */
N#define __DSB() do {\
N                   __schedule_barrier();\
N                   __dsb(0xF);\
N                   __schedule_barrier();\
N                } while (0U)
X#define __DSB() do {                   __schedule_barrier();                   __dsb(0xF);                   __schedule_barrier();                } while (0U)
N
N/**
N  \brief   Data Memory Barrier
N  \details Ensures the apparent order of the explicit memory operations before
N           and after the instruction, without ensuring their completion.
N */
N#define __DMB() do {\
N                   __schedule_barrier();\
N                   __dmb(0xF);\
N                   __schedule_barrier();\
N                } while (0U)
X#define __DMB() do {                   __schedule_barrier();                   __dmb(0xF);                   __schedule_barrier();                } while (0U)
N
N/**
N  \brief   Reverse byte order (32 bit)
N  \details Reverses the byte order in integer value.
N  \param [in]    value  Value to reverse
N  \return               Reversed value
N */
N#define __REV                             __rev
N
N
N/**
N  \brief   Reverse byte order (16 bit)
N  \details Reverses the byte order in two unsigned short values.
N  \param [in]    value  Value to reverse
N  \return               Reversed value
N */
N#ifndef __NO_EMBEDDED_ASM
N__attribute__((section(".rev16_text"))) __STATIC_INLINE __ASM uint32_t __REV16(uint32_t value)
X__attribute__((section(".rev16_text"))) static __inline __asm uint32_t __REV16(uint32_t value)
N{
N  rev16 r0, r0
N  bx lr
N}
N#endif
N
N
N/**
N  \brief   Reverse byte order in signed short value
N  \details Reverses the byte order in a signed short value with sign extension to integer.
N  \param [in]    value  Value to reverse
N  \return               Reversed value
N */
N#ifndef __NO_EMBEDDED_ASM
N__attribute__((section(".revsh_text"))) __STATIC_INLINE __ASM int32_t __REVSH(int32_t value)
X__attribute__((section(".revsh_text"))) static __inline __asm int32_t __REVSH(int32_t value)
N{
N  revsh r0, r0
N  bx lr
N}
N#endif
N
N
N/**
N  \brief   Rotate Right in unsigned value (32 bit)
N  \details Rotate Right (immediate) provides the value of the contents of a register rotated by a variable number of bits.
N  \param [in]    op1  Value to rotate
N  \param [in]    op2  Number of Bits to rotate
N  \return               Rotated value
N */
N#define __ROR                             __ror
N
N
N/**
N  \brief   Breakpoint
N  \details Causes the processor to enter Debug state.
N           Debug tools can use this to investigate system state when the instruction at a particular address is reached.
N  \param [in]    value  is ignored by the processor.
N                 If required, a debugger can use it to store additional information about the breakpoint.
N */
N#define __BKPT(value)                       __breakpoint(value)
N
N
N/**
N  \brief   Reverse bit order of value
N  \details Reverses the bit order of the given value.
N  \param [in]    value  Value to reverse
N  \return               Reversed value
N */
N#if ((defined (__ARM_ARCH_7M__ ) && (__ARM_ARCH_7M__  == 1)) || \
N     (defined (__ARM_ARCH_7EM__) && (__ARM_ARCH_7EM__ == 1))     )
X#if ((1L && (1  == 1)) ||      (0L && (__ARM_ARCH_7EM__ == 1))     )
N  #define __RBIT                          __rbit
N#else
S__attribute__((always_inline)) __STATIC_INLINE uint32_t __RBIT(uint32_t value)
S{
S  uint32_t result;
S  int32_t s = (4 /*sizeof(v)*/ * 8) - 1; /* extra shift needed at end */
S
S  result = value;                      /* r will be reversed bits of v; first get LSB of v */
S  for (value >>= 1U; value; value >>= 1U)
S  {
S    result <<= 1U;
S    result |= value & 1U;
S    s--;
S  }
S  result <<= s;                        /* shift when v's highest bits are zero */
S  return(result);
S}
N#endif
N
N
N/**
N  \brief   Count leading zeros
N  \details Counts the number of leading zeros of a data value.
N  \param [in]  value  Value to count the leading zeros
N  \return             number of leading zeros in value
N */
N#define __CLZ                             __clz
N
N
N#if ((defined (__ARM_ARCH_7M__ ) && (__ARM_ARCH_7M__  == 1)) || \
N     (defined (__ARM_ARCH_7EM__) && (__ARM_ARCH_7EM__ == 1))     )
X#if ((1L && (1  == 1)) ||      (0L && (__ARM_ARCH_7EM__ == 1))     )
N
N/**
N  \brief   LDR Exclusive (8 bit)
N  \details Executes a exclusive LDR instruction for 8 bit value.
N  \param [in]    ptr  Pointer to data
N  \return             value of type uint8_t at (*ptr)
N */
N#if defined(__ARMCC_VERSION) && (__ARMCC_VERSION < 5060020)
X#if 1L && (5060528 < 5060020)
S  #define __LDREXB(ptr)                                                        ((uint8_t ) __ldrex(ptr))
N#else
N  #define __LDREXB(ptr)          _Pragma("push") _Pragma("diag_suppress 3731") ((uint8_t ) __ldrex(ptr))  _Pragma("pop")
N#endif
N
N
N/**
N  \brief   LDR Exclusive (16 bit)
N  \details Executes a exclusive LDR instruction for 16 bit values.
N  \param [in]    ptr  Pointer to data
N  \return        value of type uint16_t at (*ptr)
N */
N#if defined(__ARMCC_VERSION) && (__ARMCC_VERSION < 5060020)
X#if 1L && (5060528 < 5060020)
S  #define __LDREXH(ptr)                                                        ((uint16_t) __ldrex(ptr))
N#else
N  #define __LDREXH(ptr)          _Pragma("push") _Pragma("diag_suppress 3731") ((uint16_t) __ldrex(ptr))  _Pragma("pop")
N#endif
N
N
N/**
N  \brief   LDR Exclusive (32 bit)
N  \details Executes a exclusive LDR instruction for 32 bit values.
N  \param [in]    ptr  Pointer to data
N  \return        value of type uint32_t at (*ptr)
N */
N#if defined(__ARMCC_VERSION) && (__ARMCC_VERSION < 5060020)
X#if 1L && (5060528 < 5060020)
S  #define __LDREXW(ptr)                                                        ((uint32_t ) __ldrex(ptr))
N#else
N  #define __LDREXW(ptr)          _Pragma("push") _Pragma("diag_suppress 3731") ((uint32_t ) __ldrex(ptr))  _Pragma("pop")
N#endif
N
N
N/**
N  \brief   STR Exclusive (8 bit)
N  \details Executes a exclusive STR instruction for 8 bit values.
N  \param [in]  value  Value to store
N  \param [in]    ptr  Pointer to location
N  \return          0  Function succeeded
N  \return          1  Function failed
N */
N#if defined(__ARMCC_VERSION) && (__ARMCC_VERSION < 5060020)
X#if 1L && (5060528 < 5060020)
S  #define __STREXB(value, ptr)                                                 __strex(value, ptr)
N#else
N  #define __STREXB(value, ptr)   _Pragma("push") _Pragma("diag_suppress 3731") __strex(value, ptr)        _Pragma("pop")
N#endif
N
N
N/**
N  \brief   STR Exclusive (16 bit)
N  \details Executes a exclusive STR instruction for 16 bit values.
N  \param [in]  value  Value to store
N  \param [in]    ptr  Pointer to location
N  \return          0  Function succeeded
N  \return          1  Function failed
N */
N#if defined(__ARMCC_VERSION) && (__ARMCC_VERSION < 5060020)
X#if 1L && (5060528 < 5060020)
S  #define __STREXH(value, ptr)                                                 __strex(value, ptr)
N#else
N  #define __STREXH(value, ptr)   _Pragma("push") _Pragma("diag_suppress 3731") __strex(value, ptr)        _Pragma("pop")
N#endif
N
N
N/**
N  \brief   STR Exclusive (32 bit)
N  \details Executes a exclusive STR instruction for 32 bit values.
N  \param [in]  value  Value to store
N  \param [in]    ptr  Pointer to location
N  \return          0  Function succeeded
N  \return          1  Function failed
N */
N#if defined(__ARMCC_VERSION) && (__ARMCC_VERSION < 5060020)
X#if 1L && (5060528 < 5060020)
S  #define __STREXW(value, ptr)                                                 __strex(value, ptr)
N#else
N  #define __STREXW(value, ptr)   _Pragma("push") _Pragma("diag_suppress 3731") __strex(value, ptr)        _Pragma("pop")
N#endif
N
N
N/**
N  \brief   Remove the exclusive lock
N  \details Removes the exclusive lock which is created by LDREX.
N */
N#define __CLREX                           __clrex
N
N
N/**
N  \brief   Signed Saturate
N  \details Saturates a signed value.
N  \param [in]  value  Value to be saturated
N  \param [in]    sat  Bit position to saturate to (1..32)
N  \return             Saturated value
N */
N#define __SSAT                            __ssat
N
N
N/**
N  \brief   Unsigned Saturate
N  \details Saturates an unsigned value.
N  \param [in]  value  Value to be saturated
N  \param [in]    sat  Bit position to saturate to (0..31)
N  \return             Saturated value
N */
N#define __USAT                            __usat
N
N
N/**
N  \brief   Rotate Right with Extend (32 bit)
N  \details Moves each bit of a bitstring right by one bit.
N           The carry input is shifted in at the left end of the bitstring.
N  \param [in]    value  Value to rotate
N  \return               Rotated value
N */
N#ifndef __NO_EMBEDDED_ASM
N__attribute__((section(".rrx_text"))) __STATIC_INLINE __ASM uint32_t __RRX(uint32_t value)
X__attribute__((section(".rrx_text"))) static __inline __asm uint32_t __RRX(uint32_t value)
N{
N  rrx r0, r0
N  bx lr
N}
N#endif
N
N
N/**
N  \brief   LDRT Unprivileged (8 bit)
N  \details Executes a Unprivileged LDRT instruction for 8 bit value.
N  \param [in]    ptr  Pointer to data
N  \return             value of type uint8_t at (*ptr)
N */
N#define __LDRBT(ptr)                      ((uint8_t )  __ldrt(ptr))
N
N
N/**
N  \brief   LDRT Unprivileged (16 bit)
N  \details Executes a Unprivileged LDRT instruction for 16 bit values.
N  \param [in]    ptr  Pointer to data
N  \return        value of type uint16_t at (*ptr)
N */
N#define __LDRHT(ptr)                      ((uint16_t)  __ldrt(ptr))
N
N
N/**
N  \brief   LDRT Unprivileged (32 bit)
N  \details Executes a Unprivileged LDRT instruction for 32 bit values.
N  \param [in]    ptr  Pointer to data
N  \return        value of type uint32_t at (*ptr)
N */
N#define __LDRT(ptr)                       ((uint32_t ) __ldrt(ptr))
N
N
N/**
N  \brief   STRT Unprivileged (8 bit)
N  \details Executes a Unprivileged STRT instruction for 8 bit values.
N  \param [in]  value  Value to store
N  \param [in]    ptr  Pointer to location
N */
N#define __STRBT(value, ptr)               __strt(value, ptr)
N
N
N/**
N  \brief   STRT Unprivileged (16 bit)
N  \details Executes a Unprivileged STRT instruction for 16 bit values.
N  \param [in]  value  Value to store
N  \param [in]    ptr  Pointer to location
N */
N#define __STRHT(value, ptr)               __strt(value, ptr)
N
N
N/**
N  \brief   STRT Unprivileged (32 bit)
N  \details Executes a Unprivileged STRT instruction for 32 bit values.
N  \param [in]  value  Value to store
N  \param [in]    ptr  Pointer to location
N */
N#define __STRT(value, ptr)                __strt(value, ptr)
N
N#endif /* ((defined (__ARM_ARCH_7M__ ) && (__ARM_ARCH_7M__  == 1)) || \
N           (defined (__ARM_ARCH_7EM__) && (__ARM_ARCH_7EM__ == 1))     ) */
X#endif  
N
N/*@}*/ /* end of group CMSIS_Core_InstructionInterface */
N
N
N/* ###################  Compiler specific Intrinsics  ########################### */
N/** \defgroup CMSIS_SIMD_intrinsics CMSIS SIMD Intrinsics
N  Access to dedicated SIMD instructions
N  @{
N*/
N
N#if ((defined (__ARM_ARCH_7EM__) && (__ARM_ARCH_7EM__ == 1))     )
X#if ((0L && (__ARM_ARCH_7EM__ == 1))     )
S
S#define __SADD8                           __sadd8
S#define __QADD8                           __qadd8
S#define __SHADD8                          __shadd8
S#define __UADD8                           __uadd8
S#define __UQADD8                          __uqadd8
S#define __UHADD8                          __uhadd8
S#define __SSUB8                           __ssub8
S#define __QSUB8                           __qsub8
S#define __SHSUB8                          __shsub8
S#define __USUB8                           __usub8
S#define __UQSUB8                          __uqsub8
S#define __UHSUB8                          __uhsub8
S#define __SADD16                          __sadd16
S#define __QADD16                          __qadd16
S#define __SHADD16                         __shadd16
S#define __UADD16                          __uadd16
S#define __UQADD16                         __uqadd16
S#define __UHADD16                         __uhadd16
S#define __SSUB16                          __ssub16
S#define __QSUB16                          __qsub16
S#define __SHSUB16                         __shsub16
S#define __USUB16                          __usub16
S#define __UQSUB16                         __uqsub16
S#define __UHSUB16                         __uhsub16
S#define __SASX                            __sasx
S#define __QASX                            __qasx
S#define __SHASX                           __shasx
S#define __UASX                            __uasx
S#define __UQASX                           __uqasx
S#define __UHASX                           __uhasx
S#define __SSAX                            __ssax
S#define __QSAX                            __qsax
S#define __SHSAX                           __shsax
S#define __USAX                            __usax
S#define __UQSAX                           __uqsax
S#define __UHSAX                           __uhsax
S#define __USAD8                           __usad8
S#define __USADA8                          __usada8
S#define __SSAT16                          __ssat16
S#define __USAT16                          __usat16
S#define __UXTB16                          __uxtb16
S#define __UXTAB16                         __uxtab16
S#define __SXTB16                          __sxtb16
S#define __SXTAB16                         __sxtab16
S#define __SMUAD                           __smuad
S#define __SMUADX                          __smuadx
S#define __SMLAD                           __smlad
S#define __SMLADX                          __smladx
S#define __SMLALD                          __smlald
S#define __SMLALDX                         __smlaldx
S#define __SMUSD                           __smusd
S#define __SMUSDX                          __smusdx
S#define __SMLSD                           __smlsd
S#define __SMLSDX                          __smlsdx
S#define __SMLSLD                          __smlsld
S#define __SMLSLDX                         __smlsldx
S#define __SEL                             __sel
S#define __QADD                            __qadd
S#define __QSUB                            __qsub
S
S#define __PKHBT(ARG1,ARG2,ARG3)          ( ((((uint32_t)(ARG1))          ) & 0x0000FFFFUL) |  \
S                                           ((((uint32_t)(ARG2)) << (ARG3)) & 0xFFFF0000UL)  )
X#define __PKHBT(ARG1,ARG2,ARG3)          ( ((((uint32_t)(ARG1))          ) & 0x0000FFFFUL) |                                             ((((uint32_t)(ARG2)) << (ARG3)) & 0xFFFF0000UL)  )
S
S#define __PKHTB(ARG1,ARG2,ARG3)          ( ((((uint32_t)(ARG1))          ) & 0xFFFF0000UL) |  \
S                                           ((((uint32_t)(ARG2)) >> (ARG3)) & 0x0000FFFFUL)  )
X#define __PKHTB(ARG1,ARG2,ARG3)          ( ((((uint32_t)(ARG1))          ) & 0xFFFF0000UL) |                                             ((((uint32_t)(ARG2)) >> (ARG3)) & 0x0000FFFFUL)  )
S
S#define __SMMLA(ARG1,ARG2,ARG3)          ( (int32_t)((((int64_t)(ARG1) * (ARG2)) + \
S                                                      ((int64_t)(ARG3) << 32U)     ) >> 32U))
X#define __SMMLA(ARG1,ARG2,ARG3)          ( (int32_t)((((int64_t)(ARG1) * (ARG2)) +                                                       ((int64_t)(ARG3) << 32U)     ) >> 32U))
S
N#endif /* ((defined (__ARM_ARCH_7EM__) && (__ARM_ARCH_7EM__ == 1))     ) */
N/*@} end of group CMSIS_SIMD_intrinsics */
N
N
N#endif /* __CMSIS_ARMCC_H */
L 35 "C:\Keil_v5\ARM\PACK\ARM\CMSIS\5.0.1\CMSIS\Include\cmsis_compiler.h" 2
N
N
N/*
N * ARM Compiler 6 (armclang)
N */
N#elif defined (__ARMCC_VERSION) && (__ARMCC_VERSION >= 6010050)
S  #include "cmsis_armclang.h"
S
S
S/*
S * GNU Compiler
S */
S#elif defined ( __GNUC__ )
S  #include "cmsis_gcc.h"
S
S
S/*
S * IAR Compiler
S */
S#elif defined ( __ICCARM__ )
S
S  #ifndef   __ASM
S    #define __ASM                     __asm
S  #endif
S  #ifndef   __INLINE
S    #define __INLINE                  inline
S  #endif
S  #ifndef   __STATIC_INLINE
S    #define __STATIC_INLINE           static inline
S  #endif
S
S  #include <cmsis_iar.h>
S
S  #ifndef   __NO_RETURN
S    #define __NO_RETURN               __noreturn
S  #endif
S  #ifndef   __USED
S    #define __USED                    __root
S  #endif
S  #ifndef   __WEAK
S    #define __WEAK                    __weak
S  #endif
S  #ifndef   __UNALIGNED_UINT32
S    __packed struct T_UINT32 { uint32_t v; };
S      #define __UNALIGNED_UINT32(x)     (((struct T_UINT32 *)(x))->v)
S  #endif
S  #ifndef   __ALIGNED
S    #warning No compiler specific solution for __ALIGNED. __ALIGNED is ignored.
S    #define __ALIGNED(x)
S  #endif
S  #ifndef   __PACKED
S    #define __PACKED                  __packed
S  #endif
S  #ifndef   __PACKED_STRUCT
S    #define __PACKED_STRUCT           __packed struct
S  #endif
S
S
S/*
S * TI ARM Compiler
S */
S#elif defined ( __TI_ARM__ )
S  #include <cmsis_ccs.h>
S
S  #ifndef   __ASM
S    #define __ASM                     __asm
S  #endif
S  #ifndef   __INLINE
S    #define __INLINE                  inline
S  #endif
S  #ifndef   __STATIC_INLINE
S    #define __STATIC_INLINE           static inline
S  #endif
S  #ifndef   __NO_RETURN
S    #define __NO_RETURN               __attribute__((noreturn))
S  #endif
S  #ifndef   __USED
S    #define __USED                    __attribute__((used))
S  #endif
S  #ifndef   __WEAK
S    #define __WEAK                    __attribute__((weak))
S  #endif
S  #ifndef   __UNALIGNED_UINT32
S    struct __attribute__((packed)) T_UINT32 { uint32_t v; };
S    #define __UNALIGNED_UINT32(x)     (((struct T_UINT32 *)(x))->v)
S  #endif
S  #ifndef   __ALIGNED
S    #define __ALIGNED(x)              __attribute__((aligned(x)))
S  #endif
S  #ifndef   __PACKED
S    #define __PACKED                  __attribute__((packed))
S  #endif
S  #ifndef   __PACKED_STRUCT
S    #define __PACKED_STRUCT           struct __attribute__((packed))
S  #endif
S
S
S/*
S * TASKING Compiler
S */
S#elif defined ( __TASKING__ )
S  /*
S   * The CMSIS functions have been implemented as intrinsics in the compiler.
S   * Please use "carm -?i" to get an up to date list of all intrinsics,
S   * Including the CMSIS ones.
S   */
S
S  #ifndef   __ASM
S    #define __ASM                     __asm
S  #endif
S  #ifndef   __INLINE
S    #define __INLINE                  inline
S  #endif
S  #ifndef   __STATIC_INLINE
S    #define __STATIC_INLINE           static inline
S  #endif
S  #ifndef   __NO_RETURN
S    #define __NO_RETURN               __attribute__((noreturn))
S  #endif
S  #ifndef   __USED
S    #define __USED                    __attribute__((used))
S  #endif
S  #ifndef   __WEAK
S    #define __WEAK                    __attribute__((weak))
S  #endif
S  #ifndef   __UNALIGNED_UINT32
S    struct __packed__ T_UINT32 { uint32_t v; };
S    #define __UNALIGNED_UINT32(x)     (((struct T_UINT32 *)(x))->v)
S  #endif
S  #ifndef   __ALIGNED
S    #define __ALIGNED(x)              __align(x)
S  #endif
S  #ifndef   __PACKED
S    #define __PACKED                  __packed__
S  #endif
S  #ifndef   __PACKED_STRUCT
S    #define __PACKED_STRUCT           struct __packed__
S  #endif
S
S
S/*
S * COSMIC Compiler
S */
S#elif defined ( __CSMC__ )
S   #include <cmsis_csm.h>
S
S #ifndef   __ASM
S    #define __ASM                     _asm
S  #endif
S  #ifndef   __INLINE
S    #define __INLINE                  inline
S  #endif
S  #ifndef   __STATIC_INLINE
S    #define __STATIC_INLINE           static inline
S  #endif
S  #ifndef   __NO_RETURN
S    // NO RETURN is automatically detected hence no warning here
S    #define __NO_RETURN
S  #endif
S  #ifndef   __USED
S    #warning No compiler specific solution for __USED. __USED is ignored.
S    #define __USED
S  #endif
S  #ifndef   __WEAK
S    #define __WEAK                    __weak
S  #endif
S  #ifndef   __UNALIGNED_UINT32
S    @packed struct T_UINT32 { uint32_t v; };
S    #define __UNALIGNED_UINT32(x)     (((struct T_UINT32 *)(x))->v)
S  #endif
S  #ifndef   __ALIGNED
S    #warning No compiler specific solution for __ALIGNED. __ALIGNED is ignored.
S    #define __ALIGNED(x)
S  #endif
S  #ifndef   __PACKED
S    #define __PACKED                  @packed
S  #endif
S  #ifndef   __PACKED_STRUCT
S    #define __PACKED_STRUCT           @packed struct
S  #endif
S
S
S#else
S  #error Unknown compiler.
N#endif
N
N
N#endif /* __CMSIS_COMPILER_H */
N
L 114 "C:\Keil_v5\ARM\PACK\ARM\CMSIS\5.0.1\CMSIS\Include\core_cm3.h" 2
N
N
N#ifdef __cplusplus
S}
N#endif
N
N#endif /* __CORE_CM3_H_GENERIC */
N
N#ifndef __CMSIS_GENERIC
N
N#ifndef __CORE_CM3_H_DEPENDANT
N#define __CORE_CM3_H_DEPENDANT
N
N#ifdef __cplusplus
S extern "C" {
N#endif
N
N/* check device defines and use defaults */
N#if defined __CHECK_DEVICE_DEFINES
X#if 0L
S  #ifndef __CM3_REV
S    #define __CM3_REV               0x0200U
S    #warning "__CM3_REV not defined in device header file; using default!"
S  #endif
S
S  #ifndef __MPU_PRESENT
S    #define __MPU_PRESENT             0U
S    #warning "__MPU_PRESENT not defined in device header file; using default!"
S  #endif
S
S  #ifndef __NVIC_PRIO_BITS
S    #define __NVIC_PRIO_BITS          3U
S    #warning "__NVIC_PRIO_BITS not defined in device header file; using default!"
S  #endif
S
S  #ifndef __Vendor_SysTickConfig
S    #define __Vendor_SysTickConfig    0U
S    #warning "__Vendor_SysTickConfig not defined in device header file; using default!"
S  #endif
N#endif
N
N/* IO definitions (access restrictions to peripheral registers) */
N/**
N    \defgroup CMSIS_glob_defs CMSIS Global Defines
N
N    <strong>IO Type Qualifiers</strong> are used
N    \li to specify the access to peripheral variables.
N    \li for automatic generation of peripheral register debug information.
N*/
N#ifdef __cplusplus
S  #define   __I     volatile             /*!< Defines 'read only' permissions */
N#else
N  #define   __I     volatile const       /*!< Defines 'read only' permissions */
N#endif
N#define     __O     volatile             /*!< Defines 'write only' permissions */
N#define     __IO    volatile             /*!< Defines 'read / write' permissions */
N
N/* following defines should be used for structure members */
N#define     __IM     volatile const      /*! Defines 'read only' structure member permissions */
N#define     __OM     volatile            /*! Defines 'write only' structure member permissions */
N#define     __IOM    volatile            /*! Defines 'read / write' structure member permissions */
N
N/*@} end of group Cortex_M3 */
N
N
N
N/*******************************************************************************
N *                 Register Abstraction
N  Core Register contain:
N  - Core Register
N  - Core NVIC Register
N  - Core SCB Register
N  - Core SysTick Register
N  - Core Debug Register
N  - Core MPU Register
N ******************************************************************************/
N/**
N  \defgroup CMSIS_core_register Defines and Type Definitions
N  \brief Type definitions and defines for Cortex-M processor based devices.
N*/
N
N/**
N  \ingroup    CMSIS_core_register
N  \defgroup   CMSIS_CORE  Status and Control Registers
N  \brief      Core Register type definitions.
N  @{
N */
N
N/**
N  \brief  Union type to access the Application Program Status Register (APSR).
N */
Ntypedef union
N{
N  struct
N  {
N    uint32_t _reserved0:27;              /*!< bit:  0..26  Reserved */
N    uint32_t Q:1;                        /*!< bit:     27  Saturation condition flag */
N    uint32_t V:1;                        /*!< bit:     28  Overflow condition code flag */
N    uint32_t C:1;                        /*!< bit:     29  Carry condition code flag */
N    uint32_t Z:1;                        /*!< bit:     30  Zero condition code flag */
N    uint32_t N:1;                        /*!< bit:     31  Negative condition code flag */
N  } b;                                   /*!< Structure used for bit  access */
N  uint32_t w;                            /*!< Type      used for word access */
N} APSR_Type;
N
N/* APSR Register Definitions */
N#define APSR_N_Pos                         31U                                            /*!< APSR: N Position */
N#define APSR_N_Msk                         (1UL << APSR_N_Pos)                            /*!< APSR: N Mask */
N
N#define APSR_Z_Pos                         30U                                            /*!< APSR: Z Position */
N#define APSR_Z_Msk                         (1UL << APSR_Z_Pos)                            /*!< APSR: Z Mask */
N
N#define APSR_C_Pos                         29U                                            /*!< APSR: C Position */
N#define APSR_C_Msk                         (1UL << APSR_C_Pos)                            /*!< APSR: C Mask */
N
N#define APSR_V_Pos                         28U                                            /*!< APSR: V Position */
N#define APSR_V_Msk                         (1UL << APSR_V_Pos)                            /*!< APSR: V Mask */
N
N#define APSR_Q_Pos                         27U                                            /*!< APSR: Q Position */
N#define APSR_Q_Msk                         (1UL << APSR_Q_Pos)                            /*!< APSR: Q Mask */
N
N
N/**
N  \brief  Union type to access the Interrupt Program Status Register (IPSR).
N */
Ntypedef union
N{
N  struct
N  {
N    uint32_t ISR:9;                      /*!< bit:  0.. 8  Exception number */
N    uint32_t _reserved0:23;              /*!< bit:  9..31  Reserved */
N  } b;                                   /*!< Structure used for bit  access */
N  uint32_t w;                            /*!< Type      used for word access */
N} IPSR_Type;
N
N/* IPSR Register Definitions */
N#define IPSR_ISR_Pos                        0U                                            /*!< IPSR: ISR Position */
N#define IPSR_ISR_Msk                       (0x1FFUL /*<< IPSR_ISR_Pos*/)                  /*!< IPSR: ISR Mask */
N
N
N/**
N  \brief  Union type to access the Special-Purpose Program Status Registers (xPSR).
N */
Ntypedef union
N{
N  struct
N  {
N    uint32_t ISR:9;                      /*!< bit:  0.. 8  Exception number */
N    uint32_t _reserved0:1;               /*!< bit:      9  Reserved */
N    uint32_t ICI_IT_1:6;                 /*!< bit: 10..15  ICI/IT part 1 */
N    uint32_t _reserved1:8;               /*!< bit: 16..23  Reserved */
N    uint32_t T:1;                        /*!< bit:     24  Thumb bit */
N    uint32_t ICI_IT_2:2;                 /*!< bit: 25..26  ICI/IT part 2 */
N    uint32_t Q:1;                        /*!< bit:     27  Saturation condition flag */
N    uint32_t V:1;                        /*!< bit:     28  Overflow condition code flag */
N    uint32_t C:1;                        /*!< bit:     29  Carry condition code flag */
N    uint32_t Z:1;                        /*!< bit:     30  Zero condition code flag */
N    uint32_t N:1;                        /*!< bit:     31  Negative condition code flag */
N  } b;                                   /*!< Structure used for bit  access */
N  uint32_t w;                            /*!< Type      used for word access */
N} xPSR_Type;
N
N/* xPSR Register Definitions */
N#define xPSR_N_Pos                         31U                                            /*!< xPSR: N Position */
N#define xPSR_N_Msk                         (1UL << xPSR_N_Pos)                            /*!< xPSR: N Mask */
N
N#define xPSR_Z_Pos                         30U                                            /*!< xPSR: Z Position */
N#define xPSR_Z_Msk                         (1UL << xPSR_Z_Pos)                            /*!< xPSR: Z Mask */
N
N#define xPSR_C_Pos                         29U                                            /*!< xPSR: C Position */
N#define xPSR_C_Msk                         (1UL << xPSR_C_Pos)                            /*!< xPSR: C Mask */
N
N#define xPSR_V_Pos                         28U                                            /*!< xPSR: V Position */
N#define xPSR_V_Msk                         (1UL << xPSR_V_Pos)                            /*!< xPSR: V Mask */
N
N#define xPSR_Q_Pos                         27U                                            /*!< xPSR: Q Position */
N#define xPSR_Q_Msk                         (1UL << xPSR_Q_Pos)                            /*!< xPSR: Q Mask */
N
N#define xPSR_ICI_IT_2_Pos                  25U                                            /*!< xPSR: ICI/IT part 2 Position */
N#define xPSR_ICI_IT_2_Msk                  (3UL << xPSR_ICI_IT_2_Pos)                     /*!< xPSR: ICI/IT part 2 Mask */
N
N#define xPSR_T_Pos                         24U                                            /*!< xPSR: T Position */
N#define xPSR_T_Msk                         (1UL << xPSR_T_Pos)                            /*!< xPSR: T Mask */
N
N#define xPSR_ICI_IT_1_Pos                  10U                                            /*!< xPSR: ICI/IT part 1 Position */
N#define xPSR_ICI_IT_1_Msk                  (0x3FUL << xPSR_ICI_IT_1_Pos)                  /*!< xPSR: ICI/IT part 1 Mask */
N
N#define xPSR_ISR_Pos                        0U                                            /*!< xPSR: ISR Position */
N#define xPSR_ISR_Msk                       (0x1FFUL /*<< xPSR_ISR_Pos*/)                  /*!< xPSR: ISR Mask */
N
N
N/**
N  \brief  Union type to access the Control Registers (CONTROL).
N */
Ntypedef union
N{
N  struct
N  {
N    uint32_t nPRIV:1;                    /*!< bit:      0  Execution privilege in Thread mode */
N    uint32_t SPSEL:1;                    /*!< bit:      1  Stack to be used */
N    uint32_t _reserved1:30;              /*!< bit:  2..31  Reserved */
N  } b;                                   /*!< Structure used for bit  access */
N  uint32_t w;                            /*!< Type      used for word access */
N} CONTROL_Type;
N
N/* CONTROL Register Definitions */
N#define CONTROL_SPSEL_Pos                   1U                                            /*!< CONTROL: SPSEL Position */
N#define CONTROL_SPSEL_Msk                  (1UL << CONTROL_SPSEL_Pos)                     /*!< CONTROL: SPSEL Mask */
N
N#define CONTROL_nPRIV_Pos                   0U                                            /*!< CONTROL: nPRIV Position */
N#define CONTROL_nPRIV_Msk                  (1UL /*<< CONTROL_nPRIV_Pos*/)                 /*!< CONTROL: nPRIV Mask */
N
N/*@} end of group CMSIS_CORE */
N
N
N/**
N  \ingroup    CMSIS_core_register
N  \defgroup   CMSIS_NVIC  Nested Vectored Interrupt Controller (NVIC)
N  \brief      Type definitions for the NVIC Registers
N  @{
N */
N
N/**
N  \brief  Structure type to access the Nested Vectored Interrupt Controller (NVIC).
N */
Ntypedef struct
N{
N  __IOM uint32_t ISER[8U];               /*!< Offset: 0x000 (R/W)  Interrupt Set Enable Register */
X  volatile uint32_t ISER[8U];                
N        uint32_t RESERVED0[24U];
N  __IOM uint32_t ICER[8U];               /*!< Offset: 0x080 (R/W)  Interrupt Clear Enable Register */
X  volatile uint32_t ICER[8U];                
N        uint32_t RSERVED1[24U];
N  __IOM uint32_t ISPR[8U];               /*!< Offset: 0x100 (R/W)  Interrupt Set Pending Register */
X  volatile uint32_t ISPR[8U];                
N        uint32_t RESERVED2[24U];
N  __IOM uint32_t ICPR[8U];               /*!< Offset: 0x180 (R/W)  Interrupt Clear Pending Register */
X  volatile uint32_t ICPR[8U];                
N        uint32_t RESERVED3[24U];
N  __IOM uint32_t IABR[8U];               /*!< Offset: 0x200 (R/W)  Interrupt Active bit Register */
X  volatile uint32_t IABR[8U];                
N        uint32_t RESERVED4[56U];
N  __IOM uint8_t  IP[240U];               /*!< Offset: 0x300 (R/W)  Interrupt Priority Register (8Bit wide) */
X  volatile uint8_t  IP[240U];                
N        uint32_t RESERVED5[644U];
N  __OM  uint32_t STIR;                   /*!< Offset: 0xE00 ( /W)  Software Trigger Interrupt Register */
X  volatile  uint32_t STIR;                    
N}  NVIC_Type;
N
N/* Software Triggered Interrupt Register Definitions */
N#define NVIC_STIR_INTID_Pos                 0U                                         /*!< STIR: INTLINESNUM Position */
N#define NVIC_STIR_INTID_Msk                (0x1FFUL /*<< NVIC_STIR_INTID_Pos*/)        /*!< STIR: INTLINESNUM Mask */
N
N/*@} end of group CMSIS_NVIC */
N
N
N/**
N  \ingroup  CMSIS_core_register
N  \defgroup CMSIS_SCB     System Control Block (SCB)
N  \brief    Type definitions for the System Control Block Registers
N  @{
N */
N
N/**
N  \brief  Structure type to access the System Control Block (SCB).
N */
Ntypedef struct
N{
N  __IM  uint32_t CPUID;                  /*!< Offset: 0x000 (R/ )  CPUID Base Register */
X  volatile const  uint32_t CPUID;                   
N  __IOM uint32_t ICSR;                   /*!< Offset: 0x004 (R/W)  Interrupt Control and State Register */
X  volatile uint32_t ICSR;                    
N  __IOM uint32_t VTOR;                   /*!< Offset: 0x008 (R/W)  Vector Table Offset Register */
X  volatile uint32_t VTOR;                    
N  __IOM uint32_t AIRCR;                  /*!< Offset: 0x00C (R/W)  Application Interrupt and Reset Control Register */
X  volatile uint32_t AIRCR;                   
N  __IOM uint32_t SCR;                    /*!< Offset: 0x010 (R/W)  System Control Register */
X  volatile uint32_t SCR;                     
N  __IOM uint32_t CCR;                    /*!< Offset: 0x014 (R/W)  Configuration Control Register */
X  volatile uint32_t CCR;                     
N  __IOM uint8_t  SHP[12U];               /*!< Offset: 0x018 (R/W)  System Handlers Priority Registers (4-7, 8-11, 12-15) */
X  volatile uint8_t  SHP[12U];                
N  __IOM uint32_t SHCSR;                  /*!< Offset: 0x024 (R/W)  System Handler Control and State Register */
X  volatile uint32_t SHCSR;                   
N  __IOM uint32_t CFSR;                   /*!< Offset: 0x028 (R/W)  Configurable Fault Status Register */
X  volatile uint32_t CFSR;                    
N  __IOM uint32_t HFSR;                   /*!< Offset: 0x02C (R/W)  HardFault Status Register */
X  volatile uint32_t HFSR;                    
N  __IOM uint32_t DFSR;                   /*!< Offset: 0x030 (R/W)  Debug Fault Status Register */
X  volatile uint32_t DFSR;                    
N  __IOM uint32_t MMFAR;                  /*!< Offset: 0x034 (R/W)  MemManage Fault Address Register */
X  volatile uint32_t MMFAR;                   
N  __IOM uint32_t BFAR;                   /*!< Offset: 0x038 (R/W)  BusFault Address Register */
X  volatile uint32_t BFAR;                    
N  __IOM uint32_t AFSR;                   /*!< Offset: 0x03C (R/W)  Auxiliary Fault Status Register */
X  volatile uint32_t AFSR;                    
N  __IM  uint32_t PFR[2U];                /*!< Offset: 0x040 (R/ )  Processor Feature Register */
X  volatile const  uint32_t PFR[2U];                 
N  __IM  uint32_t DFR;                    /*!< Offset: 0x048 (R/ )  Debug Feature Register */
X  volatile const  uint32_t DFR;                     
N  __IM  uint32_t ADR;                    /*!< Offset: 0x04C (R/ )  Auxiliary Feature Register */
X  volatile const  uint32_t ADR;                     
N  __IM  uint32_t MMFR[4U];               /*!< Offset: 0x050 (R/ )  Memory Model Feature Register */
X  volatile const  uint32_t MMFR[4U];                
N  __IM  uint32_t ISAR[5U];               /*!< Offset: 0x060 (R/ )  Instruction Set Attributes Register */
X  volatile const  uint32_t ISAR[5U];                
N        uint32_t RESERVED0[5U];
N  __IOM uint32_t CPACR;                  /*!< Offset: 0x088 (R/W)  Coprocessor Access Control Register */
X  volatile uint32_t CPACR;                   
N} SCB_Type;
N
N/* SCB CPUID Register Definitions */
N#define SCB_CPUID_IMPLEMENTER_Pos          24U                                            /*!< SCB CPUID: IMPLEMENTER Position */
N#define SCB_CPUID_IMPLEMENTER_Msk          (0xFFUL << SCB_CPUID_IMPLEMENTER_Pos)          /*!< SCB CPUID: IMPLEMENTER Mask */
N
N#define SCB_CPUID_VARIANT_Pos              20U                                            /*!< SCB CPUID: VARIANT Position */
N#define SCB_CPUID_VARIANT_Msk              (0xFUL << SCB_CPUID_VARIANT_Pos)               /*!< SCB CPUID: VARIANT Mask */
N
N#define SCB_CPUID_ARCHITECTURE_Pos         16U                                            /*!< SCB CPUID: ARCHITECTURE Position */
N#define SCB_CPUID_ARCHITECTURE_Msk         (0xFUL << SCB_CPUID_ARCHITECTURE_Pos)          /*!< SCB CPUID: ARCHITECTURE Mask */
N
N#define SCB_CPUID_PARTNO_Pos                4U                                            /*!< SCB CPUID: PARTNO Position */
N#define SCB_CPUID_PARTNO_Msk               (0xFFFUL << SCB_CPUID_PARTNO_Pos)              /*!< SCB CPUID: PARTNO Mask */
N
N#define SCB_CPUID_REVISION_Pos              0U                                            /*!< SCB CPUID: REVISION Position */
N#define SCB_CPUID_REVISION_Msk             (0xFUL /*<< SCB_CPUID_REVISION_Pos*/)          /*!< SCB CPUID: REVISION Mask */
N
N/* SCB Interrupt Control State Register Definitions */
N#define SCB_ICSR_NMIPENDSET_Pos            31U                                            /*!< SCB ICSR: NMIPENDSET Position */
N#define SCB_ICSR_NMIPENDSET_Msk            (1UL << SCB_ICSR_NMIPENDSET_Pos)               /*!< SCB ICSR: NMIPENDSET Mask */
N
N#define SCB_ICSR_PENDSVSET_Pos             28U                                            /*!< SCB ICSR: PENDSVSET Position */
N#define SCB_ICSR_PENDSVSET_Msk             (1UL << SCB_ICSR_PENDSVSET_Pos)                /*!< SCB ICSR: PENDSVSET Mask */
N
N#define SCB_ICSR_PENDSVCLR_Pos             27U                                            /*!< SCB ICSR: PENDSVCLR Position */
N#define SCB_ICSR_PENDSVCLR_Msk             (1UL << SCB_ICSR_PENDSVCLR_Pos)                /*!< SCB ICSR: PENDSVCLR Mask */
N
N#define SCB_ICSR_PENDSTSET_Pos             26U                                            /*!< SCB ICSR: PENDSTSET Position */
N#define SCB_ICSR_PENDSTSET_Msk             (1UL << SCB_ICSR_PENDSTSET_Pos)                /*!< SCB ICSR: PENDSTSET Mask */
N
N#define SCB_ICSR_PENDSTCLR_Pos             25U                                            /*!< SCB ICSR: PENDSTCLR Position */
N#define SCB_ICSR_PENDSTCLR_Msk             (1UL << SCB_ICSR_PENDSTCLR_Pos)                /*!< SCB ICSR: PENDSTCLR Mask */
N
N#define SCB_ICSR_ISRPREEMPT_Pos            23U                                            /*!< SCB ICSR: ISRPREEMPT Position */
N#define SCB_ICSR_ISRPREEMPT_Msk            (1UL << SCB_ICSR_ISRPREEMPT_Pos)               /*!< SCB ICSR: ISRPREEMPT Mask */
N
N#define SCB_ICSR_ISRPENDING_Pos            22U                                            /*!< SCB ICSR: ISRPENDING Position */
N#define SCB_ICSR_ISRPENDING_Msk            (1UL << SCB_ICSR_ISRPENDING_Pos)               /*!< SCB ICSR: ISRPENDING Mask */
N
N#define SCB_ICSR_VECTPENDING_Pos           12U                                            /*!< SCB ICSR: VECTPENDING Position */
N#define SCB_ICSR_VECTPENDING_Msk           (0x1FFUL << SCB_ICSR_VECTPENDING_Pos)          /*!< SCB ICSR: VECTPENDING Mask */
N
N#define SCB_ICSR_RETTOBASE_Pos             11U                                            /*!< SCB ICSR: RETTOBASE Position */
N#define SCB_ICSR_RETTOBASE_Msk             (1UL << SCB_ICSR_RETTOBASE_Pos)                /*!< SCB ICSR: RETTOBASE Mask */
N
N#define SCB_ICSR_VECTACTIVE_Pos             0U                                            /*!< SCB ICSR: VECTACTIVE Position */
N#define SCB_ICSR_VECTACTIVE_Msk            (0x1FFUL /*<< SCB_ICSR_VECTACTIVE_Pos*/)       /*!< SCB ICSR: VECTACTIVE Mask */
N
N/* SCB Vector Table Offset Register Definitions */
N#if defined (__CM3_REV) && (__CM3_REV < 0x0201U)                   /* core r2p1 */
X#if 1L && (0x0102 < 0x0201U)                    
N#define SCB_VTOR_TBLBASE_Pos               29U                                            /*!< SCB VTOR: TBLBASE Position */
N#define SCB_VTOR_TBLBASE_Msk               (1UL << SCB_VTOR_TBLBASE_Pos)                  /*!< SCB VTOR: TBLBASE Mask */
N
N#define SCB_VTOR_TBLOFF_Pos                 7U                                            /*!< SCB VTOR: TBLOFF Position */
N#define SCB_VTOR_TBLOFF_Msk                (0x3FFFFFUL << SCB_VTOR_TBLOFF_Pos)            /*!< SCB VTOR: TBLOFF Mask */
N#else
S#define SCB_VTOR_TBLOFF_Pos                 7U                                            /*!< SCB VTOR: TBLOFF Position */
S#define SCB_VTOR_TBLOFF_Msk                (0x1FFFFFFUL << SCB_VTOR_TBLOFF_Pos)           /*!< SCB VTOR: TBLOFF Mask */
N#endif
N
N/* SCB Application Interrupt and Reset Control Register Definitions */
N#define SCB_AIRCR_VECTKEY_Pos              16U                                            /*!< SCB AIRCR: VECTKEY Position */
N#define SCB_AIRCR_VECTKEY_Msk              (0xFFFFUL << SCB_AIRCR_VECTKEY_Pos)            /*!< SCB AIRCR: VECTKEY Mask */
N
N#define SCB_AIRCR_VECTKEYSTAT_Pos          16U                                            /*!< SCB AIRCR: VECTKEYSTAT Position */
N#define SCB_AIRCR_VECTKEYSTAT_Msk          (0xFFFFUL << SCB_AIRCR_VECTKEYSTAT_Pos)        /*!< SCB AIRCR: VECTKEYSTAT Mask */
N
N#define SCB_AIRCR_ENDIANESS_Pos            15U                                            /*!< SCB AIRCR: ENDIANESS Position */
N#define SCB_AIRCR_ENDIANESS_Msk            (1UL << SCB_AIRCR_ENDIANESS_Pos)               /*!< SCB AIRCR: ENDIANESS Mask */
N
N#define SCB_AIRCR_PRIGROUP_Pos              8U                                            /*!< SCB AIRCR: PRIGROUP Position */
N#define SCB_AIRCR_PRIGROUP_Msk             (7UL << SCB_AIRCR_PRIGROUP_Pos)                /*!< SCB AIRCR: PRIGROUP Mask */
N
N#define SCB_AIRCR_SYSRESETREQ_Pos           2U                                            /*!< SCB AIRCR: SYSRESETREQ Position */
N#define SCB_AIRCR_SYSRESETREQ_Msk          (1UL << SCB_AIRCR_SYSRESETREQ_Pos)             /*!< SCB AIRCR: SYSRESETREQ Mask */
N
N#define SCB_AIRCR_VECTCLRACTIVE_Pos         1U                                            /*!< SCB AIRCR: VECTCLRACTIVE Position */
N#define SCB_AIRCR_VECTCLRACTIVE_Msk        (1UL << SCB_AIRCR_VECTCLRACTIVE_Pos)           /*!< SCB AIRCR: VECTCLRACTIVE Mask */
N
N#define SCB_AIRCR_VECTRESET_Pos             0U                                            /*!< SCB AIRCR: VECTRESET Position */
N#define SCB_AIRCR_VECTRESET_Msk            (1UL /*<< SCB_AIRCR_VECTRESET_Pos*/)           /*!< SCB AIRCR: VECTRESET Mask */
N
N/* SCB System Control Register Definitions */
N#define SCB_SCR_SEVONPEND_Pos               4U                                            /*!< SCB SCR: SEVONPEND Position */
N#define SCB_SCR_SEVONPEND_Msk              (1UL << SCB_SCR_SEVONPEND_Pos)                 /*!< SCB SCR: SEVONPEND Mask */
N
N#define SCB_SCR_SLEEPDEEP_Pos               2U                                            /*!< SCB SCR: SLEEPDEEP Position */
N#define SCB_SCR_SLEEPDEEP_Msk              (1UL << SCB_SCR_SLEEPDEEP_Pos)                 /*!< SCB SCR: SLEEPDEEP Mask */
N
N#define SCB_SCR_SLEEPONEXIT_Pos             1U                                            /*!< SCB SCR: SLEEPONEXIT Position */
N#define SCB_SCR_SLEEPONEXIT_Msk            (1UL << SCB_SCR_SLEEPONEXIT_Pos)               /*!< SCB SCR: SLEEPONEXIT Mask */
N
N/* SCB Configuration Control Register Definitions */
N#define SCB_CCR_STKALIGN_Pos                9U                                            /*!< SCB CCR: STKALIGN Position */
N#define SCB_CCR_STKALIGN_Msk               (1UL << SCB_CCR_STKALIGN_Pos)                  /*!< SCB CCR: STKALIGN Mask */
N
N#define SCB_CCR_BFHFNMIGN_Pos               8U                                            /*!< SCB CCR: BFHFNMIGN Position */
N#define SCB_CCR_BFHFNMIGN_Msk              (1UL << SCB_CCR_BFHFNMIGN_Pos)                 /*!< SCB CCR: BFHFNMIGN Mask */
N
N#define SCB_CCR_DIV_0_TRP_Pos               4U                                            /*!< SCB CCR: DIV_0_TRP Position */
N#define SCB_CCR_DIV_0_TRP_Msk              (1UL << SCB_CCR_DIV_0_TRP_Pos)                 /*!< SCB CCR: DIV_0_TRP Mask */
N
N#define SCB_CCR_UNALIGN_TRP_Pos             3U                                            /*!< SCB CCR: UNALIGN_TRP Position */
N#define SCB_CCR_UNALIGN_TRP_Msk            (1UL << SCB_CCR_UNALIGN_TRP_Pos)               /*!< SCB CCR: UNALIGN_TRP Mask */
N
N#define SCB_CCR_USERSETMPEND_Pos            1U                                            /*!< SCB CCR: USERSETMPEND Position */
N#define SCB_CCR_USERSETMPEND_Msk           (1UL << SCB_CCR_USERSETMPEND_Pos)              /*!< SCB CCR: USERSETMPEND Mask */
N
N#define SCB_CCR_NONBASETHRDENA_Pos          0U                                            /*!< SCB CCR: NONBASETHRDENA Position */
N#define SCB_CCR_NONBASETHRDENA_Msk         (1UL /*<< SCB_CCR_NONBASETHRDENA_Pos*/)        /*!< SCB CCR: NONBASETHRDENA Mask */
N
N/* SCB System Handler Control and State Register Definitions */
N#define SCB_SHCSR_USGFAULTENA_Pos          18U                                            /*!< SCB SHCSR: USGFAULTENA Position */
N#define SCB_SHCSR_USGFAULTENA_Msk          (1UL << SCB_SHCSR_USGFAULTENA_Pos)             /*!< SCB SHCSR: USGFAULTENA Mask */
N
N#define SCB_SHCSR_BUSFAULTENA_Pos          17U                                            /*!< SCB SHCSR: BUSFAULTENA Position */
N#define SCB_SHCSR_BUSFAULTENA_Msk          (1UL << SCB_SHCSR_BUSFAULTENA_Pos)             /*!< SCB SHCSR: BUSFAULTENA Mask */
N
N#define SCB_SHCSR_MEMFAULTENA_Pos          16U                                            /*!< SCB SHCSR: MEMFAULTENA Position */
N#define SCB_SHCSR_MEMFAULTENA_Msk          (1UL << SCB_SHCSR_MEMFAULTENA_Pos)             /*!< SCB SHCSR: MEMFAULTENA Mask */
N
N#define SCB_SHCSR_SVCALLPENDED_Pos         15U                                            /*!< SCB SHCSR: SVCALLPENDED Position */
N#define SCB_SHCSR_SVCALLPENDED_Msk         (1UL << SCB_SHCSR_SVCALLPENDED_Pos)            /*!< SCB SHCSR: SVCALLPENDED Mask */
N
N#define SCB_SHCSR_BUSFAULTPENDED_Pos       14U                                            /*!< SCB SHCSR: BUSFAULTPENDED Position */
N#define SCB_SHCSR_BUSFAULTPENDED_Msk       (1UL << SCB_SHCSR_BUSFAULTPENDED_Pos)          /*!< SCB SHCSR: BUSFAULTPENDED Mask */
N
N#define SCB_SHCSR_MEMFAULTPENDED_Pos       13U                                            /*!< SCB SHCSR: MEMFAULTPENDED Position */
N#define SCB_SHCSR_MEMFAULTPENDED_Msk       (1UL << SCB_SHCSR_MEMFAULTPENDED_Pos)          /*!< SCB SHCSR: MEMFAULTPENDED Mask */
N
N#define SCB_SHCSR_USGFAULTPENDED_Pos       12U                                            /*!< SCB SHCSR: USGFAULTPENDED Position */
N#define SCB_SHCSR_USGFAULTPENDED_Msk       (1UL << SCB_SHCSR_USGFAULTPENDED_Pos)          /*!< SCB SHCSR: USGFAULTPENDED Mask */
N
N#define SCB_SHCSR_SYSTICKACT_Pos           11U                                            /*!< SCB SHCSR: SYSTICKACT Position */
N#define SCB_SHCSR_SYSTICKACT_Msk           (1UL << SCB_SHCSR_SYSTICKACT_Pos)              /*!< SCB SHCSR: SYSTICKACT Mask */
N
N#define SCB_SHCSR_PENDSVACT_Pos            10U                                            /*!< SCB SHCSR: PENDSVACT Position */
N#define SCB_SHCSR_PENDSVACT_Msk            (1UL << SCB_SHCSR_PENDSVACT_Pos)               /*!< SCB SHCSR: PENDSVACT Mask */
N
N#define SCB_SHCSR_MONITORACT_Pos            8U                                            /*!< SCB SHCSR: MONITORACT Position */
N#define SCB_SHCSR_MONITORACT_Msk           (1UL << SCB_SHCSR_MONITORACT_Pos)              /*!< SCB SHCSR: MONITORACT Mask */
N
N#define SCB_SHCSR_SVCALLACT_Pos             7U                                            /*!< SCB SHCSR: SVCALLACT Position */
N#define SCB_SHCSR_SVCALLACT_Msk            (1UL << SCB_SHCSR_SVCALLACT_Pos)               /*!< SCB SHCSR: SVCALLACT Mask */
N
N#define SCB_SHCSR_USGFAULTACT_Pos           3U                                            /*!< SCB SHCSR: USGFAULTACT Position */
N#define SCB_SHCSR_USGFAULTACT_Msk          (1UL << SCB_SHCSR_USGFAULTACT_Pos)             /*!< SCB SHCSR: USGFAULTACT Mask */
N
N#define SCB_SHCSR_BUSFAULTACT_Pos           1U                                            /*!< SCB SHCSR: BUSFAULTACT Position */
N#define SCB_SHCSR_BUSFAULTACT_Msk          (1UL << SCB_SHCSR_BUSFAULTACT_Pos)             /*!< SCB SHCSR: BUSFAULTACT Mask */
N
N#define SCB_SHCSR_MEMFAULTACT_Pos           0U                                            /*!< SCB SHCSR: MEMFAULTACT Position */
N#define SCB_SHCSR_MEMFAULTACT_Msk          (1UL /*<< SCB_SHCSR_MEMFAULTACT_Pos*/)         /*!< SCB SHCSR: MEMFAULTACT Mask */
N
N/* SCB Configurable Fault Status Register Definitions */
N#define SCB_CFSR_USGFAULTSR_Pos            16U                                            /*!< SCB CFSR: Usage Fault Status Register Position */
N#define SCB_CFSR_USGFAULTSR_Msk            (0xFFFFUL << SCB_CFSR_USGFAULTSR_Pos)          /*!< SCB CFSR: Usage Fault Status Register Mask */
N
N#define SCB_CFSR_BUSFAULTSR_Pos             8U                                            /*!< SCB CFSR: Bus Fault Status Register Position */
N#define SCB_CFSR_BUSFAULTSR_Msk            (0xFFUL << SCB_CFSR_BUSFAULTSR_Pos)            /*!< SCB CFSR: Bus Fault Status Register Mask */
N
N#define SCB_CFSR_MEMFAULTSR_Pos             0U                                            /*!< SCB CFSR: Memory Manage Fault Status Register Position */
N#define SCB_CFSR_MEMFAULTSR_Msk            (0xFFUL /*<< SCB_CFSR_MEMFAULTSR_Pos*/)        /*!< SCB CFSR: Memory Manage Fault Status Register Mask */
N
N/* MemManage Fault Status Register (part of SCB Configurable Fault Status Register) */
N#define SCB_CFSR_MMARVALID_Pos             (SCB_SHCSR_MEMFAULTACT_Pos + 7U)               /*!< SCB CFSR (MMFSR): MMARVALID Position */
N#define SCB_CFSR_MMARVALID_Msk             (1UL << SCB_CFSR_MMARVALID_Pos)                /*!< SCB CFSR (MMFSR): MMARVALID Mask */
N
N#define SCB_CFSR_MSTKERR_Pos               (SCB_SHCSR_MEMFAULTACT_Pos + 4U)               /*!< SCB CFSR (MMFSR): MSTKERR Position */
N#define SCB_CFSR_MSTKERR_Msk               (1UL << SCB_CFSR_MSTKERR_Pos)                  /*!< SCB CFSR (MMFSR): MSTKERR Mask */
N
N#define SCB_CFSR_MUNSTKERR_Pos             (SCB_SHCSR_MEMFAULTACT_Pos + 3U)               /*!< SCB CFSR (MMFSR): MUNSTKERR Position */
N#define SCB_CFSR_MUNSTKERR_Msk             (1UL << SCB_CFSR_MUNSTKERR_Pos)                /*!< SCB CFSR (MMFSR): MUNSTKERR Mask */
N
N#define SCB_CFSR_DACCVIOL_Pos              (SCB_SHCSR_MEMFAULTACT_Pos + 1U)               /*!< SCB CFSR (MMFSR): DACCVIOL Position */
N#define SCB_CFSR_DACCVIOL_Msk              (1UL << SCB_CFSR_DACCVIOL_Pos)                 /*!< SCB CFSR (MMFSR): DACCVIOL Mask */
N
N#define SCB_CFSR_IACCVIOL_Pos              (SCB_SHCSR_MEMFAULTACT_Pos + 0U)               /*!< SCB CFSR (MMFSR): IACCVIOL Position */
N#define SCB_CFSR_IACCVIOL_Msk              (1UL /*<< SCB_CFSR_IACCVIOL_Pos*/)             /*!< SCB CFSR (MMFSR): IACCVIOL Mask */
N
N/* BusFault Status Register (part of SCB Configurable Fault Status Register) */
N#define SCB_CFSR_BFARVALID_Pos            (SCB_CFSR_BUSFAULTSR_Pos + 7U)                  /*!< SCB CFSR (BFSR): BFARVALID Position */
N#define SCB_CFSR_BFARVALID_Msk            (1UL << SCB_CFSR_BFARVALID_Pos)                 /*!< SCB CFSR (BFSR): BFARVALID Mask */
N
N#define SCB_CFSR_STKERR_Pos               (SCB_CFSR_BUSFAULTSR_Pos + 4U)                  /*!< SCB CFSR (BFSR): STKERR Position */
N#define SCB_CFSR_STKERR_Msk               (1UL << SCB_CFSR_STKERR_Pos)                    /*!< SCB CFSR (BFSR): STKERR Mask */
N
N#define SCB_CFSR_UNSTKERR_Pos             (SCB_CFSR_BUSFAULTSR_Pos + 3U)                  /*!< SCB CFSR (BFSR): UNSTKERR Position */
N#define SCB_CFSR_UNSTKERR_Msk             (1UL << SCB_CFSR_UNSTKERR_Pos)                  /*!< SCB CFSR (BFSR): UNSTKERR Mask */
N
N#define SCB_CFSR_IMPRECISERR_Pos          (SCB_CFSR_BUSFAULTSR_Pos + 2U)                  /*!< SCB CFSR (BFSR): IMPRECISERR Position */
N#define SCB_CFSR_IMPRECISERR_Msk          (1UL << SCB_CFSR_IMPRECISERR_Pos)               /*!< SCB CFSR (BFSR): IMPRECISERR Mask */
N
N#define SCB_CFSR_PRECISERR_Pos            (SCB_CFSR_BUSFAULTSR_Pos + 1U)                  /*!< SCB CFSR (BFSR): PRECISERR Position */
N#define SCB_CFSR_PRECISERR_Msk            (1UL << SCB_CFSR_PRECISERR_Pos)                 /*!< SCB CFSR (BFSR): PRECISERR Mask */
N
N#define SCB_CFSR_IBUSERR_Pos              (SCB_CFSR_BUSFAULTSR_Pos + 0U)                  /*!< SCB CFSR (BFSR): IBUSERR Position */
N#define SCB_CFSR_IBUSERR_Msk              (1UL << SCB_CFSR_IBUSERR_Pos)                   /*!< SCB CFSR (BFSR): IBUSERR Mask */
N
N/* UsageFault Status Register (part of SCB Configurable Fault Status Register) */
N#define SCB_CFSR_DIVBYZERO_Pos            (SCB_CFSR_USGFAULTSR_Pos + 9U)                  /*!< SCB CFSR (UFSR): DIVBYZERO Position */
N#define SCB_CFSR_DIVBYZERO_Msk            (1UL << SCB_CFSR_DIVBYZERO_Pos)                 /*!< SCB CFSR (UFSR): DIVBYZERO Mask */
N
N#define SCB_CFSR_UNALIGNED_Pos            (SCB_CFSR_USGFAULTSR_Pos + 8U)                  /*!< SCB CFSR (UFSR): UNALIGNED Position */
N#define SCB_CFSR_UNALIGNED_Msk            (1UL << SCB_CFSR_UNALIGNED_Pos)                 /*!< SCB CFSR (UFSR): UNALIGNED Mask */
N
N#define SCB_CFSR_NOCP_Pos                 (SCB_CFSR_USGFAULTSR_Pos + 3U)                  /*!< SCB CFSR (UFSR): NOCP Position */
N#define SCB_CFSR_NOCP_Msk                 (1UL << SCB_CFSR_NOCP_Pos)                      /*!< SCB CFSR (UFSR): NOCP Mask */
N
N#define SCB_CFSR_INVPC_Pos                (SCB_CFSR_USGFAULTSR_Pos + 2U)                  /*!< SCB CFSR (UFSR): INVPC Position */
N#define SCB_CFSR_INVPC_Msk                (1UL << SCB_CFSR_INVPC_Pos)                     /*!< SCB CFSR (UFSR): INVPC Mask */
N
N#define SCB_CFSR_INVSTATE_Pos             (SCB_CFSR_USGFAULTSR_Pos + 1U)                  /*!< SCB CFSR (UFSR): INVSTATE Position */
N#define SCB_CFSR_INVSTATE_Msk             (1UL << SCB_CFSR_INVSTATE_Pos)                  /*!< SCB CFSR (UFSR): INVSTATE Mask */
N
N#define SCB_CFSR_UNDEFINSTR_Pos           (SCB_CFSR_USGFAULTSR_Pos + 0U)                  /*!< SCB CFSR (UFSR): UNDEFINSTR Position */
N#define SCB_CFSR_UNDEFINSTR_Msk           (1UL << SCB_CFSR_UNDEFINSTR_Pos)                /*!< SCB CFSR (UFSR): UNDEFINSTR Mask */
N
N/* SCB Hard Fault Status Register Definitions */
N#define SCB_HFSR_DEBUGEVT_Pos              31U                                            /*!< SCB HFSR: DEBUGEVT Position */
N#define SCB_HFSR_DEBUGEVT_Msk              (1UL << SCB_HFSR_DEBUGEVT_Pos)                 /*!< SCB HFSR: DEBUGEVT Mask */
N
N#define SCB_HFSR_FORCED_Pos                30U                                            /*!< SCB HFSR: FORCED Position */
N#define SCB_HFSR_FORCED_Msk                (1UL << SCB_HFSR_FORCED_Pos)                   /*!< SCB HFSR: FORCED Mask */
N
N#define SCB_HFSR_VECTTBL_Pos                1U                                            /*!< SCB HFSR: VECTTBL Position */
N#define SCB_HFSR_VECTTBL_Msk               (1UL << SCB_HFSR_VECTTBL_Pos)                  /*!< SCB HFSR: VECTTBL Mask */
N
N/* SCB Debug Fault Status Register Definitions */
N#define SCB_DFSR_EXTERNAL_Pos               4U                                            /*!< SCB DFSR: EXTERNAL Position */
N#define SCB_DFSR_EXTERNAL_Msk              (1UL << SCB_DFSR_EXTERNAL_Pos)                 /*!< SCB DFSR: EXTERNAL Mask */
N
N#define SCB_DFSR_VCATCH_Pos                 3U                                            /*!< SCB DFSR: VCATCH Position */
N#define SCB_DFSR_VCATCH_Msk                (1UL << SCB_DFSR_VCATCH_Pos)                   /*!< SCB DFSR: VCATCH Mask */
N
N#define SCB_DFSR_DWTTRAP_Pos                2U                                            /*!< SCB DFSR: DWTTRAP Position */
N#define SCB_DFSR_DWTTRAP_Msk               (1UL << SCB_DFSR_DWTTRAP_Pos)                  /*!< SCB DFSR: DWTTRAP Mask */
N
N#define SCB_DFSR_BKPT_Pos                   1U                                            /*!< SCB DFSR: BKPT Position */
N#define SCB_DFSR_BKPT_Msk                  (1UL << SCB_DFSR_BKPT_Pos)                     /*!< SCB DFSR: BKPT Mask */
N
N#define SCB_DFSR_HALTED_Pos                 0U                                            /*!< SCB DFSR: HALTED Position */
N#define SCB_DFSR_HALTED_Msk                (1UL /*<< SCB_DFSR_HALTED_Pos*/)               /*!< SCB DFSR: HALTED Mask */
N
N/*@} end of group CMSIS_SCB */
N
N
N/**
N  \ingroup  CMSIS_core_register
N  \defgroup CMSIS_SCnSCB System Controls not in SCB (SCnSCB)
N  \brief    Type definitions for the System Control and ID Register not in the SCB
N  @{
N */
N
N/**
N  \brief  Structure type to access the System Control and ID Register not in the SCB.
N */
Ntypedef struct
N{
N        uint32_t RESERVED0[1U];
N  __IM  uint32_t ICTR;                   /*!< Offset: 0x004 (R/ )  Interrupt Controller Type Register */
X  volatile const  uint32_t ICTR;                    
N#if defined (__CM3_REV) && (__CM3_REV >= 0x200U)
X#if 1L && (0x0102 >= 0x200U)
S  __IOM uint32_t ACTLR;                  /*!< Offset: 0x008 (R/W)  Auxiliary Control Register */
N#else
N        uint32_t RESERVED1[1U];
N#endif
N} SCnSCB_Type;
N
N/* Interrupt Controller Type Register Definitions */
N#define SCnSCB_ICTR_INTLINESNUM_Pos         0U                                         /*!< ICTR: INTLINESNUM Position */
N#define SCnSCB_ICTR_INTLINESNUM_Msk        (0xFUL /*<< SCnSCB_ICTR_INTLINESNUM_Pos*/)  /*!< ICTR: INTLINESNUM Mask */
N
N/* Auxiliary Control Register Definitions */
N
N#define SCnSCB_ACTLR_DISFOLD_Pos            2U                                         /*!< ACTLR: DISFOLD Position */
N#define SCnSCB_ACTLR_DISFOLD_Msk           (1UL << SCnSCB_ACTLR_DISFOLD_Pos)           /*!< ACTLR: DISFOLD Mask */
N
N#define SCnSCB_ACTLR_DISDEFWBUF_Pos         1U                                         /*!< ACTLR: DISDEFWBUF Position */
N#define SCnSCB_ACTLR_DISDEFWBUF_Msk        (1UL << SCnSCB_ACTLR_DISDEFWBUF_Pos)        /*!< ACTLR: DISDEFWBUF Mask */
N
N#define SCnSCB_ACTLR_DISMCYCINT_Pos         0U                                         /*!< ACTLR: DISMCYCINT Position */
N#define SCnSCB_ACTLR_DISMCYCINT_Msk        (1UL /*<< SCnSCB_ACTLR_DISMCYCINT_Pos*/)    /*!< ACTLR: DISMCYCINT Mask */
N
N/*@} end of group CMSIS_SCnotSCB */
N
N
N/**
N  \ingroup  CMSIS_core_register
N  \defgroup CMSIS_SysTick     System Tick Timer (SysTick)
N  \brief    Type definitions for the System Timer Registers.
N  @{
N */
N
N/**
N  \brief  Structure type to access the System Timer (SysTick).
N */
Ntypedef struct
N{
N  __IOM uint32_t CTRL;                   /*!< Offset: 0x000 (R/W)  SysTick Control and Status Register */
X  volatile uint32_t CTRL;                    
N  __IOM uint32_t LOAD;                   /*!< Offset: 0x004 (R/W)  SysTick Reload Value Register */
X  volatile uint32_t LOAD;                    
N  __IOM uint32_t VAL;                    /*!< Offset: 0x008 (R/W)  SysTick Current Value Register */
X  volatile uint32_t VAL;                     
N  __IM  uint32_t CALIB;                  /*!< Offset: 0x00C (R/ )  SysTick Calibration Register */
X  volatile const  uint32_t CALIB;                   
N} SysTick_Type;
N
N/* SysTick Control / Status Register Definitions */
N#define SysTick_CTRL_COUNTFLAG_Pos         16U                                            /*!< SysTick CTRL: COUNTFLAG Position */
N#define SysTick_CTRL_COUNTFLAG_Msk         (1UL << SysTick_CTRL_COUNTFLAG_Pos)            /*!< SysTick CTRL: COUNTFLAG Mask */
N
N#define SysTick_CTRL_CLKSOURCE_Pos          2U                                            /*!< SysTick CTRL: CLKSOURCE Position */
N#define SysTick_CTRL_CLKSOURCE_Msk         (1UL << SysTick_CTRL_CLKSOURCE_Pos)            /*!< SysTick CTRL: CLKSOURCE Mask */
N
N#define SysTick_CTRL_TICKINT_Pos            1U                                            /*!< SysTick CTRL: TICKINT Position */
N#define SysTick_CTRL_TICKINT_Msk           (1UL << SysTick_CTRL_TICKINT_Pos)              /*!< SysTick CTRL: TICKINT Mask */
N
N#define SysTick_CTRL_ENABLE_Pos             0U                                            /*!< SysTick CTRL: ENABLE Position */
N#define SysTick_CTRL_ENABLE_Msk            (1UL /*<< SysTick_CTRL_ENABLE_Pos*/)           /*!< SysTick CTRL: ENABLE Mask */
N
N/* SysTick Reload Register Definitions */
N#define SysTick_LOAD_RELOAD_Pos             0U                                            /*!< SysTick LOAD: RELOAD Position */
N#define SysTick_LOAD_RELOAD_Msk            (0xFFFFFFUL /*<< SysTick_LOAD_RELOAD_Pos*/)    /*!< SysTick LOAD: RELOAD Mask */
N
N/* SysTick Current Register Definitions */
N#define SysTick_VAL_CURRENT_Pos             0U                                            /*!< SysTick VAL: CURRENT Position */
N#define SysTick_VAL_CURRENT_Msk            (0xFFFFFFUL /*<< SysTick_VAL_CURRENT_Pos*/)    /*!< SysTick VAL: CURRENT Mask */
N
N/* SysTick Calibration Register Definitions */
N#define SysTick_CALIB_NOREF_Pos            31U                                            /*!< SysTick CALIB: NOREF Position */
N#define SysTick_CALIB_NOREF_Msk            (1UL << SysTick_CALIB_NOREF_Pos)               /*!< SysTick CALIB: NOREF Mask */
N
N#define SysTick_CALIB_SKEW_Pos             30U                                            /*!< SysTick CALIB: SKEW Position */
N#define SysTick_CALIB_SKEW_Msk             (1UL << SysTick_CALIB_SKEW_Pos)                /*!< SysTick CALIB: SKEW Mask */
N
N#define SysTick_CALIB_TENMS_Pos             0U                                            /*!< SysTick CALIB: TENMS Position */
N#define SysTick_CALIB_TENMS_Msk            (0xFFFFFFUL /*<< SysTick_CALIB_TENMS_Pos*/)    /*!< SysTick CALIB: TENMS Mask */
N
N/*@} end of group CMSIS_SysTick */
N
N
N/**
N  \ingroup  CMSIS_core_register
N  \defgroup CMSIS_ITM     Instrumentation Trace Macrocell (ITM)
N  \brief    Type definitions for the Instrumentation Trace Macrocell (ITM)
N  @{
N */
N
N/**
N  \brief  Structure type to access the Instrumentation Trace Macrocell Register (ITM).
N */
Ntypedef struct
N{
N  __OM  union
X  volatile  union
N  {
N    __OM  uint8_t    u8;                 /*!< Offset: 0x000 ( /W)  ITM Stimulus Port 8-bit */
X    volatile  uint8_t    u8;                  
N    __OM  uint16_t   u16;                /*!< Offset: 0x000 ( /W)  ITM Stimulus Port 16-bit */
X    volatile  uint16_t   u16;                 
N    __OM  uint32_t   u32;                /*!< Offset: 0x000 ( /W)  ITM Stimulus Port 32-bit */
X    volatile  uint32_t   u32;                 
N  }  PORT [32U];                         /*!< Offset: 0x000 ( /W)  ITM Stimulus Port Registers */
N        uint32_t RESERVED0[864U];
N  __IOM uint32_t TER;                    /*!< Offset: 0xE00 (R/W)  ITM Trace Enable Register */
X  volatile uint32_t TER;                     
N        uint32_t RESERVED1[15U];
N  __IOM uint32_t TPR;                    /*!< Offset: 0xE40 (R/W)  ITM Trace Privilege Register */
X  volatile uint32_t TPR;                     
N        uint32_t RESERVED2[15U];
N  __IOM uint32_t TCR;                    /*!< Offset: 0xE80 (R/W)  ITM Trace Control Register */
X  volatile uint32_t TCR;                     
N        uint32_t RESERVED3[29U];
N  __OM  uint32_t IWR;                    /*!< Offset: 0xEF8 ( /W)  ITM Integration Write Register */
X  volatile  uint32_t IWR;                     
N  __IM  uint32_t IRR;                    /*!< Offset: 0xEFC (R/ )  ITM Integration Read Register */
X  volatile const  uint32_t IRR;                     
N  __IOM uint32_t IMCR;                   /*!< Offset: 0xF00 (R/W)  ITM Integration Mode Control Register */
X  volatile uint32_t IMCR;                    
N        uint32_t RESERVED4[43U];
N  __OM  uint32_t LAR;                    /*!< Offset: 0xFB0 ( /W)  ITM Lock Access Register */
X  volatile  uint32_t LAR;                     
N  __IM  uint32_t LSR;                    /*!< Offset: 0xFB4 (R/ )  ITM Lock Status Register */
X  volatile const  uint32_t LSR;                     
N        uint32_t RESERVED5[6U];
N  __IM  uint32_t PID4;                   /*!< Offset: 0xFD0 (R/ )  ITM Peripheral Identification Register #4 */
X  volatile const  uint32_t PID4;                    
N  __IM  uint32_t PID5;                   /*!< Offset: 0xFD4 (R/ )  ITM Peripheral Identification Register #5 */
X  volatile const  uint32_t PID5;                    
N  __IM  uint32_t PID6;                   /*!< Offset: 0xFD8 (R/ )  ITM Peripheral Identification Register #6 */
X  volatile const  uint32_t PID6;                    
N  __IM  uint32_t PID7;                   /*!< Offset: 0xFDC (R/ )  ITM Peripheral Identification Register #7 */
X  volatile const  uint32_t PID7;                    
N  __IM  uint32_t PID0;                   /*!< Offset: 0xFE0 (R/ )  ITM Peripheral Identification Register #0 */
X  volatile const  uint32_t PID0;                    
N  __IM  uint32_t PID1;                   /*!< Offset: 0xFE4 (R/ )  ITM Peripheral Identification Register #1 */
X  volatile const  uint32_t PID1;                    
N  __IM  uint32_t PID2;                   /*!< Offset: 0xFE8 (R/ )  ITM Peripheral Identification Register #2 */
X  volatile const  uint32_t PID2;                    
N  __IM  uint32_t PID3;                   /*!< Offset: 0xFEC (R/ )  ITM Peripheral Identification Register #3 */
X  volatile const  uint32_t PID3;                    
N  __IM  uint32_t CID0;                   /*!< Offset: 0xFF0 (R/ )  ITM Component  Identification Register #0 */
X  volatile const  uint32_t CID0;                    
N  __IM  uint32_t CID1;                   /*!< Offset: 0xFF4 (R/ )  ITM Component  Identification Register #1 */
X  volatile const  uint32_t CID1;                    
N  __IM  uint32_t CID2;                   /*!< Offset: 0xFF8 (R/ )  ITM Component  Identification Register #2 */
X  volatile const  uint32_t CID2;                    
N  __IM  uint32_t CID3;                   /*!< Offset: 0xFFC (R/ )  ITM Component  Identification Register #3 */
X  volatile const  uint32_t CID3;                    
N} ITM_Type;
N
N/* ITM Trace Privilege Register Definitions */
N#define ITM_TPR_PRIVMASK_Pos                0U                                            /*!< ITM TPR: PRIVMASK Position */
N#define ITM_TPR_PRIVMASK_Msk               (0xFUL /*<< ITM_TPR_PRIVMASK_Pos*/)            /*!< ITM TPR: PRIVMASK Mask */
N
N/* ITM Trace Control Register Definitions */
N#define ITM_TCR_BUSY_Pos                   23U                                            /*!< ITM TCR: BUSY Position */
N#define ITM_TCR_BUSY_Msk                   (1UL << ITM_TCR_BUSY_Pos)                      /*!< ITM TCR: BUSY Mask */
N
N#define ITM_TCR_TraceBusID_Pos             16U                                            /*!< ITM TCR: ATBID Position */
N#define ITM_TCR_TraceBusID_Msk             (0x7FUL << ITM_TCR_TraceBusID_Pos)             /*!< ITM TCR: ATBID Mask */
N
N#define ITM_TCR_GTSFREQ_Pos                10U                                            /*!< ITM TCR: Global timestamp frequency Position */
N#define ITM_TCR_GTSFREQ_Msk                (3UL << ITM_TCR_GTSFREQ_Pos)                   /*!< ITM TCR: Global timestamp frequency Mask */
N
N#define ITM_TCR_TSPrescale_Pos              8U                                            /*!< ITM TCR: TSPrescale Position */
N#define ITM_TCR_TSPrescale_Msk             (3UL << ITM_TCR_TSPrescale_Pos)                /*!< ITM TCR: TSPrescale Mask */
N
N#define ITM_TCR_SWOENA_Pos                  4U                                            /*!< ITM TCR: SWOENA Position */
N#define ITM_TCR_SWOENA_Msk                 (1UL << ITM_TCR_SWOENA_Pos)                    /*!< ITM TCR: SWOENA Mask */
N
N#define ITM_TCR_DWTENA_Pos                  3U                                            /*!< ITM TCR: DWTENA Position */
N#define ITM_TCR_DWTENA_Msk                 (1UL << ITM_TCR_DWTENA_Pos)                    /*!< ITM TCR: DWTENA Mask */
N
N#define ITM_TCR_SYNCENA_Pos                 2U                                            /*!< ITM TCR: SYNCENA Position */
N#define ITM_TCR_SYNCENA_Msk                (1UL << ITM_TCR_SYNCENA_Pos)                   /*!< ITM TCR: SYNCENA Mask */
N
N#define ITM_TCR_TSENA_Pos                   1U                                            /*!< ITM TCR: TSENA Position */
N#define ITM_TCR_TSENA_Msk                  (1UL << ITM_TCR_TSENA_Pos)                     /*!< ITM TCR: TSENA Mask */
N
N#define ITM_TCR_ITMENA_Pos                  0U                                            /*!< ITM TCR: ITM Enable bit Position */
N#define ITM_TCR_ITMENA_Msk                 (1UL /*<< ITM_TCR_ITMENA_Pos*/)                /*!< ITM TCR: ITM Enable bit Mask */
N
N/* ITM Integration Write Register Definitions */
N#define ITM_IWR_ATVALIDM_Pos                0U                                            /*!< ITM IWR: ATVALIDM Position */
N#define ITM_IWR_ATVALIDM_Msk               (1UL /*<< ITM_IWR_ATVALIDM_Pos*/)              /*!< ITM IWR: ATVALIDM Mask */
N
N/* ITM Integration Read Register Definitions */
N#define ITM_IRR_ATREADYM_Pos                0U                                            /*!< ITM IRR: ATREADYM Position */
N#define ITM_IRR_ATREADYM_Msk               (1UL /*<< ITM_IRR_ATREADYM_Pos*/)              /*!< ITM IRR: ATREADYM Mask */
N
N/* ITM Integration Mode Control Register Definitions */
N#define ITM_IMCR_INTEGRATION_Pos            0U                                            /*!< ITM IMCR: INTEGRATION Position */
N#define ITM_IMCR_INTEGRATION_Msk           (1UL /*<< ITM_IMCR_INTEGRATION_Pos*/)          /*!< ITM IMCR: INTEGRATION Mask */
N
N/* ITM Lock Status Register Definitions */
N#define ITM_LSR_ByteAcc_Pos                 2U                                            /*!< ITM LSR: ByteAcc Position */
N#define ITM_LSR_ByteAcc_Msk                (1UL << ITM_LSR_ByteAcc_Pos)                   /*!< ITM LSR: ByteAcc Mask */
N
N#define ITM_LSR_Access_Pos                  1U                                            /*!< ITM LSR: Access Position */
N#define ITM_LSR_Access_Msk                 (1UL << ITM_LSR_Access_Pos)                    /*!< ITM LSR: Access Mask */
N
N#define ITM_LSR_Present_Pos                 0U                                            /*!< ITM LSR: Present Position */
N#define ITM_LSR_Present_Msk                (1UL /*<< ITM_LSR_Present_Pos*/)               /*!< ITM LSR: Present Mask */
N
N/*@}*/ /* end of group CMSIS_ITM */
N
N
N/**
N  \ingroup  CMSIS_core_register
N  \defgroup CMSIS_DWT     Data Watchpoint and Trace (DWT)
N  \brief    Type definitions for the Data Watchpoint and Trace (DWT)
N  @{
N */
N
N/**
N  \brief  Structure type to access the Data Watchpoint and Trace Register (DWT).
N */
Ntypedef struct
N{
N  __IOM uint32_t CTRL;                   /*!< Offset: 0x000 (R/W)  Control Register */
X  volatile uint32_t CTRL;                    
N  __IOM uint32_t CYCCNT;                 /*!< Offset: 0x004 (R/W)  Cycle Count Register */
X  volatile uint32_t CYCCNT;                  
N  __IOM uint32_t CPICNT;                 /*!< Offset: 0x008 (R/W)  CPI Count Register */
X  volatile uint32_t CPICNT;                  
N  __IOM uint32_t EXCCNT;                 /*!< Offset: 0x00C (R/W)  Exception Overhead Count Register */
X  volatile uint32_t EXCCNT;                  
N  __IOM uint32_t SLEEPCNT;               /*!< Offset: 0x010 (R/W)  Sleep Count Register */
X  volatile uint32_t SLEEPCNT;                
N  __IOM uint32_t LSUCNT;                 /*!< Offset: 0x014 (R/W)  LSU Count Register */
X  volatile uint32_t LSUCNT;                  
N  __IOM uint32_t FOLDCNT;                /*!< Offset: 0x018 (R/W)  Folded-instruction Count Register */
X  volatile uint32_t FOLDCNT;                 
N  __IM  uint32_t PCSR;                   /*!< Offset: 0x01C (R/ )  Program Counter Sample Register */
X  volatile const  uint32_t PCSR;                    
N  __IOM uint32_t COMP0;                  /*!< Offset: 0x020 (R/W)  Comparator Register 0 */
X  volatile uint32_t COMP0;                   
N  __IOM uint32_t MASK0;                  /*!< Offset: 0x024 (R/W)  Mask Register 0 */
X  volatile uint32_t MASK0;                   
N  __IOM uint32_t FUNCTION0;              /*!< Offset: 0x028 (R/W)  Function Register 0 */
X  volatile uint32_t FUNCTION0;               
N        uint32_t RESERVED0[1U];
N  __IOM uint32_t COMP1;                  /*!< Offset: 0x030 (R/W)  Comparator Register 1 */
X  volatile uint32_t COMP1;                   
N  __IOM uint32_t MASK1;                  /*!< Offset: 0x034 (R/W)  Mask Register 1 */
X  volatile uint32_t MASK1;                   
N  __IOM uint32_t FUNCTION1;              /*!< Offset: 0x038 (R/W)  Function Register 1 */
X  volatile uint32_t FUNCTION1;               
N        uint32_t RESERVED1[1U];
N  __IOM uint32_t COMP2;                  /*!< Offset: 0x040 (R/W)  Comparator Register 2 */
X  volatile uint32_t COMP2;                   
N  __IOM uint32_t MASK2;                  /*!< Offset: 0x044 (R/W)  Mask Register 2 */
X  volatile uint32_t MASK2;                   
N  __IOM uint32_t FUNCTION2;              /*!< Offset: 0x048 (R/W)  Function Register 2 */
X  volatile uint32_t FUNCTION2;               
N        uint32_t RESERVED2[1U];
N  __IOM uint32_t COMP3;                  /*!< Offset: 0x050 (R/W)  Comparator Register 3 */
X  volatile uint32_t COMP3;                   
N  __IOM uint32_t MASK3;                  /*!< Offset: 0x054 (R/W)  Mask Register 3 */
X  volatile uint32_t MASK3;                   
N  __IOM uint32_t FUNCTION3;              /*!< Offset: 0x058 (R/W)  Function Register 3 */
X  volatile uint32_t FUNCTION3;               
N} DWT_Type;
N
N/* DWT Control Register Definitions */
N#define DWT_CTRL_NUMCOMP_Pos               28U                                         /*!< DWT CTRL: NUMCOMP Position */
N#define DWT_CTRL_NUMCOMP_Msk               (0xFUL << DWT_CTRL_NUMCOMP_Pos)             /*!< DWT CTRL: NUMCOMP Mask */
N
N#define DWT_CTRL_NOTRCPKT_Pos              27U                                         /*!< DWT CTRL: NOTRCPKT Position */
N#define DWT_CTRL_NOTRCPKT_Msk              (0x1UL << DWT_CTRL_NOTRCPKT_Pos)            /*!< DWT CTRL: NOTRCPKT Mask */
N
N#define DWT_CTRL_NOEXTTRIG_Pos             26U                                         /*!< DWT CTRL: NOEXTTRIG Position */
N#define DWT_CTRL_NOEXTTRIG_Msk             (0x1UL << DWT_CTRL_NOEXTTRIG_Pos)           /*!< DWT CTRL: NOEXTTRIG Mask */
N
N#define DWT_CTRL_NOCYCCNT_Pos              25U                                         /*!< DWT CTRL: NOCYCCNT Position */
N#define DWT_CTRL_NOCYCCNT_Msk              (0x1UL << DWT_CTRL_NOCYCCNT_Pos)            /*!< DWT CTRL: NOCYCCNT Mask */
N
N#define DWT_CTRL_NOPRFCNT_Pos              24U                                         /*!< DWT CTRL: NOPRFCNT Position */
N#define DWT_CTRL_NOPRFCNT_Msk              (0x1UL << DWT_CTRL_NOPRFCNT_Pos)            /*!< DWT CTRL: NOPRFCNT Mask */
N
N#define DWT_CTRL_CYCEVTENA_Pos             22U                                         /*!< DWT CTRL: CYCEVTENA Position */
N#define DWT_CTRL_CYCEVTENA_Msk             (0x1UL << DWT_CTRL_CYCEVTENA_Pos)           /*!< DWT CTRL: CYCEVTENA Mask */
N
N#define DWT_CTRL_FOLDEVTENA_Pos            21U                                         /*!< DWT CTRL: FOLDEVTENA Position */
N#define DWT_CTRL_FOLDEVTENA_Msk            (0x1UL << DWT_CTRL_FOLDEVTENA_Pos)          /*!< DWT CTRL: FOLDEVTENA Mask */
N
N#define DWT_CTRL_LSUEVTENA_Pos             20U                                         /*!< DWT CTRL: LSUEVTENA Position */
N#define DWT_CTRL_LSUEVTENA_Msk             (0x1UL << DWT_CTRL_LSUEVTENA_Pos)           /*!< DWT CTRL: LSUEVTENA Mask */
N
N#define DWT_CTRL_SLEEPEVTENA_Pos           19U                                         /*!< DWT CTRL: SLEEPEVTENA Position */
N#define DWT_CTRL_SLEEPEVTENA_Msk           (0x1UL << DWT_CTRL_SLEEPEVTENA_Pos)         /*!< DWT CTRL: SLEEPEVTENA Mask */
N
N#define DWT_CTRL_EXCEVTENA_Pos             18U                                         /*!< DWT CTRL: EXCEVTENA Position */
N#define DWT_CTRL_EXCEVTENA_Msk             (0x1UL << DWT_CTRL_EXCEVTENA_Pos)           /*!< DWT CTRL: EXCEVTENA Mask */
N
N#define DWT_CTRL_CPIEVTENA_Pos             17U                                         /*!< DWT CTRL: CPIEVTENA Position */
N#define DWT_CTRL_CPIEVTENA_Msk             (0x1UL << DWT_CTRL_CPIEVTENA_Pos)           /*!< DWT CTRL: CPIEVTENA Mask */
N
N#define DWT_CTRL_EXCTRCENA_Pos             16U                                         /*!< DWT CTRL: EXCTRCENA Position */
N#define DWT_CTRL_EXCTRCENA_Msk             (0x1UL << DWT_CTRL_EXCTRCENA_Pos)           /*!< DWT CTRL: EXCTRCENA Mask */
N
N#define DWT_CTRL_PCSAMPLENA_Pos            12U                                         /*!< DWT CTRL: PCSAMPLENA Position */
N#define DWT_CTRL_PCSAMPLENA_Msk            (0x1UL << DWT_CTRL_PCSAMPLENA_Pos)          /*!< DWT CTRL: PCSAMPLENA Mask */
N
N#define DWT_CTRL_SYNCTAP_Pos               10U                                         /*!< DWT CTRL: SYNCTAP Position */
N#define DWT_CTRL_SYNCTAP_Msk               (0x3UL << DWT_CTRL_SYNCTAP_Pos)             /*!< DWT CTRL: SYNCTAP Mask */
N
N#define DWT_CTRL_CYCTAP_Pos                 9U                                         /*!< DWT CTRL: CYCTAP Position */
N#define DWT_CTRL_CYCTAP_Msk                (0x1UL << DWT_CTRL_CYCTAP_Pos)              /*!< DWT CTRL: CYCTAP Mask */
N
N#define DWT_CTRL_POSTINIT_Pos               5U                                         /*!< DWT CTRL: POSTINIT Position */
N#define DWT_CTRL_POSTINIT_Msk              (0xFUL << DWT_CTRL_POSTINIT_Pos)            /*!< DWT CTRL: POSTINIT Mask */
N
N#define DWT_CTRL_POSTPRESET_Pos             1U                                         /*!< DWT CTRL: POSTPRESET Position */
N#define DWT_CTRL_POSTPRESET_Msk            (0xFUL << DWT_CTRL_POSTPRESET_Pos)          /*!< DWT CTRL: POSTPRESET Mask */
N
N#define DWT_CTRL_CYCCNTENA_Pos              0U                                         /*!< DWT CTRL: CYCCNTENA Position */
N#define DWT_CTRL_CYCCNTENA_Msk             (0x1UL /*<< DWT_CTRL_CYCCNTENA_Pos*/)       /*!< DWT CTRL: CYCCNTENA Mask */
N
N/* DWT CPI Count Register Definitions */
N#define DWT_CPICNT_CPICNT_Pos               0U                                         /*!< DWT CPICNT: CPICNT Position */
N#define DWT_CPICNT_CPICNT_Msk              (0xFFUL /*<< DWT_CPICNT_CPICNT_Pos*/)       /*!< DWT CPICNT: CPICNT Mask */
N
N/* DWT Exception Overhead Count Register Definitions */
N#define DWT_EXCCNT_EXCCNT_Pos               0U                                         /*!< DWT EXCCNT: EXCCNT Position */
N#define DWT_EXCCNT_EXCCNT_Msk              (0xFFUL /*<< DWT_EXCCNT_EXCCNT_Pos*/)       /*!< DWT EXCCNT: EXCCNT Mask */
N
N/* DWT Sleep Count Register Definitions */
N#define DWT_SLEEPCNT_SLEEPCNT_Pos           0U                                         /*!< DWT SLEEPCNT: SLEEPCNT Position */
N#define DWT_SLEEPCNT_SLEEPCNT_Msk          (0xFFUL /*<< DWT_SLEEPCNT_SLEEPCNT_Pos*/)   /*!< DWT SLEEPCNT: SLEEPCNT Mask */
N
N/* DWT LSU Count Register Definitions */
N#define DWT_LSUCNT_LSUCNT_Pos               0U                                         /*!< DWT LSUCNT: LSUCNT Position */
N#define DWT_LSUCNT_LSUCNT_Msk              (0xFFUL /*<< DWT_LSUCNT_LSUCNT_Pos*/)       /*!< DWT LSUCNT: LSUCNT Mask */
N
N/* DWT Folded-instruction Count Register Definitions */
N#define DWT_FOLDCNT_FOLDCNT_Pos             0U                                         /*!< DWT FOLDCNT: FOLDCNT Position */
N#define DWT_FOLDCNT_FOLDCNT_Msk            (0xFFUL /*<< DWT_FOLDCNT_FOLDCNT_Pos*/)     /*!< DWT FOLDCNT: FOLDCNT Mask */
N
N/* DWT Comparator Mask Register Definitions */
N#define DWT_MASK_MASK_Pos                   0U                                         /*!< DWT MASK: MASK Position */
N#define DWT_MASK_MASK_Msk                  (0x1FUL /*<< DWT_MASK_MASK_Pos*/)           /*!< DWT MASK: MASK Mask */
N
N/* DWT Comparator Function Register Definitions */
N#define DWT_FUNCTION_MATCHED_Pos           24U                                         /*!< DWT FUNCTION: MATCHED Position */
N#define DWT_FUNCTION_MATCHED_Msk           (0x1UL << DWT_FUNCTION_MATCHED_Pos)         /*!< DWT FUNCTION: MATCHED Mask */
N
N#define DWT_FUNCTION_DATAVADDR1_Pos        16U                                         /*!< DWT FUNCTION: DATAVADDR1 Position */
N#define DWT_FUNCTION_DATAVADDR1_Msk        (0xFUL << DWT_FUNCTION_DATAVADDR1_Pos)      /*!< DWT FUNCTION: DATAVADDR1 Mask */
N
N#define DWT_FUNCTION_DATAVADDR0_Pos        12U                                         /*!< DWT FUNCTION: DATAVADDR0 Position */
N#define DWT_FUNCTION_DATAVADDR0_Msk        (0xFUL << DWT_FUNCTION_DATAVADDR0_Pos)      /*!< DWT FUNCTION: DATAVADDR0 Mask */
N
N#define DWT_FUNCTION_DATAVSIZE_Pos         10U                                         /*!< DWT FUNCTION: DATAVSIZE Position */
N#define DWT_FUNCTION_DATAVSIZE_Msk         (0x3UL << DWT_FUNCTION_DATAVSIZE_Pos)       /*!< DWT FUNCTION: DATAVSIZE Mask */
N
N#define DWT_FUNCTION_LNK1ENA_Pos            9U                                         /*!< DWT FUNCTION: LNK1ENA Position */
N#define DWT_FUNCTION_LNK1ENA_Msk           (0x1UL << DWT_FUNCTION_LNK1ENA_Pos)         /*!< DWT FUNCTION: LNK1ENA Mask */
N
N#define DWT_FUNCTION_DATAVMATCH_Pos         8U                                         /*!< DWT FUNCTION: DATAVMATCH Position */
N#define DWT_FUNCTION_DATAVMATCH_Msk        (0x1UL << DWT_FUNCTION_DATAVMATCH_Pos)      /*!< DWT FUNCTION: DATAVMATCH Mask */
N
N#define DWT_FUNCTION_CYCMATCH_Pos           7U                                         /*!< DWT FUNCTION: CYCMATCH Position */
N#define DWT_FUNCTION_CYCMATCH_Msk          (0x1UL << DWT_FUNCTION_CYCMATCH_Pos)        /*!< DWT FUNCTION: CYCMATCH Mask */
N
N#define DWT_FUNCTION_EMITRANGE_Pos          5U                                         /*!< DWT FUNCTION: EMITRANGE Position */
N#define DWT_FUNCTION_EMITRANGE_Msk         (0x1UL << DWT_FUNCTION_EMITRANGE_Pos)       /*!< DWT FUNCTION: EMITRANGE Mask */
N
N#define DWT_FUNCTION_FUNCTION_Pos           0U                                         /*!< DWT FUNCTION: FUNCTION Position */
N#define DWT_FUNCTION_FUNCTION_Msk          (0xFUL /*<< DWT_FUNCTION_FUNCTION_Pos*/)    /*!< DWT FUNCTION: FUNCTION Mask */
N
N/*@}*/ /* end of group CMSIS_DWT */
N
N
N/**
N  \ingroup  CMSIS_core_register
N  \defgroup CMSIS_TPI     Trace Port Interface (TPI)
N  \brief    Type definitions for the Trace Port Interface (TPI)
N  @{
N */
N
N/**
N  \brief  Structure type to access the Trace Port Interface Register (TPI).
N */
Ntypedef struct
N{
N  __IOM uint32_t SSPSR;                  /*!< Offset: 0x000 (R/ )  Supported Parallel Port Size Register */
X  volatile uint32_t SSPSR;                   
N  __IOM uint32_t CSPSR;                  /*!< Offset: 0x004 (R/W)  Current Parallel Port Size Register */
X  volatile uint32_t CSPSR;                   
N        uint32_t RESERVED0[2U];
N  __IOM uint32_t ACPR;                   /*!< Offset: 0x010 (R/W)  Asynchronous Clock Prescaler Register */
X  volatile uint32_t ACPR;                    
N        uint32_t RESERVED1[55U];
N  __IOM uint32_t SPPR;                   /*!< Offset: 0x0F0 (R/W)  Selected Pin Protocol Register */
X  volatile uint32_t SPPR;                    
N        uint32_t RESERVED2[131U];
N  __IM  uint32_t FFSR;                   /*!< Offset: 0x300 (R/ )  Formatter and Flush Status Register */
X  volatile const  uint32_t FFSR;                    
N  __IOM uint32_t FFCR;                   /*!< Offset: 0x304 (R/W)  Formatter and Flush Control Register */
X  volatile uint32_t FFCR;                    
N  __IM  uint32_t FSCR;                   /*!< Offset: 0x308 (R/ )  Formatter Synchronization Counter Register */
X  volatile const  uint32_t FSCR;                    
N        uint32_t RESERVED3[759U];
N  __IM  uint32_t TRIGGER;                /*!< Offset: 0xEE8 (R/ )  TRIGGER */
X  volatile const  uint32_t TRIGGER;                 
N  __IM  uint32_t FIFO0;                  /*!< Offset: 0xEEC (R/ )  Integration ETM Data */
X  volatile const  uint32_t FIFO0;                   
N  __IM  uint32_t ITATBCTR2;              /*!< Offset: 0xEF0 (R/ )  ITATBCTR2 */
X  volatile const  uint32_t ITATBCTR2;               
N        uint32_t RESERVED4[1U];
N  __IM  uint32_t ITATBCTR0;              /*!< Offset: 0xEF8 (R/ )  ITATBCTR0 */
X  volatile const  uint32_t ITATBCTR0;               
N  __IM  uint32_t FIFO1;                  /*!< Offset: 0xEFC (R/ )  Integration ITM Data */
X  volatile const  uint32_t FIFO1;                   
N  __IOM uint32_t ITCTRL;                 /*!< Offset: 0xF00 (R/W)  Integration Mode Control */
X  volatile uint32_t ITCTRL;                  
N        uint32_t RESERVED5[39U];
N  __IOM uint32_t CLAIMSET;               /*!< Offset: 0xFA0 (R/W)  Claim tag set */
X  volatile uint32_t CLAIMSET;                
N  __IOM uint32_t CLAIMCLR;               /*!< Offset: 0xFA4 (R/W)  Claim tag clear */
X  volatile uint32_t CLAIMCLR;                
N        uint32_t RESERVED7[8U];
N  __IM  uint32_t DEVID;                  /*!< Offset: 0xFC8 (R/ )  TPIU_DEVID */
X  volatile const  uint32_t DEVID;                   
N  __IM  uint32_t DEVTYPE;                /*!< Offset: 0xFCC (R/ )  TPIU_DEVTYPE */
X  volatile const  uint32_t DEVTYPE;                 
N} TPI_Type;
N
N/* TPI Asynchronous Clock Prescaler Register Definitions */
N#define TPI_ACPR_PRESCALER_Pos              0U                                         /*!< TPI ACPR: PRESCALER Position */
N#define TPI_ACPR_PRESCALER_Msk             (0x1FFFUL /*<< TPI_ACPR_PRESCALER_Pos*/)    /*!< TPI ACPR: PRESCALER Mask */
N
N/* TPI Selected Pin Protocol Register Definitions */
N#define TPI_SPPR_TXMODE_Pos                 0U                                         /*!< TPI SPPR: TXMODE Position */
N#define TPI_SPPR_TXMODE_Msk                (0x3UL /*<< TPI_SPPR_TXMODE_Pos*/)          /*!< TPI SPPR: TXMODE Mask */
N
N/* TPI Formatter and Flush Status Register Definitions */
N#define TPI_FFSR_FtNonStop_Pos              3U                                         /*!< TPI FFSR: FtNonStop Position */
N#define TPI_FFSR_FtNonStop_Msk             (0x1UL << TPI_FFSR_FtNonStop_Pos)           /*!< TPI FFSR: FtNonStop Mask */
N
N#define TPI_FFSR_TCPresent_Pos              2U                                         /*!< TPI FFSR: TCPresent Position */
N#define TPI_FFSR_TCPresent_Msk             (0x1UL << TPI_FFSR_TCPresent_Pos)           /*!< TPI FFSR: TCPresent Mask */
N
N#define TPI_FFSR_FtStopped_Pos              1U                                         /*!< TPI FFSR: FtStopped Position */
N#define TPI_FFSR_FtStopped_Msk             (0x1UL << TPI_FFSR_FtStopped_Pos)           /*!< TPI FFSR: FtStopped Mask */
N
N#define TPI_FFSR_FlInProg_Pos               0U                                         /*!< TPI FFSR: FlInProg Position */
N#define TPI_FFSR_FlInProg_Msk              (0x1UL /*<< TPI_FFSR_FlInProg_Pos*/)        /*!< TPI FFSR: FlInProg Mask */
N
N/* TPI Formatter and Flush Control Register Definitions */
N#define TPI_FFCR_TrigIn_Pos                 8U                                         /*!< TPI FFCR: TrigIn Position */
N#define TPI_FFCR_TrigIn_Msk                (0x1UL << TPI_FFCR_TrigIn_Pos)              /*!< TPI FFCR: TrigIn Mask */
N
N#define TPI_FFCR_EnFCont_Pos                1U                                         /*!< TPI FFCR: EnFCont Position */
N#define TPI_FFCR_EnFCont_Msk               (0x1UL << TPI_FFCR_EnFCont_Pos)             /*!< TPI FFCR: EnFCont Mask */
N
N/* TPI TRIGGER Register Definitions */
N#define TPI_TRIGGER_TRIGGER_Pos             0U                                         /*!< TPI TRIGGER: TRIGGER Position */
N#define TPI_TRIGGER_TRIGGER_Msk            (0x1UL /*<< TPI_TRIGGER_TRIGGER_Pos*/)      /*!< TPI TRIGGER: TRIGGER Mask */
N
N/* TPI Integration ETM Data Register Definitions (FIFO0) */
N#define TPI_FIFO0_ITM_ATVALID_Pos          29U                                         /*!< TPI FIFO0: ITM_ATVALID Position */
N#define TPI_FIFO0_ITM_ATVALID_Msk          (0x3UL << TPI_FIFO0_ITM_ATVALID_Pos)        /*!< TPI FIFO0: ITM_ATVALID Mask */
N
N#define TPI_FIFO0_ITM_bytecount_Pos        27U                                         /*!< TPI FIFO0: ITM_bytecount Position */
N#define TPI_FIFO0_ITM_bytecount_Msk        (0x3UL << TPI_FIFO0_ITM_bytecount_Pos)      /*!< TPI FIFO0: ITM_bytecount Mask */
N
N#define TPI_FIFO0_ETM_ATVALID_Pos          26U                                         /*!< TPI FIFO0: ETM_ATVALID Position */
N#define TPI_FIFO0_ETM_ATVALID_Msk          (0x3UL << TPI_FIFO0_ETM_ATVALID_Pos)        /*!< TPI FIFO0: ETM_ATVALID Mask */
N
N#define TPI_FIFO0_ETM_bytecount_Pos        24U                                         /*!< TPI FIFO0: ETM_bytecount Position */
N#define TPI_FIFO0_ETM_bytecount_Msk        (0x3UL << TPI_FIFO0_ETM_bytecount_Pos)      /*!< TPI FIFO0: ETM_bytecount Mask */
N
N#define TPI_FIFO0_ETM2_Pos                 16U                                         /*!< TPI FIFO0: ETM2 Position */
N#define TPI_FIFO0_ETM2_Msk                 (0xFFUL << TPI_FIFO0_ETM2_Pos)              /*!< TPI FIFO0: ETM2 Mask */
N
N#define TPI_FIFO0_ETM1_Pos                  8U                                         /*!< TPI FIFO0: ETM1 Position */
N#define TPI_FIFO0_ETM1_Msk                 (0xFFUL << TPI_FIFO0_ETM1_Pos)              /*!< TPI FIFO0: ETM1 Mask */
N
N#define TPI_FIFO0_ETM0_Pos                  0U                                         /*!< TPI FIFO0: ETM0 Position */
N#define TPI_FIFO0_ETM0_Msk                 (0xFFUL /*<< TPI_FIFO0_ETM0_Pos*/)          /*!< TPI FIFO0: ETM0 Mask */
N
N/* TPI ITATBCTR2 Register Definitions */
N#define TPI_ITATBCTR2_ATREADY_Pos           0U                                         /*!< TPI ITATBCTR2: ATREADY Position */
N#define TPI_ITATBCTR2_ATREADY_Msk          (0x1UL /*<< TPI_ITATBCTR2_ATREADY_Pos*/)    /*!< TPI ITATBCTR2: ATREADY Mask */
N
N/* TPI Integration ITM Data Register Definitions (FIFO1) */
N#define TPI_FIFO1_ITM_ATVALID_Pos          29U                                         /*!< TPI FIFO1: ITM_ATVALID Position */
N#define TPI_FIFO1_ITM_ATVALID_Msk          (0x3UL << TPI_FIFO1_ITM_ATVALID_Pos)        /*!< TPI FIFO1: ITM_ATVALID Mask */
N
N#define TPI_FIFO1_ITM_bytecount_Pos        27U                                         /*!< TPI FIFO1: ITM_bytecount Position */
N#define TPI_FIFO1_ITM_bytecount_Msk        (0x3UL << TPI_FIFO1_ITM_bytecount_Pos)      /*!< TPI FIFO1: ITM_bytecount Mask */
N
N#define TPI_FIFO1_ETM_ATVALID_Pos          26U                                         /*!< TPI FIFO1: ETM_ATVALID Position */
N#define TPI_FIFO1_ETM_ATVALID_Msk          (0x3UL << TPI_FIFO1_ETM_ATVALID_Pos)        /*!< TPI FIFO1: ETM_ATVALID Mask */
N
N#define TPI_FIFO1_ETM_bytecount_Pos        24U                                         /*!< TPI FIFO1: ETM_bytecount Position */
N#define TPI_FIFO1_ETM_bytecount_Msk        (0x3UL << TPI_FIFO1_ETM_bytecount_Pos)      /*!< TPI FIFO1: ETM_bytecount Mask */
N
N#define TPI_FIFO1_ITM2_Pos                 16U                                         /*!< TPI FIFO1: ITM2 Position */
N#define TPI_FIFO1_ITM2_Msk                 (0xFFUL << TPI_FIFO1_ITM2_Pos)              /*!< TPI FIFO1: ITM2 Mask */
N
N#define TPI_FIFO1_ITM1_Pos                  8U                                         /*!< TPI FIFO1: ITM1 Position */
N#define TPI_FIFO1_ITM1_Msk                 (0xFFUL << TPI_FIFO1_ITM1_Pos)              /*!< TPI FIFO1: ITM1 Mask */
N
N#define TPI_FIFO1_ITM0_Pos                  0U                                         /*!< TPI FIFO1: ITM0 Position */
N#define TPI_FIFO1_ITM0_Msk                 (0xFFUL /*<< TPI_FIFO1_ITM0_Pos*/)          /*!< TPI FIFO1: ITM0 Mask */
N
N/* TPI ITATBCTR0 Register Definitions */
N#define TPI_ITATBCTR0_ATREADY_Pos           0U                                         /*!< TPI ITATBCTR0: ATREADY Position */
N#define TPI_ITATBCTR0_ATREADY_Msk          (0x1UL /*<< TPI_ITATBCTR0_ATREADY_Pos*/)    /*!< TPI ITATBCTR0: ATREADY Mask */
N
N/* TPI Integration Mode Control Register Definitions */
N#define TPI_ITCTRL_Mode_Pos                 0U                                         /*!< TPI ITCTRL: Mode Position */
N#define TPI_ITCTRL_Mode_Msk                (0x1UL /*<< TPI_ITCTRL_Mode_Pos*/)          /*!< TPI ITCTRL: Mode Mask */
N
N/* TPI DEVID Register Definitions */
N#define TPI_DEVID_NRZVALID_Pos             11U                                         /*!< TPI DEVID: NRZVALID Position */
N#define TPI_DEVID_NRZVALID_Msk             (0x1UL << TPI_DEVID_NRZVALID_Pos)           /*!< TPI DEVID: NRZVALID Mask */
N
N#define TPI_DEVID_MANCVALID_Pos            10U                                         /*!< TPI DEVID: MANCVALID Position */
N#define TPI_DEVID_MANCVALID_Msk            (0x1UL << TPI_DEVID_MANCVALID_Pos)          /*!< TPI DEVID: MANCVALID Mask */
N
N#define TPI_DEVID_PTINVALID_Pos             9U                                         /*!< TPI DEVID: PTINVALID Position */
N#define TPI_DEVID_PTINVALID_Msk            (0x1UL << TPI_DEVID_PTINVALID_Pos)          /*!< TPI DEVID: PTINVALID Mask */
N
N#define TPI_DEVID_MinBufSz_Pos              6U                                         /*!< TPI DEVID: MinBufSz Position */
N#define TPI_DEVID_MinBufSz_Msk             (0x7UL << TPI_DEVID_MinBufSz_Pos)           /*!< TPI DEVID: MinBufSz Mask */
N
N#define TPI_DEVID_AsynClkIn_Pos             5U                                         /*!< TPI DEVID: AsynClkIn Position */
N#define TPI_DEVID_AsynClkIn_Msk            (0x1UL << TPI_DEVID_AsynClkIn_Pos)          /*!< TPI DEVID: AsynClkIn Mask */
N
N#define TPI_DEVID_NrTraceInput_Pos          0U                                         /*!< TPI DEVID: NrTraceInput Position */
N#define TPI_DEVID_NrTraceInput_Msk         (0x1FUL /*<< TPI_DEVID_NrTraceInput_Pos*/)  /*!< TPI DEVID: NrTraceInput Mask */
N
N/* TPI DEVTYPE Register Definitions */
N#define TPI_DEVTYPE_MajorType_Pos           4U                                         /*!< TPI DEVTYPE: MajorType Position */
N#define TPI_DEVTYPE_MajorType_Msk          (0xFUL << TPI_DEVTYPE_MajorType_Pos)        /*!< TPI DEVTYPE: MajorType Mask */
N
N#define TPI_DEVTYPE_SubType_Pos             0U                                         /*!< TPI DEVTYPE: SubType Position */
N#define TPI_DEVTYPE_SubType_Msk            (0xFUL /*<< TPI_DEVTYPE_SubType_Pos*/)      /*!< TPI DEVTYPE: SubType Mask */
N
N/*@}*/ /* end of group CMSIS_TPI */
N
N
N#if defined (__MPU_PRESENT) && (__MPU_PRESENT == 1U)
X#if 1L && (1 == 1U)
N/**
N  \ingroup  CMSIS_core_register
N  \defgroup CMSIS_MPU     Memory Protection Unit (MPU)
N  \brief    Type definitions for the Memory Protection Unit (MPU)
N  @{
N */
N
N/**
N  \brief  Structure type to access the Memory Protection Unit (MPU).
N */
Ntypedef struct
N{
N  __IM  uint32_t TYPE;                   /*!< Offset: 0x000 (R/ )  MPU Type Register */
X  volatile const  uint32_t TYPE;                    
N  __IOM uint32_t CTRL;                   /*!< Offset: 0x004 (R/W)  MPU Control Register */
X  volatile uint32_t CTRL;                    
N  __IOM uint32_t RNR;                    /*!< Offset: 0x008 (R/W)  MPU Region RNRber Register */
X  volatile uint32_t RNR;                     
N  __IOM uint32_t RBAR;                   /*!< Offset: 0x00C (R/W)  MPU Region Base Address Register */
X  volatile uint32_t RBAR;                    
N  __IOM uint32_t RASR;                   /*!< Offset: 0x010 (R/W)  MPU Region Attribute and Size Register */
X  volatile uint32_t RASR;                    
N  __IOM uint32_t RBAR_A1;                /*!< Offset: 0x014 (R/W)  MPU Alias 1 Region Base Address Register */
X  volatile uint32_t RBAR_A1;                 
N  __IOM uint32_t RASR_A1;                /*!< Offset: 0x018 (R/W)  MPU Alias 1 Region Attribute and Size Register */
X  volatile uint32_t RASR_A1;                 
N  __IOM uint32_t RBAR_A2;                /*!< Offset: 0x01C (R/W)  MPU Alias 2 Region Base Address Register */
X  volatile uint32_t RBAR_A2;                 
N  __IOM uint32_t RASR_A2;                /*!< Offset: 0x020 (R/W)  MPU Alias 2 Region Attribute and Size Register */
X  volatile uint32_t RASR_A2;                 
N  __IOM uint32_t RBAR_A3;                /*!< Offset: 0x024 (R/W)  MPU Alias 3 Region Base Address Register */
X  volatile uint32_t RBAR_A3;                 
N  __IOM uint32_t RASR_A3;                /*!< Offset: 0x028 (R/W)  MPU Alias 3 Region Attribute and Size Register */
X  volatile uint32_t RASR_A3;                 
N} MPU_Type;
N
N/* MPU Type Register Definitions */
N#define MPU_TYPE_IREGION_Pos               16U                                            /*!< MPU TYPE: IREGION Position */
N#define MPU_TYPE_IREGION_Msk               (0xFFUL << MPU_TYPE_IREGION_Pos)               /*!< MPU TYPE: IREGION Mask */
N
N#define MPU_TYPE_DREGION_Pos                8U                                            /*!< MPU TYPE: DREGION Position */
N#define MPU_TYPE_DREGION_Msk               (0xFFUL << MPU_TYPE_DREGION_Pos)               /*!< MPU TYPE: DREGION Mask */
N
N#define MPU_TYPE_SEPARATE_Pos               0U                                            /*!< MPU TYPE: SEPARATE Position */
N#define MPU_TYPE_SEPARATE_Msk              (1UL /*<< MPU_TYPE_SEPARATE_Pos*/)             /*!< MPU TYPE: SEPARATE Mask */
N
N/* MPU Control Register Definitions */
N#define MPU_CTRL_PRIVDEFENA_Pos             2U                                            /*!< MPU CTRL: PRIVDEFENA Position */
N#define MPU_CTRL_PRIVDEFENA_Msk            (1UL << MPU_CTRL_PRIVDEFENA_Pos)               /*!< MPU CTRL: PRIVDEFENA Mask */
N
N#define MPU_CTRL_HFNMIENA_Pos               1U                                            /*!< MPU CTRL: HFNMIENA Position */
N#define MPU_CTRL_HFNMIENA_Msk              (1UL << MPU_CTRL_HFNMIENA_Pos)                 /*!< MPU CTRL: HFNMIENA Mask */
N
N#define MPU_CTRL_ENABLE_Pos                 0U                                            /*!< MPU CTRL: ENABLE Position */
N#define MPU_CTRL_ENABLE_Msk                (1UL /*<< MPU_CTRL_ENABLE_Pos*/)               /*!< MPU CTRL: ENABLE Mask */
N
N/* MPU Region Number Register Definitions */
N#define MPU_RNR_REGION_Pos                  0U                                            /*!< MPU RNR: REGION Position */
N#define MPU_RNR_REGION_Msk                 (0xFFUL /*<< MPU_RNR_REGION_Pos*/)             /*!< MPU RNR: REGION Mask */
N
N/* MPU Region Base Address Register Definitions */
N#define MPU_RBAR_ADDR_Pos                   5U                                            /*!< MPU RBAR: ADDR Position */
N#define MPU_RBAR_ADDR_Msk                  (0x7FFFFFFUL << MPU_RBAR_ADDR_Pos)             /*!< MPU RBAR: ADDR Mask */
N
N#define MPU_RBAR_VALID_Pos                  4U                                            /*!< MPU RBAR: VALID Position */
N#define MPU_RBAR_VALID_Msk                 (1UL << MPU_RBAR_VALID_Pos)                    /*!< MPU RBAR: VALID Mask */
N
N#define MPU_RBAR_REGION_Pos                 0U                                            /*!< MPU RBAR: REGION Position */
N#define MPU_RBAR_REGION_Msk                (0xFUL /*<< MPU_RBAR_REGION_Pos*/)             /*!< MPU RBAR: REGION Mask */
N
N/* MPU Region Attribute and Size Register Definitions */
N#define MPU_RASR_ATTRS_Pos                 16U                                            /*!< MPU RASR: MPU Region Attribute field Position */
N#define MPU_RASR_ATTRS_Msk                 (0xFFFFUL << MPU_RASR_ATTRS_Pos)               /*!< MPU RASR: MPU Region Attribute field Mask */
N
N#define MPU_RASR_XN_Pos                    28U                                            /*!< MPU RASR: ATTRS.XN Position */
N#define MPU_RASR_XN_Msk                    (1UL << MPU_RASR_XN_Pos)                       /*!< MPU RASR: ATTRS.XN Mask */
N
N#define MPU_RASR_AP_Pos                    24U                                            /*!< MPU RASR: ATTRS.AP Position */
N#define MPU_RASR_AP_Msk                    (0x7UL << MPU_RASR_AP_Pos)                     /*!< MPU RASR: ATTRS.AP Mask */
N
N#define MPU_RASR_TEX_Pos                   19U                                            /*!< MPU RASR: ATTRS.TEX Position */
N#define MPU_RASR_TEX_Msk                   (0x7UL << MPU_RASR_TEX_Pos)                    /*!< MPU RASR: ATTRS.TEX Mask */
N
N#define MPU_RASR_S_Pos                     18U                                            /*!< MPU RASR: ATTRS.S Position */
N#define MPU_RASR_S_Msk                     (1UL << MPU_RASR_S_Pos)                        /*!< MPU RASR: ATTRS.S Mask */
N
N#define MPU_RASR_C_Pos                     17U                                            /*!< MPU RASR: ATTRS.C Position */
N#define MPU_RASR_C_Msk                     (1UL << MPU_RASR_C_Pos)                        /*!< MPU RASR: ATTRS.C Mask */
N
N#define MPU_RASR_B_Pos                     16U                                            /*!< MPU RASR: ATTRS.B Position */
N#define MPU_RASR_B_Msk                     (1UL << MPU_RASR_B_Pos)                        /*!< MPU RASR: ATTRS.B Mask */
N
N#define MPU_RASR_SRD_Pos                    8U                                            /*!< MPU RASR: Sub-Region Disable Position */
N#define MPU_RASR_SRD_Msk                   (0xFFUL << MPU_RASR_SRD_Pos)                   /*!< MPU RASR: Sub-Region Disable Mask */
N
N#define MPU_RASR_SIZE_Pos                   1U                                            /*!< MPU RASR: Region Size Field Position */
N#define MPU_RASR_SIZE_Msk                  (0x1FUL << MPU_RASR_SIZE_Pos)                  /*!< MPU RASR: Region Size Field Mask */
N
N#define MPU_RASR_ENABLE_Pos                 0U                                            /*!< MPU RASR: Region enable bit Position */
N#define MPU_RASR_ENABLE_Msk                (1UL /*<< MPU_RASR_ENABLE_Pos*/)               /*!< MPU RASR: Region enable bit Disable Mask */
N
N/*@} end of group CMSIS_MPU */
N#endif
N
N
N/**
N  \ingroup  CMSIS_core_register
N  \defgroup CMSIS_CoreDebug       Core Debug Registers (CoreDebug)
N  \brief    Type definitions for the Core Debug Registers
N  @{
N */
N
N/**
N  \brief  Structure type to access the Core Debug Register (CoreDebug).
N */
Ntypedef struct
N{
N  __IOM uint32_t DHCSR;                  /*!< Offset: 0x000 (R/W)  Debug Halting Control and Status Register */
X  volatile uint32_t DHCSR;                   
N  __OM  uint32_t DCRSR;                  /*!< Offset: 0x004 ( /W)  Debug Core Register Selector Register */
X  volatile  uint32_t DCRSR;                   
N  __IOM uint32_t DCRDR;                  /*!< Offset: 0x008 (R/W)  Debug Core Register Data Register */
X  volatile uint32_t DCRDR;                   
N  __IOM uint32_t DEMCR;                  /*!< Offset: 0x00C (R/W)  Debug Exception and Monitor Control Register */
X  volatile uint32_t DEMCR;                   
N} CoreDebug_Type;
N
N/* Debug Halting Control and Status Register Definitions */
N#define CoreDebug_DHCSR_DBGKEY_Pos         16U                                            /*!< CoreDebug DHCSR: DBGKEY Position */
N#define CoreDebug_DHCSR_DBGKEY_Msk         (0xFFFFUL << CoreDebug_DHCSR_DBGKEY_Pos)       /*!< CoreDebug DHCSR: DBGKEY Mask */
N
N#define CoreDebug_DHCSR_S_RESET_ST_Pos     25U                                            /*!< CoreDebug DHCSR: S_RESET_ST Position */
N#define CoreDebug_DHCSR_S_RESET_ST_Msk     (1UL << CoreDebug_DHCSR_S_RESET_ST_Pos)        /*!< CoreDebug DHCSR: S_RESET_ST Mask */
N
N#define CoreDebug_DHCSR_S_RETIRE_ST_Pos    24U                                            /*!< CoreDebug DHCSR: S_RETIRE_ST Position */
N#define CoreDebug_DHCSR_S_RETIRE_ST_Msk    (1UL << CoreDebug_DHCSR_S_RETIRE_ST_Pos)       /*!< CoreDebug DHCSR: S_RETIRE_ST Mask */
N
N#define CoreDebug_DHCSR_S_LOCKUP_Pos       19U                                            /*!< CoreDebug DHCSR: S_LOCKUP Position */
N#define CoreDebug_DHCSR_S_LOCKUP_Msk       (1UL << CoreDebug_DHCSR_S_LOCKUP_Pos)          /*!< CoreDebug DHCSR: S_LOCKUP Mask */
N
N#define CoreDebug_DHCSR_S_SLEEP_Pos        18U                                            /*!< CoreDebug DHCSR: S_SLEEP Position */
N#define CoreDebug_DHCSR_S_SLEEP_Msk        (1UL << CoreDebug_DHCSR_S_SLEEP_Pos)           /*!< CoreDebug DHCSR: S_SLEEP Mask */
N
N#define CoreDebug_DHCSR_S_HALT_Pos         17U                                            /*!< CoreDebug DHCSR: S_HALT Position */
N#define CoreDebug_DHCSR_S_HALT_Msk         (1UL << CoreDebug_DHCSR_S_HALT_Pos)            /*!< CoreDebug DHCSR: S_HALT Mask */
N
N#define CoreDebug_DHCSR_S_REGRDY_Pos       16U                                            /*!< CoreDebug DHCSR: S_REGRDY Position */
N#define CoreDebug_DHCSR_S_REGRDY_Msk       (1UL << CoreDebug_DHCSR_S_REGRDY_Pos)          /*!< CoreDebug DHCSR: S_REGRDY Mask */
N
N#define CoreDebug_DHCSR_C_SNAPSTALL_Pos     5U                                            /*!< CoreDebug DHCSR: C_SNAPSTALL Position */
N#define CoreDebug_DHCSR_C_SNAPSTALL_Msk    (1UL << CoreDebug_DHCSR_C_SNAPSTALL_Pos)       /*!< CoreDebug DHCSR: C_SNAPSTALL Mask */
N
N#define CoreDebug_DHCSR_C_MASKINTS_Pos      3U                                            /*!< CoreDebug DHCSR: C_MASKINTS Position */
N#define CoreDebug_DHCSR_C_MASKINTS_Msk     (1UL << CoreDebug_DHCSR_C_MASKINTS_Pos)        /*!< CoreDebug DHCSR: C_MASKINTS Mask */
N
N#define CoreDebug_DHCSR_C_STEP_Pos          2U                                            /*!< CoreDebug DHCSR: C_STEP Position */
N#define CoreDebug_DHCSR_C_STEP_Msk         (1UL << CoreDebug_DHCSR_C_STEP_Pos)            /*!< CoreDebug DHCSR: C_STEP Mask */
N
N#define CoreDebug_DHCSR_C_HALT_Pos          1U                                            /*!< CoreDebug DHCSR: C_HALT Position */
N#define CoreDebug_DHCSR_C_HALT_Msk         (1UL << CoreDebug_DHCSR_C_HALT_Pos)            /*!< CoreDebug DHCSR: C_HALT Mask */
N
N#define CoreDebug_DHCSR_C_DEBUGEN_Pos       0U                                            /*!< CoreDebug DHCSR: C_DEBUGEN Position */
N#define CoreDebug_DHCSR_C_DEBUGEN_Msk      (1UL /*<< CoreDebug_DHCSR_C_DEBUGEN_Pos*/)     /*!< CoreDebug DHCSR: C_DEBUGEN Mask */
N
N/* Debug Core Register Selector Register Definitions */
N#define CoreDebug_DCRSR_REGWnR_Pos         16U                                            /*!< CoreDebug DCRSR: REGWnR Position */
N#define CoreDebug_DCRSR_REGWnR_Msk         (1UL << CoreDebug_DCRSR_REGWnR_Pos)            /*!< CoreDebug DCRSR: REGWnR Mask */
N
N#define CoreDebug_DCRSR_REGSEL_Pos          0U                                            /*!< CoreDebug DCRSR: REGSEL Position */
N#define CoreDebug_DCRSR_REGSEL_Msk         (0x1FUL /*<< CoreDebug_DCRSR_REGSEL_Pos*/)     /*!< CoreDebug DCRSR: REGSEL Mask */
N
N/* Debug Exception and Monitor Control Register Definitions */
N#define CoreDebug_DEMCR_TRCENA_Pos         24U                                            /*!< CoreDebug DEMCR: TRCENA Position */
N#define CoreDebug_DEMCR_TRCENA_Msk         (1UL << CoreDebug_DEMCR_TRCENA_Pos)            /*!< CoreDebug DEMCR: TRCENA Mask */
N
N#define CoreDebug_DEMCR_MON_REQ_Pos        19U                                            /*!< CoreDebug DEMCR: MON_REQ Position */
N#define CoreDebug_DEMCR_MON_REQ_Msk        (1UL << CoreDebug_DEMCR_MON_REQ_Pos)           /*!< CoreDebug DEMCR: MON_REQ Mask */
N
N#define CoreDebug_DEMCR_MON_STEP_Pos       18U                                            /*!< CoreDebug DEMCR: MON_STEP Position */
N#define CoreDebug_DEMCR_MON_STEP_Msk       (1UL << CoreDebug_DEMCR_MON_STEP_Pos)          /*!< CoreDebug DEMCR: MON_STEP Mask */
N
N#define CoreDebug_DEMCR_MON_PEND_Pos       17U                                            /*!< CoreDebug DEMCR: MON_PEND Position */
N#define CoreDebug_DEMCR_MON_PEND_Msk       (1UL << CoreDebug_DEMCR_MON_PEND_Pos)          /*!< CoreDebug DEMCR: MON_PEND Mask */
N
N#define CoreDebug_DEMCR_MON_EN_Pos         16U                                            /*!< CoreDebug DEMCR: MON_EN Position */
N#define CoreDebug_DEMCR_MON_EN_Msk         (1UL << CoreDebug_DEMCR_MON_EN_Pos)            /*!< CoreDebug DEMCR: MON_EN Mask */
N
N#define CoreDebug_DEMCR_VC_HARDERR_Pos     10U                                            /*!< CoreDebug DEMCR: VC_HARDERR Position */
N#define CoreDebug_DEMCR_VC_HARDERR_Msk     (1UL << CoreDebug_DEMCR_VC_HARDERR_Pos)        /*!< CoreDebug DEMCR: VC_HARDERR Mask */
N
N#define CoreDebug_DEMCR_VC_INTERR_Pos       9U                                            /*!< CoreDebug DEMCR: VC_INTERR Position */
N#define CoreDebug_DEMCR_VC_INTERR_Msk      (1UL << CoreDebug_DEMCR_VC_INTERR_Pos)         /*!< CoreDebug DEMCR: VC_INTERR Mask */
N
N#define CoreDebug_DEMCR_VC_BUSERR_Pos       8U                                            /*!< CoreDebug DEMCR: VC_BUSERR Position */
N#define CoreDebug_DEMCR_VC_BUSERR_Msk      (1UL << CoreDebug_DEMCR_VC_BUSERR_Pos)         /*!< CoreDebug DEMCR: VC_BUSERR Mask */
N
N#define CoreDebug_DEMCR_VC_STATERR_Pos      7U                                            /*!< CoreDebug DEMCR: VC_STATERR Position */
N#define CoreDebug_DEMCR_VC_STATERR_Msk     (1UL << CoreDebug_DEMCR_VC_STATERR_Pos)        /*!< CoreDebug DEMCR: VC_STATERR Mask */
N
N#define CoreDebug_DEMCR_VC_CHKERR_Pos       6U                                            /*!< CoreDebug DEMCR: VC_CHKERR Position */
N#define CoreDebug_DEMCR_VC_CHKERR_Msk      (1UL << CoreDebug_DEMCR_VC_CHKERR_Pos)         /*!< CoreDebug DEMCR: VC_CHKERR Mask */
N
N#define CoreDebug_DEMCR_VC_NOCPERR_Pos      5U                                            /*!< CoreDebug DEMCR: VC_NOCPERR Position */
N#define CoreDebug_DEMCR_VC_NOCPERR_Msk     (1UL << CoreDebug_DEMCR_VC_NOCPERR_Pos)        /*!< CoreDebug DEMCR: VC_NOCPERR Mask */
N
N#define CoreDebug_DEMCR_VC_MMERR_Pos        4U                                            /*!< CoreDebug DEMCR: VC_MMERR Position */
N#define CoreDebug_DEMCR_VC_MMERR_Msk       (1UL << CoreDebug_DEMCR_VC_MMERR_Pos)          /*!< CoreDebug DEMCR: VC_MMERR Mask */
N
N#define CoreDebug_DEMCR_VC_CORERESET_Pos    0U                                            /*!< CoreDebug DEMCR: VC_CORERESET Position */
N#define CoreDebug_DEMCR_VC_CORERESET_Msk   (1UL /*<< CoreDebug_DEMCR_VC_CORERESET_Pos*/)  /*!< CoreDebug DEMCR: VC_CORERESET Mask */
N
N/*@} end of group CMSIS_CoreDebug */
N
N
N/**
N  \ingroup    CMSIS_core_register
N  \defgroup   CMSIS_core_bitfield     Core register bit field macros
N  \brief      Macros for use with bit field definitions (xxx_Pos, xxx_Msk).
N  @{
N */
N
N/**
N  \brief   Mask and shift a bit field value for use in a register bit range.
N  \param[in] field  Name of the register bit field.
N  \param[in] value  Value of the bit field. This parameter is interpreted as an uint32_t type.
N  \return           Masked and shifted value.
N*/
N#define _VAL2FLD(field, value)    (((uint32_t)(value) << field ## _Pos) & field ## _Msk)
N
N/**
N  \brief     Mask and shift a register value to extract a bit filed value.
N  \param[in] field  Name of the register bit field.
N  \param[in] value  Value of register. This parameter is interpreted as an uint32_t type.
N  \return           Masked and shifted bit field value.
N*/
N#define _FLD2VAL(field, value)    (((uint32_t)(value) & field ## _Msk) >> field ## _Pos)
N
N/*@} end of group CMSIS_core_bitfield */
N
N
N/**
N  \ingroup    CMSIS_core_register
N  \defgroup   CMSIS_core_base     Core Definitions
N  \brief      Definitions for base addresses, unions, and structures.
N  @{
N */
N
N/* Memory mapping of Core Hardware */
N#define SCS_BASE            (0xE000E000UL)                            /*!< System Control Space Base Address */
N#define ITM_BASE            (0xE0000000UL)                            /*!< ITM Base Address */
N#define DWT_BASE            (0xE0001000UL)                            /*!< DWT Base Address */
N#define TPI_BASE            (0xE0040000UL)                            /*!< TPI Base Address */
N#define CoreDebug_BASE      (0xE000EDF0UL)                            /*!< Core Debug Base Address */
N#define SysTick_BASE        (SCS_BASE +  0x0010UL)                    /*!< SysTick Base Address */
N#define NVIC_BASE           (SCS_BASE +  0x0100UL)                    /*!< NVIC Base Address */
N#define SCB_BASE            (SCS_BASE +  0x0D00UL)                    /*!< System Control Block Base Address */
N
N#define SCnSCB              ((SCnSCB_Type    *)     SCS_BASE      )   /*!< System control Register not in SCB */
N#define SCB                 ((SCB_Type       *)     SCB_BASE      )   /*!< SCB configuration struct */
N#define SysTick             ((SysTick_Type   *)     SysTick_BASE  )   /*!< SysTick configuration struct */
N#define NVIC                ((NVIC_Type      *)     NVIC_BASE     )   /*!< NVIC configuration struct */
N#define ITM                 ((ITM_Type       *)     ITM_BASE      )   /*!< ITM configuration struct */
N#define DWT                 ((DWT_Type       *)     DWT_BASE      )   /*!< DWT configuration struct */
N#define TPI                 ((TPI_Type       *)     TPI_BASE      )   /*!< TPI configuration struct */
N#define CoreDebug           ((CoreDebug_Type *)     CoreDebug_BASE)   /*!< Core Debug configuration struct */
N
N#if defined (__MPU_PRESENT) && (__MPU_PRESENT == 1U)
X#if 1L && (1 == 1U)
N  #define MPU_BASE          (SCS_BASE +  0x0D90UL)                    /*!< Memory Protection Unit */
N  #define MPU               ((MPU_Type       *)     MPU_BASE      )   /*!< Memory Protection Unit */
N#endif
N
N/*@} */
N
N
N
N/*******************************************************************************
N *                Hardware Abstraction Layer
N  Core Function Interface contains:
N  - Core NVIC Functions
N  - Core SysTick Functions
N  - Core Debug Functions
N  - Core Register Access Functions
N ******************************************************************************/
N/**
N  \defgroup CMSIS_Core_FunctionInterface Functions and Instructions Reference
N*/
N
N
N
N/* ##########################   NVIC functions  #################################### */
N/**
N  \ingroup  CMSIS_Core_FunctionInterface
N  \defgroup CMSIS_Core_NVICFunctions NVIC Functions
N  \brief    Functions that manage interrupts and exceptions via the NVIC.
N  @{
N */
N
N#ifdef CMSIS_NVIC_VIRTUAL
S  #ifndef CMSIS_NVIC_VIRTUAL_HEADER_FILE
S    #define CMSIS_NVIC_VIRTUAL_HEADER_FILE "cmsis_nvic_virtual.h"
S  #endif
S  #include CMSIS_NVIC_VIRTUAL_HEADER_FILE
N#else
N  #define NVIC_SetPriorityGrouping    __NVIC_SetPriorityGrouping
N  #define NVIC_GetPriorityGrouping    __NVIC_GetPriorityGrouping
N  #define NVIC_EnableIRQ              __NVIC_EnableIRQ
N  #define NVIC_GetEnableIRQ           __NVIC_GetEnableIRQ
N  #define NVIC_DisableIRQ             __NVIC_DisableIRQ
N  #define NVIC_GetPendingIRQ          __NVIC_GetPendingIRQ
N  #define NVIC_SetPendingIRQ          __NVIC_SetPendingIRQ
N  #define NVIC_ClearPendingIRQ        __NVIC_ClearPendingIRQ
N  #define NVIC_GetActive              __NVIC_GetActive
N  #define NVIC_SetPriority            __NVIC_SetPriority
N  #define NVIC_GetPriority            __NVIC_GetPriority
N  #define NVIC_SystemReset            __NVIC_SystemReset
N#endif /* CMSIS_NVIC_VIRTUAL */
N
N#ifdef CMSIS_VECTAB_VIRTUAL
S  #ifndef CMSIS_VECTAB_VIRTUAL_HEADER_FILE
S   #define CMSIS_VECTAB_VIRTUAL_HEADER_FILE "cmsis_vectab_virtual.h"
S  #endif
S  #include CMSIS_VECTAB_VIRTUAL_HEADER_FILE
N#else
N  #define NVIC_SetVector              __NVIC_SetVector
N  #define NVIC_GetVector              __NVIC_GetVector
N#endif  /* (CMSIS_VECTAB_VIRTUAL) */
N
N#define NVIC_USER_IRQ_OFFSET          16
N
N
N
N/**
N  \brief   Set Priority Grouping
N  \details Sets the priority grouping field using the required unlock sequence.
N           The parameter PriorityGroup is assigned to the field SCB->AIRCR [10:8] PRIGROUP field.
N           Only values from 0..7 are used.
N           In case of a conflict between priority grouping and available
N           priority bits (__NVIC_PRIO_BITS), the smallest possible priority group is set.
N  \param [in]      PriorityGroup  Priority grouping field.
N */
N__STATIC_INLINE void __NVIC_SetPriorityGrouping(uint32_t PriorityGroup)
Xstatic __inline void __NVIC_SetPriorityGrouping(uint32_t PriorityGroup)
N{
N  uint32_t reg_value;
N  uint32_t PriorityGroupTmp = (PriorityGroup & (uint32_t)0x07UL);             /* only values 0..7 are used          */
N
N  reg_value  =  SCB->AIRCR;                                                   /* read old register configuration    */
X  reg_value  =  ((SCB_Type *) ((0xE000E000UL) + 0x0D00UL) )->AIRCR;                                                    
N  reg_value &= ~((uint32_t)(SCB_AIRCR_VECTKEY_Msk | SCB_AIRCR_PRIGROUP_Msk)); /* clear bits to change               */
X  reg_value &= ~((uint32_t)((0xFFFFUL << 16U) | (7UL << 8U)));  
N  reg_value  =  (reg_value                                   |
N                ((uint32_t)0x5FAUL << SCB_AIRCR_VECTKEY_Pos) |
X                ((uint32_t)0x5FAUL << 16U) |
N                (PriorityGroupTmp << 8U)                      );              /* Insert write key and priorty group */
N  SCB->AIRCR =  reg_value;
X  ((SCB_Type *) ((0xE000E000UL) + 0x0D00UL) )->AIRCR =  reg_value;
N}
N
N
N/**
N  \brief   Get Priority Grouping
N  \details Reads the priority grouping field from the NVIC Interrupt Controller.
N  \return                Priority grouping field (SCB->AIRCR [10:8] PRIGROUP field).
N */
N__STATIC_INLINE uint32_t __NVIC_GetPriorityGrouping(void)
Xstatic __inline uint32_t __NVIC_GetPriorityGrouping(void)
N{
N  return ((uint32_t)((SCB->AIRCR & SCB_AIRCR_PRIGROUP_Msk) >> SCB_AIRCR_PRIGROUP_Pos));
X  return ((uint32_t)((((SCB_Type *) ((0xE000E000UL) + 0x0D00UL) )->AIRCR & (7UL << 8U)) >> 8U));
N}
N
N
N/**
N  \brief   Enable Interrupt
N  \details Enables a device specific interrupt in the NVIC interrupt controller.
N  \param [in]      IRQn  Device specific interrupt number.
N  \note    IRQn must not be negative.
N */
N__STATIC_INLINE void __NVIC_EnableIRQ(IRQn_Type IRQn)
Xstatic __inline void __NVIC_EnableIRQ(IRQn_Type IRQn)
N{
N  if ((int32_t)(IRQn) >= 0)
N  {
N    NVIC->ISER[(((uint32_t)(int32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)(int32_t)IRQn) & 0x1FUL));
X    ((NVIC_Type *) ((0xE000E000UL) + 0x0100UL) )->ISER[(((uint32_t)(int32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)(int32_t)IRQn) & 0x1FUL));
N  }
N}
N
N
N/**
N  \brief   Get Interrupt Enable status
N  \details Returns a device specific interrupt enable status from the NVIC interrupt controller.
N  \param [in]      IRQn  Device specific interrupt number.
N  \return             0  Interrupt is not enabled.
N  \return             1  Interrupt is enabled.
N  \note    IRQn must not be negative.
N */
N__STATIC_INLINE uint32_t __NVIC_GetEnableIRQ(IRQn_Type IRQn)
Xstatic __inline uint32_t __NVIC_GetEnableIRQ(IRQn_Type IRQn)
N{
N  if ((int32_t)(IRQn) >= 0)
N  {
N    return((uint32_t)(((NVIC->ISER[(((uint32_t)(int32_t)IRQn) >> 5UL)] & (1UL << (((uint32_t)(int32_t)IRQn) & 0x1FUL))) != 0UL) ? 1UL : 0UL));
X    return((uint32_t)(((((NVIC_Type *) ((0xE000E000UL) + 0x0100UL) )->ISER[(((uint32_t)(int32_t)IRQn) >> 5UL)] & (1UL << (((uint32_t)(int32_t)IRQn) & 0x1FUL))) != 0UL) ? 1UL : 0UL));
N  }
N  else
N  {
N    return(0U);
N  }
N}
N
N
N/**
N  \brief   Disable Interrupt
N  \details Disables a device specific interrupt in the NVIC interrupt controller.
N  \param [in]      IRQn  Device specific interrupt number.
N  \note    IRQn must not be negative.
N */
N__STATIC_INLINE void __NVIC_DisableIRQ(IRQn_Type IRQn)
Xstatic __inline void __NVIC_DisableIRQ(IRQn_Type IRQn)
N{
N  if ((int32_t)(IRQn) >= 0)
N  {
N    NVIC->ICER[(((uint32_t)(int32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)(int32_t)IRQn) & 0x1FUL));
X    ((NVIC_Type *) ((0xE000E000UL) + 0x0100UL) )->ICER[(((uint32_t)(int32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)(int32_t)IRQn) & 0x1FUL));
N    __DSB();
X    do { __schedule_barrier(); __dsb(0xF); __schedule_barrier(); } while (0U);
N    __ISB();
X    do { __schedule_barrier(); __isb(0xF); __schedule_barrier(); } while (0U);
N  }
N}
N
N
N/**
N  \brief   Get Pending Interrupt
N  \details Reads the NVIC pending register and returns the pending bit for the specified device specific interrupt.
N  \param [in]      IRQn  Device specific interrupt number.
N  \return             0  Interrupt status is not pending.
N  \return             1  Interrupt status is pending.
N  \note    IRQn must not be negative.
N */
N__STATIC_INLINE uint32_t __NVIC_GetPendingIRQ(IRQn_Type IRQn)
Xstatic __inline uint32_t __NVIC_GetPendingIRQ(IRQn_Type IRQn)
N{
N  if ((int32_t)(IRQn) >= 0)
N  {
N    return((uint32_t)(((NVIC->ISPR[(((uint32_t)(int32_t)IRQn) >> 5UL)] & (1UL << (((uint32_t)(int32_t)IRQn) & 0x1FUL))) != 0UL) ? 1UL : 0UL));
X    return((uint32_t)(((((NVIC_Type *) ((0xE000E000UL) + 0x0100UL) )->ISPR[(((uint32_t)(int32_t)IRQn) >> 5UL)] & (1UL << (((uint32_t)(int32_t)IRQn) & 0x1FUL))) != 0UL) ? 1UL : 0UL));
N  }
N  else
N  {
N    return(0U);
N  }
N}
N
N
N/**
N  \brief   Set Pending Interrupt
N  \details Sets the pending bit of a device specific interrupt in the NVIC pending register.
N  \param [in]      IRQn  Device specific interrupt number.
N  \note    IRQn must not be negative.
N */
N__STATIC_INLINE void __NVIC_SetPendingIRQ(IRQn_Type IRQn)
Xstatic __inline void __NVIC_SetPendingIRQ(IRQn_Type IRQn)
N{
N  if ((int32_t)(IRQn) >= 0)
N  {
N    NVIC->ISPR[(((uint32_t)(int32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)(int32_t)IRQn) & 0x1FUL));
X    ((NVIC_Type *) ((0xE000E000UL) + 0x0100UL) )->ISPR[(((uint32_t)(int32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)(int32_t)IRQn) & 0x1FUL));
N  }
N}
N
N
N/**
N  \brief   Clear Pending Interrupt
N  \details Clears the pending bit of a device specific interrupt in the NVIC pending register.
N  \param [in]      IRQn  Device specific interrupt number.
N  \note    IRQn must not be negative.
N */
N__STATIC_INLINE void __NVIC_ClearPendingIRQ(IRQn_Type IRQn)
Xstatic __inline void __NVIC_ClearPendingIRQ(IRQn_Type IRQn)
N{
N  if ((int32_t)(IRQn) >= 0)
N  {
N    NVIC->ICPR[(((uint32_t)(int32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)(int32_t)IRQn) & 0x1FUL));
X    ((NVIC_Type *) ((0xE000E000UL) + 0x0100UL) )->ICPR[(((uint32_t)(int32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)(int32_t)IRQn) & 0x1FUL));
N  }
N}
N
N
N/**
N  \brief   Get Active Interrupt
N  \details Reads the active register in the NVIC and returns the active bit for the device specific interrupt.
N  \param [in]      IRQn  Device specific interrupt number.
N  \return             0  Interrupt status is not active.
N  \return             1  Interrupt status is active.
N  \note    IRQn must not be negative.
N */
N__STATIC_INLINE uint32_t __NVIC_GetActive(IRQn_Type IRQn)
Xstatic __inline uint32_t __NVIC_GetActive(IRQn_Type IRQn)
N{
N  if ((int32_t)(IRQn) >= 0)
N  {
N    return((uint32_t)(((NVIC->IABR[(((uint32_t)(int32_t)IRQn) >> 5UL)] & (1UL << (((uint32_t)(int32_t)IRQn) & 0x1FUL))) != 0UL) ? 1UL : 0UL));
X    return((uint32_t)(((((NVIC_Type *) ((0xE000E000UL) + 0x0100UL) )->IABR[(((uint32_t)(int32_t)IRQn) >> 5UL)] & (1UL << (((uint32_t)(int32_t)IRQn) & 0x1FUL))) != 0UL) ? 1UL : 0UL));
N  }
N  else
N  {
N    return(0U);
N  }
N}
N
N
N/**
N  \brief   Set Interrupt Priority
N  \details Sets the priority of a device specific interrupt or a processor exception.
N           The interrupt number can be positive to specify a device specific interrupt,
N           or negative to specify a processor exception.
N  \param [in]      IRQn  Interrupt number.
N  \param [in]  priority  Priority to set.
N  \note    The priority cannot be set for every processor exception.
N */
N__STATIC_INLINE void __NVIC_SetPriority(IRQn_Type IRQn, uint32_t priority)
Xstatic __inline void __NVIC_SetPriority(IRQn_Type IRQn, uint32_t priority)
N{
N  if ((int32_t)(IRQn) >= 0)
N  {
N    NVIC->IP[((uint32_t)(int32_t)IRQn)]               = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
X    ((NVIC_Type *) ((0xE000E000UL) + 0x0100UL) )->IP[((uint32_t)(int32_t)IRQn)]               = (uint8_t)((priority << (8U - 3)) & (uint32_t)0xFFUL);
N  }
N  else
N  {
N    SCB->SHP[(((uint32_t)(int32_t)IRQn) & 0xFUL)-4UL] = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
X    ((SCB_Type *) ((0xE000E000UL) + 0x0D00UL) )->SHP[(((uint32_t)(int32_t)IRQn) & 0xFUL)-4UL] = (uint8_t)((priority << (8U - 3)) & (uint32_t)0xFFUL);
N  }
N}
N
N
N/**
N  \brief   Get Interrupt Priority
N  \details Reads the priority of a device specific interrupt or a processor exception.
N           The interrupt number can be positive to specify a device specific interrupt,
N           or negative to specify a processor exception.
N  \param [in]   IRQn  Interrupt number.
N  \return             Interrupt Priority.
N                      Value is aligned automatically to the implemented priority bits of the microcontroller.
N */
N__STATIC_INLINE uint32_t __NVIC_GetPriority(IRQn_Type IRQn)
Xstatic __inline uint32_t __NVIC_GetPriority(IRQn_Type IRQn)
N{
N
N  if ((int32_t)(IRQn) >= 0)
N  {
N    return(((uint32_t)NVIC->IP[((uint32_t)(int32_t)IRQn)]               >> (8U - __NVIC_PRIO_BITS)));
X    return(((uint32_t)((NVIC_Type *) ((0xE000E000UL) + 0x0100UL) )->IP[((uint32_t)(int32_t)IRQn)]               >> (8U - 3)));
N  }
N  else
N  {
N    return(((uint32_t)SCB->SHP[(((uint32_t)(int32_t)IRQn) & 0xFUL)-4UL] >> (8U - __NVIC_PRIO_BITS)));
X    return(((uint32_t)((SCB_Type *) ((0xE000E000UL) + 0x0D00UL) )->SHP[(((uint32_t)(int32_t)IRQn) & 0xFUL)-4UL] >> (8U - 3)));
N  }
N}
N
N
N/**
N  \brief   Encode Priority
N  \details Encodes the priority for an interrupt with the given priority group,
N           preemptive priority value, and subpriority value.
N           In case of a conflict between priority grouping and available
N           priority bits (__NVIC_PRIO_BITS), the smallest possible priority group is set.
N  \param [in]     PriorityGroup  Used priority group.
N  \param [in]   PreemptPriority  Preemptive priority value (starting from 0).
N  \param [in]       SubPriority  Subpriority value (starting from 0).
N  \return                        Encoded priority. Value can be used in the function \ref NVIC_SetPriority().
N */
N__STATIC_INLINE uint32_t NVIC_EncodePriority (uint32_t PriorityGroup, uint32_t PreemptPriority, uint32_t SubPriority)
Xstatic __inline uint32_t NVIC_EncodePriority (uint32_t PriorityGroup, uint32_t PreemptPriority, uint32_t SubPriority)
N{
N  uint32_t PriorityGroupTmp = (PriorityGroup & (uint32_t)0x07UL);   /* only values 0..7 are used          */
N  uint32_t PreemptPriorityBits;
N  uint32_t SubPriorityBits;
N
N  PreemptPriorityBits = ((7UL - PriorityGroupTmp) > (uint32_t)(__NVIC_PRIO_BITS)) ? (uint32_t)(__NVIC_PRIO_BITS) : (uint32_t)(7UL - PriorityGroupTmp);
X  PreemptPriorityBits = ((7UL - PriorityGroupTmp) > (uint32_t)(3)) ? (uint32_t)(3) : (uint32_t)(7UL - PriorityGroupTmp);
N  SubPriorityBits     = ((PriorityGroupTmp + (uint32_t)(__NVIC_PRIO_BITS)) < (uint32_t)7UL) ? (uint32_t)0UL : (uint32_t)((PriorityGroupTmp - 7UL) + (uint32_t)(__NVIC_PRIO_BITS));
X  SubPriorityBits     = ((PriorityGroupTmp + (uint32_t)(3)) < (uint32_t)7UL) ? (uint32_t)0UL : (uint32_t)((PriorityGroupTmp - 7UL) + (uint32_t)(3));
N
N  return (
N           ((PreemptPriority & (uint32_t)((1UL << (PreemptPriorityBits)) - 1UL)) << SubPriorityBits) |
N           ((SubPriority     & (uint32_t)((1UL << (SubPriorityBits    )) - 1UL)))
N         );
N}
N
N
N/**
N  \brief   Decode Priority
N  \details Decodes an interrupt priority value with a given priority group to
N           preemptive priority value and subpriority value.
N           In case of a conflict between priority grouping and available
N           priority bits (__NVIC_PRIO_BITS) the smallest possible priority group is set.
N  \param [in]         Priority   Priority value, which can be retrieved with the function \ref NVIC_GetPriority().
N  \param [in]     PriorityGroup  Used priority group.
N  \param [out] pPreemptPriority  Preemptive priority value (starting from 0).
N  \param [out]     pSubPriority  Subpriority value (starting from 0).
N */
N__STATIC_INLINE void NVIC_DecodePriority (uint32_t Priority, uint32_t PriorityGroup, uint32_t* const pPreemptPriority, uint32_t* const pSubPriority)
Xstatic __inline void NVIC_DecodePriority (uint32_t Priority, uint32_t PriorityGroup, uint32_t* const pPreemptPriority, uint32_t* const pSubPriority)
N{
N  uint32_t PriorityGroupTmp = (PriorityGroup & (uint32_t)0x07UL);   /* only values 0..7 are used          */
N  uint32_t PreemptPriorityBits;
N  uint32_t SubPriorityBits;
N
N  PreemptPriorityBits = ((7UL - PriorityGroupTmp) > (uint32_t)(__NVIC_PRIO_BITS)) ? (uint32_t)(__NVIC_PRIO_BITS) : (uint32_t)(7UL - PriorityGroupTmp);
X  PreemptPriorityBits = ((7UL - PriorityGroupTmp) > (uint32_t)(3)) ? (uint32_t)(3) : (uint32_t)(7UL - PriorityGroupTmp);
N  SubPriorityBits     = ((PriorityGroupTmp + (uint32_t)(__NVIC_PRIO_BITS)) < (uint32_t)7UL) ? (uint32_t)0UL : (uint32_t)((PriorityGroupTmp - 7UL) + (uint32_t)(__NVIC_PRIO_BITS));
X  SubPriorityBits     = ((PriorityGroupTmp + (uint32_t)(3)) < (uint32_t)7UL) ? (uint32_t)0UL : (uint32_t)((PriorityGroupTmp - 7UL) + (uint32_t)(3));
N
N  *pPreemptPriority = (Priority >> SubPriorityBits) & (uint32_t)((1UL << (PreemptPriorityBits)) - 1UL);
N  *pSubPriority     = (Priority                   ) & (uint32_t)((1UL << (SubPriorityBits    )) - 1UL);
N}
N
N
N/**
N  \brief   Set Interrupt Vector
N  \details Sets an interrupt vector in SRAM based interrupt vector table.
N           The interrupt number can be positive to specify a device specific interrupt,
N           or negative to specify a processor exception.
N           VTOR must been relocated to SRAM before.
N  \param [in]   IRQn      Interrupt number
N  \param [in]   vector    Address of interrupt handler function
N */
N__STATIC_INLINE void __NVIC_SetVector(IRQn_Type IRQn, uint32_t vector)
Xstatic __inline void __NVIC_SetVector(IRQn_Type IRQn, uint32_t vector)
N{
N  uint32_t *vectors = (uint32_t *)SCB->VTOR;
X  uint32_t *vectors = (uint32_t *)((SCB_Type *) ((0xE000E000UL) + 0x0D00UL) )->VTOR;
N  vectors[(int32_t)IRQn + NVIC_USER_IRQ_OFFSET] = vector;
X  vectors[(int32_t)IRQn + 16] = vector;
N}
N
N
N/**
N  \brief   Get Interrupt Vector
N  \details Reads an interrupt vector from interrupt vector table.
N           The interrupt number can be positive to specify a device specific interrupt,
N           or negative to specify a processor exception.
N  \param [in]   IRQn      Interrupt number.
N  \return                 Address of interrupt handler function
N */
N__STATIC_INLINE uint32_t __NVIC_GetVector(IRQn_Type IRQn)
Xstatic __inline uint32_t __NVIC_GetVector(IRQn_Type IRQn)
N{
N  uint32_t *vectors = (uint32_t *)SCB->VTOR;
X  uint32_t *vectors = (uint32_t *)((SCB_Type *) ((0xE000E000UL) + 0x0D00UL) )->VTOR;
N  return vectors[(int32_t)IRQn + NVIC_USER_IRQ_OFFSET];
X  return vectors[(int32_t)IRQn + 16];
N}
N
N
N/**
N  \brief   System Reset
N  \details Initiates a system reset request to reset the MCU.
N */
N__STATIC_INLINE void __NVIC_SystemReset(void)
Xstatic __inline void __NVIC_SystemReset(void)
N{
N  __DSB();                                                          /* Ensure all outstanding memory accesses included
X  do { __schedule_barrier(); __dsb(0xF); __schedule_barrier(); } while (0U);                                                          
N                                                                       buffered write are completed before reset */
N  SCB->AIRCR  = (uint32_t)((0x5FAUL << SCB_AIRCR_VECTKEY_Pos)    |
X  ((SCB_Type *) ((0xE000E000UL) + 0x0D00UL) )->AIRCR  = (uint32_t)((0x5FAUL << 16U)    |
N                           (SCB->AIRCR & SCB_AIRCR_PRIGROUP_Msk) |
X                           (((SCB_Type *) ((0xE000E000UL) + 0x0D00UL) )->AIRCR & (7UL << 8U)) |
N                            SCB_AIRCR_SYSRESETREQ_Msk    );         /* Keep priority group unchanged */
X                            (1UL << 2U)    );          
N  __DSB();                                                          /* Ensure completion of memory access */
X  do { __schedule_barrier(); __dsb(0xF); __schedule_barrier(); } while (0U);                                                           
N
N  for(;;)                                                           /* wait until reset */
N  {
N    __NOP();
X    __nop();
N  }
N}
N
N/*@} end of CMSIS_Core_NVICFunctions */
N
N
N/* ##########################  FPU functions  #################################### */
N/**
N  \ingroup  CMSIS_Core_FunctionInterface
N  \defgroup CMSIS_Core_FpuFunctions FPU Functions
N  \brief    Function that provides FPU type.
N  @{
N */
N
N/**
N  \brief   get FPU type
N  \details returns the FPU type
N  \returns
N   - \b  0: No FPU
N   - \b  1: Single precision FPU
N   - \b  2: Double + Single precision FPU
N */
N__STATIC_INLINE uint32_t SCB_GetFPUType(void)
Xstatic __inline uint32_t SCB_GetFPUType(void)
N{
N    return 0U;           /* No FPU */
N}
N
N
N/*@} end of CMSIS_Core_FpuFunctions */
N
N
N
N/* ##################################    SysTick function  ############################################ */
N/**
N  \ingroup  CMSIS_Core_FunctionInterface
N  \defgroup CMSIS_Core_SysTickFunctions SysTick Functions
N  \brief    Functions that configure the System.
N  @{
N */
N
N#if defined (__Vendor_SysTickConfig) && (__Vendor_SysTickConfig == 0U)
X#if 1L && (0 == 0U)
N
N/**
N  \brief   System Tick Configuration
N  \details Initializes the System Timer and its interrupt, and starts the System Tick Timer.
N           Counter is in free running mode to generate periodic interrupts.
N  \param [in]  ticks  Number of ticks between two interrupts.
N  \return          0  Function succeeded.
N  \return          1  Function failed.
N  \note    When the variable <b>__Vendor_SysTickConfig</b> is set to 1, then the
N           function <b>SysTick_Config</b> is not included. In this case, the file <b><i>device</i>.h</b>
N           must contain a vendor-specific implementation of this function.
N */
N__STATIC_INLINE uint32_t SysTick_Config(uint32_t ticks)
Xstatic __inline uint32_t SysTick_Config(uint32_t ticks)
N{
N  if ((ticks - 1UL) > SysTick_LOAD_RELOAD_Msk)
X  if ((ticks - 1UL) > (0xFFFFFFUL ))
N  {
N    return (1UL);                                                   /* Reload value impossible */
N  }
N
N  SysTick->LOAD  = (uint32_t)(ticks - 1UL);                         /* set reload register */
X  ((SysTick_Type *) ((0xE000E000UL) + 0x0010UL) )->LOAD  = (uint32_t)(ticks - 1UL);                          
N  NVIC_SetPriority (SysTick_IRQn, (1UL << __NVIC_PRIO_BITS) - 1UL); /* set Priority for Systick Interrupt */
X  __NVIC_SetPriority (SysTick_IRQn, (1UL << 3) - 1UL);  
N  SysTick->VAL   = 0UL;                                             /* Load the SysTick Counter Value */
X  ((SysTick_Type *) ((0xE000E000UL) + 0x0010UL) )->VAL   = 0UL;                                              
N  SysTick->CTRL  = SysTick_CTRL_CLKSOURCE_Msk |
X  ((SysTick_Type *) ((0xE000E000UL) + 0x0010UL) )->CTRL  = (1UL << 2U) |
N                   SysTick_CTRL_TICKINT_Msk   |
X                   (1UL << 1U)   |
N                   SysTick_CTRL_ENABLE_Msk;                         /* Enable SysTick IRQ and SysTick Timer */
X                   (1UL );                          
N  return (0UL);                                                     /* Function successful */
N}
N
N#endif
N
N/*@} end of CMSIS_Core_SysTickFunctions */
N
N
N
N/* ##################################### Debug In/Output function ########################################### */
N/**
N  \ingroup  CMSIS_Core_FunctionInterface
N  \defgroup CMSIS_core_DebugFunctions ITM Functions
N  \brief    Functions that access the ITM debug interface.
N  @{
N */
N
Nextern volatile int32_t ITM_RxBuffer;                              /*!< External variable to receive characters. */
N#define                 ITM_RXBUFFER_EMPTY  ((int32_t)0x5AA55AA5U) /*!< Value identifying \ref ITM_RxBuffer is ready for next character. */
N
N
N/**
N  \brief   ITM Send Character
N  \details Transmits a character via the ITM channel 0, and
N           \li Just returns when no debugger is connected that has booked the output.
N           \li Is blocking when a debugger is connected, but the previous character sent has not been transmitted.
N  \param [in]     ch  Character to transmit.
N  \returns            Character to transmit.
N */
N__STATIC_INLINE uint32_t ITM_SendChar (uint32_t ch)
Xstatic __inline uint32_t ITM_SendChar (uint32_t ch)
N{
N  if (((ITM->TCR & ITM_TCR_ITMENA_Msk) != 0UL) &&      /* ITM enabled */
X  if (((((ITM_Type *) (0xE0000000UL) )->TCR & (1UL )) != 0UL) &&       
N      ((ITM->TER & 1UL               ) != 0UL)   )     /* ITM Port #0 enabled */
X      ((((ITM_Type *) (0xE0000000UL) )->TER & 1UL               ) != 0UL)   )      
N  {
N    while (ITM->PORT[0U].u32 == 0UL)
X    while (((ITM_Type *) (0xE0000000UL) )->PORT[0U].u32 == 0UL)
N    {
N      __NOP();
X      __nop();
N    }
N    ITM->PORT[0U].u8 = (uint8_t)ch;
X    ((ITM_Type *) (0xE0000000UL) )->PORT[0U].u8 = (uint8_t)ch;
N  }
N  return (ch);
N}
N
N
N/**
N  \brief   ITM Receive Character
N  \details Inputs a character via the external variable \ref ITM_RxBuffer.
N  \return             Received character.
N  \return         -1  No character pending.
N */
N__STATIC_INLINE int32_t ITM_ReceiveChar (void)
Xstatic __inline int32_t ITM_ReceiveChar (void)
N{
N  int32_t ch = -1;                           /* no character available */
N
N  if (ITM_RxBuffer != ITM_RXBUFFER_EMPTY)
X  if (ITM_RxBuffer != ((int32_t)0x5AA55AA5U))
N  {
N    ch = ITM_RxBuffer;
N    ITM_RxBuffer = ITM_RXBUFFER_EMPTY;       /* ready for next character */
X    ITM_RxBuffer = ((int32_t)0x5AA55AA5U);        
N  }
N
N  return (ch);
N}
N
N
N/**
N  \brief   ITM Check Character
N  \details Checks whether a character is pending for reading in the variable \ref ITM_RxBuffer.
N  \return          0  No character available.
N  \return          1  Character available.
N */
N__STATIC_INLINE int32_t ITM_CheckChar (void)
Xstatic __inline int32_t ITM_CheckChar (void)
N{
N
N  if (ITM_RxBuffer == ITM_RXBUFFER_EMPTY)
X  if (ITM_RxBuffer == ((int32_t)0x5AA55AA5U))
N  {
N    return (0);                              /* no character available */
N  }
N  else
N  {
N    return (1);                              /*    character available */
N  }
N}
N
N/*@} end of CMSIS_core_DebugFunctions */
N
N
N
N
N#ifdef __cplusplus
S}
N#endif
N
N#endif /* __CORE_CM3_H_DEPENDANT */
N
N#endif /* __CMSIS_GENERIC */
L 80 "C:\Keil_v5\ARM\PACK\Keil\MDR1986BExx\1.5.3\Libraries\CMSIS\CM3\DeviceSupport\MDR32F9Qx\inc\MDR32Fx.h" 2
N#include "system_MDR32F9Qx.h"
L 1 ".\RTE\Device\MDR1986BE92\system_MDR32F9Qx.h" 1
N/**
N  ******************************************************************************
N  * @file    system_MDR32F9Qx.h
N  * @author  Phyton Application Team
N  * @version V1.3.0
N  * @date    11/06/2010
N  * @brief   CMSIS Cortex-M3 Device Peripheral Access Layer System Header File.
N  ******************************************************************************
N  * <br><br>
N  *
N  * THE PRESENT FIRMWARE WHICH IS FOR GUIDANCE ONLY AIMS AT PROVIDING CUSTOMERS
N  * WITH CODING INFORMATION REGARDING THEIR PRODUCTS IN ORDER FOR THEM TO SAVE
N  * TIME. AS A RESULT, PHYTON SHALL NOT BE HELD LIABLE FOR ANY DIRECT, INDIRECT
N  * OR CONSEQUENTIAL DAMAGES WITH RESPECT TO ANY CLAIMS ARISING
N  * FROM THE CONTENT OF SUCH FIRMWARE AND/OR THE USE MADE BY CUSTOMERS OF THE
N  * CODING INFORMATION CONTAINED HEREIN IN CONNECTION WITH THEIR PRODUCTS.
N  *
N  * <h2><center>&copy; COPYRIGHT 2010 Phyton</center></h2>
N  ******************************************************************************
N  * FILE system_MDR32F9Qx.h
N  */
N
N/** @addtogroup __CMSIS CMSIS
N  * @{
N  */
N
N/** @defgroup MDR1986VE9x
N *  @{
N */
N
N/** @defgroup __MDR32F9QX MDR32F9QX System
N  * @{
N  */
N
N/* Define to prevent recursive inclusion -------------------------------------*/
N#ifndef __SYSTEM_MDR32F9Qx_H
N#define __SYSTEM_MDR32F9Qx_H
N
N/** @addtogroup __MDR32F9QX_System_Exported_Variables MDR32F9QX System Exported Variables
N  * @{
N  */
N
Nextern uint32_t SystemCoreClock;          /*!< System Clock Frequency (Core Clock)
N                                           *   default value */
N
N/** @} */ /* End of group __MDR32F9QX_System_Exported_Variables */
N
N/** @addtogroup __MDR32F9QX_System_Exported_Functions MDR32F9QX System Exported Functions
N  * @{
N  */
N
Nextern void SystemInit(void);
Nextern void SystemCoreClockUpdate(void);
N
N/** @} */ /* End of group __MDR32F9QX_System_Exported_Functions */
N
N#endif /*__SYSTEM_MDR32F9Qx_H */
N
N/** @} */ /* End of group __MDR32F9QX */
N
N/** @} */ /* End of group MDR1986VE9x */
N
N/** @} */ /* End of group __CMSIS */
N
N/******************* (C) COPYRIGHT 2010 Phyton *********************************
N*
N* END OF FILE system_MDR32F9Qx.h */
L 81 "C:\Keil_v5\ARM\PACK\Keil\MDR1986BExx\1.5.3\Libraries\CMSIS\CM3\DeviceSupport\MDR32F9Qx\inc\MDR32Fx.h" 2
N
N/** @defgroup __Exported_types Exported types
N  * @{
N  */
N
Ntypedef enum {RESET = 0, SET = !RESET} FlagStatus, ITStatus, BitStatus;
N
N#define IS_BIT_STATUS(STATUS)	(((STATUS) == RESET) || ((STATE) == SET))
N
Ntypedef enum {DISABLE = 0, ENABLE = !DISABLE} FunctionalState;
N#define IS_FUNCTIONAL_STATE(STATE) (((STATE) == DISABLE) || ((STATE) == ENABLE))
N
Ntypedef enum {ERROR = 0, SUCCESS = !ERROR} ErrorStatus;
N
N/** @} */ /* End of group __Exported_types */
N
N/** @addtogroup __MDR32Fx_Peripheral_Units MDR32F9Qx Peripheral Units
N  * @{
N  */
N
N/** @defgroup MDR32Fx_Periph_CAN CAN
N  * @{
N  */
N
N/** @defgroup MDR32Fx_Periph_CAN_Data_Structures Data Structures
N  * @{
N  */
N
N/* MDR_CAN_BUF_TypeDef structure */
Ntypedef struct
N{
N  __IO uint32_t ID;
X  volatile uint32_t ID;
N  __IO uint32_t DLC;
X  volatile uint32_t DLC;
N  __IO uint32_t DATAL;
X  volatile uint32_t DATAL;
N  __IO uint32_t DATAH;
X  volatile uint32_t DATAH;
N}MDR_CAN_BUF_TypeDef;
N
N/* MDR_CAN_BUF_FILTER_TypeDef structure */
Ntypedef struct
N{
N  __IO uint32_t MASK;
X  volatile uint32_t MASK;
N  __IO uint32_t FILTER;
X  volatile uint32_t FILTER;
N}MDR_CAN_BUF_FILTER_TypeDef;
N
N/* MDR_CAN_TypeDef structure */
Ntypedef struct
N{
N  __IO uint32_t CONTROL;
X  volatile uint32_t CONTROL;
N  __IO uint32_t STATUS;
X  volatile uint32_t STATUS;
N  __IO uint32_t BITTMNG;
X  volatile uint32_t BITTMNG;
N       uint32_t RESERVED0;
N  __IO uint32_t INT_EN;
X  volatile uint32_t INT_EN;
N       uint32_t RESERVED1[2];
N  __IO uint32_t OVER;
X  volatile uint32_t OVER;
N  __IO uint32_t RXID;
X  volatile uint32_t RXID;
N  __IO uint32_t RXDLC;
X  volatile uint32_t RXDLC;
N  __IO uint32_t RXDATAL;
X  volatile uint32_t RXDATAL;
N  __IO uint32_t RXDATAH;
X  volatile uint32_t RXDATAH;
N  __IO uint32_t TXID;
X  volatile uint32_t TXID;
N  __IO uint32_t TXDLC;
X  volatile uint32_t TXDLC;
N  __IO uint32_t DATAL;
X  volatile uint32_t DATAL;
N  __IO uint32_t DATAH;
X  volatile uint32_t DATAH;
N  __IO uint32_t BUF_CON[32];
X  volatile uint32_t BUF_CON[32];
N  __IO uint32_t INT_RX;
X  volatile uint32_t INT_RX;
N  __IO uint32_t RX;
X  volatile uint32_t RX;
N  __IO uint32_t INT_TX;
X  volatile uint32_t INT_TX;
N  __IO uint32_t TX;
X  volatile uint32_t TX;
N       uint32_t RESERVED2[76];
N    MDR_CAN_BUF_TypeDef CAN_BUF[32];
N       uint32_t RESERVED3[64];
N    MDR_CAN_BUF_FILTER_TypeDef CAN_BUF_FILTER[32];
N}MDR_CAN_TypeDef;
N
N/** @} */ /* End of group MDR32Fx_Periph_CAN_Data_Structures */
N
N/** @defgroup MDR32Fx_Periph_CAN_Defines Defines
N  * @{
N  */
N
N/** @defgroup Periph_CAN_CONTROL	CAN CONTROL
N  * @{
N  */ 
N
N/*-- CAN_CONTROL: CAN Control Register -----------------------------*/
N/* Bit field positions: */
N#define CAN_CONTROL_CAN_EN_Pos                  0
N#define CAN_CONTROL_ROM_Pos                     1
N#define CAN_CONTROL_STM_Pos                     2
N#define CAN_CONTROL_SAP_Pos                     3
N#define CAN_CONTROL_ROP_Pos                     4
N
N/* Bit field masks: */
N#define CAN_CONTROL_CAN_EN                      ((uint32_t)0x00000001)
N#define CAN_CONTROL_ROM                         ((uint32_t)0x00000002)
N#define CAN_CONTROL_STM                         ((uint32_t)0x00000004)
N#define CAN_CONTROL_SAP                         ((uint32_t)0x00000008)
N#define CAN_CONTROL_ROP                         ((uint32_t)0x00000010)
N
N/** @} */ /* End of group CAN_CONTROL */
N
N/** @defgroup Periph_CAN_STATUS	CAN STATUS
N  * @{
N  */ 
N
N/*-- CAN_STATUS: CAN Status Register -------------------------------*/
N/* Bit field positions: */
N#define CAN_STATUS_RX_READY_Pos                 0
N#define CAN_STATUS_TX_READY_Pos                 1
N#define CAN_STATUS_ERROR_OVER_Pos               2
N#define CAN_STATUS_BIT_ERR_Pos                  3
N#define CAN_STATUS_BIT_STUFF_ERR_Pos            4
N#define CAN_STATUS_CRC_ERR_Pos                  5
N#define CAN_STATUS_FRAME_ERR_Pos                6
N#define CAN_STATUS_ACK_ERR_Pos                  7
N#define CAN_STATUS_IDLOWER_Pos                  8
N#define CAN_STATUS_ERR_STATUS_Pos               9
N#define CAN_STATUS_RX_ERR_CNT8_Pos              11
N#define CAN_STATUS_TX_ERR_CNT8_Pos              12
N#define CAN_STATUS_RX_ERR_CNT_Pos               16
N#define CAN_STATUS_TX_ERR_CNT_Pos               24
N
N/* Bit field masks: */
N#define CAN_STATUS_RX_READY                     ((uint32_t)0x00000001)
N#define CAN_STATUS_TX_READY                     ((uint32_t)0x00000002)
N#define CAN_STATUS_ERROR_OVER                   ((uint32_t)0x00000004)
N#define CAN_STATUS_BIT_ERR                      ((uint32_t)0x00000008)
N#define CAN_STATUS_BIT_STUFF_ERR                ((uint32_t)0x00000010)
N#define CAN_STATUS_CRC_ERR                      ((uint32_t)0x00000020)
N#define CAN_STATUS_FRAME_ERR                    ((uint32_t)0x00000040)
N#define CAN_STATUS_ACK_ERR                      ((uint32_t)0x00000080)
N#define CAN_STATUS_IDLOWER                      ((uint32_t)0x00000100)
N#define CAN_STATUS_ERR_STATUS_Msk               ((uint32_t)0x00000600)
N#define CAN_STATUS_RX_ERR_CNT8                  ((uint32_t)0x00000800)
N#define CAN_STATUS_TX_ERR_CNT8                  ((uint32_t)0x00001000)
N#define CAN_STATUS_RX_ERR_CNT_Msk               ((uint32_t)0x00FF0000)
N#define CAN_STATUS_TX_ERR_CNT_Msk               ((uint32_t)0xFF000000)
N
N/** @} */ /* End of group CAN_STATUS */
N
N/** @defgroup Periph_CAN_BITTMNG	CAN BITTMNG
N  * @{
N  */ 
N
N/*-- CAN_BITTMNG: CAN Bittiming Register ---------------------------*/
N/* Bit field positions: */
N#define CAN_BITTMNG_BRP_Pos                     0
N#define CAN_BITTMNG_PSEG_Pos                    16
N#define CAN_BITTMNG_SEG1_Pos                    19
N#define CAN_BITTMNG_SEG2_Pos                    22
N#define CAN_BITTMNG_SJW_Pos                     25
N#define CAN_BITTMNG_SB_Pos                      27
N
N/* Bit field masks: */
N#define CAN_BITTMNG_BRP_Msk                     ((uint32_t)0x0000FFFF)
N#define CAN_BITTMNG_PSEG_Msk                    ((uint32_t)0x00070000)
N#define CAN_BITTMNG_SEG1_Msk                    ((uint32_t)0x00380000)
N#define CAN_BITTMNG_SEG2_Msk                    ((uint32_t)0x01C00000)
N#define CAN_BITTMNG_SJW_Msk                     ((uint32_t)0x06000000)
N#define CAN_BITTMNG_SB                          ((uint32_t)0x08000000)
N
N/** @} */ /* End of group CAN_BITTMNG */
N
N/** @defgroup Periph_CAN_INT_EN	CAN INT EN
N  * @{
N  */ 
N
N/*-- CAN_INT_EN: CAN Interrupt enable Register ---------------------*/
N/* Bit field positions: */
N#define CAN_INT_EN_GLB_INT_EN_Pos               0
N#define CAN_INT_EN_RX_INT_EN_Pos                1
N#define CAN_INT_EN_TX_INT_EN_Pos                2
N#define CAN_INT_EN_ERR_INT_EN_Pos               3
N#define CAN_INT_EN_ERR_OVER_INT_EN_Pos          4
N
N/* Bit field masks: */
N#define CAN_INT_EN_GLB_INT_EN                   ((uint32_t)0x00000001)
N#define CAN_INT_EN_RX_INT_EN                    ((uint32_t)0x00000002)
N#define CAN_INT_EN_TX_INT_EN                    ((uint32_t)0x00000004)
N#define CAN_INT_EN_ERR_INT_EN                   ((uint32_t)0x00000008)
N#define CAN_INT_EN_ERR_OVER_INT_EN              ((uint32_t)0x00000010)
N
N/** @} */ /* End of group CAN_INT_EN */
N
N/** @defgroup Periph_CAN_RXID	CAN RXID
N  * @{
N  */ 
N
N/*-- CAN_RXID:   CAN Receive ID Register ---------------------------*/
N/*-- CAN_TXID:   CAN Transmit ID Register --------------------------*/
N/*-- CAN_BUF_ID: CAN Buffer ID Register ----------------------------*/
N/* Bit field positions: */
N#define CAN_ID_EID_Pos                          0
N#define CAN_ID_SID_Pos                          18
N
N/* Bit field masks: */
N#define CAN_ID_EID_Msk                          ((uint32_t)0x0003FFFF)
N#define CAN_ID_SID_Msk                          ((uint32_t)0x1FFC0000)
N
N/** @} */ /* End of group CAN_RXID */
N
N/** @defgroup Periph_CAN_RXDLC	CAN RXDLC
N  * @{
N  */ 
N
N/*-- CAN_RXDLC:   CAN Receive DLC Register -------------------------*/
N/*-- CAN_TXDLC:   CAN Transmit DLC Register ------------------------*/
N/*-- CAN_BUF_DLC: CAN Buffer DLC Register --------------------------*/
N/* Bit field positions: */
N#define CAN_DLC_Pos                             0
N#define CAN_DLC_RTR_Pos                         8
N#define CAN_DLC_R1_Pos                          9
N#define CAN_DLC_R0_Pos                          10
N#define CAN_DLC_SSR_Pos                         11
N#define CAN_DLC_IDE_Pos                         12
N
N/* Bit field masks: */
N#define CAN_DLC_Msk                             ((uint32_t)0x0000000F)
N#define CAN_DLC_RTR                             ((uint32_t)0x00000100)
N#define CAN_DLC_R1                              ((uint32_t)0x00000200)
N#define CAN_DLC_R0                              ((uint32_t)0x00000400)
N#define CAN_DLC_SSR                             ((uint32_t)0x00000800)
N#define CAN_DLC_IDE                             ((uint32_t)0x00001000)
N
N/** @} */ /* End of group CAN_RXDLC */
N
N/** @defgroup Periph_CAN_RXDATAL	CAN RXDATAL
N  * @{
N  */ 
N
N/*-- CAN_RXDATAL:   CAN Receive Data low Register ------------------*/
N/*-- CAN_DATAL:     CAN Transmit Data low Register -----------------*/
N/*-- CAN_BUF_DATAL: CAN Buffer Data low Register -------------------*/
N/* Bit field positions: */
N#define CAN_DATAL_DB0_Pos                       0
N#define CAN_DATAL_DB1_Pos                       8
N#define CAN_DATAL_DB2_Pos                       16
N#define CAN_DATAL_DB3_Pos                       24
N
N/* Bit field masks: */
N#define CAN_DATAL_DB0_Msk                       ((uint32_t)0x000000FF)
N#define CAN_DATAL_DB1_Msk                       ((uint32_t)0x0000FF00)
N#define CAN_DATAL_DB2_Msk                       ((uint32_t)0x00FF0000)
N#define CAN_DATAL_DB3_Msk                       ((uint32_t)0xFF000000)
N
N/** @} */ /* End of group CAN_RXDATAL */
N
N/** @defgroup Periph_CAN_RXDATAH	CAN RXDATAH
N  * @{
N  */ 
N
N/*-- CAN_RXDATAH:   CAN Receive Data high Register -----------------*/
N/*-- CAN_DATAH:     CAN Transmit Data high Register ----------------*/
N/*-- CAN_BUF_DATAH: CAN Buffer Data high Register ------------------*/
N/* Bit field positions: */
N#define CAN_DATAH_DB4_Pos                       0
N#define CAN_DATAH_DB5_Pos                       8
N#define CAN_DATAH_DB6_Pos                       16
N#define CAN_DATAH_DB7_Pos                       24
N
N/* Bit field masks: */
N#define CAN_DATAH_DB4_Msk                       ((uint32_t)0x000000FF)
N#define CAN_DATAH_DB5_Msk                       ((uint32_t)0x0000FF00)
N#define CAN_DATAH_DB6_Msk                       ((uint32_t)0x00FF0000)
N#define CAN_DATAH_DB7_Msk                       ((uint32_t)0xFF000000)
N
N/** @} */ /* End of group CAN_RXDATAH */
N
N/** @defgroup Periph_CAN_BUF_CON	CAN BUF CON
N  * @{
N  */ 
N
N/*-- CAN_BUF_CON: CAN Buffer Connection Register -------------------*/
N/* Bit field positions: */
N#define CAN_BUF_CON_EN_Pos                      0
N#define CAN_BUF_CON_RX_TXN_Pos                  1
N#define CAN_BUF_CON_OVER_EN_Pos                 2
N#define CAN_BUF_CON_RTR_EN_Pos                  3
N#define CAN_BUF_CON_PRIOR_0_Pos                 4
N#define CAN_BUF_CON_TX_REQ_Pos                  5
N#define CAN_BUF_CON_RX_FULL_Pos                 6
N#define CAN_BUF_CON_OVER_WR_Pos                 7
N
N/* Bit field masks: */
N#define CAN_BUF_CON_EN                          ((uint32_t)0x00000001)
N#define CAN_BUF_CON_RX_TXN                      ((uint32_t)0x00000002)
N#define CAN_BUF_CON_OVER_EN                     ((uint32_t)0x00000004)
N#define CAN_BUF_CON_RTR_EN                      ((uint32_t)0x00000008)
N#define CAN_BUF_CON_PRIOR_0                     ((uint32_t)0x00000010)
N#define CAN_BUF_CON_TX_REQ                      ((uint32_t)0x00000020)
N#define CAN_BUF_CON_RX_FULL                     ((uint32_t)0x00000040)
N#define CAN_BUF_CON_OVER_WR                     ((uint32_t)0x00000080)
N
N/** @} */ /* End of group CAN_BUF_CON */
N
N/** @} */ /* End of group MDR32Fx_Periph_CAN_Defines */
N
N/** @} */ /* End of group MDR32Fx_Periph_CAN */
N
N/** @defgroup MDR32Fx_Periph_USB USB
N  * @{
N  */
N
N/** @defgroup MDR32Fx_Periph_USB_Data_Structures Data Structures
N  * @{
N  */
N
N/* MDR_USB_SEP_TypeDef structure */
Ntypedef struct
N{
N  __IO uint32_t CTRL;
X  volatile uint32_t CTRL;
N  __IO uint32_t STS;
X  volatile uint32_t STS;
N  __IO uint32_t TS;
X  volatile uint32_t TS;
N  __IO uint32_t NTS;
X  volatile uint32_t NTS;
N}MDR_USB_SEP_TypeDef;
N
N/* MDR_USB_SEP_FIFO_TypeDef structure */
Ntypedef struct
N{
N  __IO uint32_t RXFD;
X  volatile uint32_t RXFD;
N       uint32_t RESERVED0;
N  __IO uint32_t RXFDC_L;
X  volatile uint32_t RXFDC_L;
N  __IO uint32_t RXFDC_H;
X  volatile uint32_t RXFDC_H;
N  __IO uint32_t RXFC;
X  volatile uint32_t RXFC;
N       uint32_t RESERVED1[11];
N  __IO uint32_t TXFD;
X  volatile uint32_t TXFD;
N       uint32_t RESERVED2[3];
N  __IO uint32_t TXFDC;
X  volatile uint32_t TXFDC;
N       uint32_t RESERVED3[11];
N}MDR_USB_SEP_FIFO_TypeDef;
N
N/* MDR_USB_TypeDef structure */
Ntypedef struct
N{
N  __IO uint32_t HTXC;
X  volatile uint32_t HTXC;
N  __IO uint32_t HTXT;
X  volatile uint32_t HTXT;
N  __IO uint32_t HTXLC;
X  volatile uint32_t HTXLC;
N  __IO uint32_t HTXSE;
X  volatile uint32_t HTXSE;
N  __IO uint32_t HTXA;
X  volatile uint32_t HTXA;
N  __IO uint32_t HTXE;
X  volatile uint32_t HTXE;
N  __IO uint32_t HFN_L;
X  volatile uint32_t HFN_L;
N  __IO uint32_t HFN_H;
X  volatile uint32_t HFN_H;
N  __IO uint32_t HIS;
X  volatile uint32_t HIS;
N  __IO uint32_t HIM;
X  volatile uint32_t HIM;
N  __IO uint32_t HRXS;
X  volatile uint32_t HRXS;
N  __IO uint32_t HRXP;
X  volatile uint32_t HRXP;
N  __IO uint32_t HRXA;
X  volatile uint32_t HRXA;
N  __IO uint32_t HRXE;
X  volatile uint32_t HRXE;
N  __IO uint32_t HRXCS;
X  volatile uint32_t HRXCS;
N  __IO uint32_t HSTM;
X  volatile uint32_t HSTM;
N       uint32_t RESERVED0[16];
N  __IO uint32_t HRXFD;
X  volatile uint32_t HRXFD;
N       uint32_t RESERVED1;
N  __IO uint32_t HRXFDC_L;
X  volatile uint32_t HRXFDC_L;
N  __IO uint32_t HRXFDC_H;
X  volatile uint32_t HRXFDC_H;
N  __IO uint32_t HRXFC;
X  volatile uint32_t HRXFC;
N       uint32_t RESERVED2[11];
N  __IO uint32_t HTXFD;
X  volatile uint32_t HTXFD;
N       uint32_t RESERVED3[3];
N  __IO uint32_t HTXFC;
X  volatile uint32_t HTXFC;
N       uint32_t RESERVED4[11];
N    MDR_USB_SEP_TypeDef USB_SEP[4];
N  __IO uint32_t SC;
X  volatile uint32_t SC;
N  __IO uint32_t SLS;
X  volatile uint32_t SLS;
N  __IO uint32_t SIS;
X  volatile uint32_t SIS;
N  __IO uint32_t SIM;
X  volatile uint32_t SIM;
N  __IO uint32_t SA;
X  volatile uint32_t SA;
N  __IO uint32_t SFN_L;
X  volatile uint32_t SFN_L;
N  __IO uint32_t SFN_H;
X  volatile uint32_t SFN_H;
N       uint32_t RESERVED5[9];
N    MDR_USB_SEP_FIFO_TypeDef USB_SEP_FIFO[4];
N  __IO uint32_t HSCR;
X  volatile uint32_t HSCR;
N  __IO uint32_t HSVR;
X  volatile uint32_t HSVR;
N}MDR_USB_TypeDef;
N
N/** @} */ /* End of group MDR32Fx_Periph_USB_Data_Structures */
N
N/** @defgroup MDR32Fx_Periph_USB_Defines Defines
N  * @{
N  */
N
N/** @defgroup Periph_USB_HTXC	USB HTXC
N  * @{
N  */ 
N
N/*-- USB_HTXC: USB HTXC Register -----------------------------------*/
N/* Bit field positions: */
N#define USB_HTXC_TREQ_Pos                       0
N#define USB_HTXC_SOFS_Pos                       1
N#define USB_HTXC_PREEN_Pos                      2
N#define USB_HTXC_ISOEN_Pos                      3
N
N/* Bit field masks: */
N#define USB_HTXC_TREQ                           ((uint32_t)0x00000001)
N#define USB_HTXC_SOFS                           ((uint32_t)0x00000002)
N#define USB_HTXC_PREEN                          ((uint32_t)0x00000004)
N#define USB_HTXC_ISOEN                          ((uint32_t)0x00000008)
N
N/** @} */ /* End of group USB_HTXC */
N
N/** @defgroup Periph_USB_HTXLC	USB HTXLC
N  * @{
N  */ 
N
N/*-- USB_HTXLC: USB HTXLC Register ---------------------------------*/
N/* Bit field positions: */
N#define USB_HTXLC_Pos                           0
N#define USB_HTXLC_DC_Pos                        2
N#define USB_HTXLC_FSPL_Pos                      3
N#define USB_HTXLC_FSLR_Pos                      4
N
N/* Bit field masks: */
N#define USB_HTXLC_Msk                           ((uint32_t)0x00000003)
N#define USB_HTXLC_DC                            ((uint32_t)0x00000004)
N#define USB_HTXLC_FSPL                          ((uint32_t)0x00000008)
N#define USB_HTXLC_FSLR                          ((uint32_t)0x00000010)
N
N/** @} */ /* End of group USB_HTXLC */
N
N/** @defgroup Periph_USB_HIS	USB HIS
N  * @{
N  */ 
N
N/*-- USB_HIS: USB_HIS Register -------------------------------------*/
N/* Bit field positions: */
N#define USB_HIS_TDONE_Pos                       0
N#define USB_HIS_RESUME_Pos                      1
N#define USB_HIS_CONEV_Pos                       2
N#define USB_HIS_SOFS_Pos                        3
N
N/* Bit field masks: */
N#define USB_HIS_TDONE                           ((uint32_t)0x00000001)
N#define USB_HIS_RESUME                          ((uint32_t)0x00000002)
N#define USB_HIS_CONEV                           ((uint32_t)0x00000004)
N#define USB_HIS_SOFS                            ((uint32_t)0x00000008)
N
N/** @} */ /* End of group USB_HIS */
N
N/** @defgroup Periph_USB_HIM	USB HIM
N  * @{
N  */ 
N
N/*-- USB_HIM: USB_HIM Register -------------------------------------*/
N/* Bit field positions: */
N#define USB_HIM_TDONEIE_Pos                     0
N#define USB_HIM_RESUMEIE_Pos                    1
N#define USB_HIM_CONEVIE_Pos                     2
N#define USB_HIM_SOFIE_Pos                       3
N
N/* Bit field masks: */
N#define USB_HIM_TDONEIE                         ((uint32_t)0x00000001)
N#define USB_HIM_RESUMEIE                        ((uint32_t)0x00000002)
N#define USB_HIM_CONEVIE                         ((uint32_t)0x00000004)
N#define USB_HIM_SOFIE                           ((uint32_t)0x00000008)
N
N/** @} */ /* End of group USB_HIM */
N
N/** @defgroup Periph_USB_HRXS	USB HRXS
N  * @{
N  */ 
N
N/*-- USB_HRXS: USB_HRXS Register -----------------------------------*/
N/* Bit field positions: */
N#define USB_HRXS_CRCERR_Pos                     0
N#define USB_HRXS_BSERR_Pos                      1
N#define USB_HRXS_RXOF_Pos                       2
N#define USB_HRXS_RXTO_Pos                       3
N#define USB_HRXS_NAKRXED_Pos                    4
N#define USB_HRXS_STALLRXED_Pos                  5
N#define USB_HRXS_ACKRXED_Pos                    6
N#define USB_HRXS_DATASEQ_Pos                    7
N
N/* Bit field masks: */
N#define USB_HRXS_CRCERR                         ((uint32_t)0x00000001)
N#define USB_HRXS_BSERR                          ((uint32_t)0x00000002)
N#define USB_HRXS_RXOF                           ((uint32_t)0x00000004)
N#define USB_HRXS_RXTO                           ((uint32_t)0x00000008)
N#define USB_HRXS_NAKRXED                        ((uint32_t)0x00000010)
N#define USB_HRXS_STALLRXED                      ((uint32_t)0x00000020)
N#define USB_HRXS_ACKRXED                        ((uint32_t)0x00000040)
N#define USB_HRXS_DATASEQ                        ((uint32_t)0x00000080)
N
N/** @} */ /* End of group USB_HRXS */
N
N/** @defgroup Periph_USB_SEP_CTRL	USB SEP CTRL
N  * @{
N  */ 
N
N/*-- USB_SEP_CTRL: USB_SEP Control Register ------------------------*/
N/* Bit field positions: */
N#define USB_SEP_CTRL_EPEN_Pos                   0
N#define USB_SEP_CTRL_EPRDY_Pos                  1
N#define USB_SEP_CTRL_EPDATASEQ_Pos              2
N#define USB_SEP_CTRL_EPSSTALL_Pos               3
N#define USB_SEP_CTRL_EPISOEN_Pos                4
N
N/* Bit field masks: */
N#define USB_SEP_CTRL_EPEN                       ((uint32_t)0x00000001)
N#define USB_SEP_CTRL_EPRDY                      ((uint32_t)0x00000002)
N#define USB_SEP_CTRL_EPDATASEQ                  ((uint32_t)0x00000004)
N#define USB_SEP_CTRL_EPSSTALL                   ((uint32_t)0x00000008)
N#define USB_SEP_CTRL_EPISOEN                    ((uint32_t)0x00000010)
N
N/** @} */ /* End of group USB_SEP_CTRL */
N
N/** @defgroup Periph_USB_SEP_STS	USB SEP STS
N  * @{
N  */ 
N
N/*-- USB_SEP_STS: USB_SEP Status Register --------------------------*/
N/* Bit field positions: */
N#define USB_SEP_STS_SCCRCERR_Pos                0
N#define USB_SEP_STS_SCBSERR_Pos                 1
N#define USB_SEP_STS_SCRXOF_Pos                  2
N#define USB_SEP_STS_SCRXTO_Pos                  3
N#define USB_SEP_STS_SCNAKSENT_Pos               4
N#define USB_SEP_STS_SCSTALLSENT_Pos             5
N#define USB_SEP_STS_SCACKRXED_Pos               6
N#define USB_SEP_STS_SCDATASEQ_Pos               7
N
N/* Bit field masks: */
N#define USB_SEP_STS_SCCRCERR                    ((uint32_t)0x00000001)
N#define USB_SEP_STS_SCBSERR                     ((uint32_t)0x00000002)
N#define USB_SEP_STS_SCRXOF                      ((uint32_t)0x00000004)
N#define USB_SEP_STS_SCRXTO                      ((uint32_t)0x00000008)
N#define USB_SEP_STS_SCNAKSENT                   ((uint32_t)0x00000010)
N#define USB_SEP_STS_SCSTALLSENT                 ((uint32_t)0x00000020)
N#define USB_SEP_STS_SCACKRXED                   ((uint32_t)0x00000040)
N#define USB_SEP_STS_SCDATASEQ                   ((uint32_t)0x00000080)
N
N/** @} */ /* End of group USB_SEP_STS */
N
N/** @defgroup Periph_USB_SC	USB SC
N  * @{
N  */ 
N
N/*-- USB_SC: USB_SC Register ---------------------------------------*/
N/* Bit field positions: */
N#define USB_SCGEN_Pos                           0
N#define USB_SCTXLS_Pos                          1
N#define USB_SCDC_Pos                            3
N#define USB_SCFSP_Pos                           4
N#define USB_SCFSR_Pos                           5
N
N/* Bit field masks: */
N#define USB_SCGEN                               ((uint32_t)0x00000001)
N#define USB_SCTXLS_Msk                          ((uint32_t)0x00000006)
N#define USB_SCDC                                ((uint32_t)0x00000008)
N#define USB_SCFSP                               ((uint32_t)0x00000010)
N#define USB_SCFSR                               ((uint32_t)0x00000020)
N
N/** @} */ /* End of group USB_SC */
N
N/** @defgroup Periph_USB_SIS	USB SIS
N  * @{
N  */ 
N
N/*-- USB_SIS: USB_SIS Register -------------------------------------*/
N/* Bit field positions: */
N#define USB_SIS_SCTDONE_Pos                     0
N#define USB_SIS_SCRESUME_Pos                    1
N#define USB_SIS_SCRESETEV_Pos                   2
N#define USB_SIS_SCSOFREC_Pos                    3
N#define USB_SIS_SCNAKSENT_Pos                   4
N
N/* Bit field masks: */
N#define USB_SIS_SCTDONE                         ((uint32_t)0x00000001)
N#define USB_SIS_SCRESUME                        ((uint32_t)0x00000002)
N#define USB_SIS_SCRESETEV                       ((uint32_t)0x00000004)
N#define USB_SIS_SCSOFREC                        ((uint32_t)0x00000008)
N#define USB_SIS_SCNAKSENT                       ((uint32_t)0x00000010)
N
N/** @} */ /* End of group USB_SIS */
N
N/** @defgroup Periph_USB_SIM	USB SIM
N  * @{
N  */ 
N
N/*-- USB_SIM: USB_SIM Register -------------------------------------*/
N/* Bit field positions: */
N#define USB_SIM_SCTDONEIE_Pos                   0
N#define USB_SIM_SCRESUMEIE_Pos                  1
N#define USB_SIM_SCRESETEVIE_Pos                 2
N#define USB_SIM_SCSOFRECIE_Pos                  3
N#define USB_SIM_SCNAKSENTIE_Pos                 4
N
N/* Bit field masks: */
N#define USB_SIM_SCTDONEIE                       ((uint32_t)0x00000001)
N#define USB_SIM_SCRESUMEIE                      ((uint32_t)0x00000002)
N#define USB_SIM_SCRESETEVIE                     ((uint32_t)0x00000004)
N#define USB_SIM_SCSOFRECIE                      ((uint32_t)0x00000008)
N#define USB_SIM_SCNAKSENTIE                     ((uint32_t)0x00000010)
N
N/** @} */ /* End of group USB_SIM */
N
N/** @defgroup Periph_USB_HSCR	USB HSCR
N  * @{
N  */ 
N
N/*-- USB_HSCR: USB_HSCR Register -----------------------------------*/
N/* Bit field positions: */
N#define USB_HSCR_HOST_MODE_Pos                  0
N#define USB_HSCR_RESET_CORE_Pos                 1
N#define USB_HSCR_EN_TX_Pos                      2
N#define USB_HSCR_EN_RX_Pos                      3
N#define USB_HSCR_DP_PULLUP_Pos                  4
N#define USB_HSCR_DP_PULLDOWN_Pos                5
N#define USB_HSCR_DM_PULLUP_Pos                  6
N#define USB_HSCR_DM_PULLDOWN_Pos                7
N
N/* Bit field masks: */
N#define USB_HSCR_HOST_MODE                      ((uint32_t)0x00000001)
N#define USB_HSCR_RESET_CORE                     ((uint32_t)0x00000002)
N#define USB_HSCR_EN_TX                          ((uint32_t)0x00000004)
N#define USB_HSCR_EN_RX                          ((uint32_t)0x00000008)
N#define USB_HSCR_DP_PULLUP                      ((uint32_t)0x00000010)
N#define USB_HSCR_DP_PULLDOWN                    ((uint32_t)0x00000020)
N#define USB_HSCR_DM_PULLUP                      ((uint32_t)0x00000040)
N#define USB_HSCR_DM_PULLDOWN                    ((uint32_t)0x00000080)
N
N/** @} */ /* End of group USB_HSCR */
N
N/** @defgroup Periph_USB_HSVR	USB HSVR
N  * @{
N  */ 
N
N/*-- USB_HSVR: USB_HSVR Register -----------------------------------*/
N/* Bit field positions: */
N#define USB_HSVR_VERSION_Pos                    0
N#define USB_HSVR_REVISION_Pos                   4
N
N/* Bit field masks: */
N#define USB_HSVR_VERSION_Msk                    ((uint32_t)0x0000000F)
N#define USB_HSVR_REVISION_Msk                   ((uint32_t)0x000000F0)
N
N/** @} */ /* End of group USB_HSVR */
N
N/** @} */ /* End of group MDR32Fx_Periph_USB_Defines */
N
N/** @} */ /* End of group MDR32Fx_Periph_USB */
N
N/** @defgroup MDR32Fx_Periph_EEPROM EEPROM
N  * @{
N  */
N
N/** @defgroup MDR32Fx_Periph_EEPROM_Data_Structures Data Structures
N  * @{
N  */
N
N/* MDR_EEPROM_TypeDef structure */
Ntypedef struct
N{
N  __IO uint32_t CMD;
X  volatile uint32_t CMD;
N  __IO uint32_t ADR;
X  volatile uint32_t ADR;
N  __IO uint32_t DI;
X  volatile uint32_t DI;
N  __IO uint32_t DO;
X  volatile uint32_t DO;
N  __IO uint32_t KEY;
X  volatile uint32_t KEY;
N}MDR_EEPROM_TypeDef;
N
N/** @} */ /* End of group MDR32Fx_Periph_EEPROM_Data_Structures */
N
N/** @defgroup MDR32Fx_Periph_EEPROM_Defines Defines
N  * @{
N  */
N
N/** @defgroup Periph_EEPROM_CMD	EEPROM CMD
N  * @{
N  */ 
N
N/*-- EEPROM_CMD: EEPROM Command Register ---------------------------*/
N/* Bit field positions: */
N#define EEPROM_CMD_CON_Pos                      0
N#define EEPROM_CMD_WR_Pos                       1
N#define EEPROM_CMD_RD_Pos                       2
N#define EEPROM_CMD_DELAY_Pos                    3
N#define EEPROM_CMD_XE_Pos                       6
N#define EEPROM_CMD_YE_Pos                       7
N#define EEPROM_CMD_SE_Pos                       8
N#define EEPROM_CMD_IFREN_Pos                    9
N#define EEPROM_CMD_ERASE_Pos                    10
N#define EEPROM_CMD_MAS1_Pos                     11
N#define EEPROM_CMD_PROG_Pos                     12
N#define EEPROM_CMD_NVSTR_Pos                    13
N
N/* Bit field masks: */
N#define EEPROM_CMD_CON                          ((uint32_t)0x00000001)
N#define EEPROM_CMD_WR                           ((uint32_t)0x00000002)
N#define EEPROM_CMD_RD                           ((uint32_t)0x00000004)
N#define EEPROM_CMD_DELAY_Msk                    ((uint32_t)0x00000038)
N#define EEPROM_CMD_XE                           ((uint32_t)0x00000040)
N#define EEPROM_CMD_YE                           ((uint32_t)0x00000080)
N#define EEPROM_CMD_SE                           ((uint32_t)0x00000100)
N#define EEPROM_CMD_IFREN                        ((uint32_t)0x00000200)
N#define EEPROM_CMD_ERASE                        ((uint32_t)0x00000400)
N#define EEPROM_CMD_MAS1                         ((uint32_t)0x00000800)
N#define EEPROM_CMD_PROG                         ((uint32_t)0x00001000)
N#define EEPROM_CMD_NVSTR                        ((uint32_t)0x00002000)
N
N/** @} */ /* End of group EEPROM_CMD */
N
N/** @} */ /* End of group MDR32Fx_Periph_EEPROM_Defines */
N
N/** @} */ /* End of group MDR32Fx_Periph_EEPROM */
N
N/** @defgroup MDR32Fx_Periph_RST_CLK RST_CLK
N  * @{
N  */
N
N/** @defgroup MDR32Fx_Periph_RST_CLK_Data_Structures Data Structures
N  * @{
N  */
N
N/* MDR_RST_CLK_TypeDef structure */
Ntypedef struct
N{
N  __IO uint32_t CLOCK_STATUS;
X  volatile uint32_t CLOCK_STATUS;
N  __IO uint32_t PLL_CONTROL;
X  volatile uint32_t PLL_CONTROL;
N  __IO uint32_t HS_CONTROL;
X  volatile uint32_t HS_CONTROL;
N  __IO uint32_t CPU_CLOCK;
X  volatile uint32_t CPU_CLOCK;
N  __IO uint32_t USB_CLOCK;
X  volatile uint32_t USB_CLOCK;
N  __IO uint32_t ADC_MCO_CLOCK;
X  volatile uint32_t ADC_MCO_CLOCK;
N  __IO uint32_t RTC_CLOCK;
X  volatile uint32_t RTC_CLOCK;
N  __IO uint32_t PER_CLOCK;
X  volatile uint32_t PER_CLOCK;
N  __IO uint32_t CAN_CLOCK;
X  volatile uint32_t CAN_CLOCK;
N  __IO uint32_t TIM_CLOCK;
X  volatile uint32_t TIM_CLOCK;
N  __IO uint32_t UART_CLOCK;
X  volatile uint32_t UART_CLOCK;
N  __IO uint32_t SSP_CLOCK;
X  volatile uint32_t SSP_CLOCK;
N}MDR_RST_CLK_TypeDef;
N
N/** @} */ /* End of group MDR32Fx_Periph_RST_CLK_Data_Structures */
N
N/** @defgroup MDR32Fx_Periph_RST_CLK_Defines Defines
N  * @{
N  */
N
N/** @defgroup Periph_RST_CLK_CLOCK_STATUS	RST CLK CLOCK STATUS
N  * @{
N  */ 
N
N/*-- RST_CLK_CLOCK_STATUS: Clock Status Register -------------------*/
N/* Bit field positions: */
N#define RST_CLK_CLOCK_STATUS_PLL_USB_RDY_Pos    0
N#define RST_CLK_CLOCK_STATUS_PLL_CPU_RDY_Pos    1
N#define RST_CLK_CLOCK_STATUS_HSE_RDY_Pos        2
N
N/* Bit field masks: */
N#define RST_CLK_CLOCK_STATUS_PLL_USB_RDY        ((uint32_t)0x00000001)
N#define RST_CLK_CLOCK_STATUS_PLL_CPU_RDY        ((uint32_t)0x00000002)
N#define RST_CLK_CLOCK_STATUS_HSE_RDY            ((uint32_t)0x00000004)
N
N/** @} */ /* End of group RST_CLK_CLOCK_STATUS */
N
N/** @defgroup Periph_RST_CLK_PLL_CONTROL	RST CLK PLL CONTROL
N  * @{
N  */ 
N
N/*-- RST_CLK_PLL_CONTROL: PLL Control Register ---------------------*/
N/* Bit field positions: */
N#define RST_CLK_PLL_CONTROL_PLL_USB_ON_Pos      0
N#define RST_CLK_PLL_CONTROL_PLL_USB_RLD_Pos     1
N#define RST_CLK_PLL_CONTROL_PLL_CPU_ON_Pos      2
N#define RST_CLK_PLL_CONTROL_PLL_CPU_PLD_Pos     3
N#define RST_CLK_PLL_CONTROL_PLL_USB_MUL_Pos     4
N#define RST_CLK_PLL_CONTROL_PLL_CPU_MUL_Pos     8
N
N/* Bit field masks: */
N#define RST_CLK_PLL_CONTROL_PLL_USB_ON          ((uint32_t)0x00000001)
N#define RST_CLK_PLL_CONTROL_PLL_USB_RLD         ((uint32_t)0x00000002)
N#define RST_CLK_PLL_CONTROL_PLL_CPU_ON          ((uint32_t)0x00000004)
N#define RST_CLK_PLL_CONTROL_PLL_CPU_PLD         ((uint32_t)0x00000008)
N#define RST_CLK_PLL_CONTROL_PLL_USB_MUL_Msk     ((uint32_t)0x000000F0)
N#define RST_CLK_PLL_CONTROL_PLL_CPU_MUL_Msk     ((uint32_t)0x00000F00)
N
N/** @} */ /* End of group RST_CLK_PLL_CONTROL */
N
N/** @defgroup Periph_RST_CLK_HS_CONTROL	RST CLK HS CONTROL
N  * @{
N  */ 
N
N/*-- RST_CLK_HS_CONTROL: HS Control Register -----------------------*/
N/* Bit field positions: */
N#define RST_CLK_HS_CONTROL_HSE_ON_Pos           0
N#define RST_CLK_HS_CONTROL_HSE_BYP_Pos          1
N
N/* Bit field masks: */
N#define RST_CLK_HS_CONTROL_HSE_ON               ((uint32_t)0x00000001)
N#define RST_CLK_HS_CONTROL_HSE_BYP              ((uint32_t)0x00000002)
N
N/** @} */ /* End of group RST_CLK_HS_CONTROL */
N
N/** @defgroup Periph_RST_CLK_CPU_CLOCK	RST CLK CPU CLOCK
N  * @{
N  */ 
N
N/*-- RST_CLK_CPU_CLOCK: CPU Clock Register -------------------------*/
N/* Bit field positions: */
N#define RST_CLK_CPU_CLOCK_CPU_C1_SEL_Pos        0
N#define RST_CLK_CPU_CLOCK_CPU_C2_SEL_Pos        2
N#define RST_CLK_CPU_CLOCK_CPU_C3_SEL_Pos        4
N#define RST_CLK_CPU_CLOCK_HCLK_SEL_Pos          8
N
N/* Bit field masks: */
N#define RST_CLK_CPU_CLOCK_CPU_C1_SEL_Msk        ((uint32_t)0x00000003)
N#define RST_CLK_CPU_CLOCK_CPU_C2_SEL            ((uint32_t)0x00000004)
N#define RST_CLK_CPU_CLOCK_CPU_C3_SEL_Msk        ((uint32_t)0x000000F0)
N#define RST_CLK_CPU_CLOCK_HCLK_SEL_Msk          ((uint32_t)0x00000300)
N
N/** @} */ /* End of group RST_CLK_CPU_CLOCK */
N
N/** @defgroup Periph_RST_CLK_USB_CLOCK	RST CLK USB CLOCK
N  * @{
N  */ 
N
N/*-- RST_CLK_USB_CLOCK: USB Clock Register -------------------------*/
N/* Bit field positions: */
N#define RST_CLK_USB_CLOCK_USB_C1_SEL_Pos        0
N#define RST_CLK_USB_CLOCK_USB_C2_SEL_Pos        2
N#define RST_CLK_USB_CLOCK_USB_C3_SEL_Pos        4
N#define RST_CLK_USB_CLOCK_USB_CLK_EN_Pos        8
N
N/* Bit field masks: */
N#define RST_CLK_USB_CLOCK_USB_C1_SEL_Msk        ((uint32_t)0x00000003)
N#define RST_CLK_USB_CLOCK_USB_C2_SEL            ((uint32_t)0x00000004)
N#define RST_CLK_USB_CLOCK_USB_C3_SEL	        ((uint32_t)0x00000010)
N#define RST_CLK_USB_CLOCK_USB_CLK_EN            ((uint32_t)0x00000100)
N
N/** @} */ /* End of group RST_CLK_USB_CLOCK */
N
N/** @defgroup Periph_RST_CLK_ADC_MCO_CLOCK	RST CLK ADC MCO CLOCK
N  * @{
N  */ 
N
N/*-- RST_CLK_ADC_MCO_CLOCK: ADC Clock Register ---------------------*/
N/* Bit field positions: */
N#define RST_CLK_ADC_MCO_CLOCK_ADC_C1_SEL_Pos    0
N#define RST_CLK_ADC_MCO_CLOCK_ADC_C2_SEL_Pos    4
N#define RST_CLK_ADC_MCO_CLOCK_ADC_C3_SEL_Pos    8
N#define RST_CLK_ADC_MCO_CLOCK_ADC_CLK_EN_Pos    13
N
N/* Bit field masks: */
N#define RST_CLK_ADC_MCO_CLOCK_ADC_C1_SEL_Msk    ((uint32_t)0x00000003)
N#define RST_CLK_ADC_MCO_CLOCK_ADC_C2_SEL_Msk    ((uint32_t)0x00000030)
N#define RST_CLK_ADC_MCO_CLOCK_ADC_C3_SEL_Msk    ((uint32_t)0x00000F00)
N#define RST_CLK_ADC_MCO_CLOCK_ADC_CLK_EN        ((uint32_t)0x00002000)
N
N/** @} */ /* End of group RST_CLK_ADC_MCO_CLOCK */
N
N/** @defgroup Periph_RST_CLK_RTC_CLOCK	RST CLK RTC CLOCK
N  * @{
N  */ 
N
N/*-- RST_CLK_RTC_CLOCK: RTC Clock Register -------------------------*/
N/* Bit field positions: */
N#define RST_CLK_RTC_CLOCK_HSE_SEL_Pos           0
N#define RST_CLK_RTC_CLOCK_HSI_SEL_Pos           4
N#define RST_CLK_RTC_CLOCK_HSE_RTC_EN_Pos        8
N#define RST_CLK_RTC_CLOCK_HSI_RTC_EN_Pos        9
N
N/* Bit field masks: */
N#define RST_CLK_RTC_CLOCK_HSE_SEL_Msk           ((uint32_t)0x0000000F)
N#define RST_CLK_RTC_CLOCK_HSI_SEL_Msk           ((uint32_t)0x000000F0)
N#define RST_CLK_RTC_CLOCK_HSE_RTC_EN            ((uint32_t)0x00000100)
N#define RST_CLK_RTC_CLOCK_HSI_RTC_EN            ((uint32_t)0x00000200)
N
N/** @} */ /* End of group RST_CLK_RTC_CLOCK */
N
N/** @defgroup Periph_RST_CLK_CAN_CLOCK	RST CLK CAN CLOCK
N  * @{
N  */ 
N
N/*-- RST_CLK_CAN_CLOCK: CAN Clock Register -------------------------*/
N/* Bit field positions: */
N#define RST_CLK_CAN_CLOCK_CAN1_BRG_Pos          0
N#define RST_CLK_CAN_CLOCK_CAN2_BRG_Pos          8
N#define RST_CLK_CAN_CLOCK_CAN1_CLK_EN_Pos       24
N#define RST_CLK_CAN_CLOCK_CAN2_CLK_EN_Pos       25
N
N/* Bit field masks: */
N#define RST_CLK_CAN_CLOCK_CAN1_BRG_Msk          ((uint32_t)0x000000FF)
N#define RST_CLK_CAN_CLOCK_CAN2_BRG_Msk          ((uint32_t)0x0000FF00)
N#define RST_CLK_CAN_CLOCK_CAN1_CLK_EN           ((uint32_t)0x01000000)
N#define RST_CLK_CAN_CLOCK_CAN2_CLK_EN           ((uint32_t)0x02000000)
N
N/** @} */ /* End of group RST_CLK_CAN_CLOCK */
N
N/** @defgroup Periph_RST_CLK_TIM_CLOCK	RST CLK TIM CLOCK
N  * @{
N  */ 
N
N/*-- RST_CLK_TIM_CLOCK: Timer Clock Register -----------------------*/
N/* Bit field positions: */
N#define RST_CLK_TIM_CLOCK_TIM1_BRG_Pos          0
N#define RST_CLK_TIM_CLOCK_TIM2_BRG_Pos          8
N#define RST_CLK_TIM_CLOCK_TIM3_BRG_Pos          16
N#define RST_CLK_TIM_CLOCK_TIM1_CLK_EN_Pos       24
N#define RST_CLK_TIM_CLOCK_TIM2_CLK_EN_Pos       25
N#define RST_CLK_TIM_CLOCK_TIM3_CLK_EN_Pos       26
N
N/* Bit field masks: */
N#define RST_CLK_TIM_CLOCK_TIM1_BRG_Msk          ((uint32_t)0x000000FF)
N#define RST_CLK_TIM_CLOCK_TIM2_BRG_Msk          ((uint32_t)0x0000FF00)
N#define RST_CLK_TIM_CLOCK_TIM3_BRG_Msk          ((uint32_t)0x00FF0000)
N#define RST_CLK_TIM_CLOCK_TIM1_CLK_EN           ((uint32_t)0x01000000)
N#define RST_CLK_TIM_CLOCK_TIM2_CLK_EN           ((uint32_t)0x02000000)
N#define RST_CLK_TIM_CLOCK_TIM3_CLK_EN           ((uint32_t)0x04000000)
N
N/** @} */ /* End of group RST_CLK_TIM_CLOCK */
N
N/** @defgroup Periph_RST_CLK_UART_CLOCK	RST CLK UART CLOCK
N  * @{
N  */ 
N
N/*-- RST_CLK_UART_CLOCK: UART Clock Register -----------------------*/
N/* Bit field positions: */
N#define RST_CLK_UART_CLOCK_UART1_BRG_Pos        0
N#define RST_CLK_UART_CLOCK_UART2_BRG_Pos        8
N#define RST_CLK_UART_CLOCK_UART1_CLK_EN_Pos     24
N#define RST_CLK_UART_CLOCK_UART2_CLK_EN_Pos     25
N
N/* Bit field masks: */
N#define RST_CLK_UART_CLOCK_UART1_BRG_Msk        ((uint32_t)0x000000FF)
N#define RST_CLK_UART_CLOCK_UART2_BRG_Msk        ((uint32_t)0x0000FF00)
N#define RST_CLK_UART_CLOCK_UART1_CLK_EN         ((uint32_t)0x01000000)
N#define RST_CLK_UART_CLOCK_UART2_CLK_EN         ((uint32_t)0x02000000)
N
N/** @} */ /* End of group RST_CLK_UART_CLOCK */
N
N/** @defgroup Periph_RST_CLK_SSP_CLOCK	RST CLK SSP CLOCK
N  * @{
N  */ 
N
N/*-- RST_CLK_SSP_CLOCK: SSP Clock Register -------------------------*/
N/* Bit field positions: */
N#define RST_CLK_SSP_CLOCK_SSP1_BRG_Pos          0
N#define RST_CLK_SSP_CLOCK_SSP2_BRG_Pos          8
N#define RST_CLK_SSP_CLOCK_SSP1_CLK_EN_Pos       24
N#define RST_CLK_SSP_CLOCK_SSP2_CLK_EN_Pos       25
N
N/* Bit field masks: */
N#define RST_CLK_SSP_CLOCK_SSP1_BRG_Msk          ((uint32_t)0x000000FF)
N#define RST_CLK_SSP_CLOCK_SSP2_BRG_Msk          ((uint32_t)0x0000FF00)
N#define RST_CLK_SSP_CLOCK_SSP1_CLK_EN           ((uint32_t)0x01000000)
N#define RST_CLK_SSP_CLOCK_SSP2_CLK_EN           ((uint32_t)0x02000000)
N
N/** @} */ /* End of group RST_CLK_SSP_CLOCK */
N
N/** @} */ /* End of group MDR32Fx_Periph_RST_CLK_Defines */
N
N/** @} */ /* End of group MDR32Fx_Periph_RST_CLK */
N
N/** @defgroup MDR32Fx_Periph_DMA DMA
N  * @{
N  */
N
N/** @defgroup MDR32Fx_Periph_DMA_Data_Structures Data Structures
N  * @{
N  */
N
N/* MDR_DMA_TypeDef structure */
Ntypedef struct
N{
N  __IO uint32_t STATUS;
X  volatile uint32_t STATUS;
N  __IO uint32_t CFG;
X  volatile uint32_t CFG;
N  __IO uint32_t CTRL_BASE_PTR;
X  volatile uint32_t CTRL_BASE_PTR;
N  __IO uint32_t ALT_CTRL_BASE_PTR;
X  volatile uint32_t ALT_CTRL_BASE_PTR;
N  __IO uint32_t WAITONREQ_STATUS;
X  volatile uint32_t WAITONREQ_STATUS;
N  __IO uint32_t CHNL_SW_REQUEST;
X  volatile uint32_t CHNL_SW_REQUEST;
N  __IO uint32_t CHNL_USEBURST_SET;
X  volatile uint32_t CHNL_USEBURST_SET;
N  __IO uint32_t CHNL_USEBURST_CLR;
X  volatile uint32_t CHNL_USEBURST_CLR;
N  __IO uint32_t CHNL_REQ_MASK_SET;
X  volatile uint32_t CHNL_REQ_MASK_SET;
N  __IO uint32_t CHNL_REQ_MASK_CLR;
X  volatile uint32_t CHNL_REQ_MASK_CLR;
N  __IO uint32_t CHNL_ENABLE_SET;
X  volatile uint32_t CHNL_ENABLE_SET;
N  __IO uint32_t CHNL_ENABLE_CLR;
X  volatile uint32_t CHNL_ENABLE_CLR;
N  __IO uint32_t CHNL_PRI_ALT_SET;
X  volatile uint32_t CHNL_PRI_ALT_SET;
N  __IO uint32_t CHNL_PRI_ALT_CLR;
X  volatile uint32_t CHNL_PRI_ALT_CLR;
N  __IO uint32_t CHNL_PRIORITY_SET;
X  volatile uint32_t CHNL_PRIORITY_SET;
N  __IO uint32_t CHNL_PRIORITY_CLR;
X  volatile uint32_t CHNL_PRIORITY_CLR;
N       uint32_t RESERVED0[3];
N  __IO uint32_t ERR_CLR;
X  volatile uint32_t ERR_CLR;
N}MDR_DMA_TypeDef;
N
N/** @} */ /* End of group MDR32Fx_Periph_DMA_Data_Structures */
N
N/** @defgroup MDR32Fx_Periph_DMA_Defines Defines
N  * @{
N  */
N
N/** @defgroup Periph_DMA_STATUS	DMA STATUS
N  * @{
N  */ 
N
N/*-- DMA_STATUS: DMA Status Register -------------------------------*/
N/* Bit field positions: */
N#define DMA_STATUS_MASTER_ENABLE_Pos            0
N#define DMA_STATUS_STATE_Pos                    4
N#define DMA_STATUS_CHNLS_MINUS1_Pos             16
N#define DMA_STATUS_TEST_STATUS_Pos              28
N
N/* Bit field masks: */
N#define DMA_STATUS_MASTER_ENABLE                ((uint32_t)0x00000001)
N#define DMA_STATUS_STATE_Msk                    ((uint32_t)0x000000F0)
N#define DMA_STATUS_CHNLS_MINUS1_Msk             ((uint32_t)0x001F0000)
N#define DMA_STATUS_TEST_STATUS_Msk              ((uint32_t)0xF0000000)
N
N/** @} */ /* End of group DMA_STATUS */
N
N/** @defgroup Periph_DMA_CFG	DMA CFG
N  * @{
N  */ 
N
N/*-- DMA_CFG: DMA Configuration Register ---------------------------*/
N/* Bit field positions: */
N#define DMA_CFG_MASTER_ENABLE_Pos               0
N#define DMA_CFG_CHNL_PROT_CTRL_Pos              5
N
N/* Bit field masks: */
N#define DMA_CFG_MASTER_ENABLE                   ((uint32_t)0x00000001)
N#define DMA_CFG_CHNL_PROT_CTRL_Msk              ((uint32_t)0x000000E0)
N
N/** @} */ /* End of group DMA_CFG */
N
N/** @} */ /* End of group MDR32Fx_Periph_DMA_Defines */
N
N/** @} */ /* End of group MDR32Fx_Periph_DMA */
N
N/** @defgroup MDR32Fx_Periph_UART UART
N  * @{
N  */
N
N/** @defgroup MDR32Fx_Periph_UART_Data_Structures Data Structures
N  * @{
N  */
N
N/* MDR_UART_TypeDef structure */
Ntypedef struct
N{
N  __IO uint32_t DR;
X  volatile uint32_t DR;
N  __IO uint32_t RSR_ECR;
X  volatile uint32_t RSR_ECR;
N       uint32_t RESERVED0[4];
N  __IO uint32_t FR;
X  volatile uint32_t FR;
N       uint32_t RESERVED1;
N  __IO uint32_t ILPR;
X  volatile uint32_t ILPR;
N  __IO uint32_t IBRD;
X  volatile uint32_t IBRD;
N  __IO uint32_t FBRD;
X  volatile uint32_t FBRD;
N  __IO uint32_t LCR_H;
X  volatile uint32_t LCR_H;
N  __IO uint32_t CR;
X  volatile uint32_t CR;
N  __IO uint32_t IFLS;
X  volatile uint32_t IFLS;
N  __IO uint32_t IMSC;
X  volatile uint32_t IMSC;
N  __IO uint32_t RIS;
X  volatile uint32_t RIS;
N  __IO uint32_t MIS;
X  volatile uint32_t MIS;
N  __IO uint32_t ICR;
X  volatile uint32_t ICR;
N  __IO uint32_t DMACR;
X  volatile uint32_t DMACR;
N}MDR_UART_TypeDef;
N
N/** @} */ /* End of group MDR32Fx_Periph_UART_Data_Structures */
N
N/** @defgroup MDR32Fx_Periph_UART_Defines Defines
N  * @{
N  */
N
N/** @defgroup Periph_UART_DR	UART DR
N  * @{
N  */ 
N
N/*-- UART_DR: UART Data Register -----------------------------------*/
N/* Bit field positions: */
N#define UART_DR_DATA_Pos                        0
N#define UART_DR_FE_Pos                          8
N#define UART_DR_PE_Pos                          9
N#define UART_DR_BE_Pos                          10
N#define UART_DR_OE_Pos                          11
N
N/* Bit field masks: */
N#define UART_DR_DATA_Msk                        ((uint32_t)0x000000FF)
N#define UART_DR_FE                              ((uint32_t)0x00000100)
N#define UART_DR_PE                              ((uint32_t)0x00000200)
N#define UART_DR_BE                              ((uint32_t)0x00000400)
N#define UART_DR_OE                              ((uint32_t)0x00000800)
N
N/** @} */ /* End of group UART_DR */
N
N/** @defgroup Periph_UART_RSR_ECR	UART RSR ECR
N  * @{
N  */ 
N
N/*-- UART_RSR_ECR: UART RSR Register -------------------------------*/
N/* Bit field positions: */
N#define UART_RSR_ECR_FE_Pos                     0
N#define UART_RSR_ECR_PE_Pos                     1
N#define UART_RSR_ECR_BE_Pos                     2
N#define UART_RSR_ECR_OE_Pos                     3
N
N/* Bit field masks: */
N#define UART_RSR_ECR_FE                         ((uint32_t)0x00000001)
N#define UART_RSR_ECR_PE                         ((uint32_t)0x00000002)
N#define UART_RSR_ECR_BE                         ((uint32_t)0x00000004)
N#define UART_RSR_ECR_OE                         ((uint32_t)0x00000008)
N
N/** @} */ /* End of group UART_RSR_ECR */
N
N/** @defgroup Periph_UART_FR	UART FR
N  * @{
N  */ 
N
N/*-- UART_FR: UART Flag Register -----------------------------------*/
N/* Bit field positions: */
N#define UART_FR_CTS_Pos                         0
N#define UART_FR_DSR_Pos                         1
N#define UART_FR_DCD_Pos                         2
N#define UART_FR_BUSY_Pos                        3
N#define UART_FR_RXFE_Pos                        4
N#define UART_FR_TXFF_Pos                        5
N#define UART_FR_RXFF_Pos                        6
N#define UART_FR_TXFE_Pos                        7
N#define UART_FR_RI_Pos                          8
N
N/* Bit field masks: */
N#define UART_FR_CTS                             ((uint32_t)0x00000001)
N#define UART_FR_DSR                             ((uint32_t)0x00000002)
N#define UART_FR_DCD                             ((uint32_t)0x00000004)
N#define UART_FR_BUSY                            ((uint32_t)0x00000008)
N#define UART_FR_RXFE                            ((uint32_t)0x00000010)
N#define UART_FR_TXFF                            ((uint32_t)0x00000020)
N#define UART_FR_RXFF                            ((uint32_t)0x00000040)
N#define UART_FR_TXFE                            ((uint32_t)0x00000080)
N#define UART_FR_RI                              ((uint32_t)0x00000100)
N
N/** @} */ /* End of group UART_FR */
N
N/** @defgroup Periph_UART_LCR_H	UART LCR H
N  * @{
N  */ 
N
N/*-- UART_LCR_H: UART LCR_H Register -------------------------------*/
N/* Bit field positions: */
N#define UART_LCR_H_BRK_Pos                      0
N#define UART_LCR_H_PEN_Pos                      1
N#define UART_LCR_H_EPS_Pos                      2
N#define UART_LCR_H_STP2_Pos                     3
N#define UART_LCR_H_FEN_Pos                      4
N#define UART_LCR_H_WLEN_Pos                     5
N#define UART_LCR_H_SPS_Pos                      7
N
N/* Bit field masks: */
N#define UART_LCR_H_BRK                          ((uint32_t)0x00000001)
N#define UART_LCR_H_PEN                          ((uint32_t)0x00000002)
N#define UART_LCR_H_EPS                          ((uint32_t)0x00000004)
N#define UART_LCR_H_STP2                         ((uint32_t)0x00000008)
N#define UART_LCR_H_FEN                          ((uint32_t)0x00000010)
N#define UART_LCR_H_WLEN_Msk                     ((uint32_t)0x00000060)
N#define UART_LCR_H_SPS                          ((uint32_t)0x00000080)
N
N/** @} */ /* End of group UART_LCR_H */
N
N/** @defgroup Periph_UART_CR	UART CR
N  * @{
N  */ 
N
N/*-- UART_CR: UART Command Register --------------------------------*/
N/* Bit field positions: */
N#define UART_CR_UARTEN_Pos                      0
N#define UART_CR_SIREN_Pos                       1
N#define UART_CR_SIRLP_Pos                       2
N#define UART_CR_LBE_Pos                         7
N#define UART_CR_TXE_Pos                         8
N#define UART_CR_RXE_Pos                         9
N#define UART_CR_DTR_Pos                         10
N#define UART_CR_RTS_Pos                         11
N#define UART_CR_OUT1_Pos                        12
N#define UART_CR_OUT2_Pos                        13
N#define UART_CR_RTSEN_Pos                       14
N#define UART_CR_CTSEN_Pos                       15
N
N/* Bit field masks: */
N#define UART_CR_UARTEN                          ((uint32_t)0x00000001)
N#define UART_CR_SIREN                           ((uint32_t)0x00000002)
N#define UART_CR_SIRLP                           ((uint32_t)0x00000004)
N#define UART_CR_LBE                             ((uint32_t)0x00000080)
N#define UART_CR_TXE                             ((uint32_t)0x00000100)
N#define UART_CR_RXE                             ((uint32_t)0x00000200)
N#define UART_CR_DTR                             ((uint32_t)0x00000400)
N#define UART_CR_RTS                             ((uint32_t)0x00000800)
N#define UART_CR_OUT1                            ((uint32_t)0x00001000)
N#define UART_CR_OUT2                            ((uint32_t)0x00002000)
N#define UART_CR_RTSEN                           ((uint32_t)0x00004000)
N#define UART_CR_CTSEN                           ((uint32_t)0x00008000)
N
N/** @} */ /* End of group UART_CR */
N
N/** @defgroup Periph_UART_IFLS	UART IFLS
N  * @{
N  */ 
N
N/*-- UART_IFLS: UART IFLS Register ---------------------------------*/
N/* Bit field positions: */
N#define UART_IFLS_TXIFLSEL_Pos                  0
N#define UART_IFLS_RXIFLSEL_Pos                  3
N
N/* Bit field masks: */
N#define UART_IFLS_TXIFLSEL_Msk                  ((uint32_t)0x00000007)
N#define UART_IFLS_RXIFLSEL_Msk                  ((uint32_t)0x00000038)
N
N/** @} */ /* End of group UART_IFLS */
N
N/** @defgroup Periph_UART_IMSC	UART IMSC
N  * @{
N  */ 
N
N/*-- UART_IMSC: UART Interrupt Mask Register -----------------------*/
N/* Bit field positions: */
N#define UART_IMSC_RIMIM_Pos                     0
N#define UART_IMSC_CTSMIM_Pos                    1
N#define UART_IMSC_DCDMIM_Pos                    2
N#define UART_IMSC_DSRMIM_Pos                    3
N#define UART_IMSC_RXIM_Pos                      4
N#define UART_IMSC_TXIM_Pos                      5
N#define UART_IMSC_RTIM_Pos                      6
N#define UART_IMSC_FEIM_Pos                      7
N#define UART_IMSC_PEIM_Pos                      8
N#define UART_IMSC_BEIM_Pos                      9
N#define UART_IMSC_OEIM_Pos                      10
N
N/* Bit field masks: */
N#define UART_IMSC_RIMIM                         ((uint32_t)0x00000001)
N#define UART_IMSC_CTSMIM                        ((uint32_t)0x00000002)
N#define UART_IMSC_DCDMIM                        ((uint32_t)0x00000004)
N#define UART_IMSC_DSRMIM                        ((uint32_t)0x00000008)
N#define UART_IMSC_RXIM                          ((uint32_t)0x00000010)
N#define UART_IMSC_TXIM                          ((uint32_t)0x00000020)
N#define UART_IMSC_RTIM                          ((uint32_t)0x00000040)
N#define UART_IMSC_FEIM                          ((uint32_t)0x00000080)
N#define UART_IMSC_PEIM                          ((uint32_t)0x00000100)
N#define UART_IMSC_BEIM                          ((uint32_t)0x00000200)
N#define UART_IMSC_OEIM                          ((uint32_t)0x00000400)
N
N/** @} */ /* End of group UART_IMSC */
N
N/** @defgroup Periph_UART_RIS	UART RIS
N  * @{
N  */ 
N
N/*-- UART_RIS: UART Interrupt Pending Register ---------------------*/
N/* Bit field positions: */
N#define UART_RIS_RIRMIS_Pos                     0
N#define UART_RIS_CTSRMIS_Pos                    1
N#define UART_RIS_DCDRMIS_Pos                    2
N#define UART_RIS_DSRRMIS_Pos                    3
N#define UART_RIS_RXRIS_Pos                      4
N#define UART_RIS_TXRIS_Pos                      5
N#define UART_RIS_RTRIS_Pos                      6
N#define UART_RIS_FERIS_Pos                      7
N#define UART_RIS_PERIS_Pos                      8
N#define UART_RIS_BERIS_Pos                      9
N#define UART_RIS_OERIS_Pos                      10
N
N/* Bit field masks: */
N#define UART_RIS_RIRMIS                         ((uint32_t)0x00000001)
N#define UART_RIS_CTSRMIS                        ((uint32_t)0x00000002)
N#define UART_RIS_DCDRMIS                        ((uint32_t)0x00000004)
N#define UART_RIS_DSRRMIS                        ((uint32_t)0x00000008)
N#define UART_RIS_RXRIS                          ((uint32_t)0x00000010)
N#define UART_RIS_TXRIS                          ((uint32_t)0x00000020)
N#define UART_RIS_RTRIS                          ((uint32_t)0x00000040)
N#define UART_RIS_FERIS                          ((uint32_t)0x00000080)
N#define UART_RIS_PERIS                          ((uint32_t)0x00000100)
N#define UART_RIS_BERIS                          ((uint32_t)0x00000200)
N#define UART_RIS_OERIS                          ((uint32_t)0x00000400)
N
N/** @} */ /* End of group UART_RIS */
N
N/** @defgroup Periph_UART_MIS	UART MIS
N  * @{
N  */ 
N
N/*-- UART_MIS: UART Masked Interrupt Pending Register --------------*/
N/* Bit field positions: */
N#define UART_MIS_RIMMIS_Pos                     0
N#define UART_MIS_CTSMMIS_Pos                    1
N#define UART_MIS_DCDMMIS_Pos                    2
N#define UART_MIS_DSRMMIS_Pos                    3
N#define UART_MIS_RXMIS_Pos                      4
N#define UART_MIS_TXMIS_Pos                      5
N#define UART_MIS_RTMIS_Pos                      6
N#define UART_MIS_FEMIS_Pos                      7
N#define UART_MIS_PEMIS_Pos                      8
N#define UART_MIS_BEMIS_Pos                      9
N#define UART_MIS_OEMIS_Pos                      10
N
N/* Bit field masks: */
N#define UART_MIS_RIMMIS                         ((uint32_t)0x00000001)
N#define UART_MIS_CTSMMIS                        ((uint32_t)0x00000002)
N#define UART_MIS_DCDMMIS                        ((uint32_t)0x00000004)
N#define UART_MIS_DSRMMIS                        ((uint32_t)0x00000008)
N#define UART_MIS_RXMIS                          ((uint32_t)0x00000010)
N#define UART_MIS_TXMIS                          ((uint32_t)0x00000020)
N#define UART_MIS_RTMIS                          ((uint32_t)0x00000040)
N#define UART_MIS_FEMIS                          ((uint32_t)0x00000080)
N#define UART_MIS_PEMIS                          ((uint32_t)0x00000100)
N#define UART_MIS_BEMIS                          ((uint32_t)0x00000200)
N#define UART_MIS_OEMIS                          ((uint32_t)0x00000400)
N
N/** @} */ /* End of group UART_MIS */
N
N/** @defgroup Periph_UART_ICR	UART ICR
N  * @{
N  */ 
N
N/*-- UART_ICR: UART Interrupt Clear Register -----------------------*/
N/* Bit field positions: */
N#define UART_ICR_RIMIC_Pos                      0
N#define UART_ICR_CTSMIC_Pos                     1
N#define UART_ICR_DCDMIC_Pos                     2
N#define UART_ICR_DSRMIC_Pos                     3
N#define UART_ICR_RXIC_Pos                       4
N#define UART_ICR_TXIC_Pos                       5
N#define UART_ICR_RTIC_Pos                       6
N#define UART_ICR_FEIC_Pos                       7
N#define UART_ICR_PEIC_Pos                       8
N#define UART_ICR_BEIC_Pos                       9
N#define UART_ICR_OEIC_Pos                       10
N
N/* Bit field masks: */
N#define UART_ICR_RIMIC                          ((uint32_t)0x00000001)
N#define UART_ICR_CTSMIC                         ((uint32_t)0x00000002)
N#define UART_ICR_DCDMIC                         ((uint32_t)0x00000004)
N#define UART_ICR_DSRMIC                         ((uint32_t)0x00000008)
N#define UART_ICR_RXIC                           ((uint32_t)0x00000010)
N#define UART_ICR_TXIC                           ((uint32_t)0x00000020)
N#define UART_ICR_RTIC                           ((uint32_t)0x00000040)
N#define UART_ICR_FEIC                           ((uint32_t)0x00000080)
N#define UART_ICR_PEIC                           ((uint32_t)0x00000100)
N#define UART_ICR_BEIC                           ((uint32_t)0x00000200)
N#define UART_ICR_OEIC                           ((uint32_t)0x00000400)
N
N/** @} */ /* End of group UART_ICR */
N
N/** @defgroup Periph_UART_DMACR	UART DMACR
N  * @{
N  */ 
N
N/*-- UART_DMACR: UART DMA Control Register -------------------------*/
N/* Bit field positions: */
N#define UART_DMACR_RXDMAE_Pos                   0
N#define UART_DMACR_TXDMAE_Pos                   1
N#define UART_DMACR_DMAONERR_Pos                 2
N
N/* Bit field masks: */
N#define UART_DMACR_RXDMAE                       ((uint32_t)0x00000001)
N#define UART_DMACR_TXDMAE                       ((uint32_t)0x00000002)
N#define UART_DMACR_DMAONERR                     ((uint32_t)0x00000004)
N
N/** @} */ /* End of group UART_DMACR */
N
N/** @} */ /* End of group MDR32Fx_Periph_UART_Defines */
N
N/** @} */ /* End of group MDR32Fx_Periph_UART */
N
N/** @defgroup MDR32Fx_Periph_SSP SSP
N  * @{
N  */
N
N/** @defgroup MDR32Fx_Periph_SSP_Data_Structures Data Structures
N  * @{
N  */
N
N/* MDR_SSP_TypeDef structure */
Ntypedef struct
N{
N  __IO uint32_t CR0;
X  volatile uint32_t CR0;
N  __IO uint32_t CR1;
X  volatile uint32_t CR1;
N  __IO uint32_t DR;
X  volatile uint32_t DR;
N  __IO uint32_t SR;
X  volatile uint32_t SR;
N  __IO uint32_t CPSR;
X  volatile uint32_t CPSR;
N  __IO uint32_t IMSC;
X  volatile uint32_t IMSC;
N  __IO uint32_t RIS;
X  volatile uint32_t RIS;
N  __IO uint32_t MIS;
X  volatile uint32_t MIS;
N  __IO uint32_t ICR;
X  volatile uint32_t ICR;
N  __IO uint32_t DMACR;
X  volatile uint32_t DMACR;
N}MDR_SSP_TypeDef;
N
N/** @} */ /* End of group MDR32Fx_Periph_SSP_Data_Structures */
N
N/** @defgroup MDR32Fx_Periph_SSP_Defines Defines
N  * @{
N  */
N
N/** @defgroup Periph_SSP_CR0	SSP CR0
N  * @{
N  */ 
N
N/*-- SSP_CR0: SSP Control0 Register --------------------------------*/
N/* Bit field positions: */
N#define SSP_CR0_DSS_Pos                         0
N#define SSP_CR0_FRF_Pos                         4
N#define SSP_CR0_SPO_Pos                         6
N#define SSP_CR0_SPH_Pos                         7
N#define SSP_CR0_SCR_Pos                         8
N
N/* Bit field masks: */
N#define SSP_CR0_DSS_Msk                         ((uint32_t)0x0000000F)
N#define SSP_CR0_FRF_Msk                         ((uint32_t)0x00000030)
N#define SSP_CR0_SPO                             ((uint32_t)0x00000040)
N#define SSP_CR0_SPH                             ((uint32_t)0x00000080)
N#define SSP_CR0_SCR_Msk                         ((uint32_t)0x0000FF00)
N
N/** @} */ /* End of group SSP_CR0 */
N
N/** @defgroup Periph_SSP_CR1	SSP CR1
N  * @{
N  */ 
N
N/*-- SSP_CR1: SSP Control1 Register --------------------------------*/
N/* Bit field positions: */
N#define SSP_CR1_LBM_Pos                         0
N#define SSP_CR1_SSE_Pos                         1
N#define SSP_CR1_MS_Pos                          2
N#define SSP_CR1_SOD_Pos                         3
N
N/* Bit field masks: */
N#define SSP_CR1_LBM                             ((uint32_t)0x00000001)
N#define SSP_CR1_SSE                             ((uint32_t)0x00000002)
N#define SSP_CR1_MS                              ((uint32_t)0x00000004)
N#define SSP_CR1_SOD                             ((uint32_t)0x00000008)
N
N/** @} */ /* End of group SSP_CR1 */
N
N/** @defgroup Periph_SSP_SR	SSP SR
N  * @{
N  */ 
N
N/*-- SSP_SR: SSP Status Register -----------------------------------*/
N/* Bit field positions: */
N#define SSP_SR_TFE_Pos                          0
N#define SSP_SR_TNF_Pos                          1
N#define SSP_SR_RNE_Pos                          2
N#define SSP_SR_RFF_Pos                          3
N#define SSP_SR_BSY_Pos                          4
N
N/* Bit field masks: */
N#define SSP_SR_TFE                              ((uint32_t)0x00000001)
N#define SSP_SR_TNF                              ((uint32_t)0x00000002)
N#define SSP_SR_RNE                              ((uint32_t)0x00000004)
N#define SSP_SR_RFF                              ((uint32_t)0x00000008)
N#define SSP_SR_BSY                              ((uint32_t)0x00000010)
N
N/** @} */ /* End of group SSP_SR */
N
N/** @defgroup Periph_SSP_IMSC	SSP IMSC
N  * @{
N  */ 
N
N/*-- SSP_IMSC: SSP Interrupt Mask Register -------------------------*/
N/* Bit field positions: */
N#define SSP_IMSC_RORIM_Pos                      0
N#define SSP_IMSC_RTIM_Pos                       1
N#define SSP_IMSC_RXIM_Pos                       2
N#define SSP_IMSC_TXIM_Pos                       3
N
N/* Bit field masks: */
N#define SSP_IMSC_RORIM                          ((uint32_t)0x00000001)
N#define SSP_IMSC_RTIM                           ((uint32_t)0x00000002)
N#define SSP_IMSC_RXIM                           ((uint32_t)0x00000004)
N#define SSP_IMSC_TXIM                           ((uint32_t)0x00000008)
N
N/** @} */ /* End of group SSP_IMSC */
N
N/** @defgroup Periph_SSP_RIS	SSP RIS
N  * @{
N  */ 
N
N/*-- SSP_RIS: SSP Interrupt Pending Register -----------------------*/
N/* Bit field positions: */
N#define SSP_RIS_RORRIS_Pos                      0
N#define SSP_RIS_RTRIS_Pos                       1
N#define SSP_RIS_RXRIS_Pos                       2
N#define SSP_RIS_TXRIS_Pos                       3
N
N/* Bit field masks: */
N#define SSP_RIS_RORRIS                          ((uint32_t)0x00000001)
N#define SSP_RIS_RTRIS                           ((uint32_t)0x00000002)
N#define SSP_RIS_RXRIS                           ((uint32_t)0x00000004)
N#define SSP_RIS_TXRIS                           ((uint32_t)0x00000008)
N
N/** @} */ /* End of group SSP_RIS */
N
N/** @defgroup Periph_SSP_MIS	SSP MIS
N  * @{
N  */ 
N
N/*-- SSP_MIS: SSP Masked Interrupt Pending Register ----------------*/
N/* Bit field positions: */
N#define SSP_MIS_RORMIS_Pos                      0
N#define SSP_MIS_RTMIS_Pos                       1
N#define SSP_MIS_RXMIS_Pos                       2
N#define SSP_MIS_TXMIS_Pos                       3
N
N/* Bit field masks: */
N#define SSP_MIS_RORMIS                          ((uint32_t)0x00000001)
N#define SSP_MIS_RTMIS                           ((uint32_t)0x00000002)
N#define SSP_MIS_RXMIS                           ((uint32_t)0x00000004)
N#define SSP_MIS_TXMIS                           ((uint32_t)0x00000008)
N
N/** @} */ /* End of group SSP_MIS */
N
N/** @defgroup Periph_SSP_ICR	SSP ICR
N  * @{
N  */ 
N
N/*-- SSP_ICR: SSP Interrupt Clear Register -------------------------*/
N/* Bit field positions: */
N#define SSP_ICR_RORIC_Pos                       0
N#define SSP_ICR_RTIC_Pos                        1
N
N/* Bit field masks: */
N#define SSP_ICR_RORIC                           ((uint32_t)0x00000001)
N#define SSP_ICR_RTIC                            ((uint32_t)0x00000002)
N
N/** @} */ /* End of group SSP_ICR */
N
N/** @defgroup Periph_SSP_DMACR	SSP DMACR
N  * @{
N  */ 
N
N/*-- SSP_DMACR: SSP DMA Control Register ---------------------------*/
N/* Bit field positions: */
N#define SSP_DMACR_RXDMAE_Pos                    0
N#define SSP_DMACR_TXDMAE_Pos                    1
N
N/* Bit field masks: */
N#define SSP_DMACR_RXDMAE                        ((uint32_t)0x00000001)
N#define SSP_DMACR_TXDMAE                        ((uint32_t)0x00000002)
N
N/** @} */ /* End of group SSP_DMACR */
N
N/** @} */ /* End of group MDR32Fx_Periph_SSP_Defines */
N
N/** @} */ /* End of group MDR32Fx_Periph_SSP */
N
N/** @defgroup MDR32Fx_Periph_I2C I2C
N  * @{
N  */
N
N/** @defgroup MDR32Fx_Periph_I2C_Data_Structures Data Structures
N  * @{
N  */
N
N/* MDR_I2C_TypeDef structure */
Ntypedef struct
N{
N  __IO uint32_t PRL;
X  volatile uint32_t PRL;
N  __IO uint32_t PRH;
X  volatile uint32_t PRH;
N  __IO uint32_t CTR;
X  volatile uint32_t CTR;
N  __IO uint32_t RXD;
X  volatile uint32_t RXD;
N  __IO uint32_t STA;
X  volatile uint32_t STA;
N  __IO uint32_t TXD;
X  volatile uint32_t TXD;
N  __IO uint32_t CMD;
X  volatile uint32_t CMD;
N}MDR_I2C_TypeDef;
N
N/** @} */ /* End of group MDR32Fx_Periph_I2C_Data_Structures */
N
N/** @defgroup MDR32Fx_Periph_I2C_Defines Defines
N  * @{
N  */
N
N/** @defgroup Periph_I2C_CTR	I2C CTR
N  * @{
N  */ 
N
N/*-- I2C_CTR: I2C Control Register ---------------------------------*/
N/* Bit field positions: */
N#define I2C_CTR_S_I2C_Pos                       5
N#define I2C_CTR_EN_INT_Pos                      6
N#define I2C_CTR_EN_I2C_Pos                      7
N
N/* Bit field masks: */
N#define I2C_CTR_S_I2C                           ((uint32_t)0x00000020)
N#define I2C_CTR_EN_INT                          ((uint32_t)0x00000040)
N#define I2C_CTR_EN_I2C                          ((uint32_t)0x00000080)
N
N/** @} */ /* End of group I2C_CTR */
N
N/** @defgroup Periph_I2C_STA	I2C STA
N  * @{
N  */ 
N
N/*-- I2C_STA: I2C Status Register ----------------------------------*/
N/* Bit field positions: */
N#define I2C_STA_INT_Pos                         0
N#define I2C_STA_TR_PROG_Pos                     1
N#define I2C_STA_LOST_ARB_Pos                    5
N#define I2C_STA_BUSY_Pos                        6
N#define I2C_STA_RX_ACK_Pos                      7
N
N/* Bit field masks: */
N#define I2C_STA_INT                             ((uint32_t)0x00000001)
N#define I2C_STA_TR_PROG                         ((uint32_t)0x00000002)
N#define I2C_STA_LOST_ARB                        ((uint32_t)0x00000020)
N#define I2C_STA_BUSY                            ((uint32_t)0x00000040)
N#define I2C_STA_RX_ACK                          ((uint32_t)0x00000080)
N
N/** @} */ /* End of group I2C_STA */
N
N/** @defgroup Periph_I2C_CMD	I2C CMD
N  * @{
N  */ 
N
N/*-- I2C_CMD: I2C Command Register ---------------------------------*/
N/* Bit field positions: */
N#define I2C_CMD_CLRINT_Pos                      0
N#define I2C_CMD_ACK_Pos                         3
N#define I2C_CMD_WR_Pos                          4
N#define I2C_CMD_RD_Pos                          5
N#define I2C_CMD_STOP_Pos                        6
N#define I2C_CMD_START_Pos                       7
N
N/* Bit field masks: */
N#define I2C_CMD_CLRINT                          ((uint32_t)0x00000001)
N#define I2C_CMD_ACK                             ((uint32_t)0x00000008)
N#define I2C_CMD_WR                              ((uint32_t)0x00000010)
N#define I2C_CMD_RD                              ((uint32_t)0x00000020)
N#define I2C_CMD_STOP                            ((uint32_t)0x00000040)
N#define I2C_CMD_START                           ((uint32_t)0x00000080)
N
N/** @} */ /* End of group I2C_CMD */
N
N/** @} */ /* End of group MDR32Fx_Periph_I2C_Defines */
N
N/** @} */ /* End of group MDR32Fx_Periph_I2C */
N
N/** @defgroup MDR32Fx_Periph_POWER POWER
N  * @{
N  */
N
N/** @defgroup MDR32Fx_Periph_POWER_Data_Structures Data Structures
N  * @{
N  */
N
N/* MDR_POWER_TypeDef structure */
Ntypedef struct
N{
N  __IO uint32_t PVDCS;
X  volatile uint32_t PVDCS;
N}MDR_POWER_TypeDef;
N
N/** @} */ /* End of group MDR32Fx_Periph_POWER_Data_Structures */
N
N/** @defgroup MDR32Fx_Periph_POWER_Defines Defines
N  * @{
N  */
N
N/** @defgroup Periph_POWER_PVDCS	POWER PVDCS
N  * @{
N  */ 
N
N/*-- POWER_PVDCS: POWER Power Detector Control/Status Register -----*/
N/* Bit field positions: */
N#define POWER_PVDCS_PVDEN_Pos                   0
N#define POWER_PVDCS_PBLS_Pos                    1
N#define POWER_PVDCS_PLS_Pos                     3
N#define POWER_PVDCS_PVBD_Pos                    6
N#define POWER_PVDCS_PVD_Pos                     7
N#define POWER_PVDCS_IEPVBD_Pos                  8
N#define POWER_PVDCS_IEPVD_Pos                   9
N#define POWER_PVDCS_INVB_Pos                    10
N#define POWER_PVDCS_INV_Pos                     11
N
N/* Bit field masks: */
N#define POWER_PVDCS_PVDEN                       ((uint32_t)0x00000001)
N#define POWER_PVDCS_PBLS_Msk                    ((uint32_t)0x00000006)
N#define POWER_PVDCS_PLS_Msk                     ((uint32_t)0x00000038)
N#define POWER_PVDCS_PVBD                        ((uint32_t)0x00000040)
N#define POWER_PVDCS_PVD                         ((uint32_t)0x00000080)
N#define POWER_PVDCS_IEPVBD                      ((uint32_t)0x00000100)
N#define POWER_PVDCS_IEPVD                       ((uint32_t)0x00000200)
N#define POWER_PVDCS_INVB                        ((uint32_t)0x00000400)
N#define POWER_PVDCS_INV                         ((uint32_t)0x00000800)
N
N/** @} */ /* End of group POWER_PVDCS */
N
N/** @} */ /* End of group MDR32Fx_Periph_POWER_Defines */
N
N/** @} */ /* End of group MDR32Fx_Periph_POWER */
N
N/** @defgroup MDR32Fx_Periph_WWDG WWDG
N  * @{
N  */
N
N/** @defgroup MDR32Fx_Periph_WWDG_Data_Structures Data Structures
N  * @{
N  */
N
N/* MDR_WWDG_TypeDef structure */
Ntypedef struct
N{
N  __IO uint32_t CR;
X  volatile uint32_t CR;
N  __IO uint32_t CFR;
X  volatile uint32_t CFR;
N  __IO uint32_t SR;
X  volatile uint32_t SR;
N}MDR_WWDG_TypeDef;
N
N/** @} */ /* End of group MDR32Fx_Periph_WWDG_Data_Structures */
N
N/** @defgroup MDR32Fx_Periph_WWDG_Defines Defines
N  * @{
N  */
N
N/** @defgroup Periph_WWDG_CR	WWDG CR
N  * @{
N  */ 
N
N/*-- WWDG_CR: WWDG Command Register --------------------------------*/
N/* Bit field positions: */
N#define WWDG_CR_T_Pos                           0
N#define WWDG_CR_WDGA_Pos                        7
N
N/* Bit field masks: */
N#define WWDG_CR_T_Msk                           ((uint32_t)0x0000007F)
N#define WWDG_CR_WDGA                            ((uint32_t)0x00000080)
N
N/** @} */ /* End of group WWDG_CR */
N
N/** @defgroup Periph_WWDG_CFR	WWDG CFR
N  * @{
N  */ 
N
N/*-- WWDG_CFR: WWDG Configuration Register -------------------------*/
N/* Bit field positions: */
N#define WWDG_CFR_W_Pos                          0
N#define WWDG_CFR_WGTB_Pos                       7
N#define WWDG_CFR_EWI_Pos                        9
N
N/* Bit field masks: */
N#define WWDG_CFR_W_Msk                          ((uint32_t)0x0000007F)
N#define WWDG_CFR_WGTB_Msk                       ((uint32_t)0x00000180)
N#define WWDG_CFR_EWI                            ((uint32_t)0x00000200)
N
N/** @} */ /* End of group WWDG_CFR */
N
N/** @} */ /* End of group MDR32Fx_Periph_WWDG_Defines */
N
N/** @} */ /* End of group MDR32Fx_Periph_WWDG */
N
N/** @defgroup MDR32Fx_Periph_IWDG IWDG
N  * @{
N  */
N
N/** @defgroup MDR32Fx_Periph_IWDG_Data_Structures Data Structures
N  * @{
N  */
N
N/* MDR_IWDG_TypeDef structure */
Ntypedef struct
N{
N  __IO uint32_t KR;
X  volatile uint32_t KR;
N  __IO uint32_t PR;
X  volatile uint32_t PR;
N  __IO uint32_t RLR;
X  volatile uint32_t RLR;
N  __IO uint32_t SR;
X  volatile uint32_t SR;
N}MDR_IWDG_TypeDef;
N
N/** @} */ /* End of group MDR32Fx_Periph_IWDG_Data_Structures */
N
N/** @defgroup MDR32Fx_Periph_IWDG_Defines Defines
N  * @{
N  */
N
N/** @defgroup Periph_IWDG_SR	IWDG SR
N  * @{
N  */ 
N
N/*-- IWDG_SR: IWDG Status Register ---------------------------------*/
N/* Bit field positions: */
N#define IWDG_SR_PVU_Pos                         0
N#define IWDG_SR_RVU_Pos                         1
N
N/* Bit field masks: */
N#define IWDG_SR_PVU                             ((uint32_t)0x00000001)
N#define IWDG_SR_RVU                             ((uint32_t)0x00000002)
N
N/** @} */ /* End of group IWDG_SR */
N
N/** @} */ /* End of group MDR32Fx_Periph_IWDG_Defines */
N
N/** @} */ /* End of group MDR32Fx_Periph_IWDG */
N
N/** @defgroup MDR32Fx_Periph_TIMER TIMER
N  * @{
N  */
N
N/** @defgroup MDR32Fx_Periph_TIMER_Data_Structures Data Structures
N  * @{
N  */
N
N/* MDR_TIMER_TypeDef structure */
Ntypedef struct
N{
N  __IO uint32_t CNT;
X  volatile uint32_t CNT;
N  __IO uint32_t PSG;
X  volatile uint32_t PSG;
N  __IO uint32_t ARR;
X  volatile uint32_t ARR;
N  __IO uint32_t CNTRL;
X  volatile uint32_t CNTRL;
N  __IO uint32_t CCR1;
X  volatile uint32_t CCR1;
N  __IO uint32_t CCR2;
X  volatile uint32_t CCR2;
N  __IO uint32_t CCR3;
X  volatile uint32_t CCR3;
N  __IO uint32_t CCR4;
X  volatile uint32_t CCR4;
N  __IO uint32_t CH1_CNTRL;
X  volatile uint32_t CH1_CNTRL;
N  __IO uint32_t CH2_CNTRL;
X  volatile uint32_t CH2_CNTRL;
N  __IO uint32_t CH3_CNTRL;
X  volatile uint32_t CH3_CNTRL;
N  __IO uint32_t CH4_CNTRL;
X  volatile uint32_t CH4_CNTRL;
N  __IO uint32_t CH1_CNTRL1;
X  volatile uint32_t CH1_CNTRL1;
N  __IO uint32_t CH2_CNTRL1;
X  volatile uint32_t CH2_CNTRL1;
N  __IO uint32_t CH3_CNTRL1;
X  volatile uint32_t CH3_CNTRL1;
N  __IO uint32_t CH4_CNTRL1;
X  volatile uint32_t CH4_CNTRL1;
N  __IO uint32_t CH1_DTG;
X  volatile uint32_t CH1_DTG;
N  __IO uint32_t CH2_DTG;
X  volatile uint32_t CH2_DTG;
N  __IO uint32_t CH3_DTG;
X  volatile uint32_t CH3_DTG;
N  __IO uint32_t CH4_DTG;
X  volatile uint32_t CH4_DTG;
N  __IO uint32_t BRKETR_CNTRL;
X  volatile uint32_t BRKETR_CNTRL;
N  __IO uint32_t STATUS;
X  volatile uint32_t STATUS;
N  __IO uint32_t IE;
X  volatile uint32_t IE;
N  __IO uint32_t DMA_RE;
X  volatile uint32_t DMA_RE;
N  __IO uint32_t CH1_CNTRL2;
X  volatile uint32_t CH1_CNTRL2;
N  __IO uint32_t CH2_CNTRL2;
X  volatile uint32_t CH2_CNTRL2;
N  __IO uint32_t CH3_CNTRL2;
X  volatile uint32_t CH3_CNTRL2;
N  __IO uint32_t CH4_CNTRL2;
X  volatile uint32_t CH4_CNTRL2;
N  __IO uint32_t CCR11;
X  volatile uint32_t CCR11;
N  __IO uint32_t CCR21;
X  volatile uint32_t CCR21;
N  __IO uint32_t CCR31;
X  volatile uint32_t CCR31;
N  __IO uint32_t CCR41;
X  volatile uint32_t CCR41;
N}MDR_TIMER_TypeDef;
N
N/** @} */ /* End of group MDR32Fx_Periph_TIMER_Data_Structures */
N
N/** @defgroup MDR32Fx_Periph_TIMER_Defines Defines
N  * @{
N  */
N
N/** @defgroup Periph_TIMER_CNTRL	TIMER CNTRL
N  * @{
N  */ 
N
N/*-- TIMER_CNTRL: Timer Control Register ---------------------------*/
N/* Bit field positions: */
N#define TIMER_CNTRL_CNT_EN_Pos                  0
N#define TIMER_CNTRL_ARRB_EN_Pos                 1
N#define TIMER_CNTRL_WR_CMPL_Pos                 2
N#define TIMER_CNTRL_DIR_Pos                     3
N#define TIMER_CNTRL_FDTS_Pos                    4
N#define TIMER_CNTRL_CNT_MODE_Pos                6
N#define TIMER_CNTRL_EVENT_SEL_Pos               8
N
N/* Bit field masks: */
N#define TIMER_CNTRL_CNT_EN                      ((uint32_t)0x00000001)
N#define TIMER_CNTRL_ARRB_EN                     ((uint32_t)0x00000002)
N#define TIMER_CNTRL_WR_CMPL                     ((uint32_t)0x00000004)
N#define TIMER_CNTRL_DIR                         ((uint32_t)0x00000008)
N#define TIMER_CNTRL_FDTS_Msk                    ((uint32_t)0x00000030)
N#define TIMER_CNTRL_CNT_MODE_Msk                ((uint32_t)0x000000C0)
N#define TIMER_CNTRL_EVENT_SEL_Msk               ((uint32_t)0x00000F00)
N
N/** @} */ /* End of group TIMER_CNTRL */
N
N/** @defgroup Periph_TIMER_CH_CNTRL	TIMER CH CNTRL
N  * @{
N  */ 
N
N/*-- TIMER_CH_CNTRL: Timer Channel Control Register ----------------*/
N/* Bit field positions: */
N#define TIMER_CH_CNTRL_CHFLTR_Pos               0
N#define TIMER_CH_CNTRL_CHSEL_Pos                4
N#define TIMER_CH_CNTRL_CHPSC_Pos                6
N#define TIMER_CH_CNTRL_OCCE_Pos                 8
N#define TIMER_CH_CNTRL_OCCM_Pos                 9
N#define TIMER_CH_CNTRL_BRKEN_Pos                12
N#define TIMER_CH_CNTRL_ETREN_Pos                13
N#define TIMER_CH_CNTRL_WR_CMPL_Pos              14
N#define TIMER_CH_CNTRL_CAP_NPWM_Pos             15
N
N/* Bit field masks: */
N#define TIMER_CH_CNTRL_CHFLTR_Msk               ((uint32_t)0x0000000F)
N#define TIMER_CH_CNTRL_CHSEL_Msk                ((uint32_t)0x00000030)
N#define TIMER_CH_CNTRL_CHPSC_Msk                ((uint32_t)0x000000C0)
N#define TIMER_CH_CNTRL_OCCE                     ((uint32_t)0x00000100)
N#define TIMER_CH_CNTRL_OCCM_Msk                 ((uint32_t)0x00000E00)
N#define TIMER_CH_CNTRL_BRKEN                    ((uint32_t)0x00001000)
N#define TIMER_CH_CNTRL_ETREN                    ((uint32_t)0x00002000)
N#define TIMER_CH_CNTRL_WR_CMPL                  ((uint32_t)0x00004000)
N#define TIMER_CH_CNTRL_CAP_NPWM                 ((uint32_t)0x00008000)
N
N/** @} */ /* End of group TIMER_CH_CNTRL */
N
N/** @defgroup Periph_TIMER_CH_CNTRL1	TIMER CH CNTRL1
N  * @{
N  */ 
N
N/*-- TIMER_CH_CNTRL1: Timer Channel Control1 Register --------------*/
N/* Bit field positions: */
N#define TIMER_CH_CNTRL1_SELOE_Pos               0
N#define TIMER_CH_CNTRL1_SELO_Pos                2
N#define TIMER_CH_CNTRL1_INV_Pos                 4
N#define TIMER_CH_CNTRL1_NSELOE_Pos              8
N#define TIMER_CH_CNTRL1_NSELO_Pos               10
N#define TIMER_CH_CNTRL1_NINV_Pos                12
N
N/* Bit field masks: */
N#define TIMER_CH_CNTRL1_SELOE_Msk               ((uint32_t)0x00000003)
N#define TIMER_CH_CNTRL1_SELO_Msk                ((uint32_t)0x0000000C)
N#define TIMER_CH_CNTRL1_INV                     ((uint32_t)0x00000010)
N#define TIMER_CH_CNTRL1_NSELOE_Msk              ((uint32_t)0x00000300)
N#define TIMER_CH_CNTRL1_NSELO_Msk               ((uint32_t)0x00000C00)
N#define TIMER_CH_CNTRL1_NINV                    ((uint32_t)0x00001000)
N
N/** @} */ /* End of group TIMER_CH_CNTRL1 */
N
N/** @defgroup Periph_TIMER_CH_DTG	TIMER CH DTG
N  * @{
N  */ 
N
N/*-- TIMER_CH_DTG: Timer Channel DTG Register ----------------------*/
N/* Bit field positions: */
N#define TIMER_CH_DTGX_Pos                       0
N#define TIMER_CH_DTG_EDTS_Pos                   4
N#define TIMER_CH_DTG_Pos                        8
N
N/* Bit field masks: */
N#define TIMER_CH_DTGX_Msk                       ((uint32_t)0x0000000F)
N#define TIMER_CH_DTG_EDTS                       ((uint32_t)0x00000010)
N#define TIMER_CH_DTG_Msk                        ((uint32_t)0x0000FF00)
N
N/** @} */ /* End of group TIMER_CH_DTG */
N
N/** @defgroup Periph_TIMER_BRKETR_CNTRL	TIMER BRKETR CNTRL
N  * @{
N  */ 
N
N/*-- TIMER_BRKETR_CNTRL: Timer BRK/ETR Control Register ------------*/
N/* Bit field positions: */
N#define TIMER_BRKETR_CNTRL_BRK_INV_Pos          0
N#define TIMER_BRKETR_CNTRL_ETR_INV_Pos          1
N#define TIMER_BRKETR_CNTRL_ETR_PSC_Pos          2
N#define TIMER_BRKETR_CNTRL_ETR_FILTER_Pos       4
N
N/* Bit field masks: */
N#define TIMER_BRKETR_CNTRL_BRK_INV              ((uint32_t)0x00000001)
N#define TIMER_BRKETR_CNTRL_ETR_INV              ((uint32_t)0x00000002)
N#define TIMER_BRKETR_CNTRL_ETR_PSC_Msk          ((uint32_t)0x0000000C)
N#define TIMER_BRKETR_CNTRL_ETR_FILTER_Msk       ((uint32_t)0x000000F0)
N
N/** @} */ /* End of group TIMER_BRKETR_CNTRL */
N
N/** @defgroup Periph_TIMER_STATUS	TIMER STATUS
N  * @{
N  */ 
N
N/*-- TIMER_STATUS: Timer Status Register ---------------------------*/
N/* Bit field positions: */
N#define TIMER_STATUS_CNT_ZERO_EVENT_Pos         0
N#define TIMER_STATUS_CNT_ARR_EVENT_Pos          1
N#define TIMER_STATUS_ETR_RE_EVENT_Pos           2
N#define TIMER_STATUS_ETR_FE_EVENT_Pos           3
N#define TIMER_STATUS_BRK_EVENT_Pos              4
N#define TIMER_STATUS_CCR_CAP_EVENT_Pos          5
N#define TIMER_STATUS_CCR_REF_EVENT_Pos          9
N#define TIMER_STATUS_CCR1_CAP_EVENT_Pos         13
N
N/* Bit field masks: */
N#define TIMER_STATUS_CNT_ZERO_EVENT             ((uint32_t)0x00000001)
N#define TIMER_STATUS_CNT_ARR_EVENT              ((uint32_t)0x00000002)
N#define TIMER_STATUS_ETR_RE_EVENT               ((uint32_t)0x00000004)
N#define TIMER_STATUS_ETR_FE_EVENT               ((uint32_t)0x00000008)
N#define TIMER_STATUS_BRK_EVENT                  ((uint32_t)0x00000010)
N#define TIMER_STATUS_CCR_CAP_EVENT_Msk          ((uint32_t)0x000001E0)
N#define TIMER_STATUS_CCR_REF_EVENT_Msk          ((uint32_t)0x00001E00)
N#define TIMER_STATUS_CCR1_CAP_EVENT_Msk         ((uint32_t)0x0001E000)
N
N/** @} */ /* End of group TIMER_STATUS */
N
N/** @defgroup Periph_TIMER_IE	TIMER IE
N  * @{
N  */ 
N
N/*-- TIMER_IE: Timer Interrupt Enable Register ---------------------*/
N/* Bit field positions: */
N#define TIMER_IE_CNT_ZERO_EVENT_IE_Pos          0
N#define TIMER_IE_CNT_ARR_EVENT_IE_Pos           1
N#define TIMER_IE_ETR_RE_EVENT_IE_Pos            2
N#define TIMER_IE_ETR_FE_EVENT_IE_Pos            3
N#define TIMER_IE_BRK_EVENT_IE_Pos               4
N#define TIMER_IE_CCR_CAP_EVENT_IE_Pos           5
N#define TIMER_IE_CCR_REF_EVENT_IE_Pos           9
N#define TIMER_IE_CCR1_CAP_EVENT_IE_Pos          13
N
N/* Bit field masks: */
N#define TIMER_IE_CNT_ZERO_EVENT_IE              ((uint32_t)0x00000001)
N#define TIMER_IE_CNT_ARR_EVENT_IE               ((uint32_t)0x00000002)
N#define TIMER_IE_ETR_RE_EVENT_IE                ((uint32_t)0x00000004)
N#define TIMER_IE_ETR_FE_EVENT_IE                ((uint32_t)0x00000008)
N#define TIMER_IE_BRK_EVENT_IE                   ((uint32_t)0x00000010)
N#define TIMER_IE_CCR_CAP_EVENT_IE_Msk           ((uint32_t)0x000001E0)
N#define TIMER_IE_CCR_REF_EVENT_IE_Msk           ((uint32_t)0x00001E00)
N#define TIMER_IE_CCR1_CAP_EVENT_IE_Msk          ((uint32_t)0x0001E000)
N
N/** @} */ /* End of group TIMER_IE */
N
N/** @defgroup Periph_TIMER_DMA_RE	TIMER DMA RE
N  * @{
N  */ 
N
N/*-- TIMER_DMA_RE: Timer DMA Request Enable Register ---------------*/
N/* Bit field positions: */
N#define TIMER_DMA_RE_CNT_ZERO_EVENT_RE_Pos      0
N#define TIMER_DMA_RE_CNT_ARR_EVENT_RE_Pos       1
N#define TIMER_DMA_RE_ETR_RE_EVENT_RE_Pos        2
N#define TIMER_DMA_RE_ETR_FE_EVENT_RE_Pos        3
N#define TIMER_DMA_RE_BRK_EVENT_RE_Pos           4
N#define TIMER_DMA_RE_CCR_CAP_EVENT_RE_Pos       5
N#define TIMER_DMA_RE_CCR_REF_EVENT_RE_Pos       9
N#define TIMER_DMA_RE_CCR1_CAP_EVENT_RE_Pos      13
N
N/* Bit field masks: */
N#define TIMER_DMA_RE_CNT_ZERO_EVENT_RE          ((uint32_t)0x00000001)
N#define TIMER_DMA_RE_CNT_ARR_EVENT_RE           ((uint32_t)0x00000002)
N#define TIMER_DMA_RE_ETR_RE_EVENT_RE            ((uint32_t)0x00000004)
N#define TIMER_DMA_RE_ETR_FE_EVENT_RE            ((uint32_t)0x00000008)
N#define TIMER_DMA_RE_BRK_EVENT_RE               ((uint32_t)0x00000010)
N#define TIMER_DMA_RE_CCR_CAP_EVENT_RE_Msk       ((uint32_t)0x000001E0)
N#define TIMER_DMA_RE_CCR_REF_EVENT_RE_Msk       ((uint32_t)0x00001E00)
N#define TIMER_DMA_RE_CCR1_CAP_EVENT_RE_Msk      ((uint32_t)0x0001E000)
N
N/** @} */ /* End of group TIMER_DMA_RE */
N
N/** @defgroup Periph_TIMER_CH_CNTRL2	TIMER CH CNTRL2
N  * @{
N  */ 
N
N/*-- TIMER_CH_CNTRL2: Timer Channel Control2 Register --------------*/
N/* Bit field positions: */
N#define TIMER_CH_CNTRL2_CHSEL1_Pos              0
N#define TIMER_CH_CNTRL2_CCR1_EN_Pos             2
N#define TIMER_CH_CNTRL2_CCRRLD_Pos              3
N
N/* Bit field masks: */
N#define TIMER_CH_CNTRL2_CHSEL1_Msk              ((uint32_t)0x00000003)
N#define TIMER_CH_CNTRL2_CCR1_EN                 ((uint32_t)0x00000004)
N#define TIMER_CH_CNTRL2_CCRRLD                  ((uint32_t)0x00000008)
N
N/** @} */ /* End of group TIMER_CH_CNTRL2 */
N
N/** @} */ /* End of group MDR32Fx_Periph_TIMER_Defines */
N
N/** @} */ /* End of group MDR32Fx_Periph_TIMER */
N
N/** @defgroup MDR32Fx_Periph_ADC ADC
N  * @{
N  */
N
N/** @defgroup MDR32Fx_Periph_ADC_Data_Structures Data Structures
N  * @{
N  */
N
N/* MDR_ADC_TypeDef structure */
Ntypedef struct
N{
N  __IO uint32_t ADC1_CFG;
X  volatile uint32_t ADC1_CFG;
N  __IO uint32_t ADC2_CFG;
X  volatile uint32_t ADC2_CFG;
N  __IO uint32_t ADC1_H_LEVEL;
X  volatile uint32_t ADC1_H_LEVEL;
N  __IO uint32_t ADC2_H_LEVEL;
X  volatile uint32_t ADC2_H_LEVEL;
N  __IO uint32_t ADC1_L_LEVEL;
X  volatile uint32_t ADC1_L_LEVEL;
N  __IO uint32_t ADC2_L_LEVEL;
X  volatile uint32_t ADC2_L_LEVEL;
N  __IO uint32_t ADC1_RESULT;
X  volatile uint32_t ADC1_RESULT;
N  __IO uint32_t ADC2_RESULT;
X  volatile uint32_t ADC2_RESULT;
N  __IO uint32_t ADC1_STATUS;
X  volatile uint32_t ADC1_STATUS;
N  __IO uint32_t ADC2_STATUS;
X  volatile uint32_t ADC2_STATUS;
N  __IO uint32_t ADC1_CHSEL;
X  volatile uint32_t ADC1_CHSEL;
N  __IO uint32_t ADC2_CHSEL;
X  volatile uint32_t ADC2_CHSEL;
N}MDR_ADC_TypeDef;
N
N/** @} */ /* End of group MDR32Fx_Periph_ADC_Data_Structures */
N
N/** @defgroup MDR32Fx_Periph_ADC_Defines Defines
N  * @{
N  */
N
N/** @defgroup Periph_ADC1_CFG	ADC1 CFG
N  * @{
N  */ 
N
N/*-- ADC1_CFG: ADC1 Configuration Register -------------------------*/
N/* Bit field positions: */
N#define ADC1_CFG_REG_ADON_Pos                   0
N#define ADC1_CFG_REG_GO_Pos                     1
N#define ADC1_CFG_REG_CLKS_Pos                   2
N#define ADC1_CFG_REG_SAMPLE_Pos                 3
N#define ADC1_CFG_REG_CHS_Pos                    4
N#define ADC1_CFG_REG_CHCH_Pos                   9
N#define ADC1_CFG_REG_RNGC_Pos                   10
N#define ADC1_CFG_M_REF_Pos                      11
N#define ADC1_CFG_REG_DIVCLK_Pos                 12
N#define ADC1_CFG_SYNC_CONVER_Pos                16
N#define ADC1_CFG_TS_EN_Pos                      17
N#define ADC1_CFG_TS_BUF_EN_Pos                  18
N#define ADC1_CFG_SEL_TS_Pos                     19
N#define ADC1_CFG_SEL_VREF_Pos                   20
N#define ADC1_CFG_TR_Pos                         21
N#define ADC1_CFG_DELAY_GO_Pos                   25
N#define ADC1_CFG_DELAY_ADC_Pos                  28
N
N/* Bit field masks: */
N#define ADC1_CFG_REG_ADON                       ((uint32_t)0x00000001)
N#define ADC1_CFG_REG_GO                         ((uint32_t)0x00000002)
N#define ADC1_CFG_REG_CLKS                       ((uint32_t)0x00000004)
N#define ADC1_CFG_REG_SAMPLE                     ((uint32_t)0x00000008)
N#define ADC1_CFG_REG_CHS_Msk                    ((uint32_t)0x000001F0)
N#define ADC1_CFG_REG_CHCH                       ((uint32_t)0x00000200)
N#define ADC1_CFG_REG_RNGC                       ((uint32_t)0x00000400)
N#define ADC1_CFG_M_REF                          ((uint32_t)0x00000800)
N#define ADC1_CFG_REG_DIVCLK_Msk                 ((uint32_t)0x0000F000)
N#define ADC1_CFG_SYNC_CONVER                    ((uint32_t)0x00010000)
N#define ADC1_CFG_TS_EN                          ((uint32_t)0x00020000)
N#define ADC1_CFG_TS_BUF_EN                      ((uint32_t)0x00040000)
N#define ADC1_CFG_SEL_TS                         ((uint32_t)0x00080000)
N#define ADC1_CFG_SEL_VREF                       ((uint32_t)0x00100000)
N#define ADC1_CFG_TR_Msk                         ((uint32_t)0x01E00000)
N#define ADC1_CFG_DELAY_GO_Msk                   ((uint32_t)0x0E000000)
N#define ADC1_CFG_DELAY_ADC_Msk                  ((uint32_t)0xF0000000)
N
N/** @} */ /* End of group ADC1_CFG */
N
N/** @defgroup Periph_ADC2_CFG	ADC2 CFG
N  * @{
N  */ 
N
N/*-- ADC2_CFG: ADC2 Configuration Register -------------------------*/
N/* Bit field positions: */
N#define ADC2_CFG_REG_ADON_Pos                   0
N#define ADC2_CFG_REG_GO_Pos                     1
N#define ADC2_CFG_REG_CLKS_Pos                   2
N#define ADC2_CFG_REG_SAMPLE_Pos                 3
N#define ADC2_CFG_REG_CHS_Pos                    4
N#define ADC2_CFG_REG_CHCH_Pos                   9
N#define ADC2_CFG_REG_RNGC_Pos                   10
N#define ADC2_CFG_M_REF_Pos                      11
N#define ADC2_CFG_REG_DIVCLK_Pos                 12
N#define ADC2_CFG_ADC1_OP_Pos                    17
N#define ADC2_CFG_ADC2_OP_Pos                    18
N#define ADC2_CFG_DELAY_GO_Pos                   25
N
N/* Bit field masks: */
N#define ADC2_CFG_REG_ADON                       ((uint32_t)0x00000001)
N#define ADC2_CFG_REG_GO                         ((uint32_t)0x00000002)
N#define ADC2_CFG_REG_CLKS                       ((uint32_t)0x00000004)
N#define ADC2_CFG_REG_SAMPLE                     ((uint32_t)0x00000008)
N#define ADC2_CFG_REG_CHS_Msk                    ((uint32_t)0x000001F0)
N#define ADC2_CFG_REG_CHCH                       ((uint32_t)0x00000200)
N#define ADC2_CFG_REG_RNGC                       ((uint32_t)0x00000400)
N#define ADC2_CFG_M_REF                          ((uint32_t)0x00000800)
N#define ADC2_CFG_REG_DIVCLK_Msk                 ((uint32_t)0x0000F000)
N#define ADC2_CFG_ADC1_OP                        ((uint32_t)0x00020000)
N#define ADC2_CFG_ADC2_OP                        ((uint32_t)0x00040000)
N#define ADC2_CFG_DELAY_GO_Msk                   ((uint32_t)0x0E000000)
N
N/** @} */ /* End of group ADC2_CFG */
N
N/** @defgroup Periph_ADC1_RESULT	ADC1 RESULT
N  * @{
N  */ 
N
N/*-- ADC1_RESULT: ADC1 Result Register -----------------------------*/
N/*-- ADC2_RESULT: ADC2 Result Register -----------------------------*/
N/* Bit field positions: */
N#define ADC_RESULT_Pos                          0
N#define ADC_RESULT_CHANNEL_Pos                  16
N
N/* Bit field masks: */
N#define ADC_RESULT_Msk                          ((uint32_t)0x00000FFF)
N#define ADC_RESULT_CHANNEL_Msk                  ((uint32_t)0x0FFF0000)
N
N/** @} */ /* End of group ADC1_RESULT */
N
N/** @defgroup Periph_ADC1_STATUS	ADC1 STATUS
N  * @{
N  */ 
N
N/*-- ADC1_STATUS: ADC1 Status Register -----------------------------*/
N/*-- ADC2_STATUS: ADC2 Status Register -----------------------------*/
N/* Bit field positions: */
N#define ADC_STATUS_FLG_REG_OVERWRITE_Pos        0
N#define ADC_STATUS_FLG_REG_AWOIFEN_Pos          1
N#define ADC_STATUS_FLG_REG_EOCIF_Pos            2
N#define ADC_STATUS_AWOIF_IE_Pos                 3
N#define ADC_STATUS_ECOIF_IE_Pos                 4
N
N/* Bit field masks: */
N#define ADC_STATUS_FLG_REG_OVERWRITE            ((uint32_t)0x00000001)
N#define ADC_STATUS_FLG_REG_AWOIFEN              ((uint32_t)0x00000002)
N#define ADC_STATUS_FLG_REG_EOCIF                ((uint32_t)0x00000004)
N#define ADC_STATUS_AWOIF_IE                     ((uint32_t)0x00000008)
N#define ADC_STATUS_ECOIF_IE                     ((uint32_t)0x00000010)
N
N/** @} */ /* End of group ADC1_STATUS */
N
N/** @} */ /* End of group MDR32Fx_Periph_ADC_Defines */
N
N/** @} */ /* End of group MDR32Fx_Periph_ADC */
N
N/** @defgroup MDR32Fx_Periph_DAC DAC
N  * @{
N  */
N
N/** @defgroup MDR32Fx_Periph_DAC_Data_Structures Data Structures
N  * @{
N  */
N
N/* MDR_DAC_TypeDef structure */
Ntypedef struct
N{
N  __IO uint32_t CFG;
X  volatile uint32_t CFG;
N  __IO uint32_t DAC1_DATA;
X  volatile uint32_t DAC1_DATA;
N  __IO uint32_t DAC2_DATA;
X  volatile uint32_t DAC2_DATA;
N}MDR_DAC_TypeDef;
N
N/** @} */ /* End of group MDR32Fx_Periph_DAC_Data_Structures */
N
N/** @defgroup MDR32Fx_Periph_DAC_Defines Defines
N  * @{
N  */
N
N/** @defgroup Periph_DAC_CFG	DAC CFG
N  * @{
N  */ 
N
N/*-- DAC_CFG: DAC Configuration Register ---------------------------*/
N/* Bit field positions: */
N#define DAC_CFG_M_REF0_Pos                      0
N#define DAC_CFG_M_REF1_Pos                      1
N#define DAC_CFG_ON_DAC0_Pos                     2
N#define DAC_CFG_ON_DAC1_Pos                     3
N#define DAC_CFG_SYNC_A_Pos                      4
N
N/* Bit field masks: */
N#define DAC_CFG_M_REF0                          ((uint32_t)0x00000001)
N#define DAC_CFG_M_REF1                          ((uint32_t)0x00000002)
N#define DAC_CFG_ON_DAC0                         ((uint32_t)0x00000004)
N#define DAC_CFG_ON_DAC1                         ((uint32_t)0x00000008)
N#define DAC_CFG_SYNC_A                          ((uint32_t)0x00000010)
N
N/** @} */ /* End of group DAC_CFG */
N
N/** @defgroup Periph_DAC1_DATA	DAC1 DATA
N  * @{
N  */ 
N
N/*-- DAC1_DATA: DAC1 Data Register ---------------------------------*/
N/* Bit field positions: */
N#define DAC1_DATA_DAC0DATA_Pos                  0
N#define DAC1_DATA_DAC1DATA_Pos                  16
N
N/* Bit field masks: */
N#define DAC1_DATA_DAC0DATA_Msk                  ((uint32_t)0x00000FFF)
N#define DAC1_DATA_DAC1DATA_Msk                  ((uint32_t)0x0FFF0000)
N
N/** @} */ /* End of group DAC1_DATA */
N
N/** @defgroup Periph_DAC2_DATA	DAC2 DATA
N  * @{
N  */ 
N
N/*-- DAC2_DATA: DAC2 Data Register ---------------------------------*/
N/* Bit field positions: */
N#define DAC2_DATA_DAC1DATA_Pos                  0
N#define DAC2_DATA_DAC0DATA_Pos                  16
N
N/* Bit field masks: */
N#define DAC2_DATA_DAC1DATA_Msk                  ((uint32_t)0x00000FFF)
N#define DAC2_DATA_DAC0DATA_Msk                  ((uint32_t)0x0FFF0000)
N
N/** @} */ /* End of group DAC2_DATA */
N
N/** @} */ /* End of group MDR32Fx_Periph_DAC_Defines */
N
N/** @} */ /* End of group MDR32Fx_Periph_DAC */
N
N/** @defgroup MDR32Fx_Periph_COMP COMP
N  * @{
N  */
N
N/** @defgroup MDR32Fx_Periph_COMP_Data_Structures Data Structures
N  * @{
N  */
N
N/* MDR_COMP_TypeDef structure */
Ntypedef struct
N{
N  __IO uint32_t CFG;
X  volatile uint32_t CFG;
N  __IO uint32_t RESULT;
X  volatile uint32_t RESULT;
N  __IO uint32_t RESULT_LATCH;
X  volatile uint32_t RESULT_LATCH;
N}MDR_COMP_TypeDef;
N
N/** @} */ /* End of group MDR32Fx_Periph_COMP_Data_Structures */
N
N/** @defgroup MDR32Fx_Periph_COMP_Defines Defines
N  * @{
N  */
N
N/** @defgroup Periph_COMP_CFG	COMP CFG
N  * @{
N  */ 
N
N/*-- COMP_CFG: COMP Configuration Register -------------------------*/
N/* Bit field positions: */
N#define COMP_CFG_ON_Pos                         0
N#define COMP_CFG_CVRR_Pos                       1
N#define COMP_CFG_CVRSS_Pos                      2
N#define COMP_CFG_CVREN_Pos                      3
N#define COMP_CFG_CVR_Pos                        4
N#define COMP_CFG_CREF_Pos                       8
N#define COMP_CFG_CCH_Pos                        9
N#define COMP_CFG_INV_Pos                        11
N#define COMP_CFG_READY_Pos                      12
N#define COMP_CFG_CMPIE_Pos                      13
N
N/* Bit field masks: */
N#define COMP_CFG_ON                             ((uint32_t)0x00000001)
N#define COMP_CFG_CVRR                           ((uint32_t)0x00000002)
N#define COMP_CFG_CVRSS                          ((uint32_t)0x00000004)
N#define COMP_CFG_CVREN                          ((uint32_t)0x00000008)
N#define COMP_CFG_CVR_Msk                        ((uint32_t)0x000000F0)
N#define COMP_CFG_CREF                           ((uint32_t)0x00000100)
N#define COMP_CFG_CCH_Msk                        ((uint32_t)0x00000600)
N#define COMP_CFG_INV                            ((uint32_t)0x00000800)
N#define COMP_CFG_READY                          ((uint32_t)0x00001000)
N#define COMP_CFG_CMPIE                          ((uint32_t)0x00002000)
N
N/** @} */ /* End of group COMP_CFG */
N
N/** @defgroup Periph_COMP_RESULT	COMP RESULT
N  * @{
N  */ 
N
N/*-- COMP_RESULT: COMP Result Register -----------------------------*/
N/* Bit field positions: */
N#define COMP_RESULT_RSLT_SY_Pos                 0
N#define COMP_RESULT_RSLT_AS_Pos                 1
N#define COMP_RESULT_RST_LCH_Pos                 2
N
N/* Bit field masks: */
N#define COMP_RESULT_RSLT_SY                     ((uint32_t)0x00000001)
N#define COMP_RESULT_RSLT_AS                     ((uint32_t)0x00000002)
N#define COMP_RESULT_RST_LCH                     ((uint32_t)0x00000004)
N
N/** @} */ /* End of group COMP_RESULT */
N
N/** @} */ /* End of group MDR32Fx_Periph_COMP_Defines */
N
N/** @} */ /* End of group MDR32Fx_Periph_COMP */
N
N/** @defgroup MDR32Fx_Periph_PORT PORT
N  * @{
N  */
N
N/** @defgroup MDR32Fx_Periph_PORT_Data_Structures Data Structures
N  * @{
N  */
N
N/* MDR_PORT_TypeDef structure */
Ntypedef struct
N{
N  __IO uint32_t RXTX;
X  volatile uint32_t RXTX;
N  __IO uint32_t OE;
X  volatile uint32_t OE;
N  __IO uint32_t FUNC;
X  volatile uint32_t FUNC;
N  __IO uint32_t ANALOG;
X  volatile uint32_t ANALOG;
N  __IO uint32_t PULL;
X  volatile uint32_t PULL;
N  __IO uint32_t PD;
X  volatile uint32_t PD;
N  __IO uint32_t PWR;
X  volatile uint32_t PWR;
N  __IO uint32_t GFEN;
X  volatile uint32_t GFEN;
N}MDR_PORT_TypeDef;
N
N/** @} */ /* End of group MDR32Fx_Periph_PORT_Data_Structures */
N
N/** @defgroup MDR32Fx_Periph_PORT_Defines Defines
N  * @{
N  */
N
N/** @defgroup Periph_PORT_FUNC	PORT FUNC
N  * @{
N  */ 
N
N/*-- PORT_FUNC: PORT Function Register -----------------------------*/
N/* Bit field positions: */
N#define PORT_FUNC_MODE0_Pos                     0
N#define PORT_FUNC_MODE1_Pos                     2
N#define PORT_FUNC_MODE2_Pos                     4
N#define PORT_FUNC_MODE3_Pos                     6
N#define PORT_FUNC_MODE4_Pos                     8
N#define PORT_FUNC_MODE5_Pos                     10
N#define PORT_FUNC_MODE6_Pos                     12
N#define PORT_FUNC_MODE7_Pos                     14
N#define PORT_FUNC_MODE8_Pos                     16
N#define PORT_FUNC_MODE9_Pos                     18
N#define PORT_FUNC_MODE10_Pos                    20
N#define PORT_FUNC_MODE11_Pos                    22
N#define PORT_FUNC_MODE12_Pos                    24
N#define PORT_FUNC_MODE13_Pos                    26
N#define PORT_FUNC_MODE14_Pos                    28
N#define PORT_FUNC_MODE15_Pos                    30
N
N/* Bit field masks: */
N#define PORT_FUNC_MODE0_Msk                     ((uint32_t)0x00000003)
N#define PORT_FUNC_MODE1_Msk                     ((uint32_t)0x0000000C)
N#define PORT_FUNC_MODE2_Msk                     ((uint32_t)0x00000030)
N#define PORT_FUNC_MODE3_Msk                     ((uint32_t)0x000000C0)
N#define PORT_FUNC_MODE4_Msk                     ((uint32_t)0x00000300)
N#define PORT_FUNC_MODE5_Msk                     ((uint32_t)0x00000C00)
N#define PORT_FUNC_MODE6_Msk                     ((uint32_t)0x00003000)
N#define PORT_FUNC_MODE7_Msk                     ((uint32_t)0x0000C000)
N#define PORT_FUNC_MODE8_Msk                     ((uint32_t)0x00030000)
N#define PORT_FUNC_MODE9_Msk                     ((uint32_t)0x000C0000)
N#define PORT_FUNC_MODE10_Msk                    ((uint32_t)0x00300000)
N#define PORT_FUNC_MODE11_Msk                    ((uint32_t)0x00C00000)
N#define PORT_FUNC_MODE12_Msk                    ((uint32_t)0x03000000)
N#define PORT_FUNC_MODE13_Msk                    ((uint32_t)0x0C000000)
N#define PORT_FUNC_MODE14_Msk                    ((uint32_t)0x30000000)
N#define PORT_FUNC_MODE15_Msk                    ((uint32_t)0xC0000000)
N
N/** @} */ /* End of group PORT_FUNC */
N
N/** @defgroup Periph_PORT_PULL	PORT PULL
N  * @{
N  */ 
N
N/*-- PORT_PULL: PORT Pull Up/Down Register -------------------------*/
N/* Bit field positions: */
N#define PORT_PULL_DOWN_Pos                      0
N#define PORT_PULL_UP_Pos                        16
N
N/* Bit field masks: */
N#define PORT_PULL_DOWN_Msk                      ((uint32_t)0x0000FFFF)
N#define PORT_PULL_UP_Msk                        ((uint32_t)0xFFFF0000)
N
N/** @} */ /* End of group PORT_PULL */
N
N/** @defgroup Periph_PORT_PD	PORT PD
N  * @{
N  */ 
N
N/*-- PORT_PD: PORT Driver Mode Register ----------------------------*/
N/* Bit field positions: */
N#define PORT_PD_Pos                             0
N#define PORT_PD_SHM_Pos                         16
N
N/* Bit field masks: */
N#define PORT_PD_Msk                             ((uint32_t)0x0000FFFF)
N#define PORT_PD_SHM_Msk                         ((uint32_t)0xFFFF0000)
N
N/** @} */ /* End of group PORT_PD */
N
N/** @defgroup Periph_PORT_PWR	PORT PWR
N  * @{
N  */ 
N
N/*-- PORT_PWR: PORT Power Register ---------------------------------*/
N/* Bit field positions: */
N#define PORT_PWR0_Pos                           0
N#define PORT_PWR1_Pos                           2
N#define PORT_PWR2_Pos                           4
N#define PORT_PWR3_Pos                           6
N#define PORT_PWR4_Pos                           8
N#define PORT_PWR5_Pos                           10
N#define PORT_PWR6_Pos                           12
N#define PORT_PWR7_Pos                           14
N#define PORT_PWR8_Pos                           16
N#define PORT_PWR9_Pos                           18
N#define PORT_PWR10_Pos                          20
N#define PORT_PWR11_Pos                          22
N#define PORT_PWR12_Pos                          24
N#define PORT_PWR13_Pos                          26
N#define PORT_PWR14_Pos                          28
N#define PORT_PWR15_Pos                          30
N
N/* Bit field masks: */
N#define PORT_PWR0_Msk                           ((uint32_t)0x00000003)
N#define PORT_PWR1_Msk                           ((uint32_t)0x0000000C)
N#define PORT_PWR2_Msk                           ((uint32_t)0x00000030)
N#define PORT_PWR3_Msk                           ((uint32_t)0x000000C0)
N#define PORT_PWR4_Msk                           ((uint32_t)0x00000300)
N#define PORT_PWR5_Msk                           ((uint32_t)0x00000C00)
N#define PORT_PWR6_Msk                           ((uint32_t)0x00003000)
N#define PORT_PWR7_Msk                           ((uint32_t)0x0000C000)
N#define PORT_PWR8_Msk                           ((uint32_t)0x00030000)
N#define PORT_PWR9_Msk                           ((uint32_t)0x000C0000)
N#define PORT_PWR10_Msk                          ((uint32_t)0x00300000)
N#define PORT_PWR11_Msk                          ((uint32_t)0x00C00000)
N#define PORT_PWR12_Msk                          ((uint32_t)0x03000000)
N#define PORT_PWR13_Msk                          ((uint32_t)0x0C000000)
N#define PORT_PWR14_Msk                          ((uint32_t)0x30000000)
N#define PORT_PWR15_Msk                          ((uint32_t)0xC0000000)
N
N/** @} */ /* End of group PORT_PWR */
N
N/** @} */ /* End of group MDR32Fx_Periph_PORT_Defines */
N
N/** @} */ /* End of group MDR32Fx_Periph_PORT */
N
N/** @defgroup MDR32Fx_Periph_BKP BKP
N  * @{
N  */
N
N/** @defgroup MDR32Fx_Periph_BKP_Data_Structures Data Structures
N  * @{
N  */
N
N/* MDR_BKP_TypeDef structure */
Ntypedef struct
N{
N  __IO uint32_t REG_00;
X  volatile uint32_t REG_00;
N  __IO uint32_t REG_01;
X  volatile uint32_t REG_01;
N  __IO uint32_t REG_02;
X  volatile uint32_t REG_02;
N  __IO uint32_t REG_03;
X  volatile uint32_t REG_03;
N  __IO uint32_t REG_04;
X  volatile uint32_t REG_04;
N  __IO uint32_t REG_05;
X  volatile uint32_t REG_05;
N  __IO uint32_t REG_06;
X  volatile uint32_t REG_06;
N  __IO uint32_t REG_07;
X  volatile uint32_t REG_07;
N  __IO uint32_t REG_08;
X  volatile uint32_t REG_08;
N  __IO uint32_t REG_09;
X  volatile uint32_t REG_09;
N  __IO uint32_t REG_0A;
X  volatile uint32_t REG_0A;
N  __IO uint32_t REG_0B;
X  volatile uint32_t REG_0B;
N  __IO uint32_t REG_0C;
X  volatile uint32_t REG_0C;
N  __IO uint32_t REG_0D;
X  volatile uint32_t REG_0D;
N  __IO uint32_t REG_0E;
X  volatile uint32_t REG_0E;
N  __IO uint32_t REG_0F;
X  volatile uint32_t REG_0F;
N  __IO uint32_t RTC_CNT;
X  volatile uint32_t RTC_CNT;
N  __IO uint32_t RTC_DIV;
X  volatile uint32_t RTC_DIV;
N  __IO uint32_t RTC_PRL;
X  volatile uint32_t RTC_PRL;
N  __IO uint32_t RTC_ALRM;
X  volatile uint32_t RTC_ALRM;
N  __IO uint32_t RTC_CS;
X  volatile uint32_t RTC_CS;
N}MDR_BKP_TypeDef;
N
N/** @} */ /* End of group MDR32Fx_Periph_BKP_Data_Structures */
N
N/** @defgroup MDR32Fx_Periph_BKP_Defines Defines
N  * @{
N  */
N
N/** @defgroup Periph_BKP_REG_0E	BKP REG 0E
N  * @{
N  */ 
N
N/*-- BKP_REG_0E: Backup Register 14 --------------------------------*/
N/* Bit field positions: */
N#define BKP_REG_0E_LOW_Pos                      0
N#define BKP_REG_0E_SELECTRI_Pos                 3
N#define BKP_REG_0E_JTAGA_Pos                    6
N#define BKP_REG_0E_JTAGB_Pos                    7
N#define BKP_REG_0E_TRIM_Pos                     8
N#define BKP_REG_0E_FPOR_Pos                     11
N#define BKP_REG_0E_BKP_REG_Pos                  12
N
N/* Bit field masks: */
N#define BKP_REG_0E_LOW_Msk                      ((uint32_t)0x00000007)
N#define BKP_REG_0E_SELECTRI_Msk                 ((uint32_t)0x00000038)
N#define BKP_REG_0E_JTAGA                        ((uint32_t)0x00000040)
N#define BKP_REG_0E_JTAGB                        ((uint32_t)0x00000080)
N#define BKP_REG_0E_TRIM_Msk                     ((uint32_t)0x00000700)
N#define BKP_REG_0E_FPOR                         ((uint32_t)0x00000800)
N#define BKP_REG_0E_BKP_REG_Msk                  ((uint32_t)0xFFFFF000)
N
N/** @} */ /* End of group BKP_REG_0E */
N
N/** @defgroup Periph_BKP_REG_0F	BKP REG 0F
N  * @{
N  */ 
N
N/*-- BKP_REG_0F: Backup Register 15 --------------------------------*/
N/* Bit field positions: */
N#define BKP_REG_0F_LSE_ON_Pos                   0
N#define BKP_REG_0F_LSE_BYP_Pos                  1
N#define BKP_REG_0F_RTC_SEL_Pos                  2
N#define BKP_REG_0F_RTC_EN_Pos                   4
N#define BKP_REG_0F_CAL_Pos                      5
N#define BKP_REG_0F_LSE_RDY_Pos                  13
N#define BKP_REG_0F_BKP_REG_Pos                  14
N#define BKP_REG_0F_LSI_ON_Pos                   15
N#define BKP_REG_0F_LSI_TRIM_Pos                 16
N#define BKP_REG_0F_LSI_RDY_Pos                  21
N#define BKP_REG_0F_HSI_ON_Pos                   22
N#define BKP_REG_0F_HSI_RDY_Pos                  23
N#define BKP_REG_0F_HSI_TRIM_Pos                 24
N#define BKP_REG_0F_STANDBY_Pos                  30
N#define BKP_REG_0F_RTC_RESET_Pos                31
N
N/* Bit field masks: */
N#define BKP_REG_0F_LSE_ON                       ((uint32_t)0x00000001)
N#define BKP_REG_0F_LSE_BYP                      ((uint32_t)0x00000002)
N#define BKP_REG_0F_RTC_SEL_Msk                  ((uint32_t)0x0000000C)
N#define BKP_REG_0F_RTC_EN                       ((uint32_t)0x00000010)
N#define BKP_REG_0F_CAL_Msk                      ((uint32_t)0x00001FE0)
N#define BKP_REG_0F_LSE_RDY                      ((uint32_t)0x00002000)
N#define BKP_REG_0F_BKP_REG                      ((uint32_t)0x00004000)
N#define BKP_REG_0F_LSI_ON                       ((uint32_t)0x00008000)
N#define BKP_REG_0F_LSI_TRIM_Msk                 ((uint32_t)0x001F0000)
N#define BKP_REG_0F_LSI_RDY                      ((uint32_t)0x00200000)
N#define BKP_REG_0F_HSI_ON                       ((uint32_t)0x00400000)
N#define BKP_REG_0F_HSI_RDY                      ((uint32_t)0x00800000)
N#define BKP_REG_0F_HSI_TRIM_Msk                 ((uint32_t)0x3F000000)
N#define BKP_REG_0F_STANDBY                      ((uint32_t)0x40000000)
N#define BKP_REG_0F_RTC_RESET                    ((uint32_t)0x80000000)
N
N/** @} */ /* End of group BKP_REG_0F */
N
N/** @defgroup Periph_BKP_RTC_CS	BKP RTC CS
N  * @{
N  */ 
N
N/*-- BKP_RTC_CS: Backup Realtime clock Register --------------------*/
N/* Bit field positions: */
N#define BKP_RTC_CS_OWF_Pos                      0
N#define BKP_RTC_CS_SECF_Pos                     1
N#define BKP_RTC_CS_ALRF_Pos                     2
N#define BKP_RTC_CS_OWF_IE_Pos                   3
N#define BKP_RTC_CS_SECF_IE_Pos                  4
N#define BKP_RTC_CS_ALRF_IE_Pos                  5
N#define BKP_RTC_CS_WEC_Pos                      6
N
N/* Bit field masks: */
N#define BKP_RTC_CS_OWF                          ((uint32_t)0x00000001)
N#define BKP_RTC_CS_SECF                         ((uint32_t)0x00000002)
N#define BKP_RTC_CS_ALRF                         ((uint32_t)0x00000004)
N#define BKP_RTC_CS_OWF_IE                       ((uint32_t)0x00000008)
N#define BKP_RTC_CS_SECF_IE                      ((uint32_t)0x00000010)
N#define BKP_RTC_CS_ALRF_IE                      ((uint32_t)0x00000020)
N#define BKP_RTC_CS_WEC                          ((uint32_t)0x00000040)
N
N/** @} */ /* End of group BKP_RTC_CS */
N
N/** @} */ /* End of group MDR32Fx_Periph_BKP_Defines */
N
N/** @} */ /* End of group MDR32Fx_Periph_BKP */
N
N/** @defgroup MDR32Fx_Periph_EBC EBC
N  * @{
N  */
N
N/** @defgroup MDR32Fx_Periph_EBC_Data_Structures Data Structures
N  * @{
N  */
N
N/* MDR_EBC_TypeDef structure */
Ntypedef struct
N{
N       uint32_t RESERVED0[20];
N  __IO uint32_t NAND_CYCLES;
X  volatile uint32_t NAND_CYCLES;
N  __IO uint32_t CONTROL;
X  volatile uint32_t CONTROL;
N#if defined (USE_MDR1986VE94)
X#if 0L
S  __IO uint32_t MEM_REGION[4];
N#endif
N}MDR_EBC_TypeDef;
N
N/** @} */ /* End of group MDR32Fx_Periph_EBC_Data_Structures */
N
N/** @defgroup MDR32Fx_Periph_EBC_Defines Defines
N  * @{
N  */
N
N/** @defgroup Periph_EBC_NAND_CYCLES	EBC NAND CYCLES
N  * @{
N  */ 
N
N/*-- EBC_NAND_CYCLES: EBC NAND Timing Register ---------------------*/
N/* Bit field positions: */
N#define EBC_NAND_CYCLES_TRC_Pos                 0
N#define EBC_NAND_CYCLES_TWC_Pos                 4
N#define EBC_NAND_CYCLES_TREA_Pos                8
N#define EBC_NAND_CYCLES_TWP_Pos                 12
N#define EBC_NAND_CYCLES_TWHR_Pos                16
N#define EBC_NAND_CYCLES_TALEA_Pos               20
N#define EBC_NAND_CYCLES_TRR_Pos                 24
N
N/* Bit field masks: */
N#define EBC_NAND_CYCLES_TRC_Msk                 ((uint32_t)0x0000000F)
N#define EBC_NAND_CYCLES_TWC_Msk                 ((uint32_t)0x000000F0)
N#define EBC_NAND_CYCLES_TREA_Msk                ((uint32_t)0x00000F00)
N#define EBC_NAND_CYCLES_TWP_Msk                 ((uint32_t)0x0000F000)
N#define EBC_NAND_CYCLES_TWHR_Msk                ((uint32_t)0x000F0000)
N#define EBC_NAND_CYCLES_TALEA_Msk               ((uint32_t)0x00F00000)
N#define EBC_NAND_CYCLES_TRR_Msk                 ((uint32_t)0x0F000000)
N
N/** @} */ /* End of group EBC_NAND_CYCLES */
N
N/** @defgroup Periph_EBC_CONTROL	EBC CONTROL
N  * @{
N  */ 
N
N/*-- EBC_CONTROL: EBC Control Register -----------------------------*/
N/* Bit field positions: */
N#define EBC_CONTROL_ROM_Pos                     0
N#define EBC_CONTROL_RAM_Pos                     1
N#define EBC_CONTROL_NAND_Pos                    2
N#define EBC_CONTROL_CPOL_Pos                    3
N#define EBC_CONTROL_BUSY_Pos                    7
N#define EBC_CONTROL_WAIT_STATE_Pos              12
N#if defined (USE_MDR1986VE94)
X#if 0L
S	#define EBC_CONTROL_FS_RDY_Pos					16
S	#define EBC_CONTROL_FF_RDY_Pos					17
N#endif
N
N/* Bit field masks: */
N#define EBC_CONTROL_ROM                         ((uint32_t)0x00000001)
N#define EBC_CONTROL_RAM                         ((uint32_t)0x00000002)
N#define EBC_CONTROL_NAND                        ((uint32_t)0x00000004)
N#define EBC_CONTROL_CPOL                        ((uint32_t)0x00000008)
N#define EBC_CONTROL_BUSY                        ((uint32_t)0x00000080)
N#define EBC_CONTROL_WAIT_STATE_Msk              ((uint32_t)0x0000F000)
N#if defined (USE_MDR1986VE94)
X#if 0L
S	#define EBC_CONTROL_FS_RDY					((uint32_t)0x00010000)
S	#define EBC_CONTROL_FF_RDY					((uint32_t)0x00020000)
N#endif
N
N
N/** @} */ /* End of group EBC_CONTROL */
N
N#if defined (USE_MDR1986VE94)
X#if 0L
S
S/** @defgroup Periph_EBC_RAM_CYCLESx	EBC RAM CYCLESx
S  * @{
S  */
S
S/*-- EBC_RAM_CYCLESx: Register customization options exchange with RAM -------*/
S/* Bit field positions: */
S#define EBC_RAM_CYCLES_ENABLE_TUNE_Pos			0
S#define EBC_RAM_CYCLES_WS_ACTIVE_Pos			1
S#define EBC_RAM_CYCLES_WS_SETUP_Pos				8
S#define EBC_RAM_CYCLES_WS_HOLD_Pos				11
S#define EBC_RAM_CYCLES_USE_READY_Pos			14
S
S/* Bit field masks: */
S#define EBC_RAM_CYCLES_ENABLE_TUNE				((uint32_t)0x00000001)
S#define EBC_RAM_CYCLES_WS_ACTIVE_Msk			((uint32_t)0x000000FE)
S#define EBC_RAM_CYCLES_WS_SETUP_Msk				((uint32_t)0x00000700)
S#define EBC_RAM_CYCLES_WS_HOLD_Msk				((uint32_t)0x00003200)
S#define EBC_RAM_CYCLES_USE_READY				((uint32_t)0x00004000)
S
S/** @} */ /* End of group EBC_RAM_CYCLESx */
N#endif
N
N/** @} */ /* End of group MDR32Fx_Periph_EBC_Defines */
N
N/** @} */ /* End of group MDR32Fx_Periph_EBC */
N
N/** @} */ /* End of group __MDR32Fx_Peripheral_Units */
N
N
N/** @defgroup __Peripheral_Memory_Map Peripheral Memory Map
N  * @{
N  */
N
N#define MDR_CAN1_BASE       (0x40000000)
N#define MDR_CAN2_BASE       (0x40008000)
N#define MDR_USB_BASE        (0x40010000)
N#define MDR_EEPROM_BASE     (0x40018000)
N#define MDR_RST_CLK_BASE    (0x40020000)
N#define MDR_DMA_BASE        (0x40028000)
N#define MDR_UART1_BASE      (0x40030000)
N#define MDR_UART2_BASE      (0x40038000)
N#define MDR_SSP1_BASE       (0x40040000)
N#define MDR_I2C_BASE        (0x40050000)
N#define MDR_POWER_BASE      (0x40058000)
N#define MDR_WWDG_BASE       (0x40060000)
N#define MDR_IWDG_BASE       (0x40068000)
N#define MDR_TIMER1_BASE     (0x40070000)
N#define MDR_TIMER2_BASE     (0x40078000)
N#define MDR_TIMER3_BASE     (0x40080000)
N#define MDR_ADC_BASE        (0x40088000)
N#define MDR_DAC_BASE        (0x40090000)
N#define MDR_COMP_BASE       (0x40098000)
N#define MDR_SSP2_BASE       (0x400A0000)
N#define MDR_PORTA_BASE      (0x400A8000)
N#define MDR_PORTB_BASE      (0x400B0000)
N#define MDR_PORTC_BASE      (0x400B8000)
N#define MDR_PORTD_BASE      (0x400C0000)
N#define MDR_PORTE_BASE      (0x400C8000)
N#define MDR_BKP_BASE        (0x400D8000)
N#define MDR_PORTF_BASE      (0x400E8000)
N#define MDR_EBC_BASE        (0x400F0000)
N
N/** @} */ /* End of group __Peripheral_Memory_Map */
N
N/** @defgroup __Peripheral_declaration Peripheral declaration
N  * @{
N  */
N
N#define MDR_CAN1            ((MDR_CAN_TypeDef     *) MDR_CAN1_BASE)
N#define MDR_CAN2            ((MDR_CAN_TypeDef     *) MDR_CAN2_BASE)
N#define MDR_USB             ((MDR_USB_TypeDef     *) MDR_USB_BASE)
N#define MDR_EEPROM          ((MDR_EEPROM_TypeDef  *) MDR_EEPROM_BASE)
N#define MDR_RST_CLK         ((MDR_RST_CLK_TypeDef *) MDR_RST_CLK_BASE)
N#define MDR_DMA             ((MDR_DMA_TypeDef     *) MDR_DMA_BASE)
N#define MDR_UART1           ((MDR_UART_TypeDef    *) MDR_UART1_BASE)
N#define MDR_UART2           ((MDR_UART_TypeDef    *) MDR_UART2_BASE)
N#define MDR_SSP1            ((MDR_SSP_TypeDef     *) MDR_SSP1_BASE)
N#define MDR_I2C             ((MDR_I2C_TypeDef     *) MDR_I2C_BASE)
N#define MDR_POWER           ((MDR_POWER_TypeDef   *) MDR_POWER_BASE)
N#define MDR_WWDG            ((MDR_WWDG_TypeDef    *) MDR_WWDG_BASE)
N#define MDR_IWDG            ((MDR_IWDG_TypeDef    *) MDR_IWDG_BASE)
N#define MDR_TIMER1          ((MDR_TIMER_TypeDef   *) MDR_TIMER1_BASE)
N#define MDR_TIMER2          ((MDR_TIMER_TypeDef   *) MDR_TIMER2_BASE)
N#define MDR_TIMER3          ((MDR_TIMER_TypeDef   *) MDR_TIMER3_BASE)
N#define MDR_ADC             ((MDR_ADC_TypeDef     *) MDR_ADC_BASE)
N#define MDR_DAC             ((MDR_DAC_TypeDef     *) MDR_DAC_BASE)
N#define MDR_COMP            ((MDR_COMP_TypeDef    *) MDR_COMP_BASE)
N#define MDR_SSP2            ((MDR_SSP_TypeDef     *) MDR_SSP2_BASE)
N#define MDR_PORTA           ((MDR_PORT_TypeDef    *) MDR_PORTA_BASE)
N#define MDR_PORTB           ((MDR_PORT_TypeDef    *) MDR_PORTB_BASE)
N#define MDR_PORTC           ((MDR_PORT_TypeDef    *) MDR_PORTC_BASE)
N#define MDR_PORTD           ((MDR_PORT_TypeDef    *) MDR_PORTD_BASE)
N#define MDR_PORTE           ((MDR_PORT_TypeDef    *) MDR_PORTE_BASE)
N#define MDR_BKP             ((MDR_BKP_TypeDef     *) MDR_BKP_BASE)
N#define MDR_PORTF           ((MDR_PORT_TypeDef    *) MDR_PORTF_BASE)
N#define MDR_EBC             ((MDR_EBC_TypeDef     *) MDR_EBC_BASE)
N
N/** @} */ /* End of group __Peripheral_declaration */
N
N#ifdef __cplusplus
S}
N#endif
N
N/** @} */ /* End of group __MDR32Fx_Peripheral */
N
N/** @} */ /* End of group MDR1986VE9x */
N
N/** @} */ /* End of group __CMSIS */
N
N#endif /* __MDR32FX_H */
N
N/*
N*
N* END OF FILE MDR32Fx.h */
L 66 ".\RTE\Device\MDR1986BE92\MDR32F9Qx_config.h" 2
N#elif defined (USE_MDR1986VE1T)
S	#include "MDR1986VE1T.h"
S#elif defined ( USE_MDR1986VE3 )
S	#include "MDR1986VE3.h"
S#elif defined ( USE_MDR1901VC1T )
S	#include "MDR1901VC1T.h"
S#elif defined (USE_MDR1986BE4)
S	#include "MDR1986BE4.h"
N#endif
N
N/* Uncomment the line(s) below to define used JTAG port(s). Leave all commented
N * if there is no JTAG ports */
N#if (defined(USE_MDR1986VE9x) || defined (USE_MDR1901VC1T))
X#if (1L || 0L)
N //#define USE_JTAG_A 
N #define USE_JTAG_B 
N#endif
N
N/* Target system parameters */
N/* RST_CLK generators frequencies in HZ */
N#define HSI_Value       ((uint32_t)8000000)
N#define HSE_Value       ((uint32_t)8000000)
N#define HSE2_Value      ((uint32_t)25000000)
N#define LSI_Value       ((uint32_t)40000)
N#define LSE_Value       ((uint32_t)32768)
N
N/* RST_CLK frequencies startup timeouts settings */
N#define HSEonTimeOut    ((uint16_t)0x0600)
N#define HSE2onTimeOut	((uint16_t)0x8000)
N#define LSEonTimeOut    ((uint16_t)0x0600)
N#define HSIonTimeOut    ((uint16_t)0x0600)
N#define LSIonTimeOut    ((uint16_t)0x0600)
N#define PLLCPUonTimeOut ((uint16_t)0x0600)
N#define PLLUSBonTimeOut ((uint16_t)0x0600)
N#define PLLDSPonTimeOut ((uint16_t)0x0600)
N
N#define FLASH_PROG_FREQ_MHZ     (8.0)
N/* Use debug uart */
N//#define _USE_DEBUG_UART_
N
N#if defined (_USE_DEBUG_UART_)
X#if 0L
S
S#if defined (USE_MDR1986VE3)
S	#define DEBUG_UART 					MDR_UART2
S	#define DEBUG_UART_PORT				MDR_PORTD
S	#define DEBUG_UART_PINS				(PORT_Pin_13 | PORT_Pin_14)
S	#define DEBUG_UART_PINS_FUNCTION	PORT_FUNC_MAIN
S	#define DEBUG_BAUD_RATE				115200
S#elif defined (USE_MDR1986VE1T)
S	#define DEBUG_UART 					MDR_UART1
S	#define DEBUG_UART_PORT				MDR_PORTC
S	#define DEBUG_UART_PINS				(PORT_Pin_3 | PORT_Pin_4)
S	#define DEBUG_UART_PINS_FUNCTION	PORT_FUNC_MAIN
S	#define DEBUG_BAUD_RATE				115200
S#elif defined (USE_MDR1986VE9x)
S	#define DEBUG_UART 					MDR_UART2
S	#define DEBUG_UART_PORT				MDR_PORTF
S	#define DEBUG_UART_PINS				(PORT_Pin_0 | PORT_Pin_1)
S	#define DEBUG_UART_PINS_FUNCTION	PORT_FUNC_OVERRID
S	#define DEBUG_BAUD_RATE				115200
S#elif defined (USE_MDR1901VC1T)
S	#define DEBUG_UART 			MDR_UART3
S	#define DEBUG_UART_PORT			MDR_PORTF
S	#define DEBUG_UART_PINS			(PORT_Pin_0 | PORT_Pin_1)
S	#define DEBUG_UART_PINS_FUNCTION	PORT_FUNC_ALTER
S	#define DEBUG_BAUD_RATE			115200
S#endif
S
S//#define PRINTF_FORMAT_FULL
S//#define PRINTF_FORMAT_LARGE
S
N#endif /* #if defined (_USE_DEBUG_UART_) */
N
N#if defined ( USE_MDR1986VE3 ) || defined ( USE_MDR1986VE1T )
X#if 0L || 0L
S	#define MIL_STD_1553_TERMINAL_ADDRESS	0x01
N#endif /* #if defined ( USE_MDR1986VE3 ) || defined ( USE_MDR1986VE1T ) */
N
N/* RTC configuration parameters */
N#define RTC_CalibratorValue   	0
N#define RTC_PRESCALER_VALUE		32768
N
N/* DMA configuration parameters */
N/* Number of DMA channels to use */
N#define DMA_Channels_Number   32          /* This parameter is in range 1..32 */
N
N/* Alternate Control Data Structure Usage */
N/* This parameter can be a value of:
N    0 = DMA_ALternateDataDisabled;
N    1 = DMA_ALternateDataEnabled; */
N/*#define DMA_AlternateData   0 */          /* DMA_AlternateDataDisabled */
N#define DMA_AlternateData   1             /* DMA_AlternateDataEnabled */
N
N/* USB configuration parameters ----------------------------------------------*/
N/* Uncomment one of the lines below to select the Device Class. Leave all commented
N * if the desired device class is not currently supported by USB library */
N#define USB_DEVICE_CLASS  USB_DEVICE_CLASS_CDC
N
N/* USB Device management */
N/* Uncomment the line below to enable appropriate functionality. */
N/* #define USB_REMOTE_WAKEUP_SUPPORTED */
N/* #define USB_SELF_POWERED_SUPPORTED */
N
N/* Uncomment the line below to let the library provide USB interrupt handler.
N * Leave this line commented if you are willing to implement the handler yourself. */
N#define USB_INT_HANDLE_REQUIRED
N
N/* USB CDC management */
N/* Uncomment the lines below to enable appropriate functionality. */
N/* #define USB_CDC_STATE_REPORTING_SUPPORTED 	*/
N/* #define USB_CDC_ENCAPSULATION_SUPPORTED 	*/
N/* #define USB_CDC_COMM_FEATURE_SUPPORTED 	*/
N#define USB_CDC_LINE_CODING_SUPPORTED 	
N/* #define USB_CDC_CONTROL_LINE_STATE_SUPPORTED */
N/* #define USB_CDC_LINE_BREAK_SUPPORTED 	*/
N
N/* VCOM Echo example flags */
N
N/* Uncomment USB_VCOM_SYNC to enable "reliable delivery" mode: no new data
N * would be received (EP3 will reply NAK) until all previous data is sent
N * to host. */
N//#define USB_VCOM_SYNC
N
N/* Uncomment USB_DEBUG_PROTO to utilize the ring buffer for received setup
N * packets and send/receive byte counters (for debug purposes). */
N//#define USB_DEBUG_PROTO
N
N/* Known errors workaround control -------------------------------------------*/
N/* MDR32F9Qx Series Errata Notice, Error 0002 */
N#define WORKAROUND_MDR32F9QX_ERROR_0002
N
N/* Parameter run-time check support ------------------------------------------*/
N
N/* Select one of the following values of USE_ASSERT_INFO macro to control
N   parameter checking in the Standard Peripheral Library drivers:
N     0 - no parameter checks ("assert_param" macro is disabled);
N     1 - check enabled, source file ID and line number are available;
N     2 - check enabled, source file ID, line number and checking expression
N         (as string) are available (increased code size).
N*/
N #define USE_ASSERT_INFO    0 
N/* #define USE_ASSERT_INFO    1 */
N/* #define USE_ASSERT_INFO    2 */
N
N/**
N  * @brief  The assert_param macro is used for function's parameters check.
N  * @param  expr: If expr is false, it calls assert_failed user's function
N  *   which gets the source file ID (see MDR32F9Qx_lib.h), line number and
N  *   expression text (if USE_ASSERT_INFO == 2) of the call that failed. That
N  *   function should not return. If expr is true, nothing is done.
N  * @retval None
N  */
N#if (USE_ASSERT_INFO == 0)
X#if (0 == 0)
N  #define assert_param(expr) ((void)0)
N#elif (USE_ASSERT_INFO == 1)
S  #define assert_param(expr) ((expr) ? (void)0 : assert_failed(ASSERT_INFO_FILE_ID, __LINE__))
S  void assert_failed(uint32_t file_id, uint32_t line);
S#elif (USE_ASSERT_INFO == 2)
S  #define assert_param(expr) ((expr) ? (void)0 : assert_failed(ASSERT_INFO_FILE_ID, __LINE__, #expr))
S  void assert_failed(uint32_t file_id, uint32_t line, const uint8_t* expr);
S#else
S  #error "Unsupported USE_ASSERT_INFO level"
N#endif /* USE_ASSERT_INFO */
N
N#if defined (__ICCARM__)
X#if 0L
S	#define __attribute__(name_section)
S	#if defined (USE_MDR1986VE3) || defined (USE_MDR1986VE1T)
S		#pragma section = "EXECUTABLE_MEMORY_SECTION"
S		#define IAR_SECTION(section) @ section
S	#elif defined (USE_MDR1986VE9x)
S		#define IAR_SECTION(section)
S	#endif
N#endif
N#if defined (__CMCARM__)
X#if 0L
S		#define __attribute__(name_section)
S		#define IAR_SECTION(section)
N#endif
N
N#if defined (__CC_ARM)
X#if 1L
N	#define IAR_SECTION(section)
N#endif
N
N#endif /* __MDR32F9Qx_CONFIG_H */
N
N/******************* (C) COPYRIGHT 2011 Milandr *********************************
N*
N* END OF FILE MDR32F9Qx_config.h */
L 15 "C:\Keil_v5\ARM\PACK\Keil\MDR1986BExx\1.5.3\Libraries\MDR32F9Qx_StdPeriph_Driver\inc\MDR32F9Qx_timer.h" 2
N#include "MDR32F9Qx_lib.h"
L 1 "C:\Keil_v5\ARM\PACK\Keil\MDR1986BExx\1.5.3\Libraries\MDR32F9Qx_StdPeriph_Driver\inc\MDR32F9Qx_lib.h" 1
N/**
N  * FILE MDR32F9Qx_lib.h
N  */
N
N/* Define to prevent recursive inclusion -------------------------------------*/
N#ifndef __MDR32F9QX_LIB_H
N#define __MDR32F9QX_LIB_H
N
N#ifdef __cplusplus
Sextern "C" {
N#endif
N
N#define FILEID__MDR32F9X_CAN_C					1
N#define FILEID__MDR32F9X_USB_C					2
N#define FILEID__MDR32F9X_EEPROM_C				3
N#define FILEID__MDR32F9X_RST_CLK_C				4
N#define FILEID__MDR32F9X_DMA_C					5
N#define FILEID__MDR32F9X_UART_C					6
N#define FILEID__MDR32F9X_SSP_C					7
N#define FILEID__MDR32F9X_I2C_C					8
N#define FILEID__MDR32F9X_POWER_C				9
N#define FILEID__MDR32F9X_WWDG_C					10
N#define FILEID__MDR32F9X_IWDG_C					11
N#define FILEID__MDR32F9X_TIMER_C				12
N#define FILEID__MDR32F9X_ADC_C					13
N#define FILEID__MDR32F9X_DAC_C					14
N#define FILEID__MDR32F9X_COMP_C					15
N#define FILEID__MDR32F9X_PORT_C					16
N#define FILEID__MDR32F9X_BKP_C					17
N#define FILEID__MDR32F9X_EBC_C					18
N#define FILEID__MDR32F9X_USB_DEVICE_C			19
N#define FILEID__MDR32F9X_USB_CDC_C				20
N#define FILEID__MDR32F9X_MIL_STD1553_C			21
N#define FILEID__MDR32F9X_ARINC429R_C			22
N#define FILEID__MDR32F9X_ARINC429T_C			23
N#define FILEID__MDR32F9X_ETH_C					24
N#define FILEID__MDR32F9Qx_AUDIO_C				25
N#define FILEID__MDR32F9Qx_KEYPAD_C				26
N#define FILEID__MDR32F9Qx_LED_C					27
N#define FILEID__MDR32F9Qx_SDIO_C				28
N#define FILEID__MDR32F9Qx_DSP_C					29
N
N#define  FILEID__USER_LO                    	100
N
N/* Supported USB Device Classes */
N#define USB_DEVICE_CLASS_CDC 2
N
N#ifdef __cplusplus
S} // extern "C" block end
N#endif
N
N#endif /* __MDR32F9QX_LIB_H */
N
N/*
N*
N* END OF FILE MDR32F9Qx_lib.h */
L 16 "C:\Keil_v5\ARM\PACK\Keil\MDR1986BExx\1.5.3\Libraries\MDR32F9Qx_StdPeriph_Driver\inc\MDR32F9Qx_timer.h" 2
N
N/** @addtogroup __MDR32F9Qx_StdPeriph_Driver MDR32F9Qx Standard Peripherial Driver
N  * @{
N  */
N
N/** @addtogroup TIMER
N  * @{
N  */
N
N/** @defgroup TIMER_Exported_Types TIMER Exported Types
N  * @{
N  */
N
N/**
N  * @brief  TIMER Counter Init structure definition
N  */
N
Ntypedef struct {
N
N#if defined(USE_MDR1986VE9x) || defined (USE_MDR1901VC1T) /* For Cortex M3 */
X#if 1L || 0L  
N	uint16_t TIMER_IniCounter; 		 /*!< Specifies the initial counter value.
N	 	 	 	 	 	 	 	     	  This parameter can be a number between 0x0000 and 0xFFFF. */
N#elif ((defined (USE_MDR1986VE3)) || (defined (USE_MDR1986VE1T)))
S	uint32_t TIMER_IniCounter;		/*!< Specifies the initial counter value.
S									 	 This parameter can be a number between 0x0000 and 0xFFFFFFFF. */
N#endif // #elif ((defined (USE_MDR1986VE3)) || (defined (USE_MDR1986VE1T)))
N
N	uint16_t TIMER_Prescaler; 		 /*!< Specifies the prescaler value used to divide the TIMER clock.
N	 	 	 	 	 	 	 	   	 	  This parameter can be a number between 0x0000 and 0xFFFF.
N	 	 	 	 	 	 	 	   	 	  CLK = TIMER_CLK/(TIMER_Prescaler + 1) */
N
N#if defined(USE_MDR1986VE9x) || defined (USE_MDR1901VC1T) /* For Cortex M3 */
X#if 1L || 0L  
N	uint16_t TIMER_Period; 			 /*!< Specifies the period value to be loaded into the
N	 	 	 	 	 	 	 	 	 	  Auto-Reload Register (ARR) at the next update event.
N	 	 	 	 	 	 	 	 	 	  This parameter must be a number between 0x0000 and 0xFFFF.  */
N#elif ((defined (USE_MDR1986VE3)) || (defined (USE_MDR1986VE1T))) /* For Cortex M1 */
S	uint32_t TIMER_Period;			/*!< Specifies the period value to be loaded into the
S										 Auto-Reload Register (ARR) at the next update event.
S										 This parameter must be a number between 0x0000 and 0xFFFFFFFF.  */
N#endif // #elif ((defined (USE_MDR1986VE3)) || (defined (USE_MDR1986VE1T))) /* For Cortex M1 */
N
N	uint16_t TIMER_CounterMode;		 /*!< Specifies the counter mode.
N	 	 	 	 	 	 	 	 	 	  This parameter can be a value of @ref TIMER_Counter_Mode */
N
N	uint16_t TIMER_CounterDirection; /*!< Specifies the counter direction.
N	 	 	 	 	 	 	 	 	 	  This parameter can be a value of @ref TIMER_Counter_Direction */
N
N	uint16_t TIMER_EventSource; 	/*!< Specifies the Counter Event source.
N	 	 	 	 	 	 	 	 	 	 This parameter can be a value of @ref TIMER_Event_Source */
N
N	uint16_t TIMER_FilterSampling;  /*!< Specifies the filter sampling clock (FDTS).
N	 	 	 	 	 	 	 	 	 	 This parameter can be a value of @ref TIMER_Filter_Sampling */
N
N	uint16_t TIMER_ARR_UpdateMode; 	/*!< Specifies the Auto-Reload Register (ARR) updating mode.
N	 	 	 	 	 	 	 	 	 	 This parameter can be a value of @ref TIMER_ARR_Update_Mode */
N
N	uint16_t TIMER_ETR_FilterConf; 	/*!< Specifies the ETR Filter configuration.
N	 	 	 	 	 	 	 	 	 	 This parameter can be a value of @ref TIMER_FilterConfiguration */
N
N	uint16_t TIMER_ETR_Prescaler; 	/*!< Specifies the ETR Prescaler configuration.
N	 	 	 	 	 	 	 	 	 	 This parameter can be a value of @ref TIMER_ETR_Prescaler */
N
N	uint16_t TIMER_ETR_Polarity; 	/*!< Specifies the ETR Polarity configuration.
N	 	 	 	 	 	 	 	 	 	 This parameter can be a value of @ref TIMER_ETR_Polarity */
N
N	uint16_t TIMER_BRK_Polarity; 	/*!< Specifies the BRK Polarity configuration.
N	 	 	 	 	 	 	 	 	 	 This parameter can be a value of @ref TIMER_BRK_Polarity */
N} TIMER_CntInitTypeDef;
N
N/**
N  * @brief  TIMER Channel Init structure definition
N  */
N
Ntypedef struct
N{
N  uint16_t TIMER_CH_Number;             /*!< Specifies the TIMER Channel number to be configured.
N                                             This parameter can be a value of @ref TIMER_CH_Number */
N
N  uint16_t TIMER_CH_Mode;               /*!< Specifies the TIMER Channel mode.
N                                             This parameter can be a value of @ref TIMER_CH_Mode */
N
N  uint16_t TIMER_CH_ETR_Ena;            /*!< Enables or disables ETR.
N                                             This parameter can be a value of FunctionalState */
N
N  uint16_t TIMER_CH_ETR_Reset;          /*!< Enables or disables ETR Reset.
N                                             This parameter can be a value of @ref TIMER_CH_ETR_Reset */
N
N  uint16_t TIMER_CH_BRK_Reset;          /*!< Enables or disables BRK Reset.
N                                             This parameter can be a value of @ref TIMER_CH_BRK_Reset */
N
N  uint16_t TIMER_CH_REF_Format;         /*!< Specifies the REF signal format.
N                                             This parameter can be a value of @ref TIMER_CH_REF_Format */
N
N  uint16_t TIMER_CH_Prescaler;          /*!< Specifies the TIMER Channel Prescaler configuration.
N                                             This parameter can be a value of @ref TIMER_CH_Prescaler */
N
N  uint16_t TIMER_CH_EventSource;        /*!< Specifies the Channel Event source.
N                                             This parameter can be a value of @ref TIMER_CH_EventSource */
N
N  uint16_t TIMER_CH_FilterConf;         /*!< Specifies the TIMER Channel Filter configuration.
N                                             This parameter can be a value of @ref TIMER_FilterConfiguration */
N
N  uint16_t TIMER_CH_CCR_UpdateMode;     /*!< Specifies the TIMER CCR, CCR1 update mode.
N                                             This parameter can be a value of @ref TIMER_CH_CCR_Update_Mode */
N
N  uint16_t TIMER_CH_CCR1_Ena;           /*!< Enables or disables the CCR1 register.
N                                             This parameter can be a value of FunctionalState */
N
N  uint16_t TIMER_CH_CCR1_EventSource;   /*!< Specifies the Channel CCR1 Event source.
N                                             This parameter can be a value of @ref TIMER_CH_CCR1_EventSource */
N}TIMER_ChnInitTypeDef;
N
N/**
N  * @brief  TIMER Channel Output Init structure definition
N  */
N
Ntypedef struct
N{
N  uint16_t TIMER_CH_Number;             /*!< Specifies the TIMER Channel number to be configured.
N                                             This parameter can be a value of @ref TIMER_CH_Number */
N
N  uint16_t TIMER_CH_DirOut_Polarity;    /*!< Specifies the TIMER CHx output polarity.
N                                             This parameter can be a value of @ref TIMER_CH_OUT_Polarity */
N
N  uint16_t TIMER_CH_DirOut_Source;      /*!< Specifies the TIMER CHx output source.
N                                             This parameter can be a value of @ref TIMER_CH_OUT_Source */
N
N  uint16_t TIMER_CH_DirOut_Mode;        /*!< Specifies the TIMER CHx output enable source.
N                                             This parameter can be a value of @ref TIMER_CH_OUT_Mode */
N
N  uint16_t TIMER_CH_NegOut_Polarity;    /*!< Enables or disables the TIMER CHxN output inversion.
N                                             This parameter can be a value of @ref TIMER_CH_OUT_Polarity */
N
N  uint16_t TIMER_CH_NegOut_Source;      /*!< Specifies the TIMER CHxN output source.
N                                             This parameter can be a value of @ref TIMER_CH_OUT_Source */
N
N  uint16_t TIMER_CH_NegOut_Mode;        /*!< Specifies the TIMER CHxN output enable source.
N                                             This parameter can be a value of @ref TIMER_CH_OUT_Mode */
N
N  uint16_t TIMER_CH_DTG_MainPrescaler;  /*!< Specifies the main prescaler of TIMER DTG.
N                                             This parameter can be a number between 0x0000 and 0x00FF.
N                                             Delay DTGdel = TIMER_CH_DTG_MainPrescaler*(TIMER_CH_DTG_AuxPrescaler + 1) clocks. */
N
N  uint16_t TIMER_CH_DTG_AuxPrescaler;   /*!< Specifies the auxiliary prescaler of TIMER DTG.
N                                             This parameter can be a number between 0x0000 and 0x000F.
N                                             Delay DTGdel = TIMER_CH_DTG_MainPrescaler*(TIMER_CH_DTG_AuxPrescaler + 1) clocks. */
N
N  uint16_t TIMER_CH_DTG_ClockSource;    /*!< Specifies the TIMER DTG clock source.
N                                             This parameter can be a value of @ref TIMER_CH_DTG_Clock_Source */
N}TIMER_ChnOutInitTypeDef;
N
N/** @} */ /* End of group TIMER_Exported_Types */
N
N/** @defgroup TIMER_Exported_Constants TIMER Exported Constants
N  * @{
N  */
N
N#if ((defined (USE_MDR1986VE9x)) || (defined (USE_MDR1901VC1T)))
X#if ((1L) || (0L))
N
N#define IS_TIMER_ALL_PERIPH(PERIPH) (((PERIPH) == MDR_TIMER1) || \
N                                     ((PERIPH) == MDR_TIMER2) || \
N                                     ((PERIPH) == MDR_TIMER3))
X#define IS_TIMER_ALL_PERIPH(PERIPH) (((PERIPH) == MDR_TIMER1) ||                                      ((PERIPH) == MDR_TIMER2) ||                                      ((PERIPH) == MDR_TIMER3))
N#elif ((defined (USE_MDR1986VE3)) || (defined (USE_MDR1986VE1T)))
S#define IS_TIMER_ALL_PERIPH(PERIPH) (((PERIPH) == MDR_TIMER1) || \
S                                     ((PERIPH) == MDR_TIMER2) || \
S                                     ((PERIPH) == MDR_TIMER3) || \
S                                     ((PERIPH) == MDR_TIMER4))
X#define IS_TIMER_ALL_PERIPH(PERIPH) (((PERIPH) == MDR_TIMER1) ||                                      ((PERIPH) == MDR_TIMER2) ||                                      ((PERIPH) == MDR_TIMER3) ||                                      ((PERIPH) == MDR_TIMER4))
N#endif
N
N/** @defgroup TIMER_Counter_Mode TIMER Counter Mode
N  * @{
N  */
N
N#define TIMER_CntMode_ClkFixedDir             (((uint32_t)0x0) << TIMER_CNTRL_CNT_MODE_Pos) /*!< The Timer clock changes the TIMERx_CNT value. The count direction is not changed. */
N#define TIMER_CntMode_ClkChangeDir            (((uint32_t)0x1) << TIMER_CNTRL_CNT_MODE_Pos) /*!< The Timer clock changes the TIMERx_CNT value. The count direction changes. */
N#define TIMER_CntMode_EvtFixedDir             (((uint32_t)0x2) << TIMER_CNTRL_CNT_MODE_Pos) /*!< The event changes the TIMERx_CNT value. The count direction is not changed. */
N#define TIMER_CntMode_EvtChangeDir            (((uint32_t)0x3) << TIMER_CNTRL_CNT_MODE_Pos) /*!< The event changes the TIMERx_CNT value. The count direction changes. */
N
N#define IS_TIMER_COUNTER_MODE(MODE) (((MODE) == TIMER_CntMode_ClkFixedDir ) || \
N                                     ((MODE) == TIMER_CntMode_ClkChangeDir) || \
N                                     ((MODE) == TIMER_CntMode_EvtFixedDir ) || \
N                                     ((MODE) == TIMER_CntMode_EvtChangeDir))
X#define IS_TIMER_COUNTER_MODE(MODE) (((MODE) == TIMER_CntMode_ClkFixedDir ) ||                                      ((MODE) == TIMER_CntMode_ClkChangeDir) ||                                      ((MODE) == TIMER_CntMode_EvtFixedDir ) ||                                      ((MODE) == TIMER_CntMode_EvtChangeDir))
N
N/** @} */ /* End of group TIMER_Counter_Mode */
N
N/** @defgroup TIMER_Counter_Direction TIMER Counter Direction
N  * @{
N  */
N
N#define TIMER_CntDir_Up                       (((uint32_t)0x0) << TIMER_CNTRL_DIR_Pos)  /*!< Increments the Timer TIMERx_CNT counter value. */
N#define TIMER_CntDir_Dn                       (((uint32_t)0x1) << TIMER_CNTRL_DIR_Pos)  /*!< Decrements the Timer TIMERx_CNT counter value. */
N
N#define IS_TIMER_COUNTER_DIR(DIR) (((DIR) == TIMER_CntDir_Up) || \
N                                   ((DIR) == TIMER_CntDir_Dn))
X#define IS_TIMER_COUNTER_DIR(DIR) (((DIR) == TIMER_CntDir_Up) ||                                    ((DIR) == TIMER_CntDir_Dn))
N
N/** @} */ /* End of group TIMER_Counter_Direction */
N
N/** @defgroup TIMER_Event_Source TIMER Event Source
N  * @{
N  */
N
N#define TIMER_EvSrc_None                      (((uint32_t)0x0) << TIMER_CNTRL_EVENT_SEL_Pos)  /*!< No events. */
N#define TIMER_EvSrc_TM1                       (((uint32_t)0x1) << TIMER_CNTRL_EVENT_SEL_Pos)  /*!< Selects TIMER1 (CNT == ARR) event. */
N#define TIMER_EvSrc_TM2                       (((uint32_t)0x2) << TIMER_CNTRL_EVENT_SEL_Pos)  /*!< Selects TIMER2 (CNT == ARR) event. */
N#define TIMER_EvSrc_TM3                       (((uint32_t)0x3) << TIMER_CNTRL_EVENT_SEL_Pos)  /*!< Selects TIMER3 (CNT == ARR) event. */
N#define TIMER_EvSrc_CH1                       (((uint32_t)0x4) << TIMER_CNTRL_EVENT_SEL_Pos)  /*!< Selects Channel 1 event. */
N#define TIMER_EvSrc_CH2                       (((uint32_t)0x5) << TIMER_CNTRL_EVENT_SEL_Pos)  /*!< Selects Channel 2 event. */
N#define TIMER_EvSrc_CH3                       (((uint32_t)0x6) << TIMER_CNTRL_EVENT_SEL_Pos)  /*!< Selects Channel 3 event. */
N#define TIMER_EvSrc_CH4                       (((uint32_t)0x7) << TIMER_CNTRL_EVENT_SEL_Pos)  /*!< Selects Channel 4 event. */
N#define TIMER_EvSrc_ETR                       (((uint32_t)0x8) << TIMER_CNTRL_EVENT_SEL_Pos)  /*!< Selects ETR event. */
N
N#define IS_TIMER_EVENT_SOURCE(SOURCE) (((SOURCE) == TIMER_EvSrc_None) || \
N                                       ((SOURCE) == TIMER_EvSrc_TM1 ) || \
N                                       ((SOURCE) == TIMER_EvSrc_TM2 ) || \
N                                       ((SOURCE) == TIMER_EvSrc_TM3 ) || \
N                                       ((SOURCE) == TIMER_EvSrc_CH1 ) || \
N                                       ((SOURCE) == TIMER_EvSrc_CH2 ) || \
N                                       ((SOURCE) == TIMER_EvSrc_CH3 ) || \
N                                       ((SOURCE) == TIMER_EvSrc_CH4 ) || \
N                                       ((SOURCE) == TIMER_EvSrc_ETR ))
X#define IS_TIMER_EVENT_SOURCE(SOURCE) (((SOURCE) == TIMER_EvSrc_None) ||                                        ((SOURCE) == TIMER_EvSrc_TM1 ) ||                                        ((SOURCE) == TIMER_EvSrc_TM2 ) ||                                        ((SOURCE) == TIMER_EvSrc_TM3 ) ||                                        ((SOURCE) == TIMER_EvSrc_CH1 ) ||                                        ((SOURCE) == TIMER_EvSrc_CH2 ) ||                                        ((SOURCE) == TIMER_EvSrc_CH3 ) ||                                        ((SOURCE) == TIMER_EvSrc_CH4 ) ||                                        ((SOURCE) == TIMER_EvSrc_ETR ))
N
N/** @} */ /* End of group TIMER_Event_Source */
N
N/** @defgroup TIMER_Filter_Sampling TIMER Filter Sampling Clock
N  * @{
N  */
N
N#define TIMER_FDTS_TIMER_CLK_div_1              (((uint32_t)0x0) << TIMER_CNTRL_FDTS_Pos) /*!< The FDTS clock occures each TIMER_CLK clock. */
N#define TIMER_FDTS_TIMER_CLK_div_2              (((uint32_t)0x1) << TIMER_CNTRL_FDTS_Pos) /*!< The FDTS clock occures each 2-nd TIMER_CLK clock. */
N#define TIMER_FDTS_TIMER_CLK_div_3              (((uint32_t)0x2) << TIMER_CNTRL_FDTS_Pos) /*!< The FDTS clock occures each 3-rd TIMER_CLK clock. */
N#define TIMER_FDTS_TIMER_CLK_div_4              (((uint32_t)0x3) << TIMER_CNTRL_FDTS_Pos) /*!< The FDTS clock occures each 4-th TIMER_CLK clock. */
N
N#define IS_TIMER_FILTER_SAMPLING(CONFIG) (((CONFIG) == TIMER_FDTS_TIMER_CLK_div_1) || \
N                                          ((CONFIG) == TIMER_FDTS_TIMER_CLK_div_2) || \
N                                          ((CONFIG) == TIMER_FDTS_TIMER_CLK_div_3) || \
N                                          ((CONFIG) == TIMER_FDTS_TIMER_CLK_div_4))
X#define IS_TIMER_FILTER_SAMPLING(CONFIG) (((CONFIG) == TIMER_FDTS_TIMER_CLK_div_1) ||                                           ((CONFIG) == TIMER_FDTS_TIMER_CLK_div_2) ||                                           ((CONFIG) == TIMER_FDTS_TIMER_CLK_div_3) ||                                           ((CONFIG) == TIMER_FDTS_TIMER_CLK_div_4))
N
N/** @} */ /* End of group TIMER_Filter_Sampling */
N
N/** @defgroup TIMER_ARR_Update_Mode TIMER ARR Update Mode
N  * @{
N  */
N
N#define TIMER_ARR_Update_Immediately          (((uint32_t)0x0) << TIMER_CNTRL_ARRB_EN_Pos)  /*!< The ARR register is updated immediately. */
N#define TIMER_ARR_Update_On_CNT_Overflow      (((uint32_t)0x1) << TIMER_CNTRL_ARRB_EN_Pos)  /*!< The ARR register is updated at CNT count end. */
N
N#define IS_TIMER_ARR_UPDATE_MODE(MODE) (((MODE) == TIMER_ARR_Update_Immediately    ) || \
N                                        ((MODE) == TIMER_ARR_Update_On_CNT_Overflow))
X#define IS_TIMER_ARR_UPDATE_MODE(MODE) (((MODE) == TIMER_ARR_Update_Immediately    ) ||                                         ((MODE) == TIMER_ARR_Update_On_CNT_Overflow))
N
N/** @} */ /* End of group TIMER_ARR_UpdateMode */
N
N/** @defgroup TIMER_FilterConfiguration TIMER Filter configuration
N  * @{
N  */
N
N#define TIMER_Filter_1FF_at_TIMER_CLK         ((uint32_t)0x0)  /*!< Signal is latched by 1 trigger  at TIMER_CLK clock frequency. */
N#define TIMER_Filter_2FF_at_TIMER_CLK         ((uint32_t)0x1)  /*!< Signal is latched by 2 triggers at TIMER_CLK clock frequency. */
N#define TIMER_Filter_4FF_at_TIMER_CLK         ((uint32_t)0x2)  /*!< Signal is latched by 4 triggers at TIMER_CLK clock frequency. */
N#define TIMER_Filter_8FF_at_TIMER_CLK         ((uint32_t)0x3)  /*!< Signal is latched by 8 triggers at TIMER_CLK clock frequency. */
N#define TIMER_Filter_6FF_at_FTDS_div_2        ((uint32_t)0x4)  /*!< Signal is latched by 6 triggers at FDTS/2  clock frequency. */
N#define TIMER_Filter_8FF_at_FTDS_div_2        ((uint32_t)0x5)  /*!< Signal is latched by 8 triggers at FDTS/2  clock frequency. */
N#define TIMER_Filter_6FF_at_FTDS_div_4        ((uint32_t)0x6)  /*!< Signal is latched by 6 triggers at FDTS/4  clock frequency. */
N#define TIMER_Filter_8FF_at_FTDS_div_4        ((uint32_t)0x7)  /*!< Signal is latched by 8 triggers at FDTS/4  clock frequency. */
N#define TIMER_Filter_6FF_at_FTDS_div_8        ((uint32_t)0x8)  /*!< Signal is latched by 6 triggers at FDTS/8  clock frequency. */
N#define TIMER_Filter_8FF_at_FTDS_div_8        ((uint32_t)0x9)  /*!< Signal is latched by 8 triggers at FDTS/8  clock frequency. */
N#define TIMER_Filter_5FF_at_FTDS_div_16       ((uint32_t)0xA)  /*!< Signal is latched by 5 triggers at FDTS/16 clock frequency. */
N#define TIMER_Filter_6FF_at_FTDS_div_16       ((uint32_t)0xB)  /*!< Signal is latched by 6 triggers at FDTS/16 clock frequency. */
N#define TIMER_Filter_8FF_at_FTDS_div_16       ((uint32_t)0xC)  /*!< Signal is latched by 8 triggers at FDTS/16 clock frequency. */
N#define TIMER_Filter_5FF_at_FTDS_div_32       ((uint32_t)0xD)  /*!< Signal is latched by 5 triggers at FDTS/32 clock frequency. */
N#define TIMER_Filter_6FF_at_FTDS_div_32       ((uint32_t)0xE)  /*!< Signal is latched by 6 triggers at FDTS/32 clock frequency. */
N#define TIMER_Filter_8FF_at_FTDS_div_32       ((uint32_t)0xF)  /*!< Signal is latched by 8 triggers at FDTS/32 clock frequency. */
N
N#define IS_TIMER_FILTER_CONF(CONF) (((CONF) == TIMER_Filter_1FF_at_TIMER_CLK  ) || \
N                                    ((CONF) == TIMER_Filter_2FF_at_TIMER_CLK  ) || \
N                                    ((CONF) == TIMER_Filter_4FF_at_TIMER_CLK  ) || \
N                                    ((CONF) == TIMER_Filter_8FF_at_TIMER_CLK  ) || \
N                                    ((CONF) == TIMER_Filter_6FF_at_FTDS_div_2 ) || \
N                                    ((CONF) == TIMER_Filter_8FF_at_FTDS_div_2 ) || \
N                                    ((CONF) == TIMER_Filter_6FF_at_FTDS_div_4 ) || \
N                                    ((CONF) == TIMER_Filter_8FF_at_FTDS_div_4 ) || \
N                                    ((CONF) == TIMER_Filter_6FF_at_FTDS_div_8 ) || \
N                                    ((CONF) == TIMER_Filter_8FF_at_FTDS_div_8 ) || \
N                                    ((CONF) == TIMER_Filter_5FF_at_FTDS_div_16) || \
N                                    ((CONF) == TIMER_Filter_6FF_at_FTDS_div_16) || \
N                                    ((CONF) == TIMER_Filter_8FF_at_FTDS_div_16) || \
N                                    ((CONF) == TIMER_Filter_5FF_at_FTDS_div_32) || \
N                                    ((CONF) == TIMER_Filter_6FF_at_FTDS_div_32) || \
N                                    ((CONF) == TIMER_Filter_8FF_at_FTDS_div_32))
X#define IS_TIMER_FILTER_CONF(CONF) (((CONF) == TIMER_Filter_1FF_at_TIMER_CLK  ) ||                                     ((CONF) == TIMER_Filter_2FF_at_TIMER_CLK  ) ||                                     ((CONF) == TIMER_Filter_4FF_at_TIMER_CLK  ) ||                                     ((CONF) == TIMER_Filter_8FF_at_TIMER_CLK  ) ||                                     ((CONF) == TIMER_Filter_6FF_at_FTDS_div_2 ) ||                                     ((CONF) == TIMER_Filter_8FF_at_FTDS_div_2 ) ||                                     ((CONF) == TIMER_Filter_6FF_at_FTDS_div_4 ) ||                                     ((CONF) == TIMER_Filter_8FF_at_FTDS_div_4 ) ||                                     ((CONF) == TIMER_Filter_6FF_at_FTDS_div_8 ) ||                                     ((CONF) == TIMER_Filter_8FF_at_FTDS_div_8 ) ||                                     ((CONF) == TIMER_Filter_5FF_at_FTDS_div_16) ||                                     ((CONF) == TIMER_Filter_6FF_at_FTDS_div_16) ||                                     ((CONF) == TIMER_Filter_8FF_at_FTDS_div_16) ||                                     ((CONF) == TIMER_Filter_5FF_at_FTDS_div_32) ||                                     ((CONF) == TIMER_Filter_6FF_at_FTDS_div_32) ||                                     ((CONF) == TIMER_Filter_8FF_at_FTDS_div_32))
N
N/** @} */ /* End of group TIMER_FilterConfiguration */
N
N/** @defgroup TIMER_ETR_Prescaler TIMER ETR Prescaler
N  * @{
N  */
N
N#define TIMER_ETR_Prescaler_None              (((uint32_t)0x0) << TIMER_BRKETR_CNTRL_ETR_PSC_Pos)  /*!< No division of input frequency. */
N#define TIMER_ETR_Prescaler_div_2             (((uint32_t)0x1) << TIMER_BRKETR_CNTRL_ETR_PSC_Pos)  /*!< Selects input frequency divider by 2. */
N#define TIMER_ETR_Prescaler_div_4             (((uint32_t)0x2) << TIMER_BRKETR_CNTRL_ETR_PSC_Pos)  /*!< Selects input frequency divider by 4. */
N#define TIMER_ETR_Prescaler_div_8             (((uint32_t)0x3) << TIMER_BRKETR_CNTRL_ETR_PSC_Pos)  /*!< Selects input frequency divider by 8. */
N
N#define IS_TIMER_ETR_PRESCALER(VALUE) (((VALUE) == TIMER_ETR_Prescaler_None ) || \
N                                       ((VALUE) == TIMER_ETR_Prescaler_div_2) || \
N                                       ((VALUE) == TIMER_ETR_Prescaler_div_4) || \
N                                       ((VALUE) == TIMER_ETR_Prescaler_div_8))
X#define IS_TIMER_ETR_PRESCALER(VALUE) (((VALUE) == TIMER_ETR_Prescaler_None ) ||                                        ((VALUE) == TIMER_ETR_Prescaler_div_2) ||                                        ((VALUE) == TIMER_ETR_Prescaler_div_4) ||                                        ((VALUE) == TIMER_ETR_Prescaler_div_8))
N
N/** @} */ /* End of group TIMER_ETR_Prescaler */
N
N/** @defgroup TIMER_ETR_Polarity TIMER ETR Polarity
N  * @{
N  */
N
N#define TIMER_ETRPolarity_NonInverted         (((uint32_t)0x0) << TIMER_BRKETR_CNTRL_ETR_INV_Pos)  /*!< No inversion of the ETR input. */
N#define TIMER_ETRPolarity_Inverted            (((uint32_t)0x1) << TIMER_BRKETR_CNTRL_ETR_INV_Pos)  /*!< The ETR input is inverted. */
N
N#define IS_TIMER_ETR_POLARITY(STATE) (((STATE) == TIMER_ETRPolarity_NonInverted) || \
N                                      ((STATE) == TIMER_ETRPolarity_Inverted   ))
X#define IS_TIMER_ETR_POLARITY(STATE) (((STATE) == TIMER_ETRPolarity_NonInverted) ||                                       ((STATE) == TIMER_ETRPolarity_Inverted   ))
N
N/** @} */ /* End of group TIMER_ETR_Polarity */
N
N/** @defgroup TIMER_BRK_Polarity TIMER BRK Polarity
N  * @{
N  */
N
N#define TIMER_BRKPolarity_NonInverted         (((uint32_t)0x0) << TIMER_BRKETR_CNTRL_BRK_INV_Pos)  /*!< No inversion of the BRK input. */
N#define TIMER_BRKPolarity_Inverted            (((uint32_t)0x1) << TIMER_BRKETR_CNTRL_BRK_INV_Pos)  /*!< The BRK input is inverted. */
N
N#define IS_TIMER_BRK_POLARITY(STATE) (((STATE) == TIMER_BRKPolarity_NonInverted) || \
N                                      ((STATE) == TIMER_BRKPolarity_Inverted   ))
X#define IS_TIMER_BRK_POLARITY(STATE) (((STATE) == TIMER_BRKPolarity_NonInverted) ||                                       ((STATE) == TIMER_BRKPolarity_Inverted   ))
N
N/** @} */ /* End of group TIMER_BRK_Polarity */
N
N/** @defgroup TIMER_CH_Number TIMER Channel Number
N  * @{
N  */
N
N#define TIMER_CHANNEL1                        ((uint32_t)0x0)  /*!< Specifies the TIMER channel 1. */
N#define TIMER_CHANNEL2                        ((uint32_t)0x1)  /*!< Specifies the TIMER channel 2. */
N#define TIMER_CHANNEL3                        ((uint32_t)0x2)  /*!< Specifies the TIMER channel 3. */
N#define TIMER_CHANNEL4                        ((uint32_t)0x3)  /*!< Specifies the TIMER channel 4. */
N
N#define IS_TIMER_CHANNEL_NUMBER(NUMBER) (((NUMBER) == TIMER_CHANNEL1) || \
N                                         ((NUMBER) == TIMER_CHANNEL2) || \
N                                         ((NUMBER) == TIMER_CHANNEL3) || \
N                                         ((NUMBER) == TIMER_CHANNEL4))
X#define IS_TIMER_CHANNEL_NUMBER(NUMBER) (((NUMBER) == TIMER_CHANNEL1) ||                                          ((NUMBER) == TIMER_CHANNEL2) ||                                          ((NUMBER) == TIMER_CHANNEL3) ||                                          ((NUMBER) == TIMER_CHANNEL4))
N
N/** @} */ /* End of group TIMER_CH_Number */
N
N/** @defgroup TIMER_CH_ETR_Reset TIMER Channel ETR Reset configuration
N  * @{
N  */
N
N#define TIMER_CH_ETR_RESET_Disable            (((uint32_t)0x0) << TIMER_CH_CNTRL_ETREN_Pos)   /*!< Disables ETR Reset. */
N#define TIMER_CH_ETR_RESET_Enable             (((uint32_t)0x1) << TIMER_CH_CNTRL_ETREN_Pos)   /*!< Enables ETR Reset. */
N
N#define IS_TIMER_CHANNEL_ETR_RESET_CONFIG(CONFIG) (((CONFIG) == TIMER_CH_ETR_RESET_Disable) || \
N                                                   ((CONFIG) == TIMER_CH_ETR_RESET_Enable ))
X#define IS_TIMER_CHANNEL_ETR_RESET_CONFIG(CONFIG) (((CONFIG) == TIMER_CH_ETR_RESET_Disable) ||                                                    ((CONFIG) == TIMER_CH_ETR_RESET_Enable ))
N
N/** @} */ /* End of group TIMER_CH_ETR_Reset */
N
N/** @defgroup TIMER_CH_BRK_Reset TIMER Channel BRK Reset configuration
N  * @{
N  */
N
N#define TIMER_CH_BRK_RESET_Disable            (((uint32_t)0x0) << TIMER_CH_CNTRL_BRKEN_Pos)   /*!< Disables BRK Reset. */
N#define TIMER_CH_BRK_RESET_Enable             (((uint32_t)0x1) << TIMER_CH_CNTRL_BRKEN_Pos)   /*!< Enables BRK Reset. */
N
N#define IS_TIMER_CHANNEL_BRK_RESET_CONFIG(CONFIG) (((CONFIG) == TIMER_CH_BRK_RESET_Disable) || \
N                                                   ((CONFIG) == TIMER_CH_BRK_RESET_Enable ))
X#define IS_TIMER_CHANNEL_BRK_RESET_CONFIG(CONFIG) (((CONFIG) == TIMER_CH_BRK_RESET_Disable) ||                                                    ((CONFIG) == TIMER_CH_BRK_RESET_Enable ))
N
N/** @} */ /* End of group TIMER_CH_BRK_Reset */
N
N/** @defgroup TIMER_CH_Mode TIMER Channel Mode
N  * @{
N  */
N
N#define TIMER_CH_MODE_PWM                     (((uint32_t)0x0) << TIMER_CH_CNTRL_CAP_NPWM_Pos)  /*!< Specifies the PWM channel mode. */
N#define TIMER_CH_MODE_CAPTURE                 (((uint32_t)0x1) << TIMER_CH_CNTRL_CAP_NPWM_Pos)  /*!< Specifies the Capture channel mode. */
N
N#define IS_TIMER_CHANNEL_MODE(MODE) (((MODE) == TIMER_CH_MODE_PWM    ) || \
N                                     ((MODE) == TIMER_CH_MODE_CAPTURE))
X#define IS_TIMER_CHANNEL_MODE(MODE) (((MODE) == TIMER_CH_MODE_PWM    ) ||                                      ((MODE) == TIMER_CH_MODE_CAPTURE))
N
N/** @} */ /* End of group TIMER_CH_Mode */
N
N/** @defgroup TIMER_CH_REF_Format TIMER Channel REF Format
N  * @{
N  */
N
N#define TIMER_CH_REF_Format0                  (((uint32_t)0x0) << TIMER_CH_CNTRL_OCCM_Pos)  /*!< REF is equal to 0 */
N#define TIMER_CH_REF_Format1                  (((uint32_t)0x1) << TIMER_CH_CNTRL_OCCM_Pos)  /*!< REF is equal to 1 if:
N                                                                                                   (CNT == CCR) or
N                                                                                                   ((CNT == CCR1) and CCR1 enabled),
N                                                                                                 else REF is equal to 0. */
N#define TIMER_CH_REF_Format2                  (((uint32_t)0x2) << TIMER_CH_CNTRL_OCCM_Pos)  /*!< REF is equal to 0 if:
N                                                                                                   (CNT == CCR) or
N                                                                                                   ((CNT == CCR1) and CCR1 enabled),
N                                                                                                 else REF is equal to 1. */
N#define TIMER_CH_REF_Format3                  (((uint32_t)0x3) << TIMER_CH_CNTRL_OCCM_Pos)  /*!< Toggle REF state if:
N                                                                                                   (CNT == CCR) or
N                                                                                                   ((CNT == CCR1) and CCR1 enabled). */
N#define TIMER_CH_REF_Format4                  (((uint32_t)0x4) << TIMER_CH_CNTRL_OCCM_Pos)  /*!< REF is equal to 0. */
N#define TIMER_CH_REF_Format5                  (((uint32_t)0x5) << TIMER_CH_CNTRL_OCCM_Pos)  /*!< REF is equal to 1. */
N#define TIMER_CH_REF_Format6                  (((uint32_t)0x6) << TIMER_CH_CNTRL_OCCM_Pos)  /*!< REF is equal to inverted DIR state if:
N                                                                                                   (CCR1 disabled and (CNT < CCR)) or
N                                                                                                   (CCR1 enabled  and (CCR1 < CNT < CCR)),
N                                                                                                 else REF is equal to DIR state. */
N#define TIMER_CH_REF_Format7                  (((uint32_t)0x7) << TIMER_CH_CNTRL_OCCM_Pos)  /*!< REF is equal to DIR state if:
N                                                                                                   (CCR1 disabled and (CNT < CCR)) or
N                                                                                                   (CCR1 enabled  and (CCR1 < CNT < CCR)),
N                                                                                                 else REF is equal to inverted DIR state. */
N
N#define IS_TIMER_CHANNEL_REF_FORMAT(FORMAT) (((FORMAT) == TIMER_CH_REF_Format0) || \
N                                             ((FORMAT) == TIMER_CH_REF_Format1) || \
N                                             ((FORMAT) == TIMER_CH_REF_Format2) || \
N                                             ((FORMAT) == TIMER_CH_REF_Format3) || \
N                                             ((FORMAT) == TIMER_CH_REF_Format4) || \
N                                             ((FORMAT) == TIMER_CH_REF_Format5) || \
N                                             ((FORMAT) == TIMER_CH_REF_Format6) || \
N                                             ((FORMAT) == TIMER_CH_REF_Format7))
X#define IS_TIMER_CHANNEL_REF_FORMAT(FORMAT) (((FORMAT) == TIMER_CH_REF_Format0) ||                                              ((FORMAT) == TIMER_CH_REF_Format1) ||                                              ((FORMAT) == TIMER_CH_REF_Format2) ||                                              ((FORMAT) == TIMER_CH_REF_Format3) ||                                              ((FORMAT) == TIMER_CH_REF_Format4) ||                                              ((FORMAT) == TIMER_CH_REF_Format5) ||                                              ((FORMAT) == TIMER_CH_REF_Format6) ||                                              ((FORMAT) == TIMER_CH_REF_Format7))
N
N/** @} */ /* End of group TIMER_CH_REF_Format */
N
N/** @defgroup TIMER_CH_Prescaler TIMER Channel Prescaler
N  * @{
N  */
N
N#define TIMER_CH_Prescaler_None               ((uint32_t)0x0)  /*!< No division of input frequency. */
N#define TIMER_CH_Prescaler_div_2              ((uint32_t)0x1)  /*!< Selects input frequency divider by 2. */
N#define TIMER_CH_Prescaler_div_4              ((uint32_t)0x2)  /*!< Selects input frequency divider by 4. */
N#define TIMER_CH_Prescaler_div_8              ((uint32_t)0x3)  /*!< Selects input frequency divider by 8. */
N
N#define IS_TIMER_CHANNEL_PRESCALER(VALUE) (((VALUE) == TIMER_CH_Prescaler_None ) || \
N                                           ((VALUE) == TIMER_CH_Prescaler_div_2) || \
N                                           ((VALUE) == TIMER_CH_Prescaler_div_4) || \
N                                           ((VALUE) == TIMER_CH_Prescaler_div_8))
X#define IS_TIMER_CHANNEL_PRESCALER(VALUE) (((VALUE) == TIMER_CH_Prescaler_None ) ||                                            ((VALUE) == TIMER_CH_Prescaler_div_2) ||                                            ((VALUE) == TIMER_CH_Prescaler_div_4) ||                                            ((VALUE) == TIMER_CH_Prescaler_div_8))
N
N/** @} */ /* End of group TIMER_CH_Prescaler */
N
N/** @defgroup TIMER_CH_EventSource TIMER Channel Event Source
N  * @{
N  */
N
N#define TIMER_CH_EvSrc_PE                     (((uint32_t)0x0) << TIMER_CH_CNTRL_CHSEL_Pos)  /*!< Selects positive edge from current TIMER channel. */
N#define TIMER_CH_EvSrc_NE                     (((uint32_t)0x1) << TIMER_CH_CNTRL_CHSEL_Pos)  /*!< Selects negative edge from current TIMER channel. */
N#define TIMER_CH_EvSrc_PE_OC1                 (((uint32_t)0x2) << TIMER_CH_CNTRL_CHSEL_Pos)  /*!< Selects positive edge from other TIMER channel (variant 1). */
N#define TIMER_CH_EvSrc_PE_OC2                 (((uint32_t)0x3) << TIMER_CH_CNTRL_CHSEL_Pos)  /*!< Selects positive edge from other TIMER channel (variant 2). */
N
N#define IS_TIMER_CHANNEL_EVENT_SOURCE(SOURCE) (((SOURCE) == TIMER_CH_EvSrc_PE    ) || \
N                                               ((SOURCE) == TIMER_CH_EvSrc_NE    ) || \
N                                               ((SOURCE) == TIMER_CH_EvSrc_PE_OC1) || \
N                                               ((SOURCE) == TIMER_CH_EvSrc_PE_OC2))
X#define IS_TIMER_CHANNEL_EVENT_SOURCE(SOURCE) (((SOURCE) == TIMER_CH_EvSrc_PE    ) ||                                                ((SOURCE) == TIMER_CH_EvSrc_NE    ) ||                                                ((SOURCE) == TIMER_CH_EvSrc_PE_OC1) ||                                                ((SOURCE) == TIMER_CH_EvSrc_PE_OC2))
N
N/** @} */ /* End of group TIMER_CH_EventSource */
N
N/** @defgroup TIMER_CH_CCR1_EventSource TIMER Channel CCR1 Event Source
N  * @{
N  */
N
N#define TIMER_CH_CCR1EvSrc_PE                 (((uint32_t)0x0) << TIMER_CH_CNTRL2_CHSEL1_Pos)  /*!< Selects positive edge from current TIMER channel. */
N#define TIMER_CH_CCR1EvSrc_NE                 (((uint32_t)0x1) << TIMER_CH_CNTRL2_CHSEL1_Pos)  /*!< Selects negative edge from current TIMER channel. */
N#define TIMER_CH_CCR1EvSrc_NE_OC1             (((uint32_t)0x2) << TIMER_CH_CNTRL2_CHSEL1_Pos)  /*!< Selects negative edge from other TIMER channel (variant 1). */
N#define TIMER_CH_CCR1EvSrc_NE_OC2             (((uint32_t)0x3) << TIMER_CH_CNTRL2_CHSEL1_Pos)  /*!< Selects negative edge from other TIMER channel (variant 2). */
N
N#define IS_TIMER_CHANNEL_CCR1_EVENT_SOURCE(SOURCE) (((SOURCE) == TIMER_CH_CCR1EvSrc_PE    ) || \
N                                                    ((SOURCE) == TIMER_CH_CCR1EvSrc_NE    ) || \
N                                                    ((SOURCE) == TIMER_CH_CCR1EvSrc_NE_OC1) || \
N                                                    ((SOURCE) == TIMER_CH_CCR1EvSrc_NE_OC2))
X#define IS_TIMER_CHANNEL_CCR1_EVENT_SOURCE(SOURCE) (((SOURCE) == TIMER_CH_CCR1EvSrc_PE    ) ||                                                     ((SOURCE) == TIMER_CH_CCR1EvSrc_NE    ) ||                                                     ((SOURCE) == TIMER_CH_CCR1EvSrc_NE_OC1) ||                                                     ((SOURCE) == TIMER_CH_CCR1EvSrc_NE_OC2))
N
N/** @} */ /* End of group TIMER_CH_CCR1_EventSource */
N
N/** @defgroup TIMER_CH_CCR_Update_Mode TIMER CCR, CCR1 Update mode
N  * @{
N  */
N
N#define TIMER_CH_CCR_Update_Immediately       (((uint32_t)0x0) << TIMER_CH_CNTRL2_CCRRLD_Pos)  /*!< The CCR, CCR1 registers is updated immediately. */
N#define TIMER_CH_CCR_Update_On_CNT_eq_0       (((uint32_t)0x1) << TIMER_CH_CNTRL2_CCRRLD_Pos)  /*!< The CCR, CCR1 registers is updated at (CNT == 0) condition. */
N
N#define IS_TIMER_CHANNEL_CCR_UPDATE_MODE(MODE) (((MODE) == TIMER_CH_CCR_Update_Immediately) || \
N                                                ((MODE) == TIMER_CH_CCR_Update_On_CNT_eq_0))
X#define IS_TIMER_CHANNEL_CCR_UPDATE_MODE(MODE) (((MODE) == TIMER_CH_CCR_Update_Immediately) ||                                                 ((MODE) == TIMER_CH_CCR_Update_On_CNT_eq_0))
N
N/** @} */ /* End of group TIMER_CH_CCR_UpdateMode */
N
N/** @defgroup TIMER_CH_OUT_Polarity TIMER Channel Output Polarity
N  * @{
N  */
N
N#define TIMER_CHOPolarity_NonInverted         ((uint32_t)0x0)   /*!< No inversion on the Channel output. */
N#define TIMER_CHOPolarity_Inverted            ((uint32_t)0x1)   /*!< The Channel output is inverted. */
N
N#define IS_TIMER_CHO_POLARITY(STATE) (((STATE) == TIMER_CHOPolarity_NonInverted) || \
N                                      ((STATE) == TIMER_CHOPolarity_Inverted   ))
X#define IS_TIMER_CHO_POLARITY(STATE) (((STATE) == TIMER_CHOPolarity_NonInverted) ||                                       ((STATE) == TIMER_CHOPolarity_Inverted   ))
N
N/** @} */ /* End of group TIMER_CH_OUT_Polarity */
N
N/** @defgroup TIMER_CH_OUT_Source TIMER Channel Output Source
N  * @{
N  */
N
N#define TIMER_CH_OutSrc_Only_0                ((uint32_t)0x0)   /*!< Selects the '0' state on the CHx (or CHxN) line. */
N#define TIMER_CH_OutSrc_Only_1                ((uint32_t)0x1)   /*!< Selects the '1' state on the CHx (or CHxN) line. */
N#define TIMER_CH_OutSrc_REF                   ((uint32_t)0x2)   /*!< Selects the REF state on the CHx (or CHxN) line. */
N#define TIMER_CH_OutSrc_DTG                   ((uint32_t)0x3)   /*!< Selects the DTG output state on the CHx (or CHxN) line. */
N
N#define IS_TIMER_CHO_SOURCE(SOURCE) (((SOURCE) == TIMER_CH_OutSrc_Only_0) || \
N                                     ((SOURCE) == TIMER_CH_OutSrc_Only_1) || \
N                                     ((SOURCE) == TIMER_CH_OutSrc_REF   ) || \
N                                     ((SOURCE) == TIMER_CH_OutSrc_DTG   ))
X#define IS_TIMER_CHO_SOURCE(SOURCE) (((SOURCE) == TIMER_CH_OutSrc_Only_0) ||                                      ((SOURCE) == TIMER_CH_OutSrc_Only_1) ||                                      ((SOURCE) == TIMER_CH_OutSrc_REF   ) ||                                      ((SOURCE) == TIMER_CH_OutSrc_DTG   ))
N
N/** @} */ /* End of group TIMER_CH_OUT_Source */
N
N/** @defgroup TIMER_CH_OUT_Mode TIMER Channel Output Enable Source
N  * @{
N  */
N
N#define TIMER_CH_OutMode_Input                ((uint32_t)0x0)   /*!< Selects the Input mode on the CHx (or CHxN) line. */
N#define TIMER_CH_OutMode_Output               ((uint32_t)0x1)   /*!< Selects the Output mode on the CHx (or CHxN) line. */
N#define TIMER_CH_OutMode_REF_as_OE            ((uint32_t)0x2)   /*!< The REF signal specifies the CHx (or CHxN) line mode. */
N#define TIMER_CH_OutMode_DTG_as_OE            ((uint32_t)0x3)   /*!< The DTG output specifies the CHx (or CHxN) line mode. */
N
N#define IS_TIMER_CHO_MODE(MODE) (((MODE) == TIMER_CH_OutMode_Input    ) || \
N                                 ((MODE) == TIMER_CH_OutMode_Output   ) || \
N                                 ((MODE) == TIMER_CH_OutMode_REF_as_OE) || \
N                                 ((MODE) == TIMER_CH_OutMode_DTG_as_OE))
X#define IS_TIMER_CHO_MODE(MODE) (((MODE) == TIMER_CH_OutMode_Input    ) ||                                  ((MODE) == TIMER_CH_OutMode_Output   ) ||                                  ((MODE) == TIMER_CH_OutMode_REF_as_OE) ||                                  ((MODE) == TIMER_CH_OutMode_DTG_as_OE))
N
N/** @} */ /* End of group TIMER_CH_OUT_Mode */
N
N/** @defgroup TIMER_CH_DTG_Prescaler TIMER Channel DTG Prescaler
N  * @{
N  */
N
N#define IS_TIMER_CHANNEL_DTG_MAIN_PRESCALER(VALUE) (((VALUE) >> 8) == 0)
N
N#define IS_TIMER_CHANNEL_DTG_AUX_PRESCALER(VALUE) (((VALUE) >> 4) == 0)
N
N/** @} */ /* End of group TIMER_CH_DTG_Prescaler */
N
N/** @defgroup TIMER_CH_DTG_Clock_Source TIMER Channel DTG Clock Source
N  * @{
N  */
N
N#define TIMER_CH_DTG_ClkSrc_TIMER_CLK         (((uint32_t)0x0) << TIMER_CH_DTG_EDTS_Pos)  /*!< Specifies the TIMER_CLK signal as DTG clock source. */
N#define TIMER_CH_DTG_ClkSrc_FDTS              (((uint32_t)0x1) << TIMER_CH_DTG_EDTS_Pos)  /*!< Specifies the FDTS signal as DTG clock source. */
N
N#define IS_TIMER_CHANNEL_DTG_CLK_SOURCE(SOURCE) (((SOURCE) == TIMER_CH_DTG_ClkSrc_TIMER_CLK) || \
N                                                 ((SOURCE) == TIMER_CH_DTG_ClkSrc_FDTS     ))
X#define IS_TIMER_CHANNEL_DTG_CLK_SOURCE(SOURCE) (((SOURCE) == TIMER_CH_DTG_ClkSrc_TIMER_CLK) ||                                                  ((SOURCE) == TIMER_CH_DTG_ClkSrc_FDTS     ))
N
N/** @} */ /* End of group TIMER_CH_DTG_Clock_Source */
N
N/** @defgroup TIMER_StatusFlags TIMER Status flags
N  * @{
N  */
N
N#define TIMER_STATUS_CNT_ZERO                 (((uint32_t)0x1) <<  0) /*!< The (CNT == 0) condition occured. */
N#define TIMER_STATUS_CNT_ARR                  (((uint32_t)0x1) <<  1) /*!< The (CNT == ARR) condition occured. */
N#define TIMER_STATUS_ETR_RISING_EDGE          (((uint32_t)0x1) <<  2) /*!< The ETR rising edge occured. */
N#define TIMER_STATUS_ETR_FALLING_EDGE         (((uint32_t)0x1) <<  3) /*!< The ETR falling edge occured. */
N#define TIMER_STATUS_BRK                      (((uint32_t)0x1) <<  4) /*!< The (BRK == 1) condition occured. */
N#define TIMER_STATUS_CCR_CAP_CH1              (((uint32_t)0x1) <<  5) /*!< The Channel 1 CCR capture condition occured. */
N#define TIMER_STATUS_CCR_CAP_CH2              (((uint32_t)0x1) <<  6) /*!< The Channel 2 CCR capture condition occured. */
N#define TIMER_STATUS_CCR_CAP_CH3              (((uint32_t)0x1) <<  7) /*!< The Channel 3 CCR capture condition occured. */
N#define TIMER_STATUS_CCR_CAP_CH4              (((uint32_t)0x1) <<  8) /*!< The Channel 4 CCR capture condition occured. */
N#define TIMER_STATUS_CCR_REF_CH1              (((uint32_t)0x1) <<  9) /*!< The Channel 1 (REF == 1) condition occured. */
N#define TIMER_STATUS_CCR_REF_CH2              (((uint32_t)0x1) << 10) /*!< The Channel 2 (REF == 1) condition occured. */
N#define TIMER_STATUS_CCR_REF_CH3              (((uint32_t)0x1) << 11) /*!< The Channel 3 (REF == 1) condition occured. */
N#define TIMER_STATUS_CCR_REF_CH4              (((uint32_t)0x1) << 12) /*!< The Channel 4 (REF == 1) condition occured. */
N#define TIMER_STATUS_CCR_CAP1_CH1             (((uint32_t)0x1) << 13) /*!< The Channel 1 CCR1 capture condition occured. */
N#define TIMER_STATUS_CCR_CAP1_CH2             (((uint32_t)0x1) << 14) /*!< The Channel 2 CCR1 capture condition occured. */
N#define TIMER_STATUS_CCR_CAP1_CH3             (((uint32_t)0x1) << 15) /*!< The Channel 3 CCR1 capture condition occured. */
N#define TIMER_STATUS_CCR_CAP1_CH4             (((uint32_t)0x1) << 16) /*!< The Channel 4 CCR1 capture condition occured. */
N
N#define TIMER_STATUS_Msk                      (TIMER_STATUS_CNT_ZERO         | \
N                                               TIMER_STATUS_CNT_ARR          | \
N                                               TIMER_STATUS_ETR_RISING_EDGE  | \
N                                               TIMER_STATUS_ETR_FALLING_EDGE | \
N                                               TIMER_STATUS_BRK              | \
N                                               TIMER_STATUS_CCR_CAP_CH1      | \
N                                               TIMER_STATUS_CCR_CAP_CH2      | \
N                                               TIMER_STATUS_CCR_CAP_CH3      | \
N                                               TIMER_STATUS_CCR_CAP_CH4      | \
N                                               TIMER_STATUS_CCR_REF_CH1      | \
N                                               TIMER_STATUS_CCR_REF_CH2      | \
N                                               TIMER_STATUS_CCR_REF_CH3      | \
N                                               TIMER_STATUS_CCR_REF_CH4      | \
N                                               TIMER_STATUS_CCR_CAP1_CH1     | \
N                                               TIMER_STATUS_CCR_CAP1_CH2     | \
N                                               TIMER_STATUS_CCR_CAP1_CH3     | \
N                                               TIMER_STATUS_CCR_CAP1_CH4)
X#define TIMER_STATUS_Msk                      (TIMER_STATUS_CNT_ZERO         |                                                TIMER_STATUS_CNT_ARR          |                                                TIMER_STATUS_ETR_RISING_EDGE  |                                                TIMER_STATUS_ETR_FALLING_EDGE |                                                TIMER_STATUS_BRK              |                                                TIMER_STATUS_CCR_CAP_CH1      |                                                TIMER_STATUS_CCR_CAP_CH2      |                                                TIMER_STATUS_CCR_CAP_CH3      |                                                TIMER_STATUS_CCR_CAP_CH4      |                                                TIMER_STATUS_CCR_REF_CH1      |                                                TIMER_STATUS_CCR_REF_CH2      |                                                TIMER_STATUS_CCR_REF_CH3      |                                                TIMER_STATUS_CCR_REF_CH4      |                                                TIMER_STATUS_CCR_CAP1_CH1     |                                                TIMER_STATUS_CCR_CAP1_CH2     |                                                TIMER_STATUS_CCR_CAP1_CH3     |                                                TIMER_STATUS_CCR_CAP1_CH4)
N
N#define IS_TIMER_STATUS_FLAG(FLAG) (((FLAG) == TIMER_STATUS_CNT_ZERO        ) || \
N                                    ((FLAG) == TIMER_STATUS_CNT_ARR         ) || \
N                                    ((FLAG) == TIMER_STATUS_ETR_RISING_EDGE ) || \
N                                    ((FLAG) == TIMER_STATUS_ETR_FALLING_EDGE) || \
N                                    ((FLAG) == TIMER_STATUS_BRK             ) || \
N                                    ((FLAG) == TIMER_STATUS_CCR_CAP_CH1     ) || \
N                                    ((FLAG) == TIMER_STATUS_CCR_CAP_CH2     ) || \
N                                    ((FLAG) == TIMER_STATUS_CCR_CAP_CH3     ) || \
N                                    ((FLAG) == TIMER_STATUS_CCR_CAP_CH4     ) || \
N                                    ((FLAG) == TIMER_STATUS_CCR_REF_CH1     ) || \
N                                    ((FLAG) == TIMER_STATUS_CCR_REF_CH2     ) || \
N                                    ((FLAG) == TIMER_STATUS_CCR_REF_CH3     ) || \
N                                    ((FLAG) == TIMER_STATUS_CCR_REF_CH4     ) || \
N                                    ((FLAG) == TIMER_STATUS_CCR_CAP1_CH1    ) || \
N                                    ((FLAG) == TIMER_STATUS_CCR_CAP1_CH2    ) || \
N                                    ((FLAG) == TIMER_STATUS_CCR_CAP1_CH3    ) || \
N                                    ((FLAG) == TIMER_STATUS_CCR_CAP1_CH4    ))
X#define IS_TIMER_STATUS_FLAG(FLAG) (((FLAG) == TIMER_STATUS_CNT_ZERO        ) ||                                     ((FLAG) == TIMER_STATUS_CNT_ARR         ) ||                                     ((FLAG) == TIMER_STATUS_ETR_RISING_EDGE ) ||                                     ((FLAG) == TIMER_STATUS_ETR_FALLING_EDGE) ||                                     ((FLAG) == TIMER_STATUS_BRK             ) ||                                     ((FLAG) == TIMER_STATUS_CCR_CAP_CH1     ) ||                                     ((FLAG) == TIMER_STATUS_CCR_CAP_CH2     ) ||                                     ((FLAG) == TIMER_STATUS_CCR_CAP_CH3     ) ||                                     ((FLAG) == TIMER_STATUS_CCR_CAP_CH4     ) ||                                     ((FLAG) == TIMER_STATUS_CCR_REF_CH1     ) ||                                     ((FLAG) == TIMER_STATUS_CCR_REF_CH2     ) ||                                     ((FLAG) == TIMER_STATUS_CCR_REF_CH3     ) ||                                     ((FLAG) == TIMER_STATUS_CCR_REF_CH4     ) ||                                     ((FLAG) == TIMER_STATUS_CCR_CAP1_CH1    ) ||                                     ((FLAG) == TIMER_STATUS_CCR_CAP1_CH2    ) ||                                     ((FLAG) == TIMER_STATUS_CCR_CAP1_CH3    ) ||                                     ((FLAG) == TIMER_STATUS_CCR_CAP1_CH4    ))
N
N#define IS_TIMER_STATUS(STATUS) (((STATUS) & TIMER_STATUS_Msk) == (STATUS))
N
N/** @} */ /* End of group TIMER_StatusFlags */
N
N/** @defgroup TIMER_DMAChannels TIMER DMAChannels
N  * @{
N  */
N/** @note Available only for MC MDR1986VE1T and MC MDR1986BE3 */
N
N#define TIMER_DMA_Channel0					((uint32_t)0x00000004)
N#define TIMER_DMA_Channel1					((uint32_t)0x00000000)
N#define TIMER_DMA_Channel2					((uint32_t)0x00000001)
N#define TIMER_DMA_Channel3					((uint32_t)0x00000002)
N#define TIMER_DMA_Channel4					((uint32_t)0x00000003)
N
N#define IS_TIMER_DMA_Channel(DMA_Channel)	((DMA_Channel == TIMER_DMA_Channel0) ||\
N											 (DMA_CHannel == TIMER_DMA_Channel1) ||\
N											 (DMA_CHannel == TIMER_DMA_Channel2) ||\
N											 (DMA_CHannel == TIMER_DMA_Channel3) ||\
N											 (DMA_CHannel == TIMER_DMA_Channel4))
X#define IS_TIMER_DMA_Channel(DMA_Channel)	((DMA_Channel == TIMER_DMA_Channel0) ||											 (DMA_CHannel == TIMER_DMA_Channel1) ||											 (DMA_CHannel == TIMER_DMA_Channel2) ||											 (DMA_CHannel == TIMER_DMA_Channel3) ||											 (DMA_CHannel == TIMER_DMA_Channel4))
N
N/** @} */ /* End of group TIMER_DMAChannels */
N
N/** @defgroup TIMER_Clock_BRG TIMER Clock BRG
N  * @{
N  */
N
N#define TIMER_HCLKdiv1                        ((uint32_t)0x0)
N#define TIMER_HCLKdiv2                        ((uint32_t)0x1)
N#define TIMER_HCLKdiv4                        ((uint32_t)0x2)
N#define TIMER_HCLKdiv8                        ((uint32_t)0x3)
N#define TIMER_HCLKdiv16                       ((uint32_t)0x4)
N#define TIMER_HCLKdiv32                       ((uint32_t)0x5)
N#define TIMER_HCLKdiv64                       ((uint32_t)0x6)
N#define TIMER_HCLKdiv128                      ((uint32_t)0x7)
N
N#define IS_TIMER_CLOCK_BRG(BRG) (((BRG) == TIMER_HCLKdiv1  ) || \
N                                 ((BRG) == TIMER_HCLKdiv2  ) || \
N                                 ((BRG) == TIMER_HCLKdiv4  ) || \
N                                 ((BRG) == TIMER_HCLKdiv8  ) || \
N                                 ((BRG) == TIMER_HCLKdiv16 ) || \
N                                 ((BRG) == TIMER_HCLKdiv32 ) || \
N                                 ((BRG) == TIMER_HCLKdiv64 ) || \
N                                 ((BRG) == TIMER_HCLKdiv128))
X#define IS_TIMER_CLOCK_BRG(BRG) (((BRG) == TIMER_HCLKdiv1  ) ||                                  ((BRG) == TIMER_HCLKdiv2  ) ||                                  ((BRG) == TIMER_HCLKdiv4  ) ||                                  ((BRG) == TIMER_HCLKdiv8  ) ||                                  ((BRG) == TIMER_HCLKdiv16 ) ||                                  ((BRG) == TIMER_HCLKdiv32 ) ||                                  ((BRG) == TIMER_HCLKdiv64 ) ||                                  ((BRG) == TIMER_HCLKdiv128))
N
N/** @} */ /* End of group TIMER_Clock_BRG */
N
N/** @} */ /* End of group TIMER_Exported_Constants */
N
N/** @defgroup TIMER_Exported_Macros TIMER Exported Macros
N  * @{
N  */
N
N/**
N  * @brief  Clears the TIMERx's interrupt pending (TIMERx's Status) bits.
N  * @param  TIMERx: where x can be 1 to 3 to select the TIMER peripheral.
N  * @param  TIMER_IT: specifies the pending bit to clear.
N  *         This parameter can be any combination of the TIMER_StatusFlags:
N  *           @arg TIMER_STATUS_CNT_ZERO:         the (CNT == 0) condition occured;
N  *           @arg TIMER_STATUS_CNT_ARR:          the (CNT == ARR) condition occured;
N  *           @arg TIMER_STATUS_ETR_RISING_EDGE:  the ETR rising edge occured;
N  *           @arg TIMER_STATUS_ETR_FALLING_EDGE: the ETR falling edge occured;
N  *           @arg TIMER_STATUS_BRK:              the (BRK == 1) condition occured;
N  *           @arg TIMER_STATUS_CCR_CAP_CH1:      the Channel 1 CCR capture condition occured;
N  *           @arg TIMER_STATUS_CCR_CAP_CH2:      the Channel 2 CCR capture condition occured;
N  *           @arg TIMER_STATUS_CCR_CAP_CH3:      the Channel 3 CCR capture condition occured;
N  *           @arg TIMER_STATUS_CCR_CAP_CH4:      the Channel 4 CCR capture condition occured;
N  *           @arg TIMER_STATUS_CCR_REF_CH1:      the Channel 1 (REF == 1) condition occured;
N  *           @arg TIMER_STATUS_CCR_REF_CH2:      the Channel 2 (REF == 1) condition occured;
N  *           @arg TIMER_STATUS_CCR_REF_CH3:      the Channel 3 (REF == 1) condition occured;
N  *           @arg TIMER_STATUS_CCR_REF_CH4:      the Channel 4 (REF == 1) condition occured;
N  *           @arg TIMER_STATUS_CCR_CAP1_CH1:     the Channel 1 CCR1 capture condition occured;
N  *           @arg TIMER_STATUS_CCR_CAP1_CH2:     the Channel 2 CCR1 capture condition occured;
N  *           @arg TIMER_STATUS_CCR_CAP1_CH3:     the Channel 3 CCR1 capture condition occured;
N  *           @arg TIMER_STATUS_CCR_CAP1_CH4:     the Channel 4 CCR1 capture condition occured.
N  * @retval None
N  */
N#define TIMER_ClearITPendingBit(TIMERx, TIMER_IT) TIMER_ClearFlag(TIMERx, TIMER_IT)
N
N/** @} */ /* End of group TIMER_Exported_Macros */
N
N/** @defgroup TIMER_Exported_Functions TIMER Exported Functions
N  * @{
N  */
N
Nvoid TIMER_DeInit(MDR_TIMER_TypeDef* TIMERx);
N
Nvoid TIMER_CntInit(MDR_TIMER_TypeDef* TIMERx, const TIMER_CntInitTypeDef* TIMER_CntInitStruct);
Nvoid TIMER_CntStructInit(TIMER_CntInitTypeDef* TIMER_CntInitStruct);
N
Nvoid TIMER_Cmd(MDR_TIMER_TypeDef* TIMERx, FunctionalState NewState);
N
N#if defined (USE_MDR1986VE1T) || defined (USE_MDR1986VE3)
X#if 0L || 0L
S	void TIMER_SetCounter(MDR_TIMER_TypeDef* TIMERx, uint32_t Counter);
N#elif defined (USE_MDR1986VE9x) || defined (USE_MDR1901VC1T)
X#elif 1L || 0L
N	void TIMER_SetCounter(MDR_TIMER_TypeDef* TIMERx, uint16_t Counter);
N#endif
N
Nvoid TIMER_SetCntPrescaler(MDR_TIMER_TypeDef* TIMERx, uint16_t Prescaler);
N#if defined (USE_MDR1986VE1T) || defined (USE_MDR1986VE3)
X#if 0L || 0L
S	void TIMER_SetCntAutoreload(MDR_TIMER_TypeDef* TIMERx, uint32_t Autoreload);
N#elif defined (USE_MDR1986VE9x) || defined (USE_MDR1901VC1T)
X#elif 1L || 0L
N	void TIMER_SetCntAutoreload(MDR_TIMER_TypeDef* TIMERx, uint16_t Autoreload);
N#endif
N#if defined (USE_MDR1986VE1T) || defined (USE_MDR1986VE3)
X#if 0L || 0L
S	void TIMER_CntAutoreloadConfig(MDR_TIMER_TypeDef* TIMERx, uint32_t Autoreload, uint32_t UpdateMode);
N#elif defined (USE_MDR1986VE9x) || defined (USE_MDR1901VC1T)
X#elif 1L || 0L
N	void TIMER_CntAutoreloadConfig(MDR_TIMER_TypeDef* TIMERx, uint16_t Autoreload, uint32_t UpdateMode);
N#endif
N
N#if defined (USE_MDR1986VE1T) || defined (USE_MDR1986VE3)
X#if 0L || 0L
S	uint32_t TIMER_GetCounter(MDR_TIMER_TypeDef* TIMERx);
N#elif defined (USE_MDR1986VE9x) || defined (USE_MDR1901VC1T)
X#elif 1L || 0L
N	uint16_t TIMER_GetCounter(MDR_TIMER_TypeDef* TIMERx);
N#endif
N
Nvoid TIMER_CntEventSourceConfig(MDR_TIMER_TypeDef* TIMERx, uint32_t EventSource);
Nvoid TIMER_FilterSamplingConfig(MDR_TIMER_TypeDef* TIMERx, uint32_t Prescaler);
Nvoid TIMER_CounterModeConfig(MDR_TIMER_TypeDef* TIMERx, uint32_t Mode);
Nvoid TIMER_SetCounterDirection(MDR_TIMER_TypeDef* TIMERx, uint32_t Direction);
Nvoid TIMER_ETRInputConfig(MDR_TIMER_TypeDef* TIMERx, uint32_t Prescaler, uint32_t Polarity, uint32_t Filter);
Nvoid TIMER_ETRFilterConfig(MDR_TIMER_TypeDef* TIMERx, uint32_t Filter);
Nvoid TIMER_ETRPrescalerConfig(MDR_TIMER_TypeDef* TIMERx, uint32_t Prescaler);
Nvoid TIMER_ETRPolarityConfig(MDR_TIMER_TypeDef* TIMERx, uint32_t Polarity);
Nvoid TIMER_BRKPolarityConfig(MDR_TIMER_TypeDef* TIMERx, uint32_t Polarity);
Nuint32_t TIMER_GetCounterDirection(MDR_TIMER_TypeDef* TIMERx);
NFlagStatus TIMER_GetCntWriteComplete(MDR_TIMER_TypeDef* TIMERx);
N
Nvoid TIMER_ChnInit(MDR_TIMER_TypeDef* TIMERx, const TIMER_ChnInitTypeDef* TIMER_ChnInitStruct);
Nvoid TIMER_ChnStructInit(TIMER_ChnInitTypeDef* TIMER_ChnInitStruct);
N
N#if defined (USE_MDR1986VE1T) || defined (USE_MDR1986VE3)
X#if 0L || 0L
S	void TIMER_SetChnCompare(MDR_TIMER_TypeDef* TIMERx, uint32_t Channel, uint32_t Compare);
N#elif defined (USE_MDR1986VE9x) || defined (USE_MDR1901VC1T)
X#elif 1L || 0L
N	void TIMER_SetChnCompare(MDR_TIMER_TypeDef* TIMERx, uint32_t Channel, uint16_t Compare);
N#endif
N
N#if defined (USE_MDR1986VE1T) || defined (USE_MDR1986VE3)
X#if 0L || 0L
S	void TIMER_SetChnCompare1(MDR_TIMER_TypeDef* TIMERx, uint32_t Channel, uint32_t Compare);
N#elif defined (USE_MDR1986VE9x) || defined (USE_MDR1901VC1T)
X#elif 1L || 0L
N	void TIMER_SetChnCompare1(MDR_TIMER_TypeDef* TIMERx, uint32_t Channel, uint16_t Compare);
N#endif
N
N#if defined (USE_MDR1986VE1T) || defined (USE_MDR1986VE3)
X#if 0L || 0L
S	void TIMER_ChnCompareConfig(MDR_TIMER_TypeDef* TIMERx, uint32_t Channel, uint32_t Compare, uint32_t UpdateMode);
N#elif defined (USE_MDR1986VE9x) || defined (USE_MDR1901VC1T)
X#elif 1L || 0L
N	void TIMER_ChnCompareConfig(MDR_TIMER_TypeDef* TIMERx, uint32_t Channel, uint16_t Compare, uint32_t UpdateMode);
N#endif
N
N#if defined (USE_MDR1986VE1T) || defined (USE_MDR1986VE3)
X#if 0L || 0L
S	void TIMER_ChnCompare1Config(MDR_TIMER_TypeDef* TIMERx, uint32_t Channel, uint32_t Compare, uint32_t UpdateMode);
N#elif defined (USE_MDR1986VE9x) || defined (USE_MDR1901VC1T)
X#elif 1L || 0L
N	void TIMER_ChnCompare1Config(MDR_TIMER_TypeDef* TIMERx, uint32_t Channel, uint16_t Compare, uint32_t UpdateMode);
N#endif
N
N#if defined (USE_MDR1986VE1T) || defined (USE_MDR1986VE3)
X#if 0L || 0L
S	uint32_t TIMER_GetChnCapture(MDR_TIMER_TypeDef* TIMERx, uint32_t Channel);
N#elif defined (USE_MDR1986VE9x) || defined (USE_MDR1901VC1T)
X#elif 1L || 0L
N	uint16_t TIMER_GetChnCapture(MDR_TIMER_TypeDef* TIMERx, uint32_t Channel);
N#endif
N
N#if defined (USE_MDR1986VE1T) || defined (USE_MDR1986VE3)
X#if 0L || 0L
S	uint32_t TIMER_GetChnCapture1(MDR_TIMER_TypeDef* TIMERx, uint32_t Channel);
N#elif defined (USE_MDR1986VE9x) || defined (USE_MDR1901VC1T)
X#elif 1L || 0L
N	uint16_t TIMER_GetChnCapture1(MDR_TIMER_TypeDef* TIMERx, uint32_t Channel);
N#endif
N
N
Nvoid TIMER_ChnETR_Cmd(MDR_TIMER_TypeDef* TIMERx, uint32_t Channel, FunctionalState NewState);
Nvoid TIMER_ChnETRResetConfig(MDR_TIMER_TypeDef* TIMERx, uint32_t Channel, uint32_t NewState);
Nvoid TIMER_ChnBRKResetConfig(MDR_TIMER_TypeDef* TIMERx, uint32_t Channel, uint32_t NewState);
Nvoid TIMER_ChnREFFormatConfig(MDR_TIMER_TypeDef* TIMERx, uint32_t Channel, uint32_t Format);
Nvoid TIMER_ChnCapturePrescalerConfig(MDR_TIMER_TypeDef* TIMERx, uint32_t Channel, uint32_t Prescaler);
Nvoid TIMER_ChnEventSourceConfig(MDR_TIMER_TypeDef* TIMERx, uint32_t Channel, uint32_t EventSource);
Nvoid TIMER_ChnFilterConfig(MDR_TIMER_TypeDef* TIMERx, uint32_t Channel, uint32_t Filter);
NFlagStatus TIMER_GetChnWriteComplete(MDR_TIMER_TypeDef* TIMERx, uint32_t Channel);
Nvoid TIMER_ChnCCR1_EventSourceConfig(MDR_TIMER_TypeDef* TIMERx, uint32_t Channel, uint32_t EventSource);
Nvoid TIMER_ChnCCR1_Cmd(MDR_TIMER_TypeDef* TIMERx, uint32_t Channel, FunctionalState NewState);
N
Nvoid TIMER_ChnOutInit(MDR_TIMER_TypeDef* TIMERx, const TIMER_ChnOutInitTypeDef* TIMER_ChnOutInitStruct);
Nvoid TIMER_ChnOutStructInit(TIMER_ChnOutInitTypeDef* TIMER_ChnOutInitStruct);
Nvoid TIMER_ChnOutConfig(MDR_TIMER_TypeDef* TIMERx, uint32_t Channel, uint32_t OutSource, uint32_t Mode, uint32_t Polarity);
Nvoid TIMER_ChnOutSourceConfig(MDR_TIMER_TypeDef* TIMERx, uint32_t Channel, uint32_t OutSource);
Nvoid TIMER_ChnOutModeConfig(MDR_TIMER_TypeDef* TIMERx, uint32_t Channel, uint32_t Mode);
Nvoid TIMER_ChnOutPolarityConfig(MDR_TIMER_TypeDef* TIMERx, uint32_t Channel, uint32_t Polarity);
Nvoid TIMER_ChnNOutConfig(MDR_TIMER_TypeDef* TIMERx, uint32_t Channel, uint32_t OutSource, uint32_t Mode, uint32_t Polarity);
Nvoid TIMER_ChnNOutSourceConfig(MDR_TIMER_TypeDef* TIMERx, uint32_t Channel, uint32_t OutSource);
Nvoid TIMER_ChnNOutModeConfig(MDR_TIMER_TypeDef* TIMERx, uint32_t Channel, uint32_t Mode);
Nvoid TIMER_ChnNOutPolarityConfig(MDR_TIMER_TypeDef* TIMERx, uint32_t Channel, uint32_t Polarity);
Nvoid TIMER_ChnOutDTGConfig(MDR_TIMER_TypeDef* TIMERx, uint32_t Channel,
N                         uint32_t MainPrescaler, uint32_t AuxPrescaler, uint32_t ClockSource);
N
Nuint32_t TIMER_GetStatus(MDR_TIMER_TypeDef* TIMERx);
NFlagStatus TIMER_GetFlagStatus(MDR_TIMER_TypeDef* TIMERx, uint32_t Flag);
Nvoid TIMER_ClearFlag(MDR_TIMER_TypeDef* TIMERx, uint32_t Flags);
N#if defined (USE_MDR1986VE1T) || defined (USE_MDR1986VE3)
X#if 0L || 0L
S	void TIMER_DMACmd(MDR_TIMER_TypeDef* TIMERx, uint32_t TIMER_DMASource, uint32_t TIMER_DMAChannel, FunctionalState NewState);
N#endif
N#if defined (USE_MDR1986VE9x) || defined (USE_MDR1901VC1T)
X#if 1L || 0L
N	void TIMER_DMACmd(MDR_TIMER_TypeDef* TIMERx, uint32_t TIMER_DMASource, FunctionalState NewState);
N#endif
N
Nvoid TIMER_ITConfig(MDR_TIMER_TypeDef* TIMERx, uint32_t TIMER_IT, FunctionalState NewState);
NITStatus TIMER_GetITStatus(MDR_TIMER_TypeDef* TIMERx, uint32_t TIMER_IT);
Nvoid TIMER_BRGInit(MDR_TIMER_TypeDef* TIMERx, uint32_t TIMER_BRG);
N
N/** @} */ /* End of group TIMER_Exported_Functions */
N
N/** @} */ /* End of group TIMER */
N
N/** @} */ /* End of group __MDR32F9Qx_StdPeriph_Driver */
N
N#ifdef __cplusplus
S} // extern "C" block end
N#endif
N
N#endif /* __MDR32F9QX_TIMER_H */
N
N/*
N*
N* END OF FILE MDR32F9Qx_timer.h */
L 7 "C:\Keil_v5\ARM\PACK\Keil\MDR1986BExx\1.5.3\Libraries\MDR32F9Qx_StdPeriph_Driver\src\MDR32F9Qx_timer.c" 2
N
N#define ASSERT_INFO_FILE_ID FILEID__MDR32F9X_TIMER_C
N
N/** @addtogroup __MDR32F9Qx_StdPeriph_Driver MDR32F9Qx Standard Peripherial Driver
N  * @{
N  */
N
N/** @defgroup TIMER TIMER
N  * @{
N  */
N
N/** @defgroup TIMER_Private_Functions TIMER Private Functions
N  * @{
N  */
N
N/**
N  * @brief  Deinitializes the TIMERx peripheral registers to their default reset values.
N  * @param  TIMERx: where x can be 1 to 3 to select the TIMER peripheral.
N  * @retval None
N  */
Nvoid TIMER_DeInit ( MDR_TIMER_TypeDef* TIMERx ) {
N	/* Check the parameters */
N	assert_param(IS_TIMER_ALL_PERIPH(TIMERx));
X	((void)0);
N
N	TIMERx->CNTRL = 0;
N	TIMERx->CNT = 0;
N	TIMERx->PSG = 0;
N	TIMERx->ARR = 0;
N
N	TIMERx->CH1_CNTRL = 0;
N	TIMERx->CH2_CNTRL = 0;
N	TIMERx->CH3_CNTRL = 0;
N	TIMERx->CH4_CNTRL = 0;
N	TIMERx->CH1_CNTRL1 = 0;
N	TIMERx->CH2_CNTRL1 = 0;
N	TIMERx->CH3_CNTRL1 = 0;
N	TIMERx->CH4_CNTRL1 = 0;
N	TIMERx->CH1_CNTRL2 = 0;
N	TIMERx->CH2_CNTRL2 = 0;
N	TIMERx->CH3_CNTRL2 = 0;
N	TIMERx->CH4_CNTRL2 = 0;
N
N	TIMERx->CCR1 = 0;
N	TIMERx->CCR2 = 0;
N	TIMERx->CCR3 = 0;
N	TIMERx->CCR4 = 0;
N	TIMERx->CCR11 = 0;
N	TIMERx->CCR21 = 0;
N	TIMERx->CCR31 = 0;
N	TIMERx->CCR41 = 0;
N	TIMERx->CH1_DTG = 0;
N	TIMERx->CH2_DTG = 0;
N	TIMERx->CH3_DTG = 0;
N	TIMERx->CH4_DTG = 0;
N	TIMERx->BRKETR_CNTRL = 0;
N	TIMERx->STATUS = 0;
N	TIMERx->IE = 0;
N	TIMERx->DMA_RE = 0;
N#if defined(USE_MDR1986VE3) || defined (USE_MDR1986VE1T) /* For Cortex M1 */
X#if 0L || 0L  
S	TIMERx->DMA_REChx[0] = TIMERx->DMA_REChx[1] =
S			TIMERx->DMA_REChx[2] = TIMERx->DMA_REChx[3] = 0;
N#endif
N}
N
N/**
N  * @brief  Initializes the TIMERx Counter peripheral according to
N  *         the specified parameters in the TIMER_CntInitStruct.
N  * @param  TIMERx: where x can be 1 to 3 to select the TIMER peripheral.
N  * @param  TIMER_CntInitStruct: pointer to a TIMER_CntInitTypeDef structure
N  *         that contains the configuration information for the specified TIMER
N  *         peripheral.
N  * @retval None
N  */
Nvoid TIMER_CntInit(MDR_TIMER_TypeDef* TIMERx, const TIMER_CntInitTypeDef* TIMER_CntInitStruct)
N{
N  uint32_t tmpreg_CNTRL;
N  uint32_t tmpreg_BRKETR_CNTRL;
N
N  /* Check the parameters */
N  assert_param(IS_TIMER_ALL_PERIPH(TIMERx));
X  ((void)0);
N  assert_param(IS_TIMER_COUNTER_MODE(TIMER_CntInitStruct->TIMER_CounterMode));
X  ((void)0);
N  assert_param(IS_TIMER_COUNTER_DIR(TIMER_CntInitStruct->TIMER_CounterDirection));
X  ((void)0);
N  assert_param(IS_TIMER_EVENT_SOURCE(TIMER_CntInitStruct->TIMER_EventSource));
X  ((void)0);
N  assert_param(IS_TIMER_FILTER_SAMPLING(TIMER_CntInitStruct->TIMER_FilterSampling));
X  ((void)0);
N  assert_param(IS_TIMER_ARR_UPDATE_MODE(TIMER_CntInitStruct->TIMER_ARR_UpdateMode));
X  ((void)0);
N  assert_param(IS_TIMER_FILTER_CONF(TIMER_CntInitStruct->TIMER_ETR_FilterConf));
X  ((void)0);
N  assert_param(IS_TIMER_ETR_PRESCALER(TIMER_CntInitStruct->TIMER_ETR_Prescaler));
X  ((void)0);
N  assert_param(IS_TIMER_ETR_POLARITY(TIMER_CntInitStruct->TIMER_ETR_Polarity));
X  ((void)0);
N  assert_param(IS_TIMER_BRK_POLARITY(TIMER_CntInitStruct->TIMER_BRK_Polarity));
X  ((void)0);
N
N  TIMERx->CNT = TIMER_CntInitStruct->TIMER_IniCounter;
N  TIMERx->PSG = TIMER_CntInitStruct->TIMER_Prescaler;
N  TIMERx->ARR = TIMER_CntInitStruct->TIMER_Period;
N
N  /* Form new value for the TIMERx_CNTRL register */
N  tmpreg_CNTRL = TIMER_CntInitStruct->TIMER_CounterMode
N               + TIMER_CntInitStruct->TIMER_CounterDirection
N               + TIMER_CntInitStruct->TIMER_EventSource
N               + TIMER_CntInitStruct->TIMER_FilterSampling
N               + TIMER_CntInitStruct->TIMER_ARR_UpdateMode;
N
N  /* Configure TIMERx_CNTRL register with new value */
N  TIMERx->CNTRL = tmpreg_CNTRL;
N
N  /* Form new value for the TIMERx_BRKETR_CNTRL register */
N  tmpreg_BRKETR_CNTRL = (TIMER_CntInitStruct->TIMER_ETR_FilterConf << TIMER_BRKETR_CNTRL_ETR_FILTER_Pos)
X  tmpreg_BRKETR_CNTRL = (TIMER_CntInitStruct->TIMER_ETR_FilterConf << 4)
N                      + TIMER_CntInitStruct->TIMER_ETR_Prescaler
N                      + TIMER_CntInitStruct->TIMER_ETR_Polarity
N                      + TIMER_CntInitStruct->TIMER_BRK_Polarity;
N
N  /* Configure TIMERx_BRKETR_CNTRL register with new value */
N  TIMERx->BRKETR_CNTRL = tmpreg_BRKETR_CNTRL;
N}
N
N/**
N  * @brief  Fills each TIMER_CntInitStruct member with its default value.
N  * @param  TIMER_CntInitStruct: pointer to a TIMER_CntInitTypeDef structure
N  *         which will be initialized.
N  * @retval None
N  */
Nvoid TIMER_CntStructInit(TIMER_CntInitTypeDef* TIMER_CntInitStruct)
N{
N  TIMER_CntInitStruct->TIMER_IniCounter = 0;
N  TIMER_CntInitStruct->TIMER_Prescaler  = 0;
N  TIMER_CntInitStruct->TIMER_Period     = 0;
N  TIMER_CntInitStruct->TIMER_CounterMode      = TIMER_CntMode_ClkFixedDir;
X  TIMER_CntInitStruct->TIMER_CounterMode      = (((uint32_t)0x0) << 6);
N  TIMER_CntInitStruct->TIMER_CounterDirection = TIMER_CntDir_Up;
X  TIMER_CntInitStruct->TIMER_CounterDirection = (((uint32_t)0x0) << 3);
N  TIMER_CntInitStruct->TIMER_EventSource      = TIMER_EvSrc_None;
X  TIMER_CntInitStruct->TIMER_EventSource      = (((uint32_t)0x0) << 8);
N  TIMER_CntInitStruct->TIMER_FilterSampling   = TIMER_FDTS_TIMER_CLK_div_1;
X  TIMER_CntInitStruct->TIMER_FilterSampling   = (((uint32_t)0x0) << 4);
N  TIMER_CntInitStruct->TIMER_ARR_UpdateMode   = TIMER_ARR_Update_Immediately;
X  TIMER_CntInitStruct->TIMER_ARR_UpdateMode   = (((uint32_t)0x0) << 1);
N  TIMER_CntInitStruct->TIMER_ETR_FilterConf   = TIMER_Filter_1FF_at_TIMER_CLK;
X  TIMER_CntInitStruct->TIMER_ETR_FilterConf   = ((uint32_t)0x0);
N  TIMER_CntInitStruct->TIMER_ETR_Prescaler    = TIMER_ETR_Prescaler_None;
X  TIMER_CntInitStruct->TIMER_ETR_Prescaler    = (((uint32_t)0x0) << 2);
N  TIMER_CntInitStruct->TIMER_ETR_Polarity     = TIMER_ETRPolarity_NonInverted;
X  TIMER_CntInitStruct->TIMER_ETR_Polarity     = (((uint32_t)0x0) << 1);
N  TIMER_CntInitStruct->TIMER_BRK_Polarity     = TIMER_BRKPolarity_NonInverted;
X  TIMER_CntInitStruct->TIMER_BRK_Polarity     = (((uint32_t)0x0) << 0);
N}
N
N/**
N  * @brief  Enables or disables the specified TIMER peripheral.
N  * @param  TIMERx: where x can be 1 to 3 to select the TIMERx peripheral.
N  * @param  NewState: new state of the TIMERx peripheral.
N  *         This parameter can be: ENABLE or DISABLE.
N  * @retval None
N  */
Nvoid TIMER_Cmd(MDR_TIMER_TypeDef* TIMERx, FunctionalState NewState)
N{
N  uint32_t tmpreg_CNTRL;
N
N  /* Check the parameters */
N  assert_param(IS_TIMER_ALL_PERIPH(TIMERx));
X  ((void)0);
N  assert_param(IS_FUNCTIONAL_STATE(NewState));
X  ((void)0);
N
N  tmpreg_CNTRL = TIMERx->CNTRL;
N
N  /* Form new value */
N  if (NewState != DISABLE)
N  {
N    /* Enable TIMERx by setting the CNT_EN bit in the CNTRL register */
N    tmpreg_CNTRL |= TIMER_CNTRL_CNT_EN;
X    tmpreg_CNTRL |= ((uint32_t)0x00000001);
N  }
N  else
N  {
N    /* Disable TIMERx by resetting the CNT_EN bit in the CNTRL register */
N    tmpreg_CNTRL &= ~TIMER_CNTRL_CNT_EN;
X    tmpreg_CNTRL &= ~((uint32_t)0x00000001);
N  }
N
N  /* Configure CNTRL register with new value */
N  TIMERx->CNTRL = tmpreg_CNTRL;
N}
N
N/**
N  * @brief  Sets the TIMERx Counter Register value.
N  * @param  TIMERx: where x can be 1 to 3 to select the TIMER peripheral.
N  * @param  Counter: specifies the Counter register new value.
N  * @retval None
N  */
N#if defined (USE_MDR1986VE1T) || defined (USE_MDR1986VE3)
X#if 0L || 0L
Svoid TIMER_SetCounter(MDR_TIMER_TypeDef* TIMERx, uint32_t Counter)
N#elif defined (USE_MDR1986VE9x) || defined (USE_MDR1901VC1T)
X#elif 1L || 0L
Nvoid TIMER_SetCounter(MDR_TIMER_TypeDef* TIMERx, uint16_t Counter)
N#endif
N{
N  /* Check the parameters */
N  assert_param(IS_TIMER_ALL_PERIPH(TIMERx));
X  ((void)0);
N
N  TIMERx->CNT = Counter;
N}
N
N/**
N  * @brief  Sets the TIMERx Prescaler.
N  * @param  TIMERx: where x can be 1 to 3 to select the TIMER peripheral.
N  * @param  Prescaler: specifies the Prescaler Register value.
N  * @retval None
N  */
Nvoid TIMER_SetCntPrescaler(MDR_TIMER_TypeDef* TIMERx, uint16_t Prescaler)
N{
N  /* Check the parameters */
N  assert_param(IS_TIMER_ALL_PERIPH(TIMERx));
X  ((void)0);
N
N  TIMERx->PSG = Prescaler;
N}
N
N/**
N  * @brief  Sets the TIMERx Autoreload Register value.
N  * @param  TIMERx: where x can be 1 to 3 to select the TIMER peripheral.
N  * @param  Autoreload: specifies the Autoreload Register value.
N  * @retval None
N  */
N#if defined (USE_MDR1986VE1T) || defined (USE_MDR1986VE3)
X#if 0L || 0L
Svoid TIMER_SetCntAutoreload(MDR_TIMER_TypeDef* TIMERx, uint32_t Autoreload)
N#elif defined (USE_MDR1986VE9x) || defined (USE_MDR1901VC1T)
X#elif 1L || 0L
Nvoid TIMER_SetCntAutoreload(MDR_TIMER_TypeDef* TIMERx, uint16_t Autoreload)
N#endif
N{
N  /* Check the parameters */
N  assert_param(IS_TIMER_ALL_PERIPH(TIMERx));
X  ((void)0);
N
N  TIMERx->ARR = Autoreload;
N}
N
N/**
N  * @brief  Sets the TIMERx Autoreload Register value.
N  * @param  TIMERx: where x can be 1 to 3 to select the TIMER peripheral.
N  * @param  Autoreload: specifies the Autoreload Register value.
N  * @param  UpdateMode: specifies the Autoreload Register Update mode.
N  *         This parameter can be one of the following values:
N  *           @arg TIMER_ARR_Update_Immediately:     the ARR register is updated immediately;
N  *           @arg TIMER_ARR_Update_On_CNT_Overflow: the ARR register is updated at CNT count end.
N  * @retval None
N  */
N#if defined (USE_MDR1986VE1T) || defined (USE_MDR1986VE3)
X#if 0L || 0L
Svoid TIMER_CntAutoreloadConfig(MDR_TIMER_TypeDef* TIMERx, uint32_t Autoreload, uint32_t UpdateMode)
N#elif defined (USE_MDR1986VE9x) || defined (USE_MDR1901VC1T)
X#elif 1L || 0L
Nvoid TIMER_CntAutoreloadConfig(MDR_TIMER_TypeDef* TIMERx, uint16_t Autoreload, uint32_t UpdateMode)
N#endif
N{
N  uint32_t tmpreg_CNTRL;
N
N  /* Check the parameters */
N  assert_param(IS_TIMER_ALL_PERIPH(TIMERx));
X  ((void)0);
N  assert_param(IS_TIMER_ARR_UPDATE_MODE(UpdateMode));
X  ((void)0);
N
N  tmpreg_CNTRL = TIMERx->CNTRL;
N  tmpreg_CNTRL &= ~TIMER_CNTRL_ARRB_EN;
X  tmpreg_CNTRL &= ~((uint32_t)0x00000002);
N  tmpreg_CNTRL += UpdateMode;
N  TIMERx->CNTRL = tmpreg_CNTRL;
N
N  TIMERx->ARR = Autoreload;
N}
N
N/**
N  * @brief  Returns the TIMERx Counter value.
N  * @param  TIMERx: where x can be 1 to 3 to select the TIMER peripheral.
N  * @retval Counter Register value.
N  */
N#if defined (USE_MDR1986VE1T) || defined (USE_MDR1986VE3)
X#if 0L || 0L
Suint32_t TIMER_GetCounter(MDR_TIMER_TypeDef* TIMERx)
N#elif defined (USE_MDR1986VE9x) || defined (USE_MDR1901VC1T)
X#elif 1L || 0L
Nuint16_t TIMER_GetCounter(MDR_TIMER_TypeDef* TIMERx)
N#endif
N{
N  /* Check the parameters */
N  assert_param(IS_TIMER_ALL_PERIPH(TIMERx));
X  ((void)0);
N
N  return TIMERx->CNT;
N}
N
N/**
N  * @brief  Configures the TIMERx Counter Event source.
N  * @param  TIMERx: where x can be 1 to 3 to select the TIMER peripheral.
N  * @param  EventSource: specifies the Event source.
N  *         This parameter can be one of the following values:
N  *           @arg TIMER_EvSrc_None: no events;
N  *           @arg TIMER_EvSrc_TM1:  selects TIMER1 (CNT == ARR) event;
N  *           @arg TIMER_EvSrc_TM2:  selects TIMER2 (CNT == ARR) event;
N  *           @arg TIMER_EvSrc_TM3:  selects TIMER3 (CNT == ARR) event;
N  *           @arg TIMER_EvSrc_CH1:  selects Channel 1 event;
N  *           @arg TIMER_EvSrc_CH2:  selects Channel 2 event;
N  *           @arg TIMER_EvSrc_CH3:  selects Channel 3 event;
N  *           @arg TIMER_EvSrc_CH4:  selects Channel 4 event;
N  *           @arg TIMER_EvSrc_ETR:  selects ETR event.
N  * @retval None
N  */
Nvoid TIMER_CntEventSourceConfig(MDR_TIMER_TypeDef* TIMERx, uint32_t EventSource)
N{
N  uint32_t tmpreg_CNTRL;
N
N  /* Check the parameters */
N  assert_param(IS_TIMER_ALL_PERIPH(TIMERx));
X  ((void)0);
N  assert_param(IS_TIMER_EVENT_SOURCE(EventSource));
X  ((void)0);
N
N  tmpreg_CNTRL = TIMERx->CNTRL;
N  tmpreg_CNTRL &= ~TIMER_CNTRL_EVENT_SEL_Msk;
X  tmpreg_CNTRL &= ~((uint32_t)0x00000F00);
N  tmpreg_CNTRL += EventSource;
N  TIMERx->CNTRL = tmpreg_CNTRL;
N}
N
N/**
N  * @brief  Configures the TIMERx Filter Sampling clock.
N  * @param  TIMERx: where x can be 1 to 3 to select the TIMER peripheral.
N  * @param  Prescaler: specifies the Filter Sampling clock.
N  *         This parameter can be one of the following values:
N  *           @arg TIMER_FDTS_TIMER_CLK_div_1: the FDTS clock occures each TIMER_CLK clock;
N  *           @arg TIMER_FDTS_TIMER_CLK_div_2: the FDTS clock occures each 2-nd TIMER_CLK clock;
N  *           @arg TIMER_FDTS_TIMER_CLK_div_3: the FDTS clock occures each 3-rd TIMER_CLK clock;
N  *           @arg TIMER_FDTS_TIMER_CLK_div_4: the FDTS clock occures each 4-th TIMER_CLK clock.
N  * @retval None
N  */
Nvoid TIMER_FilterSamplingConfig(MDR_TIMER_TypeDef* TIMERx, uint32_t Prescaler)
N{
N  uint32_t tmpreg_CNTRL;
N
N  /* Check the parameters */
N  assert_param(IS_TIMER_ALL_PERIPH(TIMERx));
X  ((void)0);
N  assert_param(IS_TIMER_FILTER_SAMPLING(Prescaler));
X  ((void)0);
N
N  tmpreg_CNTRL = TIMERx->CNTRL;
N  tmpreg_CNTRL &= ~TIMER_CNTRL_FDTS_Msk;
X  tmpreg_CNTRL &= ~((uint32_t)0x00000030);
N  tmpreg_CNTRL += Prescaler;
N  TIMERx->CNTRL = tmpreg_CNTRL;
N}
N
N/**
N  * @brief  Configures the TIMERx count mode.
N  * @param  TIMERx: where x can be 1 to 3 to select the TIMER peripheral.
N  * @param  Mode: specifies the Timer count mode.
N  *         This parameter can be one of the following values:
N  *           @arg TIMER_CntMode_ClkFixedDir:  The Timer clock changes the TIMERx_CNT value. The count direction is not changed.
N  *           @arg TIMER_CntMode_ClkChangeDir: The Timer clock changes the TIMERx_CNT value. The count direction changes.
N  *           @arg TIMER_CntMode_EvtFixedDir:  The event changes the TIMERx_CNT value. The count direction is not changed.
N  *           @arg TIMER_CntMode_EvtChangeDir: The event changes the TIMERx_CNT value. The count direction changes.
N  * @retval None
N  */
Nvoid TIMER_CounterModeConfig(MDR_TIMER_TypeDef* TIMERx, uint32_t Mode)
N{
N  uint32_t tmpreg_CNTRL;
N
N  /* Check the parameters */
N  assert_param(IS_TIMER_ALL_PERIPH(TIMERx));
X  ((void)0);
N  assert_param(IS_TIMER_COUNTER_MODE(Mode));
X  ((void)0);
N
N  tmpreg_CNTRL = TIMERx->CNTRL;
N  tmpreg_CNTRL &= ~TIMER_CNTRL_CNT_MODE_Msk;
X  tmpreg_CNTRL &= ~((uint32_t)0x000000C0);
N  tmpreg_CNTRL += Mode;
N  TIMERx->CNTRL = tmpreg_CNTRL;
N}
N
N/**
N  * @brief  Configures the TIMERx count direction.
N  * @param  TIMERx: where x can be 1 to 3 to select the TIMER peripheral.
N  * @param  Direction: specifies the Timer count direction.
N  *         This parameter can be one of the following values:
N  *           @arg TIMER_CntDir_Up: increments the Timer TIMERx_CNT counter value;
N  *           @arg TIMER_CntDir_Dn: decrements the Timer TIMERx_CNT counter value.
N  * @retval None
N  */
Nvoid TIMER_SetCounterDirection(MDR_TIMER_TypeDef* TIMERx, uint32_t Direction)
N{
N  uint32_t tmpreg_CNTRL;
N
N  /* Check the parameters */
N  assert_param(IS_TIMER_ALL_PERIPH(TIMERx));
X  ((void)0);
N  assert_param(IS_TIMER_COUNTER_DIR(Direction));
X  ((void)0);
N
N  tmpreg_CNTRL = TIMERx->CNTRL;
N  tmpreg_CNTRL &= ~TIMER_CNTRL_DIR;
X  tmpreg_CNTRL &= ~((uint32_t)0x00000008);
N  tmpreg_CNTRL += Direction;
N  TIMERx->CNTRL = tmpreg_CNTRL;
N}
N
N/**
N  * @brief  Configures the TIMERx count direction.
N  * @param  TIMERx: where x can be 1 to 3 to select the TIMER peripheral.
N  * @param  Prescaler: specifies the ETR signal prescaler value.
N  *         This parameter can be one of the following values:
N  *           @arg TIMER_ETR_Prescaler_None : no division of input frequency;
N  *           @arg TIMER_ETR_Prescaler_div_2: selects input frequency divider by 2;
N  *           @arg TIMER_ETR_Prescaler_div_4: selects input frequency divider by 4;
N  *           @arg TIMER_ETR_Prescaler_div_8: selects input frequency divider by 8.
N  * @param  Polarity: enables or disables inversion on ETR input.
N  *         This parameter can be one of the following values:
N  *           @arg TIMER_ETRPolarity_NonInverted: no inversion of the ETR input;
N  *           @arg TIMER_ETRPolarity_Inverted:    the ETR input is inverted.
N  * @param  Filter: specifies the ETR Filter configuration.
N  *         This parameter can be one of the following values:
N  *           @arg TIMER_Filter_1FF_at_TIMER_CLK:   signal is latched by 1 trigger  at TIMER_CLK clock frequency;
N  *           @arg TIMER_Filter_2FF_at_TIMER_CLK:   signal is latched by 2 triggers at TIMER_CLK clock frequency;
N  *           @arg TIMER_Filter_4FF_at_TIMER_CLK:   signal is latched by 4 triggers at TIMER_CLK clock frequency;
N  *           @arg TIMER_Filter_8FF_at_TIMER_CLK:   signal is latched by 8 triggers at TIMER_CLK clock frequency;
N  *           @arg TIMER_Filter_6FF_at_FTDS_div_2:  signal is latched by 6 triggers at FDTS/2  clock frequency;
N  *           @arg TIMER_Filter_8FF_at_FTDS_div_2:  signal is latched by 8 triggers at FDTS/2  clock frequency;
N  *           @arg TIMER_Filter_6FF_at_FTDS_div_4:  signal is latched by 6 triggers at FDTS/4  clock frequency;
N  *           @arg TIMER_Filter_8FF_at_FTDS_div_4:  signal is latched by 8 triggers at FDTS/4  clock frequency;
N  *           @arg TIMER_Filter_6FF_at_FTDS_div_8:  signal is latched by 6 triggers at FDTS/8  clock frequency;
N  *           @arg TIMER_Filter_8FF_at_FTDS_div_8:  signal is latched by 8 triggers at FDTS/8  clock frequency;
N  *           @arg TIMER_Filter_5FF_at_FTDS_div_16: signal is latched by 5 triggers at FDTS/16 clock frequency;
N  *           @arg TIMER_Filter_6FF_at_FTDS_div_16: signal is latched by 6 triggers at FDTS/16 clock frequency;
N  *           @arg TIMER_Filter_8FF_at_FTDS_div_16: signal is latched by 8 triggers at FDTS/16 clock frequency;
N  *           @arg TIMER_Filter_5FF_at_FTDS_div_32: signal is latched by 5 triggers at FDTS/32 clock frequency;
N  *           @arg TIMER_Filter_6FF_at_FTDS_div_32: signal is latched by 6 triggers at FDTS/32 clock frequency;
N  *           @arg TIMER_Filter_8FF_at_FTDS_div_32: signal is latched by 8 triggers at FDTS/32 clock frequency.
N  * @retval None
N  */
Nvoid TIMER_ETRInputConfig(MDR_TIMER_TypeDef* TIMERx, uint32_t Prescaler, uint32_t Polarity, uint32_t Filter)
N{
N  uint32_t tmpreg_BRKETR_CNTRL;
N
N  /* Check the parameters */
N  assert_param(IS_TIMER_ALL_PERIPH(TIMERx));
X  ((void)0);
N  assert_param(IS_TIMER_ETR_PRESCALER(Prescaler));
X  ((void)0);
N  assert_param(IS_TIMER_ETR_POLARITY(Polarity));
X  ((void)0);
N  assert_param(IS_TIMER_FILTER_CONF(Filter));
X  ((void)0);
N
N  tmpreg_BRKETR_CNTRL = TIMERx->BRKETR_CNTRL;
N  tmpreg_BRKETR_CNTRL &= ~(TIMER_BRKETR_CNTRL_ETR_PSC_Msk + TIMER_BRKETR_CNTRL_ETR_INV + TIMER_BRKETR_CNTRL_ETR_FILTER_Msk);
X  tmpreg_BRKETR_CNTRL &= ~(((uint32_t)0x0000000C) + ((uint32_t)0x00000002) + ((uint32_t)0x000000F0));
N  tmpreg_BRKETR_CNTRL += Prescaler + Polarity + (Filter << TIMER_BRKETR_CNTRL_ETR_FILTER_Pos);
X  tmpreg_BRKETR_CNTRL += Prescaler + Polarity + (Filter << 4);
N  TIMERx->BRKETR_CNTRL = tmpreg_BRKETR_CNTRL;
N}
N
N/**
N  * @brief  Configures the TIMERx ETR Filter peripheral.
N  * @param  TIMERx: where x can be 1 to 3 to select the TIMER peripheral.
N  * @param  Filter: specifies the ETR Filter configuration.
N  *         This parameter can be one of the following values:
N  *           @arg TIMER_Filter_1FF_at_TIMER_CLK:   signal is latched by 1 trigger  at TIMER_CLK clock frequency;
N  *           @arg TIMER_Filter_2FF_at_TIMER_CLK:   signal is latched by 2 triggers at TIMER_CLK clock frequency;
N  *           @arg TIMER_Filter_4FF_at_TIMER_CLK:   signal is latched by 4 triggers at TIMER_CLK clock frequency;
N  *           @arg TIMER_Filter_8FF_at_TIMER_CLK:   signal is latched by 8 triggers at TIMER_CLK clock frequency;
N  *           @arg TIMER_Filter_6FF_at_FTDS_div_2:  signal is latched by 6 triggers at FDTS/2  clock frequency;
N  *           @arg TIMER_Filter_8FF_at_FTDS_div_2:  signal is latched by 8 triggers at FDTS/2  clock frequency;
N  *           @arg TIMER_Filter_6FF_at_FTDS_div_4:  signal is latched by 6 triggers at FDTS/4  clock frequency;
N  *           @arg TIMER_Filter_8FF_at_FTDS_div_4:  signal is latched by 8 triggers at FDTS/4  clock frequency;
N  *           @arg TIMER_Filter_6FF_at_FTDS_div_8:  signal is latched by 6 triggers at FDTS/8  clock frequency;
N  *           @arg TIMER_Filter_8FF_at_FTDS_div_8:  signal is latched by 8 triggers at FDTS/8  clock frequency;
N  *           @arg TIMER_Filter_5FF_at_FTDS_div_16: signal is latched by 5 triggers at FDTS/16 clock frequency;
N  *           @arg TIMER_Filter_6FF_at_FTDS_div_16: signal is latched by 6 triggers at FDTS/16 clock frequency;
N  *           @arg TIMER_Filter_8FF_at_FTDS_div_16: signal is latched by 8 triggers at FDTS/16 clock frequency;
N  *           @arg TIMER_Filter_5FF_at_FTDS_div_32: signal is latched by 5 triggers at FDTS/32 clock frequency;
N  *           @arg TIMER_Filter_6FF_at_FTDS_div_32: signal is latched by 6 triggers at FDTS/32 clock frequency;
N  *           @arg TIMER_Filter_8FF_at_FTDS_div_32: signal is latched by 8 triggers at FDTS/32 clock frequency.
N  * @retval None
N  */
Nvoid TIMER_ETRFilterConfig(MDR_TIMER_TypeDef* TIMERx, uint32_t Filter)
N{
N  uint32_t tmpreg_BRKETR_CNTRL;
N
N  /* Check the parameters */
N  assert_param(IS_TIMER_ALL_PERIPH(TIMERx));
X  ((void)0);
N  assert_param(IS_TIMER_FILTER_CONF(Filter));
X  ((void)0);
N
N  tmpreg_BRKETR_CNTRL = TIMERx->BRKETR_CNTRL;
N  tmpreg_BRKETR_CNTRL &= ~TIMER_BRKETR_CNTRL_ETR_FILTER_Msk;
X  tmpreg_BRKETR_CNTRL &= ~((uint32_t)0x000000F0);
N  tmpreg_BRKETR_CNTRL += Filter << TIMER_BRKETR_CNTRL_ETR_FILTER_Pos;
X  tmpreg_BRKETR_CNTRL += Filter << 4;
N  TIMERx->BRKETR_CNTRL = tmpreg_BRKETR_CNTRL;
N}
N
N/**
N  * @brief  Configures the TIMERx ETR signal prescaler value.
N  * @param  TIMERx: where x can be 1 to 3 to select the TIMER peripheral.
N  * @param  Prescaler: specifies the ETR signal prescaler value.
N  *         This parameter can be one of the following values:
N  *           @arg TIMER_ETR_Prescaler_None : no division of input frequency;
N  *           @arg TIMER_ETR_Prescaler_div_2: selects input frequency divider by 2;
N  *           @arg TIMER_ETR_Prescaler_div_4: selects input frequency divider by 4;
N  *           @arg TIMER_ETR_Prescaler_div_8: selects input frequency divider by 8.
N  * @retval None
N  */
Nvoid TIMER_ETRPrescalerConfig(MDR_TIMER_TypeDef* TIMERx, uint32_t Prescaler)
N{
N  uint32_t tmpreg_BRKETR_CNTRL;
N
N  /* Check the parameters */
N  assert_param(IS_TIMER_ALL_PERIPH(TIMERx));
X  ((void)0);
N  assert_param(IS_TIMER_ETR_PRESCALER(Prescaler));
X  ((void)0);
N
N  tmpreg_BRKETR_CNTRL = TIMERx->BRKETR_CNTRL;
N  tmpreg_BRKETR_CNTRL &= ~TIMER_BRKETR_CNTRL_ETR_PSC_Msk;
X  tmpreg_BRKETR_CNTRL &= ~((uint32_t)0x0000000C);
N  tmpreg_BRKETR_CNTRL += Prescaler;
N  TIMERx->BRKETR_CNTRL = tmpreg_BRKETR_CNTRL;
N}
N
N/**
N  * @brief  Configures the TIMERx ETR input inversion.
N  * @param  TIMERx: where x can be 1 to 3 to select the TIMER peripheral.
N  * @param  Polarity: enables or disables inversion on ETR input.
N  *         This parameter can be one of the following values:
N  *           @arg TIMER_ETRPolarity_NonInverted: no inversion of the ETR input;
N  *           @arg TIMER_ETRPolarity_Inverted:    the ETR input is inverted.
N  * @retval None
N  */
Nvoid TIMER_ETRPolarityConfig(MDR_TIMER_TypeDef* TIMERx, uint32_t Polarity)
N{
N  uint32_t tmpreg_BRKETR_CNTRL;
N
N  /* Check the parameters */
N  assert_param(IS_TIMER_ALL_PERIPH(TIMERx));
X  ((void)0);
N  assert_param(IS_TIMER_ETR_POLARITY(Polarity));
X  ((void)0);
N
N  tmpreg_BRKETR_CNTRL = TIMERx->BRKETR_CNTRL;
N  tmpreg_BRKETR_CNTRL &= ~TIMER_BRKETR_CNTRL_ETR_INV;
X  tmpreg_BRKETR_CNTRL &= ~((uint32_t)0x00000002);
N  tmpreg_BRKETR_CNTRL += Polarity;
N  TIMERx->BRKETR_CNTRL = tmpreg_BRKETR_CNTRL;
N}
N
N/**
N  * @brief  Configures the TIMERx BRK input inversion.
N  * @param  TIMERx: where x can be 1 to 3 to select the TIMER peripheral.
N  * @param  Polarity: enables or disables inversion on BRK input.
N  *         This parameter can be one of the following values:
N  *           @arg TIMER_BRKPolarity_NonInverted: no inversion of the BRK input;
N  *           @arg TIMER_BRKPolarity_Inverted:    the BRK input is inverted.
N  * @retval None
N  */
Nvoid TIMER_BRKPolarityConfig(MDR_TIMER_TypeDef* TIMERx, uint32_t Polarity)
N{
N  uint32_t tmpreg_BRKETR_CNTRL;
N
N  /* Check the parameters */
N  assert_param(IS_TIMER_ALL_PERIPH(TIMERx));
X  ((void)0);
N  assert_param(IS_TIMER_BRK_POLARITY(Polarity));
X  ((void)0);
N
N  tmpreg_BRKETR_CNTRL = TIMERx->BRKETR_CNTRL;
N  tmpreg_BRKETR_CNTRL &= ~TIMER_BRKETR_CNTRL_BRK_INV;
X  tmpreg_BRKETR_CNTRL &= ~((uint32_t)0x00000001);
N  tmpreg_BRKETR_CNTRL += Polarity;
N  TIMERx->BRKETR_CNTRL = tmpreg_BRKETR_CNTRL;
N}
N
N/**
N  * @brief  Returns the TIMERx count direction.
N  * @param  TIMERx: where x can be 1 to 3 to select the TIMER peripheral.
N  * @retval The current Timer count direction (TIMER_CntDir_Up or TIMER_CntDir_Dn)
N  */
Nuint32_t TIMER_GetCounterDirection(MDR_TIMER_TypeDef* TIMERx)
N{
N  uint32_t bitstatus;
N
N  /* Check the parameters */
N  assert_param(IS_TIMER_ALL_PERIPH(TIMERx));
X  ((void)0);
N
N  if ((TIMERx->CNTRL & TIMER_CNTRL_DIR) == 0)
X  if ((TIMERx->CNTRL & ((uint32_t)0x00000008)) == 0)
N  {
N    bitstatus = TIMER_CntDir_Up;
X    bitstatus = (((uint32_t)0x0) << 3);
N  }
N  else
N  {
N    bitstatus = TIMER_CntDir_Dn;
X    bitstatus = (((uint32_t)0x1) << 3);
N  }
N
N  return bitstatus;
N}
N
N/**
N  * @brief  Checks whether the TIMERx WR_CMPL flag is set or not.
N  * @param  TIMERx: where x can be 1 to 3 to select the TIMER peripheral.
N  * @retval The WR_CMPL flag current state (SET or RESET).
N  */
NFlagStatus TIMER_GetCntWriteComplete(MDR_TIMER_TypeDef* TIMERx)
N{
N  FlagStatus bitstatus;
N
N  /* Check the parameters */
N  assert_param(IS_TIMER_ALL_PERIPH(TIMERx));
X  ((void)0);
N
N  if ((TIMERx->CNTRL & TIMER_CNTRL_WR_CMPL) == 0)
X  if ((TIMERx->CNTRL & ((uint32_t)0x00000004)) == 0)
N  {
N    bitstatus = RESET;
N  }
N  else
N  {
N    bitstatus = SET;
N  }
N
N  return bitstatus;
N}
N
N/**
N  * @brief  Initializes the TIMERx Channel peripheral according to
N  *         the specified parameters in the TIMER_ChnInitStruct.
N  * @param  TIMERx: where x can be 1 to 3 to select the TIMER peripheral.
N  * @param  TIMER_ChnInitStruct: pointer to a TIMER_ChnInitTypeDef structure
N  *         that contains the configuration information for the specified
N  *         TIMER Channel peripheral.
N  * @retval None
N  */
Nvoid TIMER_ChnInit(MDR_TIMER_TypeDef* TIMERx, const TIMER_ChnInitTypeDef* TIMER_ChnInitStruct)
N{
N  uint32_t tmpreg_CH_Number;
N  uint32_t tmpreg_CH_CNTRL;
N  uint32_t tmpreg_CH_CNTRL2;
N
N  /* Check the parameters */
N  assert_param(IS_TIMER_ALL_PERIPH(TIMERx));
X  ((void)0);
N  assert_param(IS_TIMER_CHANNEL_NUMBER(TIMER_ChnInitStruct->TIMER_CH_Number));
X  ((void)0);
N  assert_param(IS_TIMER_CHANNEL_MODE(TIMER_ChnInitStruct->TIMER_CH_Mode));
X  ((void)0);
N  assert_param(IS_FUNCTIONAL_STATE(TIMER_ChnInitStruct->TIMER_CH_ETR_Ena));
X  ((void)0);
N  assert_param(IS_TIMER_CHANNEL_ETR_RESET_CONFIG(TIMER_ChnInitStruct->TIMER_CH_ETR_Reset));
X  ((void)0);
N  assert_param(IS_TIMER_CHANNEL_BRK_RESET_CONFIG(TIMER_ChnInitStruct->TIMER_CH_BRK_Reset));
X  ((void)0);
N  assert_param(IS_TIMER_CHANNEL_REF_FORMAT(TIMER_ChnInitStruct->TIMER_CH_REF_Format));
X  ((void)0);
N  assert_param(IS_TIMER_CHANNEL_PRESCALER(TIMER_ChnInitStruct->TIMER_CH_Prescaler));
X  ((void)0);
N  assert_param(IS_TIMER_CHANNEL_EVENT_SOURCE(TIMER_ChnInitStruct->TIMER_CH_EventSource));
X  ((void)0);
N  assert_param(IS_TIMER_FILTER_CONF(TIMER_ChnInitStruct->TIMER_CH_FilterConf));
X  ((void)0);
N  assert_param(IS_TIMER_CHANNEL_CCR_UPDATE_MODE(TIMER_ChnInitStruct->TIMER_CH_CCR_UpdateMode));
X  ((void)0);
N  assert_param(IS_FUNCTIONAL_STATE(TIMER_ChnInitStruct->TIMER_CH_CCR1_Ena));
X  ((void)0);
N  assert_param(IS_TIMER_CHANNEL_CCR1_EVENT_SOURCE(TIMER_ChnInitStruct->TIMER_CH_CCR1_EventSource));
X  ((void)0);
N
N  tmpreg_CH_CNTRL = TIMER_ChnInitStruct->TIMER_CH_Mode
N                  + TIMER_ChnInitStruct->TIMER_CH_ETR_Reset
N                  + TIMER_ChnInitStruct->TIMER_CH_BRK_Reset
N                  + TIMER_ChnInitStruct->TIMER_CH_REF_Format
N                  + (TIMER_ChnInitStruct->TIMER_CH_Prescaler << TIMER_CH_CNTRL_CHPSC_Pos)
X                  + (TIMER_ChnInitStruct->TIMER_CH_Prescaler << 6)
N                  + TIMER_ChnInitStruct->TIMER_CH_EventSource
N                  + (TIMER_ChnInitStruct->TIMER_CH_FilterConf << TIMER_CH_CNTRL_CHFLTR_Pos);
X                  + (TIMER_ChnInitStruct->TIMER_CH_FilterConf << 0);
N
N  if (TIMER_ChnInitStruct->TIMER_CH_ETR_Ena != DISABLE)
N  {
N    tmpreg_CH_CNTRL += TIMER_CH_CNTRL_ETREN;
X    tmpreg_CH_CNTRL += ((uint32_t)0x00002000);
N  }
N
N  tmpreg_CH_Number = TIMER_ChnInitStruct->TIMER_CH_Number;
N
N  *(&TIMERx->CH1_CNTRL + tmpreg_CH_Number) = tmpreg_CH_CNTRL;
N
N  tmpreg_CH_CNTRL2 = TIMER_ChnInitStruct->TIMER_CH_CCR_UpdateMode
N                   + TIMER_ChnInitStruct->TIMER_CH_CCR1_EventSource;
N
N  if (TIMER_ChnInitStruct->TIMER_CH_CCR1_Ena != DISABLE)
N  {
N    tmpreg_CH_CNTRL2 += TIMER_CH_CNTRL2_CCR1_EN;
X    tmpreg_CH_CNTRL2 += ((uint32_t)0x00000004);
N  }
N
N  *(&TIMERx->CH1_CNTRL2 + tmpreg_CH_Number) = tmpreg_CH_CNTRL2;
N}
N
N/**
N  * @brief  Fills each TIMER_ChnInitStruct member with its default value.
N  * @param  TIMER_ChnInitStruct : pointer to a TIMER_ChnInitTypeDef structure
N  *         which will be initialized.
N  * @retval None
N  */
Nvoid TIMER_ChnStructInit(TIMER_ChnInitTypeDef* TIMER_ChnInitStruct)
N{
N  TIMER_ChnInitStruct->TIMER_CH_Number           = TIMER_CHANNEL1;
X  TIMER_ChnInitStruct->TIMER_CH_Number           = ((uint32_t)0x0);
N  TIMER_ChnInitStruct->TIMER_CH_Mode             = TIMER_CH_MODE_PWM;
X  TIMER_ChnInitStruct->TIMER_CH_Mode             = (((uint32_t)0x0) << 15);
N  TIMER_ChnInitStruct->TIMER_CH_ETR_Ena          = DISABLE;
N  TIMER_ChnInitStruct->TIMER_CH_ETR_Reset        = TIMER_CH_ETR_RESET_Disable;
X  TIMER_ChnInitStruct->TIMER_CH_ETR_Reset        = (((uint32_t)0x0) << 13);
N  TIMER_ChnInitStruct->TIMER_CH_BRK_Reset        = TIMER_CH_BRK_RESET_Disable;
X  TIMER_ChnInitStruct->TIMER_CH_BRK_Reset        = (((uint32_t)0x0) << 12);
N  TIMER_ChnInitStruct->TIMER_CH_REF_Format       = TIMER_CH_REF_Format0;
X  TIMER_ChnInitStruct->TIMER_CH_REF_Format       = (((uint32_t)0x0) << 9);
N  TIMER_ChnInitStruct->TIMER_CH_Prescaler        = TIMER_CH_Prescaler_None;
X  TIMER_ChnInitStruct->TIMER_CH_Prescaler        = ((uint32_t)0x0);
N  TIMER_ChnInitStruct->TIMER_CH_EventSource      = TIMER_CH_EvSrc_PE;
X  TIMER_ChnInitStruct->TIMER_CH_EventSource      = (((uint32_t)0x0) << 4);
N  TIMER_ChnInitStruct->TIMER_CH_FilterConf       = TIMER_Filter_1FF_at_TIMER_CLK;
X  TIMER_ChnInitStruct->TIMER_CH_FilterConf       = ((uint32_t)0x0);
N  TIMER_ChnInitStruct->TIMER_CH_CCR_UpdateMode   = TIMER_CH_CCR_Update_Immediately;
X  TIMER_ChnInitStruct->TIMER_CH_CCR_UpdateMode   = (((uint32_t)0x0) << 3);
N  TIMER_ChnInitStruct->TIMER_CH_CCR1_Ena         = DISABLE;
N  TIMER_ChnInitStruct->TIMER_CH_CCR1_EventSource = TIMER_CH_CCR1EvSrc_PE;
X  TIMER_ChnInitStruct->TIMER_CH_CCR1_EventSource = (((uint32_t)0x0) << 0);
N}
N
N/**
N  * @brief  Sets the TIMERx Channel Capture Compare Register (CCR) value.
N  * @param  TIMERx: where x can be 1 to 3 to select the TIMER peripheral.
N  * @param  Channel: specifies the Timer Channel number.
N  *         This parameter can be one of the following values:
N  *           @arg TIMER_CHANNEL1: specifies TIMERx Channel 1;
N  *           @arg TIMER_CHANNEL2: specifies TIMERx Channel 2;
N  *           @arg TIMER_CHANNEL3: specifies TIMERx Channel 3;
N  *           @arg TIMER_CHANNEL4: specifies TIMERx Channel 4.
N  * @param  Compare: specifies the Capture Compare Register (CCR) new value.
N  * @retval None
N  */
N#if defined (USE_MDR1986VE1T) || defined (USE_MDR1986VE3)
X#if 0L || 0L
Svoid TIMER_SetChnCompare(MDR_TIMER_TypeDef* TIMERx, uint32_t Channel, uint32_t Compare)
N#elif defined (USE_MDR1986VE9x) || defined (USE_MDR1901VC1T)
X#elif 1L || 0L
Nvoid TIMER_SetChnCompare(MDR_TIMER_TypeDef* TIMERx, uint32_t Channel, uint16_t Compare)
N#endif
N{
N  __IO uint32_t *tmpreg_CCRx;
X  volatile uint32_t *tmpreg_CCRx;
N
N  /* Check the parameters */
N  assert_param(IS_TIMER_ALL_PERIPH(TIMERx));
X  ((void)0);
N  assert_param(IS_TIMER_CHANNEL_NUMBER(Channel));
X  ((void)0);
N
N  tmpreg_CCRx = &TIMERx->CCR1 + Channel;
N  *tmpreg_CCRx = Compare;
N}
N
N/**
N  * @brief  Sets the TIMERx Channel Capture Compare Register1 (CCR1) value.
N  * @param  TIMERx: where x can be 1 to 3 to select the TIMER peripheral.
N  * @param  Channel: specifies the Timer Channel number.
N  *         This parameter can be one of the following values:
N  *           @arg TIMER_CHANNEL1: specifies TIMERx Channel 1;
N  *           @arg TIMER_CHANNEL2: specifies TIMERx Channel 2;
N  *           @arg TIMER_CHANNEL3: specifies TIMERx Channel 3;
N  *           @arg TIMER_CHANNEL4: specifies TIMERx Channel 4.
N  * @param  Compare: specifies the Capture Compare Register1 (CCR1) new value.
N  * @retval None
N  */
N#if defined (USE_MDR1986VE1T) || defined (USE_MDR1986VE3)
X#if 0L || 0L
Svoid TIMER_SetChnCompare1(MDR_TIMER_TypeDef* TIMERx, uint32_t Channel, uint32_t Compare)
N#elif defined (USE_MDR1986VE9x) || defined (USE_MDR1901VC1T)
X#elif 1L || 0L
Nvoid TIMER_SetChnCompare1(MDR_TIMER_TypeDef* TIMERx, uint32_t Channel, uint16_t Compare)
N#endif
N{
N  __IO uint32_t *tmpreg_CCR1x;
X  volatile uint32_t *tmpreg_CCR1x;
N
N  /* Check the parameters */
N  assert_param(IS_TIMER_ALL_PERIPH(TIMERx));
X  ((void)0);
N  assert_param(IS_TIMER_CHANNEL_NUMBER(Channel));
X  ((void)0);
N
N  tmpreg_CCR1x = &TIMERx->CCR11 + Channel;
N  *tmpreg_CCR1x = Compare;
N}
N
N/**
N  * @brief  Sets the TIMERx Channel Capture Compare Register (CCR) value.
N  * @param  TIMERx: where x can be 1 to 3 to select the TIMER peripheral.
N  * @param  Channel: specifies the Timer Channel number.
N  *         This parameter can be one of the following values:
N  *           @arg TIMER_CHANNEL1: specifies TIMERx Channel 1;
N  *           @arg TIMER_CHANNEL2: specifies TIMERx Channel 2;
N  *           @arg TIMER_CHANNEL3: specifies TIMERx Channel 3;
N  *           @arg TIMER_CHANNEL4: specifies TIMERx Channel 4.
N  * @param  Compare: specifies the Capture Compare Register (CCR) new value.
N  * @param  UpdateMode: specifies the Capture Compare Register Update mode.
N  *         This parameter can be one of the following values:
N  *           @arg TIMER_CH_CCR_Update_Immediately: the CCR register is updated immediately;
N  *           @arg TIMER_CH_CCR_Update_On_CNT_eq_0: the CCR register is updated at (CNT == 0) condition.
N  * @retval None
N  */
N#if defined (USE_MDR1986VE1T) || defined (USE_MDR1986VE3)
X#if 0L || 0L
Svoid TIMER_ChnCompareConfig(MDR_TIMER_TypeDef* TIMERx, uint32_t Channel, uint32_t Compare, uint32_t UpdateMode)
N#elif defined (USE_MDR1986VE9x) || defined (USE_MDR1901VC1T)
X#elif 1L || 0L
Nvoid TIMER_ChnCompareConfig(MDR_TIMER_TypeDef* TIMERx, uint32_t Channel, uint16_t Compare, uint32_t UpdateMode)
N#endif
N{
N  __IO uint32_t *tmpreg_CNTRL2x;
X  volatile uint32_t *tmpreg_CNTRL2x;
N  __IO uint32_t *tmpreg_CCRx;
X  volatile uint32_t *tmpreg_CCRx;
N  uint32_t tmpreg_CNTRL2;
N
N  /* Check the parameters */
N  assert_param(IS_TIMER_ALL_PERIPH(TIMERx));
X  ((void)0);
N  assert_param(IS_TIMER_CHANNEL_NUMBER(Channel));
X  ((void)0);
N  assert_param(IS_TIMER_ARR_UPDATE_MODE(UpdateMode));
X  ((void)0);
N
N  tmpreg_CNTRL2x = &TIMERx->CH1_CNTRL2 + Channel;
N
N  tmpreg_CNTRL2 = *tmpreg_CNTRL2x;
N  tmpreg_CNTRL2 &= ~TIMER_CH_CNTRL2_CCRRLD;
X  tmpreg_CNTRL2 &= ~((uint32_t)0x00000008);
N  tmpreg_CNTRL2 += UpdateMode;
N  *tmpreg_CNTRL2x = tmpreg_CNTRL2;
N
N  tmpreg_CCRx = &TIMERx->CCR1 + Channel;
N
N  *tmpreg_CCRx = Compare;
N}
N
N/**
N  * @brief  Sets the TIMERx Channel Capture Compare Register1 (CCR1) value.
N  * @param  TIMERx: where x can be 1 to 3 to select the TIMER peripheral.
N  * @param  Channel: specifies the Timer Channel number.
N  *         This parameter can be one of the following values:
N  *           @arg TIMER_CHANNEL1: specifies TIMERx Channel 1;
N  *           @arg TIMER_CHANNEL2: specifies TIMERx Channel 2;
N  *           @arg TIMER_CHANNEL3: specifies TIMERx Channel 3;
N  *           @arg TIMER_CHANNEL4: specifies TIMERx Channel 4.
N  * @param  Compare: specifies the Capture Compare Register1 (CCR1) new value.
N  * @param  UpdateMode: specifies the Capture Compare Register1 Update mode.
N  *         This parameter can be one of the following values:
N  *           @arg TIMER_CH_CCR_Update_Immediately: the CCR1 register is updated immediately;
N  *           @arg TIMER_CH_CCR_Update_On_CNT_eq_0: the CCR1 register is updated at (CNT == 0) condition.
N  * @retval None
N  */
N#if defined (USE_MDR1986VE1T) || defined (USE_MDR1986VE3)
X#if 0L || 0L
Svoid TIMER_ChnCompare1Config(MDR_TIMER_TypeDef* TIMERx, uint32_t Channel, uint32_t Compare, uint32_t UpdateMode)
N#elif defined (USE_MDR1986VE9x) || defined (USE_MDR1901VC1T)
X#elif 1L || 0L
Nvoid TIMER_ChnCompare1Config(MDR_TIMER_TypeDef* TIMERx, uint32_t Channel, uint16_t Compare, uint32_t UpdateMode)
N#endif
N{
N  __IO uint32_t *tmpreg_CNTRL2x;
X  volatile uint32_t *tmpreg_CNTRL2x;
N  __IO uint32_t *tmpreg_CCR1x;
X  volatile uint32_t *tmpreg_CCR1x;
N  uint32_t tmpreg_CNTRL2;
N
N  /* Check the parameters */
N  assert_param(IS_TIMER_ALL_PERIPH(TIMERx));
X  ((void)0);
N  assert_param(IS_TIMER_CHANNEL_NUMBER(Channel));
X  ((void)0);
N  assert_param(IS_TIMER_ARR_UPDATE_MODE(UpdateMode));
X  ((void)0);
N
N  tmpreg_CNTRL2x = &TIMERx->CH1_CNTRL2 + Channel;
N
N  tmpreg_CNTRL2 = *tmpreg_CNTRL2x;
N  tmpreg_CNTRL2 &= ~TIMER_CH_CNTRL2_CCRRLD;
X  tmpreg_CNTRL2 &= ~((uint32_t)0x00000008);
N  tmpreg_CNTRL2 += UpdateMode;
N  *tmpreg_CNTRL2x = tmpreg_CNTRL2;
N
N  tmpreg_CCR1x = &TIMERx->CCR11 + Channel;
N
N  *tmpreg_CCR1x = Compare;
N}
N
N/**
N  * @brief  Returns the TIMERx Channel Capture Compare Register (CCR) value.
N  * @param  TIMERx: where x can be 1 to 3 to select the TIMER peripheral.
N  * @param  Channel: specifies the Timer Channel number.
N  *         This parameter can be one of the following values:
N  *           @arg TIMER_CHANNEL1: specifies TIMERx Channel 1;
N  *           @arg TIMER_CHANNEL2: specifies TIMERx Channel 2;
N  *           @arg TIMER_CHANNEL3: specifies TIMERx Channel 3;
N  *           @arg TIMER_CHANNEL4: specifies TIMERx Channel 4.
N  * @retval Capture Compare Register (CCR) value.
N  */
N#if defined (USE_MDR1986VE1T) || defined (USE_MDR1986VE3)
X#if 0L || 0L
Suint32_t TIMER_GetChnCapture(MDR_TIMER_TypeDef* TIMERx, uint32_t Channel)
N#elif defined (USE_MDR1986VE9x) || defined (USE_MDR1901VC1T)
X#elif 1L || 0L
Nuint16_t TIMER_GetChnCapture(MDR_TIMER_TypeDef* TIMERx, uint32_t Channel)
N#endif
N{
N  __IO uint32_t *tmpreg_CCRx;
X  volatile uint32_t *tmpreg_CCRx;
N  uint32_t tmpreg;
N
N  /* Check the parameters */
N  assert_param(IS_TIMER_ALL_PERIPH(TIMERx));
X  ((void)0);
N  assert_param(IS_TIMER_CHANNEL_NUMBER(Channel));
X  ((void)0);
N
N  tmpreg_CCRx = &TIMERx->CCR1 + Channel;
N  tmpreg = *tmpreg_CCRx;
N
N  return tmpreg;
N}
N
N/**
N  * @brief  Returns the TIMERx Channel Capture Compare Register1 (CCR1) value.
N  * @param  TIMERx: where x can be 1 to 3 to select the TIMER peripheral.
N  * @param  Channel: specifies the Timer Channel number.
N  *         This parameter can be one of the following values:
N  *           @arg TIMER_CHANNEL1: specifies TIMERx Channel 1;
N  *           @arg TIMER_CHANNEL2: specifies TIMERx Channel 2;
N  *           @arg TIMER_CHANNEL3: specifies TIMERx Channel 3;
N  *           @arg TIMER_CHANNEL4: specifies TIMERx Channel 4.
N  * @retval Capture Compare Register1 (CCR1) value.
N  */
N#if defined (USE_MDR1986VE1T) || defined (USE_MDR1986VE3)
X#if 0L || 0L
Suint32_t TIMER_GetChnCapture1(MDR_TIMER_TypeDef* TIMERx, uint32_t Channel)
N#elif defined (USE_MDR1986VE9x) || defined (USE_MDR1901VC1T)
X#elif 1L || 0L
Nuint16_t TIMER_GetChnCapture1(MDR_TIMER_TypeDef* TIMERx, uint32_t Channel)
N#endif
N{
N  __IO uint32_t *tmpreg_CCR1x;
X  volatile uint32_t *tmpreg_CCR1x;
N  uint32_t tmpreg;
N
N  /* Check the parameters */
N  assert_param(IS_TIMER_ALL_PERIPH(TIMERx));
X  ((void)0);
N  assert_param(IS_TIMER_CHANNEL_NUMBER(Channel));
X  ((void)0);
N
N  tmpreg_CCR1x = &TIMERx->CCR11 + Channel;
N  tmpreg = *tmpreg_CCR1x;
N
N  return tmpreg;
N}
N
N/**
N  * @brief  Enables or disables the TIMERx Channel ETR input.
N  * @param  TIMERx: where x can be 1 to 3 to select the TIMER peripheral.
N  * @param  Channel: specifies the Timer Channel number.
N  *         This parameter can be one of the following values:
N  *           @arg TIMER_CHANNEL1: specifies TIMERx Channel 1;
N  *           @arg TIMER_CHANNEL2: specifies TIMERx Channel 2;
N  *           @arg TIMER_CHANNEL3: specifies TIMERx Channel 3;
N  *           @arg TIMER_CHANNEL4: specifies TIMERx Channel 4.
N  * @param  NewState: new state of the ETR enable (OCCE) bit.
N  *         This parameter can be: ENABLE or DISABLE.
N  * @retval None
N  */
Nvoid TIMER_ChnETR_Cmd(MDR_TIMER_TypeDef* TIMERx, uint32_t Channel, FunctionalState NewState)
N{
N  __IO uint32_t *tmpreg_CH_CNTRLx;
X  volatile uint32_t *tmpreg_CH_CNTRLx;
N  uint32_t tmpreg_CH_CNTRL;
N
N  /* Check the parameters */
N  assert_param(IS_TIMER_ALL_PERIPH(TIMERx));
X  ((void)0);
N  assert_param(IS_TIMER_CHANNEL_NUMBER(Channel));
X  ((void)0);
N  assert_param(IS_FUNCTIONAL_STATE(NewState));
X  ((void)0);
N
N  tmpreg_CH_CNTRLx = &TIMERx->CH1_CNTRL + Channel;
N
N  tmpreg_CH_CNTRL = *tmpreg_CH_CNTRLx;
N
N  /* Form new value */
N  if (NewState != DISABLE)
N  {
N    /* Enable TIMERx by setting the CNT_EN bit in the CNTRL register */
N    tmpreg_CH_CNTRL |= TIMER_CH_CNTRL_OCCE;
X    tmpreg_CH_CNTRL |= ((uint32_t)0x00000100);
N  }
N  else
N  {
N    /* Disable TIMERx by resetting the CNT_EN bit in the CNTRL register */
N    tmpreg_CH_CNTRL &= ~TIMER_CH_CNTRL_OCCE;
X    tmpreg_CH_CNTRL &= ~((uint32_t)0x00000100);
N  }
N
N  /* Configure CNTRL register with new value */
N  *tmpreg_CH_CNTRLx = tmpreg_CH_CNTRL;
N}
N
N/**
N  * @brief  Enables or disables TIMERx Channel ETR Reset.
N  * @param  TIMERx: where x can be 1 to 3 to select the TIMER peripheral.
N  * @param  Channel: specifies the Timer Channel number.
N  *         This parameter can be one of the following values:
N  *           @arg TIMER_CHANNEL1: specifies TIMERx Channel 1;
N  *           @arg TIMER_CHANNEL2: specifies TIMERx Channel 2;
N  *           @arg TIMER_CHANNEL3: specifies TIMERx Channel 3;
N  *           @arg TIMER_CHANNEL4: specifies TIMERx Channel 4.
N  * @param  NewState: new state of the ETR Reset enable.
N  *         This parameter can be one of the following values:
N  *           @arg TIMER_CH_ETR_RESET_Disable: disables ETR Reset;
N  *           @arg TIMER_CH_ETR_RESET_Enable:  enables ETR Reset.
N  * @retval None
N  */
Nvoid TIMER_ChnETRResetConfig(MDR_TIMER_TypeDef* TIMERx, uint32_t Channel, uint32_t NewState)
N{
N  __IO uint32_t *tmpreg_CH_CNTRLx;
X  volatile uint32_t *tmpreg_CH_CNTRLx;
N  uint32_t tmpreg_CH_CNTRL;
N
N  /* Check the parameters */
N  assert_param(IS_TIMER_ALL_PERIPH(TIMERx));
X  ((void)0);
N  assert_param(IS_TIMER_CHANNEL_NUMBER(Channel));
X  ((void)0);
N  assert_param(IS_TIMER_CHANNEL_ETR_RESET_CONFIG(NewState));
X  ((void)0);
N
N  tmpreg_CH_CNTRLx = &TIMERx->CH1_CNTRL + Channel;
N
N  tmpreg_CH_CNTRL = *tmpreg_CH_CNTRLx;
N  tmpreg_CH_CNTRL &= ~TIMER_CH_CNTRL_ETREN;
X  tmpreg_CH_CNTRL &= ~((uint32_t)0x00002000);
N  tmpreg_CH_CNTRL += NewState;
N  *tmpreg_CH_CNTRLx = tmpreg_CH_CNTRL;
N}
N
N/**
N  * @brief  Enables or disables TIMERx Channel BRK Reset.
N  * @param  TIMERx: where x can be 1 to 3 to select the TIMER peripheral.
N  * @param  Channel: specifies the Timer Channel number.
N  *         This parameter can be one of the following values:
N  *           @arg TIMER_CHANNEL1: specifies TIMERx Channel 1;
N  *           @arg TIMER_CHANNEL2: specifies TIMERx Channel 2;
N  *           @arg TIMER_CHANNEL3: specifies TIMERx Channel 3;
N  *           @arg TIMER_CHANNEL4: specifies TIMERx Channel 4.
N  * @param  NewState: new state of the BRK Reset enable.
N  *         This parameter can be one of the following values:
N  *           @arg TIMER_CH_BRK_RESET_Disable: disables BRK Reset;
N  *           @arg TIMER_CH_BRK_RESET_Enable:  enables BRK Reset.
N  * @retval None
N  */
Nvoid TIMER_ChnBRKResetConfig(MDR_TIMER_TypeDef* TIMERx, uint32_t Channel, uint32_t NewState)
N{
N  __IO uint32_t *tmpreg_CH_CNTRLx;
X  volatile uint32_t *tmpreg_CH_CNTRLx;
N  uint32_t tmpreg_CH_CNTRL;
N
N  /* Check the parameters */
N  assert_param(IS_TIMER_ALL_PERIPH(TIMERx));
X  ((void)0);
N  assert_param(IS_TIMER_CHANNEL_NUMBER(Channel));
X  ((void)0);
N  assert_param(IS_TIMER_CHANNEL_BRK_RESET_CONFIG(NewState));
X  ((void)0);
N
N  tmpreg_CH_CNTRLx = &TIMERx->CH1_CNTRL + Channel;
N
N  tmpreg_CH_CNTRL = *tmpreg_CH_CNTRLx;
N  tmpreg_CH_CNTRL &= ~TIMER_CH_CNTRL_BRKEN;
X  tmpreg_CH_CNTRL &= ~((uint32_t)0x00001000);
N  tmpreg_CH_CNTRL += NewState;
N  *tmpreg_CH_CNTRLx = tmpreg_CH_CNTRL;
N}
N
N/**
N  * @brief  Configures the TIMERx REF signal format.
N  * @param  TIMERx: where x can be 1 to 3 to select the TIMER peripheral.
N  * @param  Channel: specifies the Timer Channel number.
N  *         This parameter can be one of the following values:
N  *           @arg TIMER_CHANNEL1: specifies TIMERx Channel 1;
N  *           @arg TIMER_CHANNEL2: specifies TIMERx Channel 2;
N  *           @arg TIMER_CHANNEL3: specifies TIMERx Channel 3;
N  *           @arg TIMER_CHANNEL4: specifies TIMERx Channel 4.
N  * @param  Format: new value of the TIMERx REF format.
N  *         This parameter can be one of @ref TIMER_CH_REF_Format values.
N  * @retval None
N  */
Nvoid TIMER_ChnREFFormatConfig(MDR_TIMER_TypeDef* TIMERx, uint32_t Channel, uint32_t Format)
N{
N  __IO uint32_t *tmpreg_CH_CNTRLx;
X  volatile uint32_t *tmpreg_CH_CNTRLx;
N  uint32_t tmpreg_CH_CNTRL;
N
N  /* Check the parameters */
N  assert_param(IS_TIMER_ALL_PERIPH(TIMERx));
X  ((void)0);
N  assert_param(IS_TIMER_CHANNEL_NUMBER(Channel));
X  ((void)0);
N  assert_param(IS_TIMER_CHANNEL_REF_FORMAT(Format));
X  ((void)0);
N
N  tmpreg_CH_CNTRLx = &TIMERx->CH1_CNTRL + Channel;
N
N  tmpreg_CH_CNTRL = *tmpreg_CH_CNTRLx;
N  tmpreg_CH_CNTRL &= ~TIMER_CH_CNTRL_OCCM_Msk;
X  tmpreg_CH_CNTRL &= ~((uint32_t)0x00000E00);
N  tmpreg_CH_CNTRL += Format;
N  *tmpreg_CH_CNTRLx = tmpreg_CH_CNTRL;
N}
N
N/**
N  * @brief  Configures the TIMERx Capture prescaler value.
N  * @param  TIMERx: where x can be 1 to 3 to select the TIMER peripheral.
N  * @param  Channel: specifies the Timer Channel number.
N  *         This parameter can be one of the following values:
N  *           @arg TIMER_CHANNEL1: specifies TIMERx Channel 1;
N  *           @arg TIMER_CHANNEL2: specifies TIMERx Channel 2;
N  *           @arg TIMER_CHANNEL3: specifies TIMERx Channel 3;
N  *           @arg TIMER_CHANNEL4: specifies TIMERx Channel 4.
N  * @param  Prescaler: specifies the Capture signal prescaler value.
N  *         This parameter can be one of the following values:
N  *           @arg TIMER_CH_Prescaler_None : no division of input frequency;
N  *           @arg TIMER_CH_Prescaler_div_2: selects input frequency divider by 2;
N  *           @arg TIMER_CH_Prescaler_div_4: selects input frequency divider by 4;
N  *           @arg TIMER_CH_Prescaler_div_8: selects input frequency divider by 8.
N  * @retval None
N  */
Nvoid TIMER_ChnCapturePrescalerConfig(MDR_TIMER_TypeDef* TIMERx, uint32_t Channel, uint32_t Prescaler)
N{
N  __IO uint32_t *tmpreg_CH_CNTRLx;
X  volatile uint32_t *tmpreg_CH_CNTRLx;
N  uint32_t tmpreg_CH_CNTRL;
N
N  /* Check the parameters */
N  assert_param(IS_TIMER_ALL_PERIPH(TIMERx));
X  ((void)0);
N  assert_param(IS_TIMER_CHANNEL_NUMBER(Channel));
X  ((void)0);
N  assert_param(IS_TIMER_CHANNEL_PRESCALER(Prescaler));
X  ((void)0);
N
N  tmpreg_CH_CNTRLx = &TIMERx->CH1_CNTRL + Channel;
N
N  tmpreg_CH_CNTRL = *tmpreg_CH_CNTRLx;
N  tmpreg_CH_CNTRL &= ~TIMER_CH_CNTRL_CHPSC_Msk;
X  tmpreg_CH_CNTRL &= ~((uint32_t)0x000000C0);
N  tmpreg_CH_CNTRL += Prescaler << TIMER_CH_CNTRL_CHPSC_Pos;
X  tmpreg_CH_CNTRL += Prescaler << 6;
N  *tmpreg_CH_CNTRLx = tmpreg_CH_CNTRL;
N}
N
N/**
N  * @brief  Configures the TIMERx Channel Capture Event source.
N  * @param  TIMERx: where x can be 1 to 3 to select the TIMER peripheral.
N  * @param  Channel: specifies the Timer Channel number.
N  *         This parameter can be one of the following values:
N  *           @arg TIMER_CHANNEL1: specifies TIMERx Channel 1;
N  *           @arg TIMER_CHANNEL2: specifies TIMERx Channel 2;
N  *           @arg TIMER_CHANNEL3: specifies TIMERx Channel 3;
N  *           @arg TIMER_CHANNEL4: specifies TIMERx Channel 4.
N  * @param  EventSource: specifies the Event source.
N  *         This parameter can be one of the following values:
N  *           @arg TIMER_CH_EvSrc_PE:     selects positive edge from current TIMER channel;
N  *           @arg TIMER_CH_EvSrc_NE:     selects negative edge from current TIMER channel;
N  *           @arg TIMER_CH_EvSrc_PE_OC1: selects positive edge from other TIMER channel (variant 1);
N  *           @arg TIMER_CH_EvSrc_PE_OC2: selects positive edge from other TIMER channel (variant 2).
N  * @retval None
N  */
Nvoid TIMER_ChnEventSourceConfig(MDR_TIMER_TypeDef* TIMERx, uint32_t Channel, uint32_t EventSource)
N{
N  __IO uint32_t *tmpreg_CH_CNTRLx;
X  volatile uint32_t *tmpreg_CH_CNTRLx;
N  uint32_t tmpreg_CH_CNTRL;
N
N  /* Check the parameters */
N  assert_param(IS_TIMER_ALL_PERIPH(TIMERx));
X  ((void)0);
N  assert_param(IS_TIMER_CHANNEL_NUMBER(Channel));
X  ((void)0);
N  assert_param(IS_TIMER_CHANNEL_EVENT_SOURCE(EventSource));
X  ((void)0);
N
N  tmpreg_CH_CNTRLx = &TIMERx->CH1_CNTRL + Channel;
N
N  tmpreg_CH_CNTRL = *tmpreg_CH_CNTRLx;
N  tmpreg_CH_CNTRL &= ~TIMER_CH_CNTRL_CHSEL_Msk;
X  tmpreg_CH_CNTRL &= ~((uint32_t)0x00000030);
N  tmpreg_CH_CNTRL += EventSource;
N  *tmpreg_CH_CNTRLx = tmpreg_CH_CNTRL;
N}
N
N/**
N  * @brief  Configures the TIMERx Channel Filter peripheral.
N  * @param  TIMERx: where x can be 1 to 3 to select the TIMER peripheral.
N  * @param  Channel: specifies the Timer Channel number.
N  *         This parameter can be one of the following values:
N  *           @arg TIMER_CHANNEL1: specifies TIMERx Channel 1;
N  *           @arg TIMER_CHANNEL2: specifies TIMERx Channel 2;
N  *           @arg TIMER_CHANNEL3: specifies TIMERx Channel 3;
N  *           @arg TIMER_CHANNEL4: specifies TIMERx Channel 4.
N  * @param  Filter: specifies the Channel Filter configuration.
N  *         This parameter can be one of the following values:
N  *           @arg TIMER_Filter_1FF_at_TIMER_CLK:   signal is latched by 1 trigger  at TIMER_CLK clock frequency;
N  *           @arg TIMER_Filter_2FF_at_TIMER_CLK:   signal is latched by 2 triggers at TIMER_CLK clock frequency;
N  *           @arg TIMER_Filter_4FF_at_TIMER_CLK:   signal is latched by 4 triggers at TIMER_CLK clock frequency;
N  *           @arg TIMER_Filter_8FF_at_TIMER_CLK:   signal is latched by 8 triggers at TIMER_CLK clock frequency;
N  *           @arg TIMER_Filter_6FF_at_FTDS_div_2:  signal is latched by 6 triggers at FDTS/2  clock frequency;
N  *           @arg TIMER_Filter_8FF_at_FTDS_div_2:  signal is latched by 8 triggers at FDTS/2  clock frequency;
N  *           @arg TIMER_Filter_6FF_at_FTDS_div_4:  signal is latched by 6 triggers at FDTS/4  clock frequency;
N  *           @arg TIMER_Filter_8FF_at_FTDS_div_4:  signal is latched by 8 triggers at FDTS/4  clock frequency;
N  *           @arg TIMER_Filter_6FF_at_FTDS_div_8:  signal is latched by 6 triggers at FDTS/8  clock frequency;
N  *           @arg TIMER_Filter_8FF_at_FTDS_div_8:  signal is latched by 8 triggers at FDTS/8  clock frequency;
N  *           @arg TIMER_Filter_5FF_at_FTDS_div_16: signal is latched by 5 triggers at FDTS/16 clock frequency;
N  *           @arg TIMER_Filter_6FF_at_FTDS_div_16: signal is latched by 6 triggers at FDTS/16 clock frequency;
N  *           @arg TIMER_Filter_8FF_at_FTDS_div_16: signal is latched by 8 triggers at FDTS/16 clock frequency;
N  *           @arg TIMER_Filter_5FF_at_FTDS_div_32: signal is latched by 5 triggers at FDTS/32 clock frequency;
N  *           @arg TIMER_Filter_6FF_at_FTDS_div_32: signal is latched by 6 triggers at FDTS/32 clock frequency;
N  *           @arg TIMER_Filter_8FF_at_FTDS_div_32: signal is latched by 8 triggers at FDTS/32 clock frequency.
N  * @retval None
N  */
Nvoid TIMER_ChnFilterConfig(MDR_TIMER_TypeDef* TIMERx, uint32_t Channel, uint32_t Filter)
N{
N  __IO uint32_t *tmpreg_CH_CNTRLx;
X  volatile uint32_t *tmpreg_CH_CNTRLx;
N  uint32_t tmpreg_CH_CNTRL;
N
N  /* Check the parameters */
N  assert_param(IS_TIMER_ALL_PERIPH(TIMERx));
X  ((void)0);
N  assert_param(IS_TIMER_CHANNEL_NUMBER(Channel));
X  ((void)0);
N  assert_param(IS_TIMER_FILTER_CONF(Filter));
X  ((void)0);
N
N  tmpreg_CH_CNTRLx = &TIMERx->CH1_CNTRL + Channel;
N
N  tmpreg_CH_CNTRL = *tmpreg_CH_CNTRLx;
N  tmpreg_CH_CNTRL &= ~TIMER_CH_CNTRL_CHFLTR_Msk;
X  tmpreg_CH_CNTRL &= ~((uint32_t)0x0000000F);
N  tmpreg_CH_CNTRL += Filter << TIMER_CH_CNTRL_CHFLTR_Pos;
X  tmpreg_CH_CNTRL += Filter << 0;
N  *tmpreg_CH_CNTRLx = tmpreg_CH_CNTRL;
N}
N
N/**
N  * @brief  Checks whether the TIMERx CCR (CCR1) writ operation is complete or not.
N  * @param  TIMERx: where x can be 1 to 3 to select the TIMER peripheral.
N  * @param  Channel: specifies the Timer Channel number.
N  *         This parameter can be one of the following values:
N  *           @arg TIMER_CHANNEL1: specifies TIMERx Channel 1;
N  *           @arg TIMER_CHANNEL2: specifies TIMERx Channel 2;
N  *           @arg TIMER_CHANNEL3: specifies TIMERx Channel 3;
N  *           @arg TIMER_CHANNEL4: specifies TIMERx Channel 4.
N  * @retval The TIMERx_CHy_CNTRL.WR_CMPL flag current state (SET or RESET).
N  */
NFlagStatus TIMER_GetChnWriteComplete(MDR_TIMER_TypeDef* TIMERx, uint32_t Channel)
N{
N  __IO uint32_t *tmpreg_CH_CNTRLx;
X  volatile uint32_t *tmpreg_CH_CNTRLx;
N  FlagStatus bitstatus;
N
N  /* Check the parameters */
N  assert_param(IS_TIMER_ALL_PERIPH(TIMERx));
X  ((void)0);
N  assert_param(IS_TIMER_CHANNEL_NUMBER(Channel));
X  ((void)0);
N
N  tmpreg_CH_CNTRLx = &TIMERx->CH1_CNTRL + Channel;
N
N  if ((*tmpreg_CH_CNTRLx & TIMER_CH_CNTRL_WR_CMPL) == 0)
X  if ((*tmpreg_CH_CNTRLx & ((uint32_t)0x00004000)) == 0)
N  {
N    bitstatus = RESET;
N  }
N  else
N  {
N    bitstatus = SET;
N  }
N
N  return bitstatus;
N}
N
N/**
N  * @brief  Configures the TIMERx Channel Capture1 Event source.
N  * @param  TIMERx: where x can be 1 to 3 to select the TIMER peripheral.
N  * @param  Channel: specifies the Timer Channel number.
N  *         This parameter can be one of the following values:
N  *           @arg TIMER_CHANNEL1: specifies TIMERx Channel 1;
N  *           @arg TIMER_CHANNEL2: specifies TIMERx Channel 2;
N  *           @arg TIMER_CHANNEL3: specifies TIMERx Channel 3;
N  *           @arg TIMER_CHANNEL4: specifies TIMERx Channel 4.
N  * @param  EventSource: specifies the Event source.
N  *         This parameter can be one of the following values:
N  *           @arg TIMER_CH_CCR1EvSrc_PE    : selects positive edge from current TIMER channel.
N  *           @arg TIMER_CH_CCR1EvSrc_NE    : selects negative edge from current TIMER channel.
N  *           @arg TIMER_CH_CCR1EvSrc_NE_OC1: selects negative edge from other TIMER channel (variant 1).
N  *           @arg TIMER_CH_CCR1EvSrc_NE_OC2: selects negative edge from other TIMER channel (variant 2).
N  * @retval None
N  */
Nvoid TIMER_ChnCCR1_EventSourceConfig(MDR_TIMER_TypeDef* TIMERx, uint32_t Channel, uint32_t EventSource)
N{
N  __IO uint32_t *tmpreg_CH_CNTRL2x;
X  volatile uint32_t *tmpreg_CH_CNTRL2x;
N  uint32_t tmpreg_CH_CNTRL2;
N
N  /* Check the parameters */
N  assert_param(IS_TIMER_ALL_PERIPH(TIMERx));
X  ((void)0);
N  assert_param(IS_TIMER_CHANNEL_NUMBER(Channel));
X  ((void)0);
N  assert_param(IS_TIMER_CHANNEL_CCR1_EVENT_SOURCE(EventSource));
X  ((void)0);
N
N  tmpreg_CH_CNTRL2x = &TIMERx->CH1_CNTRL2 + Channel;
N
N  tmpreg_CH_CNTRL2 = *tmpreg_CH_CNTRL2x;
N  tmpreg_CH_CNTRL2 &= ~TIMER_CH_CNTRL2_CHSEL1_Msk;
X  tmpreg_CH_CNTRL2 &= ~((uint32_t)0x00000003);
N  tmpreg_CH_CNTRL2 += EventSource;
N  *tmpreg_CH_CNTRL2x = tmpreg_CH_CNTRL2;
N}
N
N/**
N  * @brief  Enables or disables the TIMERx Channel CCR1 register.
N  * @param  TIMERx: where x can be 1 to 3 to select the TIMER peripheral.
N  * @param  Channel: specifies the Timer Channel number.
N  *         This parameter can be one of the following values:
N  *           @arg TIMER_CHANNEL1: specifies TIMERx Channel 1;
N  *           @arg TIMER_CHANNEL2: specifies TIMERx Channel 2;
N  *           @arg TIMER_CHANNEL3: specifies TIMERx Channel 3;
N  *           @arg TIMER_CHANNEL4: specifies TIMERx Channel 4.
N  * @param  NewState: new state of the CCR1_EN bit.
N  *         This parameter can be: ENABLE or DISABLE.
N  * @retval None
N  */
Nvoid TIMER_ChnCCR1_Cmd(MDR_TIMER_TypeDef* TIMERx, uint32_t Channel, FunctionalState NewState)
N{
N  __IO uint32_t *tmpreg_CH_CNTRL2x;
X  volatile uint32_t *tmpreg_CH_CNTRL2x;
N  uint32_t tmpreg_CH_CNTRL2;
N
N  /* Check the parameters */
N  assert_param(IS_TIMER_ALL_PERIPH(TIMERx));
X  ((void)0);
N  assert_param(IS_TIMER_CHANNEL_NUMBER(Channel));
X  ((void)0);
N  assert_param(IS_FUNCTIONAL_STATE(NewState));
X  ((void)0);
N
N  tmpreg_CH_CNTRL2x = &TIMERx->CH1_CNTRL2 + Channel;
N
N  tmpreg_CH_CNTRL2 = *tmpreg_CH_CNTRL2x;
N
N  /* Form new value */
N  if (NewState != DISABLE)
N  {
N    /* Enable TIMERx by setting the CCR1_EN bit in the CNTRL2 register */
N    tmpreg_CH_CNTRL2 |= TIMER_CH_CNTRL2_CCR1_EN;
X    tmpreg_CH_CNTRL2 |= ((uint32_t)0x00000004);
N  }
N  else
N  {
N    /* Disable TIMERx by resetting the CCR1_EN bit in the CNTRL2 register */
N    tmpreg_CH_CNTRL2 &= ~TIMER_CH_CNTRL2_CCR1_EN;
X    tmpreg_CH_CNTRL2 &= ~((uint32_t)0x00000004);
N  }
N
N  /* Configure CNTRL register with new value */
N  *tmpreg_CH_CNTRL2x = tmpreg_CH_CNTRL2;
N}
N
N/**
N  * @brief  Initializes the TIMERx Channel Output peripheral according to
N  *         the specified parameters in the TIMER_ChnOutInitStruct.
N  * @param  TIMERx: where x can be 1 to 3 to select the TIMER peripheral.
N  * @param  TIMER_ChnOutInitStruct: pointer to a TIMER_ChnOutInitTypeDef structure
N  *         that contains the configuration information for the specified
N  *         TIMER Channel peripheral.
N  * @retval None
N  */
Nvoid TIMER_ChnOutInit(MDR_TIMER_TypeDef* TIMERx, const TIMER_ChnOutInitTypeDef* TIMER_ChnOutInitStruct)
N{
N  uint32_t tmpreg_CH_Number;
N  uint32_t tmpreg_CH_CNTRL1;
N  uint32_t tmpreg_CH_DTG;
N
N  /* Check the parameters */
N  assert_param(IS_TIMER_ALL_PERIPH(TIMERx));
X  ((void)0);
N  assert_param(IS_TIMER_CHANNEL_NUMBER(TIMER_ChnOutInitStruct->TIMER_CH_Number));
X  ((void)0);
N  assert_param(IS_TIMER_CHO_POLARITY(TIMER_ChnOutInitStruct->TIMER_CH_DirOut_Polarity));
X  ((void)0);
N  assert_param(IS_TIMER_CHO_SOURCE(TIMER_ChnOutInitStruct->TIMER_CH_DirOut_Source));
X  ((void)0);
N  assert_param(IS_TIMER_CHO_MODE(TIMER_ChnOutInitStruct->TIMER_CH_DirOut_Mode));
X  ((void)0);
N  assert_param(IS_TIMER_CHO_POLARITY(TIMER_ChnOutInitStruct->TIMER_CH_NegOut_Polarity));
X  ((void)0);
N  assert_param(IS_TIMER_CHO_SOURCE(TIMER_ChnOutInitStruct->TIMER_CH_NegOut_Source));
X  ((void)0);
N  assert_param(IS_TIMER_CHO_MODE(TIMER_ChnOutInitStruct->TIMER_CH_NegOut_Mode));
X  ((void)0);
N  assert_param(IS_TIMER_CHANNEL_DTG_MAIN_PRESCALER(TIMER_ChnOutInitStruct->TIMER_CH_DTG_MainPrescaler));
X  ((void)0);
N  assert_param(IS_TIMER_CHANNEL_DTG_AUX_PRESCALER(TIMER_ChnOutInitStruct->TIMER_CH_DTG_AuxPrescaler));
X  ((void)0);
N  assert_param(IS_TIMER_CHANNEL_DTG_CLK_SOURCE(TIMER_ChnOutInitStruct->TIMER_CH_DTG_ClockSource));
X  ((void)0);
N
N  tmpreg_CH_CNTRL1 = (TIMER_ChnOutInitStruct->TIMER_CH_DirOut_Polarity << TIMER_CH_CNTRL1_INV_Pos)
X  tmpreg_CH_CNTRL1 = (TIMER_ChnOutInitStruct->TIMER_CH_DirOut_Polarity << 4)
N                   + (TIMER_ChnOutInitStruct->TIMER_CH_DirOut_Source   << TIMER_CH_CNTRL1_SELO_Pos)
X                   + (TIMER_ChnOutInitStruct->TIMER_CH_DirOut_Source   << 2)
N                   + (TIMER_ChnOutInitStruct->TIMER_CH_DirOut_Mode     << TIMER_CH_CNTRL1_SELOE_Pos)
X                   + (TIMER_ChnOutInitStruct->TIMER_CH_DirOut_Mode     << 0)
N                   + (TIMER_ChnOutInitStruct->TIMER_CH_NegOut_Polarity << TIMER_CH_CNTRL1_NINV_Pos)
X                   + (TIMER_ChnOutInitStruct->TIMER_CH_NegOut_Polarity << 12)
N                   + (TIMER_ChnOutInitStruct->TIMER_CH_NegOut_Source   << TIMER_CH_CNTRL1_NSELO_Pos)
X                   + (TIMER_ChnOutInitStruct->TIMER_CH_NegOut_Source   << 10)
N                   + (TIMER_ChnOutInitStruct->TIMER_CH_NegOut_Mode     << TIMER_CH_CNTRL1_NSELOE_Pos);
X                   + (TIMER_ChnOutInitStruct->TIMER_CH_NegOut_Mode     << 8);
N
N  tmpreg_CH_Number = TIMER_ChnOutInitStruct->TIMER_CH_Number;
N
N  *(&TIMERx->CH1_CNTRL1 + tmpreg_CH_Number) = tmpreg_CH_CNTRL1;
N
N  tmpreg_CH_DTG = (TIMER_ChnOutInitStruct->TIMER_CH_DTG_MainPrescaler << TIMER_CH_DTG_Pos)
X  tmpreg_CH_DTG = (TIMER_ChnOutInitStruct->TIMER_CH_DTG_MainPrescaler << 8)
N                + (TIMER_ChnOutInitStruct->TIMER_CH_DTG_AuxPrescaler  << TIMER_CH_DTGX_Pos)
X                + (TIMER_ChnOutInitStruct->TIMER_CH_DTG_AuxPrescaler  << 0)
N                + TIMER_ChnOutInitStruct->TIMER_CH_DTG_ClockSource;
N
N  *(&TIMERx->CH1_DTG + tmpreg_CH_Number) = tmpreg_CH_DTG;
N}
N
N/**
N  * @brief  Fills each TIMER_ChnOutInitStruct member with its default value.
N  * @param  TIMER_ChnOutInitStruct: pointer to a TIMER_ChnOutInitTypeDef structure
N  *         which will be initialized.
N  * @retval None
N  */
Nvoid TIMER_ChnOutStructInit(TIMER_ChnOutInitTypeDef* TIMER_ChnOutInitStruct)
N{
N  TIMER_ChnOutInitStruct->TIMER_CH_DirOut_Polarity   = TIMER_CHOPolarity_NonInverted;
X  TIMER_ChnOutInitStruct->TIMER_CH_DirOut_Polarity   = ((uint32_t)0x0);
N  TIMER_ChnOutInitStruct->TIMER_CH_DirOut_Source     = TIMER_CH_OutSrc_Only_0;
X  TIMER_ChnOutInitStruct->TIMER_CH_DirOut_Source     = ((uint32_t)0x0);
N  TIMER_ChnOutInitStruct->TIMER_CH_DirOut_Mode       = TIMER_CH_OutMode_Input;
X  TIMER_ChnOutInitStruct->TIMER_CH_DirOut_Mode       = ((uint32_t)0x0);
N  TIMER_ChnOutInitStruct->TIMER_CH_NegOut_Polarity   = TIMER_CHOPolarity_NonInverted;
X  TIMER_ChnOutInitStruct->TIMER_CH_NegOut_Polarity   = ((uint32_t)0x0);
N  TIMER_ChnOutInitStruct->TIMER_CH_NegOut_Source     = TIMER_CH_OutSrc_Only_0;
X  TIMER_ChnOutInitStruct->TIMER_CH_NegOut_Source     = ((uint32_t)0x0);
N  TIMER_ChnOutInitStruct->TIMER_CH_NegOut_Mode       = TIMER_CH_OutMode_Input;
X  TIMER_ChnOutInitStruct->TIMER_CH_NegOut_Mode       = ((uint32_t)0x0);
N  TIMER_ChnOutInitStruct->TIMER_CH_DTG_MainPrescaler = 0;
N  TIMER_ChnOutInitStruct->TIMER_CH_DTG_AuxPrescaler  = 0;
N  TIMER_ChnOutInitStruct->TIMER_CH_DTG_ClockSource   = TIMER_CH_DTG_ClkSrc_TIMER_CLK;
X  TIMER_ChnOutInitStruct->TIMER_CH_DTG_ClockSource   = (((uint32_t)0x0) << 4);
N}
N
N/**
N  * @brief  Configures the TIMERx Channel output.
N  * @param  TIMERx: where x can be 1 to 3 to select the TIMER peripheral.
N  * @param  Channel: specifies the Timer Channel number.
N  *         This parameter can be one of the following values:
N  *           @arg TIMER_CHANNEL1: specifies TIMERx Channel 1;
N  *           @arg TIMER_CHANNEL2: specifies TIMERx Channel 2;
N  *           @arg TIMER_CHANNEL3: specifies TIMERx Channel 3;
N  *           @arg TIMER_CHANNEL4: specifies TIMERx Channel 4.
N  * @param  OutSource: specifies the Channel Output source.
N  *         This parameter can be one of the following values:
N  *           @arg TIMER_CH_OutSrc_Only_0: selects the '0' state on the CHx line;
N  *           @arg TIMER_CH_OutSrc_Only_1: selects the '1' state on the CHx line;
N  *           @arg TIMER_CH_OutSrc_REF:    selects the REF state on the CHx line;
N  *           @arg TIMER_CH_OutSrc_DTG:    selects the DTG output state on the CHx line.
N  * @param  Mode: specifies the Channel Output Enable source.
N  *         This parameter can be one of the following values:
N  *           @arg TIMER_CH_OutMode_Input:     selects the Input mode on the CHx line;
N  *           @arg TIMER_CH_OutMode_Output:    selects the Output mode on the CHx line;
N  *           @arg TIMER_CH_OutMode_REF_as_OE: the REF signal specifies the CHx line mode;
N  *           @arg TIMER_CH_OutMode_DTG_as_OE: the DTG output specifies the CHx line mode.
N  * @param  Polarity: enables or disables the Channel Output inversion.
N  *         This parameter can be one of the following values:
N  *           @arg TIMER_CHOPolarity_NonInverted: no inversion on the Channel output;
N  *           @arg TIMER_CHOPolarity_Inverted:    the Channel output is inverted.
N  * @retval None
N  */
Nvoid TIMER_ChnOutConfig(MDR_TIMER_TypeDef* TIMERx, uint32_t Channel, uint32_t OutSource, uint32_t Mode, uint32_t Polarity)
N{
N  __IO uint32_t *tmpreg_CH_CNTRL1x;
X  volatile uint32_t *tmpreg_CH_CNTRL1x;
N  uint32_t tmpreg_CH_CNTRL1;
N
N  /* Check the parameters */
N  assert_param(IS_TIMER_ALL_PERIPH(TIMERx));
X  ((void)0);
N  assert_param(IS_TIMER_CHANNEL_NUMBER(Channel));
X  ((void)0);
N  assert_param(IS_TIMER_CHO_SOURCE(OutSource));
X  ((void)0);
N  assert_param(IS_TIMER_CHO_MODE(Mode));
X  ((void)0);
N  assert_param(IS_TIMER_CHO_POLARITY(Polarity));
X  ((void)0);
N
N  tmpreg_CH_CNTRL1x = &TIMERx->CH1_CNTRL1 + Channel;
N
N  tmpreg_CH_CNTRL1 = *tmpreg_CH_CNTRL1x;
N  tmpreg_CH_CNTRL1 &= ~(TIMER_CH_CNTRL1_INV + TIMER_CH_CNTRL1_SELO_Msk + TIMER_CH_CNTRL1_SELOE_Msk);
X  tmpreg_CH_CNTRL1 &= ~(((uint32_t)0x00000010) + ((uint32_t)0x0000000C) + ((uint32_t)0x00000003));
N  tmpreg_CH_CNTRL1 += (Polarity  << TIMER_CH_CNTRL1_INV_Pos)
X  tmpreg_CH_CNTRL1 += (Polarity  << 4)
N                    + (OutSource << TIMER_CH_CNTRL1_SELO_Pos)
X                    + (OutSource << 2)
N                    + (Mode      << TIMER_CH_CNTRL1_SELOE_Pos);
X                    + (Mode      << 0);
N  *tmpreg_CH_CNTRL1x = tmpreg_CH_CNTRL1;
N}
N
N/**
N  * @brief  Configures the TIMERx Channel Output source.
N  * @param  TIMERx: where x can be 1 to 3 to select the TIMER peripheral.
N  * @param  Channel: specifies the Timer Channel number.
N  *         This parameter can be one of the following values:
N  *           @arg TIMER_CHANNEL1: specifies TIMERx Channel 1;
N  *           @arg TIMER_CHANNEL2: specifies TIMERx Channel 2;
N  *           @arg TIMER_CHANNEL3: specifies TIMERx Channel 3;
N  *           @arg TIMER_CHANNEL4: specifies TIMERx Channel 4.
N  * @param  OutSource: specifies the Channel Output source.
N  *         This parameter can be one of the following values:
N  *           @arg TIMER_CH_OutSrc_Only_0: selects the '0' state on the CHx line;
N  *           @arg TIMER_CH_OutSrc_Only_1: selects the '1' state on the CHx line;
N  *           @arg TIMER_CH_OutSrc_REF:    selects the REF state on the CHx line;
N  *           @arg TIMER_CH_OutSrc_DTG:    selects the DTG output state on the CHx line.
N  * @retval None
N  */
Nvoid TIMER_ChnOutSourceConfig(MDR_TIMER_TypeDef* TIMERx, uint32_t Channel, uint32_t OutSource)
N{
N  __IO uint32_t *tmpreg_CH_CNTRL1x;
X  volatile uint32_t *tmpreg_CH_CNTRL1x;
N  uint32_t tmpreg_CH_CNTRL1;
N
N  /* Check the parameters */
N  assert_param(IS_TIMER_ALL_PERIPH(TIMERx));
X  ((void)0);
N  assert_param(IS_TIMER_CHANNEL_NUMBER(Channel));
X  ((void)0);
N  assert_param(IS_TIMER_CHO_SOURCE(OutSource));
X  ((void)0);
N
N  tmpreg_CH_CNTRL1x = &TIMERx->CH1_CNTRL1 + Channel;
N
N  tmpreg_CH_CNTRL1 = *tmpreg_CH_CNTRL1x;
N  tmpreg_CH_CNTRL1 &= ~TIMER_CH_CNTRL1_SELO_Msk;
X  tmpreg_CH_CNTRL1 &= ~((uint32_t)0x0000000C);
N  tmpreg_CH_CNTRL1 += OutSource << TIMER_CH_CNTRL1_SELO_Pos;
X  tmpreg_CH_CNTRL1 += OutSource << 2;
N  *tmpreg_CH_CNTRL1x = tmpreg_CH_CNTRL1;
N}
N
N/**
N  * @brief  Configures the TIMERx Channel Output mode.
N  * @param  TIMERx: where x can be 1 to 3 to select the TIMER peripheral.
N  * @param  Channel: specifies the Timer Channel number.
N  *         This parameter can be one of the following values:
N  *           @arg TIMER_CHANNEL1: specifies TIMERx Channel 1;
N  *           @arg TIMER_CHANNEL2: specifies TIMERx Channel 2;
N  *           @arg TIMER_CHANNEL3: specifies TIMERx Channel 3;
N  *           @arg TIMER_CHANNEL4: specifies TIMERx Channel 4.
N  * @param  Mode: specifies the Channel Output Enable source.
N  *         This parameter can be one of the following values:
N  *           @arg TIMER_CH_OutMode_Input:     selects the Input mode on the CHx line;
N  *           @arg TIMER_CH_OutMode_Output:    selects the Output mode on the CHx line;
N  *           @arg TIMER_CH_OutMode_REF_as_OE: the REF signal specifies the CHx line mode;
N  *           @arg TIMER_CH_OutMode_DTG_as_OE: the DTG output specifies the CHx line mode.
N  * @retval None
N  */
Nvoid TIMER_ChnOutModeConfig(MDR_TIMER_TypeDef* TIMERx, uint32_t Channel, uint32_t Mode)
N{
N  __IO uint32_t *tmpreg_CH_CNTRL1x;
X  volatile uint32_t *tmpreg_CH_CNTRL1x;
N  uint32_t tmpreg_CH_CNTRL1;
N
N  /* Check the parameters */
N  assert_param(IS_TIMER_ALL_PERIPH(TIMERx));
X  ((void)0);
N  assert_param(IS_TIMER_CHANNEL_NUMBER(Channel));
X  ((void)0);
N  assert_param(IS_TIMER_CHO_MODE(Mode));
X  ((void)0);
N
N  tmpreg_CH_CNTRL1x = &TIMERx->CH1_CNTRL1 + Channel;
N
N  tmpreg_CH_CNTRL1 = *tmpreg_CH_CNTRL1x;
N  tmpreg_CH_CNTRL1 &= ~TIMER_CH_CNTRL1_SELOE_Msk;
X  tmpreg_CH_CNTRL1 &= ~((uint32_t)0x00000003);
N  tmpreg_CH_CNTRL1 += Mode << TIMER_CH_CNTRL1_SELOE_Pos;
X  tmpreg_CH_CNTRL1 += Mode << 0;
N  *tmpreg_CH_CNTRL1x = tmpreg_CH_CNTRL1;
N}
N
N/**
N  * @brief  Configures the TIMERx Channel Output polarity.
N  * @param  TIMERx: where x can be 1 to 3 to select the TIMER peripheral.
N  * @param  Channel: specifies the Timer Channel number.
N  *         This parameter can be one of the following values:
N  *           @arg TIMER_CHANNEL1: specifies TIMERx Channel 1;
N  *           @arg TIMER_CHANNEL2: specifies TIMERx Channel 2;
N  *           @arg TIMER_CHANNEL3: specifies TIMERx Channel 3;
N  *           @arg TIMER_CHANNEL4: specifies TIMERx Channel 4.
N  * @param  Polarity: enables or disables the Channel Output inversion.
N  *         This parameter can be one of the following values:
N  *           @arg TIMER_CHOPolarity_NonInverted: no inversion on the Channel output;
N  *           @arg TIMER_CHOPolarity_Inverted:    the Channel output is inverted.
N  * @retval None
N  */
Nvoid TIMER_ChnOutPolarityConfig(MDR_TIMER_TypeDef* TIMERx, uint32_t Channel, uint32_t Polarity)
N{
N  __IO uint32_t *tmpreg_CH_CNTRL1x;
X  volatile uint32_t *tmpreg_CH_CNTRL1x;
N  uint32_t tmpreg_CH_CNTRL1;
N
N  /* Check the parameters */
N  assert_param(IS_TIMER_ALL_PERIPH(TIMERx));
X  ((void)0);
N  assert_param(IS_TIMER_CHANNEL_NUMBER(Channel));
X  ((void)0);
N  assert_param(IS_TIMER_CHO_POLARITY(Polarity));
X  ((void)0);
N
N  tmpreg_CH_CNTRL1x = &TIMERx->CH1_CNTRL1 + Channel;
N
N  tmpreg_CH_CNTRL1 = *tmpreg_CH_CNTRL1x;
N  tmpreg_CH_CNTRL1 &= ~TIMER_CH_CNTRL1_INV;
X  tmpreg_CH_CNTRL1 &= ~((uint32_t)0x00000010);
N  tmpreg_CH_CNTRL1 += Polarity << TIMER_CH_CNTRL1_INV_Pos;
X  tmpreg_CH_CNTRL1 += Polarity << 4;
N  *tmpreg_CH_CNTRL1x = tmpreg_CH_CNTRL1;
N}
N
N/**
N  * @brief  Configures the TIMERx NChannel output.
N  * @param  TIMERx: where x can be 1 to 3 to select the TIMER peripheral.
N  * @param  Channel: specifies the Timer Channel number.
N  *         This parameter can be one of the following values:
N  *           @arg TIMER_CHANNEL1: specifies TIMERx Channel 1;
N  *           @arg TIMER_CHANNEL2: specifies TIMERx Channel 2;
N  *           @arg TIMER_CHANNEL3: specifies TIMERx Channel 3;
N  *           @arg TIMER_CHANNEL4: specifies TIMERx Channel 4.
N  * @param  OutSource: specifies the NChannel Output source.
N  *         This parameter can be one of the following values:
N  *           @arg TIMER_CH_OutSrc_Only_0: selects the '0' state on the CHxN line;
N  *           @arg TIMER_CH_OutSrc_Only_1: selects the '1' state on the CHxN line;
N  *           @arg TIMER_CH_OutSrc_REF:    selects the REF state on the CHxN line;
N  *           @arg TIMER_CH_OutSrc_DTG:    selects the DTG output state on the CHxN line.
N  * @param  Mode: specifies the NChannel Output Enable source.
N  *         This parameter can be one of the following values:
N  *           @arg TIMER_CH_OutMode_Input:     selects the Input mode on the CHxN line;
N  *           @arg TIMER_CH_OutMode_Output:    selects the Output mode on the CHxN line;
N  *           @arg TIMER_CH_OutMode_REF_as_OE: the REF signal specifies the CHxN line mode;
N  *           @arg TIMER_CH_OutMode_DTG_as_OE: the DTG output specifies the CHxN line mode.
N  * @param  Polarity: enables or disables the NChannel Output inversion.
N  *         This parameter can be one of the following values:
N  *           @arg TIMER_CHOPolarity_NonInverted: no inversion on the NChannel output;
N  *           @arg TIMER_CHOPolarity_Inverted:    the NChannel output is inverted.
N  * @retval None
N  */
Nvoid TIMER_ChnNOutConfig(MDR_TIMER_TypeDef* TIMERx, uint32_t Channel, uint32_t OutSource, uint32_t Mode, uint32_t Polarity)
N{
N  __IO uint32_t *tmpreg_CH_CNTRL1x;
X  volatile uint32_t *tmpreg_CH_CNTRL1x;
N  uint32_t tmpreg_CH_CNTRL1;
N
N  /* Check the parameters */
N  assert_param(IS_TIMER_ALL_PERIPH(TIMERx));
X  ((void)0);
N  assert_param(IS_TIMER_CHANNEL_NUMBER(Channel));
X  ((void)0);
N  assert_param(IS_TIMER_CHO_SOURCE(OutSource));
X  ((void)0);
N  assert_param(IS_TIMER_CHO_MODE(Mode));
X  ((void)0);
N  assert_param(IS_TIMER_CHO_POLARITY(Polarity));
X  ((void)0);
N
N  tmpreg_CH_CNTRL1x = &TIMERx->CH1_CNTRL1 + Channel;
N
N  tmpreg_CH_CNTRL1 = *tmpreg_CH_CNTRL1x;
N  tmpreg_CH_CNTRL1 &= ~(TIMER_CH_CNTRL1_NINV + TIMER_CH_CNTRL1_NSELO_Msk + TIMER_CH_CNTRL1_NSELOE_Msk);
X  tmpreg_CH_CNTRL1 &= ~(((uint32_t)0x00001000) + ((uint32_t)0x00000C00) + ((uint32_t)0x00000300));
N  tmpreg_CH_CNTRL1 += (Polarity  << TIMER_CH_CNTRL1_NINV_Pos)
X  tmpreg_CH_CNTRL1 += (Polarity  << 12)
N                    + (OutSource << TIMER_CH_CNTRL1_NSELO_Pos)
X                    + (OutSource << 10)
N                    + (Mode      << TIMER_CH_CNTRL1_NSELOE_Pos);
X                    + (Mode      << 8);
N  *tmpreg_CH_CNTRL1x = tmpreg_CH_CNTRL1;
N}
N
N/**
N  * @brief  Configures the TIMERx NChannel Output source.
N  * @param  TIMERx: where x can be 1 to 3 to select the TIMER peripheral.
N  * @param  Channel: specifies the Timer Channel number.
N  *         This parameter can be one of the following values:
N  *           @arg TIMER_CHANNEL1: specifies TIMERx Channel 1;
N  *           @arg TIMER_CHANNEL2: specifies TIMERx Channel 2;
N  *           @arg TIMER_CHANNEL3: specifies TIMERx Channel 3;
N  *           @arg TIMER_CHANNEL4: specifies TIMERx Channel 4.
N  * @param  OutSource: specifies the NChannel Output source.
N  *         This parameter can be one of the following values:
N  *           @arg TIMER_CH_OutSrc_Only_0: selects the '0' state on the CHxN line;
N  *           @arg TIMER_CH_OutSrc_Only_1: selects the '1' state on the CHxN line;
N  *           @arg TIMER_CH_OutSrc_REF:    selects the REF state on the CHxN line;
N  *           @arg TIMER_CH_OutSrc_DTG:    selects the DTG output state on the CHxN line.
N  * @retval None
N  */
Nvoid TIMER_ChnNOutSourceConfig(MDR_TIMER_TypeDef* TIMERx, uint32_t Channel, uint32_t OutSource)
N{
N  __IO uint32_t *tmpreg_CH_CNTRL1x;
X  volatile uint32_t *tmpreg_CH_CNTRL1x;
N  uint32_t tmpreg_CH_CNTRL1;
N
N  /* Check the parameters */
N  assert_param(IS_TIMER_ALL_PERIPH(TIMERx));
X  ((void)0);
N  assert_param(IS_TIMER_CHANNEL_NUMBER(Channel));
X  ((void)0);
N  assert_param(IS_TIMER_CHO_SOURCE(OutSource));
X  ((void)0);
N
N  tmpreg_CH_CNTRL1x = &TIMERx->CH1_CNTRL1 + Channel;
N
N  tmpreg_CH_CNTRL1 = *tmpreg_CH_CNTRL1x;
N  tmpreg_CH_CNTRL1 &= ~TIMER_CH_CNTRL1_NSELO_Msk;
X  tmpreg_CH_CNTRL1 &= ~((uint32_t)0x00000C00);
N  tmpreg_CH_CNTRL1 += OutSource << TIMER_CH_CNTRL1_NSELO_Pos;
X  tmpreg_CH_CNTRL1 += OutSource << 10;
N  *tmpreg_CH_CNTRL1x = tmpreg_CH_CNTRL1;
N}
N
N/**
N  * @brief  Configures the TIMERx NChannel Output mode.
N  * @param  TIMERx: where x can be 1 to 3 to select the TIMER peripheral.
N  * @param  Channel: specifies the Timer Channel number.
N  *         This parameter can be one of the following values:
N  *           @arg TIMER_CHANNEL1: specifies TIMERx Channel 1;
N  *           @arg TIMER_CHANNEL2: specifies TIMERx Channel 2;
N  *           @arg TIMER_CHANNEL3: specifies TIMERx Channel 3;
N  *           @arg TIMER_CHANNEL4: specifies TIMERx Channel 4.
N  * @param  Mode: specifies the NChannel Output Enable source.
N  *         This parameter can be one of the following values:
N  *           @arg TIMER_CH_OutMode_Input:     selects the Input mode on the CHxN line;
N  *           @arg TIMER_CH_OutMode_Output:    selects the Output mode on the CHxN line;
N  *           @arg TIMER_CH_OutMode_REF_as_OE: the REF signal specifies the CHxN line mode;
N  *           @arg TIMER_CH_OutMode_DTG_as_OE: the DTG output specifies the CHxN line mode.
N  * @retval None
N  */
Nvoid TIMER_ChnNOutModeConfig(MDR_TIMER_TypeDef* TIMERx, uint32_t Channel, uint32_t Mode)
N{
N  __IO uint32_t *tmpreg_CH_CNTRL1x;
X  volatile uint32_t *tmpreg_CH_CNTRL1x;
N  uint32_t tmpreg_CH_CNTRL1;
N
N  /* Check the parameters */
N  assert_param(IS_TIMER_ALL_PERIPH(TIMERx));
X  ((void)0);
N  assert_param(IS_TIMER_CHANNEL_NUMBER(Channel));
X  ((void)0);
N  assert_param(IS_TIMER_CHO_MODE(Mode));
X  ((void)0);
N
N  tmpreg_CH_CNTRL1x = &TIMERx->CH1_CNTRL1 + Channel;
N
N  tmpreg_CH_CNTRL1 = *tmpreg_CH_CNTRL1x;
N  tmpreg_CH_CNTRL1 &= ~TIMER_CH_CNTRL1_NSELOE_Msk;
X  tmpreg_CH_CNTRL1 &= ~((uint32_t)0x00000300);
N  tmpreg_CH_CNTRL1 += Mode << TIMER_CH_CNTRL1_NSELOE_Pos;
X  tmpreg_CH_CNTRL1 += Mode << 8;
N  *tmpreg_CH_CNTRL1x = tmpreg_CH_CNTRL1;
N}
N
N/**
N  * @brief  Configures the TIMERx NChannel Output polarity.
N  * @param  TIMERx: where x can be 1 to 3 to select the TIMER peripheral.
N  * @param  Channel: specifies the Timer Channel number.
N  *         This parameter can be one of the following values:
N  *           @arg TIMER_CHANNEL1: specifies TIMERx Channel 1;
N  *           @arg TIMER_CHANNEL2: specifies TIMERx Channel 2;
N  *           @arg TIMER_CHANNEL3: specifies TIMERx Channel 3;
N  *           @arg TIMER_CHANNEL4: specifies TIMERx Channel 4.
N  * @param  Polarity: enables or disables the NChannel Output inversion.
N  *         This parameter can be one of the following values:
N  *           @arg TIMER_CHOPolarity_NonInverted: no inversion on the NChannel output;
N  *           @arg TIMER_CHOPolarity_Inverted:    the NChannel output is inverted.
N  * @retval None
N  */
Nvoid TIMER_ChnNOutPolarityConfig(MDR_TIMER_TypeDef* TIMERx, uint32_t Channel, uint32_t Polarity)
N{
N  __IO uint32_t *tmpreg_CH_CNTRL1x;
X  volatile uint32_t *tmpreg_CH_CNTRL1x;
N  uint32_t tmpreg_CH_CNTRL1;
N
N  /* Check the parameters */
N  assert_param(IS_TIMER_ALL_PERIPH(TIMERx));
X  ((void)0);
N  assert_param(IS_TIMER_CHANNEL_NUMBER(Channel));
X  ((void)0);
N  assert_param(IS_TIMER_CHO_POLARITY(Polarity));
X  ((void)0);
N
N  tmpreg_CH_CNTRL1x = &TIMERx->CH1_CNTRL1 + Channel;
N
N  tmpreg_CH_CNTRL1 = *tmpreg_CH_CNTRL1x;
N  tmpreg_CH_CNTRL1 &= ~TIMER_CH_CNTRL1_NINV;
X  tmpreg_CH_CNTRL1 &= ~((uint32_t)0x00001000);
N  tmpreg_CH_CNTRL1 += Polarity << TIMER_CH_CNTRL1_NINV_Pos;
X  tmpreg_CH_CNTRL1 += Polarity << 12;
N  *tmpreg_CH_CNTRL1x = tmpreg_CH_CNTRL1;
N}
N
N/**
N  * @brief  Configures the TIMERx Dead Time Generator (DTG) peripheral.
N  * @param  TIMERx: where x can be 1 to 3 to select the TIMER peripheral.
N  * @param  Channel: specifies the Timer Channel number.
N  *         This parameter can be one of the following values:
N  *           @arg TIMER_CHANNEL1: specifies TIMERx Channel 1;
N  *           @arg TIMER_CHANNEL2: specifies TIMERx Channel 2;
N  *           @arg TIMER_CHANNEL3: specifies TIMERx Channel 3;
N  *           @arg TIMER_CHANNEL4: specifies TIMERx Channel 4.
N  * @param  MainPrescaler: specifies the Main Prescaler value.
N  *         This parameter can be a number between 0x0000 and 0x00FF.
N  * @param  AuxPrescaler: specifies the Auxiliary Prescaler value.
N  *         This parameter can be a number between 0x0000 and 0x000F.
N  * @param  ClockSource: specifies the DTG clock source.
N  *         This parameter can be one of the following values:
N  *           @arg TIMER_CH_DTG_ClkSrc_TIMER_CLK: specifies the TIMER_CLK signal as DTG clock source;
N  *           @arg TIMER_CH_DTG_ClkSrc_FDTS:      specifies the FDTS signal as DTG clock source.
N  * @retval None
N  */
Nvoid TIMER_ChnOutDTGConfig(MDR_TIMER_TypeDef* TIMERx, uint32_t Channel,
N                         uint32_t MainPrescaler, uint32_t AuxPrescaler, uint32_t ClockSource)
N{
N  uint32_t tmpreg_CH_DTG;
N
N  /* Check the parameters */
N  assert_param(IS_TIMER_ALL_PERIPH(TIMERx));
X  ((void)0);
N  assert_param(IS_TIMER_CHANNEL_NUMBER(Channel));
X  ((void)0);
N  assert_param(IS_TIMER_CHANNEL_DTG_MAIN_PRESCALER(MainPrescaler));
X  ((void)0);
N  assert_param(IS_TIMER_CHANNEL_DTG_AUX_PRESCALER(AuxPrescaler));
X  ((void)0);
N  assert_param(IS_TIMER_CHANNEL_DTG_CLK_SOURCE(ClockSource));
X  ((void)0);
N
N  tmpreg_CH_DTG = (MainPrescaler << TIMER_CH_DTG_Pos)
X  tmpreg_CH_DTG = (MainPrescaler << 8)
N                + (AuxPrescaler  << TIMER_CH_DTGX_Pos)
X                + (AuxPrescaler  << 0)
N                + ClockSource;
N
N  *(&TIMERx->CH1_DTG + Channel) = tmpreg_CH_DTG;
N}
N
N/**
N  * @brief  Returns the TIMERx Status Register value.
N  * @param  TIMERx: where x can be 1 to 3 to select the TIMER peripheral.
N  * @retval The TIMERx_STATUS Register value.
N  */
Nuint32_t TIMER_GetStatus(MDR_TIMER_TypeDef* TIMERx)
N{
N  /* Check the parameters */
N  assert_param(IS_TIMER_ALL_PERIPH(TIMERx));
X  ((void)0);
N
N  return (TIMERx->STATUS);
N}
N
N/**
N  * @brief  Checks whether the specified TIMERx Status flag is set or not.
N  * @param  TIMERx: where x can be 1 to 3 to select the TIMER peripheral.
N  * @param  Flag: specifies the flag to check.
N  *         This parameter can be one of the following values:
N  *           @arg TIMER_STATUS_CNT_ZERO:         the (CNT == 0) condition occured;
N  *           @arg TIMER_STATUS_CNT_ARR:          the (CNT == ARR) condition occured;
N  *           @arg TIMER_STATUS_ETR_RISING_EDGE:  the ETR rising edge occured;
N  *           @arg TIMER_STATUS_ETR_FALLING_EDGE: the ETR falling edge occured;
N  *           @arg TIMER_STATUS_BRK:              the (BRK == 1) condition occured;
N  *           @arg TIMER_STATUS_CCR_CAP_CH1:      the Channel 1 CCR capture condition occured;
N  *           @arg TIMER_STATUS_CCR_CAP_CH2:      the Channel 2 CCR capture condition occured;
N  *           @arg TIMER_STATUS_CCR_CAP_CH3:      the Channel 3 CCR capture condition occured;
N  *           @arg TIMER_STATUS_CCR_CAP_CH4:      the Channel 4 CCR capture condition occured;
N  *           @arg TIMER_STATUS_CCR_REF_CH1:      the Channel 1 (REF == 1) condition occured;
N  *           @arg TIMER_STATUS_CCR_REF_CH2:      the Channel 2 (REF == 1) condition occured;
N  *           @arg TIMER_STATUS_CCR_REF_CH3:      the Channel 3 (REF == 1) condition occured;
N  *           @arg TIMER_STATUS_CCR_REF_CH4:      the Channel 4 (REF == 1) condition occured;
N  *           @arg TIMER_STATUS_CCR_CAP1_CH1:     the Channel 1 CCR1 capture condition occured;
N  *           @arg TIMER_STATUS_CCR_CAP1_CH2:     the Channel 2 CCR1 capture condition occured;
N  *           @arg TIMER_STATUS_CCR_CAP1_CH3:     the Channel 3 CCR1 capture condition occured;
N  *           @arg TIMER_STATUS_CCR_CAP1_CH4:     the Channel 4 CCR1 capture condition occured.
N  * @retval Current Status flag state (SET or RESET).
N  */
NFlagStatus TIMER_GetFlagStatus(MDR_TIMER_TypeDef* TIMERx, uint32_t Flag)
N{
N  FlagStatus bitstatus;
N
N  /* Check the parameters */
N  assert_param(IS_TIMER_ALL_PERIPH(TIMERx));
X  ((void)0);
N  assert_param(IS_TIMER_STATUS_FLAG(Flag));
X  ((void)0);
N
N  if ((TIMERx->STATUS & Flag) == 0)
N  {
N    bitstatus = RESET;
N  }
N  else
N  {
N    bitstatus = SET;
N  }
N
N  return bitstatus;
N}
N
N/**
N  * @brief  Clears the TIMERx's pending flags.
N  * @param  TIMERx: where x can be 1 to 3 to select the TIMER peripheral.
N  * @param  Flags: specifies the flag bit mask to clear.
N  *         This parameter can be any combination of the following values:
N  *           @arg TIMER_STATUS_CNT_ZERO:         the (CNT == 0) condition occured;
N  *           @arg TIMER_STATUS_CNT_ARR:          the (CNT == ARR) condition occured;
N  *           @arg TIMER_STATUS_ETR_RISING_EDGE:  the ETR rising edge occured;
N  *           @arg TIMER_STATUS_ETR_FALLING_EDGE: the ETR falling edge occured;
N  *           @arg TIMER_STATUS_BRK:              the (BRK == 1) condition occured;
N  *           @arg TIMER_STATUS_CCR_CAP_CH1:      the Channel 1 CCR capture condition occured;
N  *           @arg TIMER_STATUS_CCR_CAP_CH2:      the Channel 2 CCR capture condition occured;
N  *           @arg TIMER_STATUS_CCR_CAP_CH3:      the Channel 3 CCR capture condition occured;
N  *           @arg TIMER_STATUS_CCR_CAP_CH4:      the Channel 4 CCR capture condition occured;
N  *           @arg TIMER_STATUS_CCR_REF_CH1:      the Channel 1 (REF == 1) condition occured;
N  *           @arg TIMER_STATUS_CCR_REF_CH2:      the Channel 2 (REF == 1) condition occured;
N  *           @arg TIMER_STATUS_CCR_REF_CH3:      the Channel 3 (REF == 1) condition occured;
N  *           @arg TIMER_STATUS_CCR_REF_CH4:      the Channel 4 (REF == 1) condition occured;
N  *           @arg TIMER_STATUS_CCR_CAP1_CH1:     the Channel 1 CCR1 capture condition occured;
N  *           @arg TIMER_STATUS_CCR_CAP1_CH2:     the Channel 2 CCR1 capture condition occured;
N  *           @arg TIMER_STATUS_CCR_CAP1_CH3:     the Channel 3 CCR1 capture condition occured;
N  *           @arg TIMER_STATUS_CCR_CAP1_CH4:     the Channel 4 CCR1 capture condition occured.
N  * @retval None
N  */
Nvoid TIMER_ClearFlag(MDR_TIMER_TypeDef* TIMERx, uint32_t Flags)
N{
N  /* Check the parameters */
N  assert_param(IS_TIMER_ALL_PERIPH(TIMERx));
X  ((void)0);
N  assert_param(IS_TIMER_STATUS(Flags));
X  ((void)0);
N
N  TIMERx->STATUS = ~Flags;
N}
N
N/**
N  * @brief  Enables or disables the TIMERx's DMA Requests.
N  * @param  TIMERx: where x can be 1 to 3 to select the TIMER peripheral.
N  * @param  TIMER_DMASource: specifies the DMA Request sources.
N  *         This parameter can be any combination of the following values:
N  *           @arg TIMER_STATUS_CNT_ZERO:         the (CNT == 0) condition occured;
N  *           @arg TIMER_STATUS_CNT_ARR:          the (CNT == ARR) condition occured;
N  *           @arg TIMER_STATUS_ETR_RISING_EDGE:  the ETR rising edge occured;
N  *           @arg TIMER_STATUS_ETR_FALLING_EDGE: the ETR falling edge occured;
N  *           @arg TIMER_STATUS_BRK:              the (BRK == 1) condition occured;
N  *           @arg TIMER_STATUS_CCR_CAP_CH1:      the Channel 1 CCR capture condition occured;
N  *           @arg TIMER_STATUS_CCR_CAP_CH2:      the Channel 2 CCR capture condition occured;
N  *           @arg TIMER_STATUS_CCR_CAP_CH3:      the Channel 3 CCR capture condition occured;
N  *           @arg TIMER_STATUS_CCR_CAP_CH4:      the Channel 4 CCR capture condition occured;
N  *           @arg TIMER_STATUS_CCR_REF_CH1:      the Channel 1 (REF == 1) condition occured;
N  *           @arg TIMER_STATUS_CCR_REF_CH2:      the Channel 2 (REF == 1) condition occured;
N  *           @arg TIMER_STATUS_CCR_REF_CH3:      the Channel 3 (REF == 1) condition occured;
N  *           @arg TIMER_STATUS_CCR_REF_CH4:      the Channel 4 (REF == 1) condition occured;
N  *           @arg TIMER_STATUS_CCR_CAP1_CH1:     the Channel 1 CCR1 capture condition occured;
N  *           @arg TIMER_STATUS_CCR_CAP1_CH2:     the Channel 2 CCR1 capture condition occured;
N  *           @arg TIMER_STATUS_CCR_CAP1_CH3:     the Channel 3 CCR1 capture condition occured;
N  *           @arg TIMER_STATUS_CCR_CAP1_CH4:     the Channel 4 CCR1 capture condition occured.
N  * @param	TIMER_DMAChannel: specifies the DMA channel.
N  * 		@note 	Available only for MC MDR1986VE1T and MC MDR1986BE3
N  * 		This parameter can be any combination of the following values:
N  * 			@arg TIMER_DMA_Channel0
N  * 			@arg TIMER_DMA_Channel1
N  * 			@arg TIMER_DMA_Channel2
N  * 			@arg TIMER_DMA_Channel3
N  * 			@arg TIMER_DMA_Channel4
N  * @param  NewState: new state of the DMA Request sources.
N  *         This parameter can be: ENABLE or DISABLE.
N  * @retval None
N  */
N#if defined (USE_MDR1986VE1T) || defined (USE_MDR1986VE3)
X#if 0L || 0L
Svoid TIMER_DMACmd(MDR_TIMER_TypeDef* TIMERx, uint32_t TIMER_DMASource, uint32_t TIMER_DMAChannel, FunctionalState NewState)
N#endif
N#if defined (USE_MDR1986VE9x) || defined (USE_MDR1901VC1T)
X#if 1L || 0L
Nvoid TIMER_DMACmd(MDR_TIMER_TypeDef* TIMERx, uint32_t TIMER_DMASource, FunctionalState NewState)
N#endif
N{
N  uint32_t tmpreg_DMA_RE;
N
N  /* Check the parameters */
N  assert_param(IS_TIMER_ALL_PERIPH(TIMERx));
X  ((void)0);
N  assert_param(IS_TIMER_STATUS(TIMER_DMASource));
X  ((void)0);
N  assert_param(IS_FUNCTIONAL_STATE(NewState));
X  ((void)0);
N#if defined (USE_MDR1986VE1T) || defined (USE_MDR1986VE3)
X#if 0L || 0L
S  if(TIMER_DMAChannel == TIMER_DMA_Channel0){
N#endif
N	  tmpreg_DMA_RE = TIMERx->DMA_RE;
N
N	  /* Form new value */
N	  if (NewState != DISABLE)
N	  {
N		/* Enable TIMERx DMA Requests by setting bits in the DMA_RE register */
N		tmpreg_DMA_RE |= TIMER_DMASource;
N	  }
N	  else
N	  {
N		/* Disable TIMERx DMA Requests by clearing bits in the DMA_RE register */
N		tmpreg_DMA_RE &= ~TIMER_DMASource;
N	  }
N
N	  /* Configure CNTRL register with new value */
N	  TIMERx->DMA_RE = tmpreg_DMA_RE;
N#if defined (USE_MDR1986VE1T) || defined (USE_MDR1986VE3)
X#if 0L || 0L
S  }
S  else{
S	  tmpreg_DMA_RE = TIMERx->DMA_REChx[TIMER_DMAChannel];
S
S	  /* Form new value */
S	  if (NewState != DISABLE)
S	  {
S		/* Enable TIMERx DMA Requests by setting bits in the DMA_RE register */
S		tmpreg_DMA_RE |= TIMER_DMASource;
S	  }
S	  else
S	  {
S		/* Disable TIMERx DMA Requests by clearing bits in the DMA_RE register */
S		tmpreg_DMA_RE &= ~TIMER_DMASource;
S	  }
S
S	  /* Configure CNTRL register with new value */
S	  TIMERx->DMA_REChx[TIMER_DMAChannel] = tmpreg_DMA_RE;
S
S  }
N#endif
N}
N
N/**
N  * @brief  Enables or disables the specified TIMER interrupts.
N  * @param  TIMERx: where x can be 1 to 3 to select the TIMER peripheral.
N  * @param  TIMER_IT: specifies the TIMER interrupts sources to be enabled or disabled.
N  *         This parameter can be any combination of the following values:
N  *           @arg TIMER_STATUS_CNT_ZERO:         the (CNT == 0) condition occured;
N  *           @arg TIMER_STATUS_CNT_ARR:          the (CNT == ARR) condition occured;
N  *           @arg TIMER_STATUS_ETR_RISING_EDGE:  the ETR rising edge occured;
N  *           @arg TIMER_STATUS_ETR_FALLING_EDGE: the ETR falling edge occured;
N  *           @arg TIMER_STATUS_BRK:              the (BRK == 1) condition occured;
N  *           @arg TIMER_STATUS_CCR_CAP_CH1:      the Channel 1 CCR capture condition occured;
N  *           @arg TIMER_STATUS_CCR_CAP_CH2:      the Channel 2 CCR capture condition occured;
N  *           @arg TIMER_STATUS_CCR_CAP_CH3:      the Channel 3 CCR capture condition occured;
N  *           @arg TIMER_STATUS_CCR_CAP_CH4:      the Channel 4 CCR capture condition occured;
N  *           @arg TIMER_STATUS_CCR_REF_CH1:      the Channel 1 (REF == 1) condition occured;
N  *           @arg TIMER_STATUS_CCR_REF_CH2:      the Channel 2 (REF == 1) condition occured;
N  *           @arg TIMER_STATUS_CCR_REF_CH3:      the Channel 3 (REF == 1) condition occured;
N  *           @arg TIMER_STATUS_CCR_REF_CH4:      the Channel 4 (REF == 1) condition occured;
N  *           @arg TIMER_STATUS_CCR_CAP1_CH1:     the Channel 1 CCR1 capture condition occured;
N  *           @arg TIMER_STATUS_CCR_CAP1_CH2:     the Channel 2 CCR1 capture condition occured;
N  *           @arg TIMER_STATUS_CCR_CAP1_CH3:     the Channel 3 CCR1 capture condition occured;
N  *           @arg TIMER_STATUS_CCR_CAP1_CH4:     the Channel 4 CCR1 capture condition occured.
N  * @param  NewState: new state of the TIMER interrupts.
N  *         This parameter can be: ENABLE or DISABLE.
N  * @retval None
N  */
Nvoid TIMER_ITConfig(MDR_TIMER_TypeDef* TIMERx, uint32_t TIMER_IT, FunctionalState NewState)
N{
N  uint32_t tmpreg_IE;
N
N  /* Check the parameters */
N  assert_param(IS_TIMER_ALL_PERIPH(TIMERx));
X  ((void)0);
N  assert_param(IS_TIMER_STATUS(TIMER_IT));
X  ((void)0);
N  assert_param(IS_FUNCTIONAL_STATE(NewState));
X  ((void)0);
N
N  tmpreg_IE = TIMERx->IE;
N
N  /* Form new value */
N  if (NewState != DISABLE)
N  {
N    /* Enable the TIMERx Interrupt requests by setting bits in the IE register */
N    tmpreg_IE |= TIMER_IT;
N  }
N  else
N  {
N    /* Disable the TIMERx Interrupt requests by clearing bits in the IE register */
N    tmpreg_IE &= ~TIMER_IT;
N  }
N
N  /* Configure CNTRL register with new value */
N  TIMERx->IE = tmpreg_IE;
N}
N
N/**
N  * @brief  Checks whether the TIMERx interrupt has occurred or not.
N  * @param  TIMERx: where x can be 1 to 3 to select the TIMER peripheral.
N  * @param  TIMER_IT: specifies the TIMER interrupt source to check.
N  *         This parameter can be one of the following values:
N  *           @arg TIMER_STATUS_CNT_ZERO:         the (CNT == 0) condition occured;
N  *           @arg TIMER_STATUS_CNT_ARR:          the (CNT == ARR) condition occured;
N  *           @arg TIMER_STATUS_ETR_RISING_EDGE:  the ETR rising edge occured;
N  *           @arg TIMER_STATUS_ETR_FALLING_EDGE: the ETR falling edge occured;
N  *           @arg TIMER_STATUS_BRK:              the (BRK == 1) condition occured;
N  *           @arg TIMER_STATUS_CCR_CAP_CH1:      the Channel 1 CCR capture condition occured;
N  *           @arg TIMER_STATUS_CCR_CAP_CH2:      the Channel 2 CCR capture condition occured;
N  *           @arg TIMER_STATUS_CCR_CAP_CH3:      the Channel 3 CCR capture condition occured;
N  *           @arg TIMER_STATUS_CCR_CAP_CH4:      the Channel 4 CCR capture condition occured;
N  *           @arg TIMER_STATUS_CCR_REF_CH1:      the Channel 1 (REF == 1) condition occured;
N  *           @arg TIMER_STATUS_CCR_REF_CH2:      the Channel 2 (REF == 1) condition occured;
N  *           @arg TIMER_STATUS_CCR_REF_CH3:      the Channel 3 (REF == 1) condition occured;
N  *           @arg TIMER_STATUS_CCR_REF_CH4:      the Channel 4 (REF == 1) condition occured;
N  *           @arg TIMER_STATUS_CCR_CAP1_CH1:     the Channel 1 CCR1 capture condition occured;
N  *           @arg TIMER_STATUS_CCR_CAP1_CH2:     the Channel 2 CCR1 capture condition occured;
N  *           @arg TIMER_STATUS_CCR_CAP1_CH3:     the Channel 3 CCR1 capture condition occured;
N  *           @arg TIMER_STATUS_CCR_CAP1_CH4:     the Channel 4 CCR1 capture condition occured.
N  * @retval The new state of the TIMER_IT (SET or RESET).
N  */
NITStatus TIMER_GetITStatus(MDR_TIMER_TypeDef* TIMERx, uint32_t TIMER_IT)
N{
N  ITStatus bitstatus;
N  uint32_t tmpreg;
N
N  /* Check the parameters */
N  assert_param(IS_TIMER_ALL_PERIPH(TIMERx));
X  ((void)0);
N  assert_param(IS_TIMER_STATUS_FLAG(TIMER_IT));
X  ((void)0);
N
N  tmpreg = TIMERx->IE;
N  tmpreg = TIMERx->STATUS & tmpreg & TIMER_IT;
N
N  if (tmpreg == 0)
N  {
N    bitstatus = RESET;
N  }
N  else
N  {
N    bitstatus = SET;
N  }
N
N  return bitstatus;
N}
N
N/**
N  * @brief  Initializes the TIMERx peripheral Clock according to the
N  *         specified parameters.
N  * @param  TIMERx: where x can be 1 to 3 to select the TIMER peripheral.
N  * @param  TIMER_BRG: specifies the HCLK division factor.
N  *         This parameter can be one of the following values:
N  *           @arg TIMER_HCLKdiv1:   no division of input frequency;
N  *           @arg TIMER_HCLKdiv2:   selects input frequency divider by 2;
N  *           @arg TIMER_HCLKdiv4:   selects input frequency divider by 4;
N  *           @arg TIMER_HCLKdiv8:   selects input frequency divider by 8;
N  *           @arg TIMER_HCLKdiv16:  selects input frequency divider by 16;
N  *           @arg TIMER_HCLKdiv32:  selects input frequency divider by 32;
N  *           @arg TIMER_HCLKdiv64:  selects input frequency divider by 64;
N  *           @arg TIMER_HCLKdiv128: selects input frequency divider by 128.
N  * @retval None
N  */
Nvoid TIMER_BRGInit ( MDR_TIMER_TypeDef* TIMERx, uint32_t TIMER_BRG ) {
N	uint32_t tmpreg;
N
N	/* Check the parameters */
N	assert_param(IS_TIMER_ALL_PERIPH(TIMERx));
X	((void)0);
N	assert_param(IS_TIMER_CLOCK_BRG(TIMER_BRG));
X	((void)0);
N
N#if ( (defined (USE_MDR1986VE3) ) || (defined (USE_MDR1986VE1T)) ) /* For USE_MDR1986VE3 (Cortex M1) */
X#if ( (0L ) || (0L) )  
S	if(TIMERx == MDR_TIMER4)
S		tmpreg = MDR_RST_CLK->UART_CLOCK;
S	else
N#endif // #if (defined (USE_MDR1986VE3) || defined (MDR1986VE1T)) /* For USE_MDR1986VE3 (Cortex M1) */
N		tmpreg = MDR_RST_CLK->TIM_CLOCK;
X		tmpreg = ((MDR_RST_CLK_TypeDef *) (0x40020000))->TIM_CLOCK;
N
N	if (TIMERx == MDR_TIMER1) {
X	if (TIMERx == ((MDR_TIMER_TypeDef *) (0x40070000))) {
N		tmpreg &= ~RST_CLK_TIM_CLOCK_TIM1_BRG_Msk;
X		tmpreg &= ~((uint32_t)0x000000FF);
N		tmpreg |= TIMER_BRG << RST_CLK_TIM_CLOCK_TIM1_BRG_Pos;
X		tmpreg |= TIMER_BRG << 0;
N		tmpreg |= RST_CLK_TIM_CLOCK_TIM1_CLK_EN;
X		tmpreg |= ((uint32_t)0x01000000);
N	}
N	else
N		if (TIMERx == MDR_TIMER2) {
X		if (TIMERx == ((MDR_TIMER_TypeDef *) (0x40078000))) {
N			tmpreg &= ~RST_CLK_TIM_CLOCK_TIM2_BRG_Msk;
X			tmpreg &= ~((uint32_t)0x0000FF00);
N			tmpreg |= TIMER_BRG << RST_CLK_TIM_CLOCK_TIM2_BRG_Pos;
X			tmpreg |= TIMER_BRG << 8;
N			tmpreg |= RST_CLK_TIM_CLOCK_TIM2_CLK_EN;
X			tmpreg |= ((uint32_t)0x02000000);
N		}
N		else
N			if (TIMERx == MDR_TIMER3) {
X			if (TIMERx == ((MDR_TIMER_TypeDef *) (0x40080000))) {
N				tmpreg &= ~RST_CLK_TIM_CLOCK_TIM3_BRG_Msk;
X				tmpreg &= ~((uint32_t)0x00FF0000);
N				tmpreg |= TIMER_BRG << RST_CLK_TIM_CLOCK_TIM3_BRG_Pos;
X				tmpreg |= TIMER_BRG << 16;
N				tmpreg |= RST_CLK_TIM_CLOCK_TIM3_CLK_EN;
X				tmpreg |= ((uint32_t)0x04000000);
N			}
N#if ( (defined (USE_MDR1986VE3) ) || (defined (USE_MDR1986VE1T)) ) /* For USE_MDR1986VE3 (Cortex M1) */
X#if ( (0L ) || (0L) )  
S			else
S				if(TIMERx == MDR_TIMER4) {
S					tmpreg &= ~RST_CLK_UART_CLOCK_TIM4_BRG_Msk;
S					tmpreg |= TIMER_BRG << RST_CLK_UART_CLOCK_TIM4_BRG_Pos;
S					tmpreg |= RST_CLK_UART_CLOCK_TIM4_CLK_EN;
S				} // if(TIMERx == MDR_TIMER4) {
N#endif // #if ( (defined (USE_MDR1986VE3) ) || (defined (MDR1986VE1T)) ) /* For USE_MDR1986VE3 (Cortex M1) */
N
N#if ( (defined (USE_MDR1986VE3) ) || (defined (USE_MDR1986VE1T)) ) /* For USE_MDR1986VE3 (Cortex M1) */
X#if ( (0L ) || (0L) )  
S	if(TIMERx == MDR_TIMER4)
S		MDR_RST_CLK->UART_CLOCK = tmpreg;
S	else
N#endif // #if (defined (USE_MDR1986VE3) || defined (MDR1986VE1T)) /* For USE_MDR1986VE3 (Cortex M1) */
N		MDR_RST_CLK->TIM_CLOCK = tmpreg;
X		((MDR_RST_CLK_TypeDef *) (0x40020000))->TIM_CLOCK = tmpreg;
N
N}
N
N/** @} */ /* End of group TIMER_Private_Functions */
N
N/** @} */ /* End of group TIMER */
N
N/** @} */ /* End of group __MDR32F9Qx_StdPeriph_Driver */
N
N/*
N*
N* END OF FILE MDR32F9Qx_timer.c */
N
