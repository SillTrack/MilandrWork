L 1 "adc.c"
N/**
N  ******************************************************************************
N  * \file    adc.c
N   * \brief   Инициализация АЦП
N  *          
N  ******************************************************************************
N*/
N
N/* Подключение заголовочного файла с макроопределениями 
N   регистров специальных функций К1986ВЕ92QI(MDR32F9Q2I) */
N#include <MDR32Fx.h>
L 1 "C:\Keil_v5\ARM\PACK\Keil\MDR1986BExx\1.5.3\Libraries\CMSIS\CM3\DeviceSupport\MDR32F9Qx\inc\MDR32Fx.h" 1
N/**
N  * FILE MDR32Fx.h
N  */
N
N/* Define to prevent recursive inclusion -------------------------------------*/
N#ifndef __MDR32FX_H
N#define __MDR32FX_H
N
N/** @addtogroup __CMSIS CMSIS
N  * @{
N  */
N
N/** @defgroup MDR1986VE9x MDR1986VE9x
N *  @{
N */
N
N/** @defgroup __MDR32Fx_Peripheral MDR32F9Qx Peripheral
N  * @{
N  */
N
N#ifdef __cplusplus
Sextern "C" {
N#endif
N
N#if defined ( __CC_ARM   )
X#if 1L
N  #pragma anon_unions
N#endif
N
N/* MDR32Fx Interrupt Number Definition */
Ntypedef enum IRQn
N{
N/*---- Cortex-M3 Processor Exceptions Numbers --------------------------------*/
N  NonMaskableInt_IRQn     = -14,  /*!<  2 Non Maskable Interrupt              *///!< NonMaskableInt_IRQn
N  HardFault_IRQn          = -13,  /*!<  3 Hard Fault Interrupt                *///!< HardFault_IRQn
N  MemoryManagement_IRQn   = -12,  /*!<  4 Memory Management Interrupt         *///!< MemoryManagement_IRQn
N  BusFault_IRQn           = -11,  /*!<  5 Bus Fault Interrupt                 *///!< BusFault_IRQn
N  UsageFault_IRQn         = -10,  /*!<  6 Usage Fault Interrupt               *///!< UsageFault_IRQn
N  SVCall_IRQn             = -5,   /*!< 11 SV Call Interrupt                   *///!< SVCall_IRQn
N  PendSV_IRQn             = -2,   /*!< 14 Pend SV Interrupt                   *///!< PendSV_IRQn
N  SysTick_IRQn            = -1,   /*!< 15 System Tick Timer Interrupt         *///!< SysTick_IRQn
N
N/*---- MDR32Fx specific Interrupt Numbers ------------------------------------*/
N  CAN1_IRQn               =  0,   /*!< CAN1 Interrupt                         *///!< CAN1_IRQn
N  CAN2_IRQn               =  1,   /*!< CAN1 Interrupt                         *///!< CAN2_IRQn
N  USB_IRQn                =  2,   /*!< USB Host Interrupt                     *///!< USB_IRQn
N  DMA_IRQn                =  5,   /*!< DMA Interrupt                          *///!< DMA_IRQn
N  UART1_IRQn              =  6,   /*!< UART1 Interrupt                        *///!< UART1_IRQn
N  UART2_IRQn              =  7,   /*!< UART2 Interrupt                        *///!< UART2_IRQn
N  SSP1_IRQn               =  8,   /*!< SSP1 Interrupt                         *///!< SSP1_IRQn
N  I2C_IRQn                =  10,  /*!< I2C Interrupt                          *///!< I2C_IRQn
N  POWER_IRQn              =  11,  /*!< POWER Detecor Interrupt                *///!< POWER_IRQn
N  WWDG_IRQn               =  12,  /*!< Window Watchdog Interrupt              *///!< WWDG_IRQn
N  Timer1_IRQn             =  14,  /*!< Timer1 Interrupt                       *///!< Timer1_IRQn
N  Timer2_IRQn             =  15,  /*!< Timer2 Interrupt                       *///!< Timer2_IRQn
N  Timer3_IRQn             =  16,  /*!< Timer3 Interrupt                       *///!< Timer3_IRQn
N  ADC_IRQn                =  17,  /*!< ADC Interrupt                          *///!< ADC_IRQn
N  COMPARATOR_IRQn         =  19,  /*!< COMPARATOR Interrupt                   *///!< COMPARATOR_IRQn
N  SSP2_IRQn               =  20,  /*!< SSP2 Interrupt                         *///!< SSP2_IRQn
N  BACKUP_IRQn             =  27,  /*!< BACKUP Interrupt                       *///!< BACKUP_IRQn
N  EXT_INT1_IRQn           =  28,  /*!< EXT_INT1 Interrupt                     *///!< EXT_INT1_IRQn
N  EXT_INT2_IRQn           =  29,  /*!< EXT_INT2 Interrupt                     *///!< EXT_INT2_IRQn
N  EXT_INT3_IRQn           =  30,  /*!< EXT_INT3 Interrupt                     *///!< EXT_INT3_IRQn
N  EXT_INT4_IRQn           =  31   /*!< EXT_INT4 Interrupt                     *///!< EXT_INT4_IRQn
N}IRQn_Type;
N
N/** @addtogroup __Configuration_of_CMSIS Configuration of CMSIS
N  * @{
N  */
N
N/* Configuration of the Cortex-M3 Processor and Core Peripherals */
N#define __CM3_REV              0x0102   /*!< Cortex-M3 Core Revision                      */
N#define __MPU_PRESENT             1     /*!< MPU present or not                           */
N#define __NVIC_PRIO_BITS          3     /*!< Number of Bits used for Priority Levels      */
N#define __Vendor_SysTickConfig    0     /*!< Set to 1 if different SysTick Config is used */
N
N/** @} */ /* End of group __Configuration_of_CMSIS */
N
N/* Includes ------------------------------------------------------------------*/
N#include "core_cm3.h"
L 1 "C:\Keil_v5\ARM\PACK\ARM\CMSIS\5.0.1\CMSIS\Include\core_cm3.h" 1
N/**************************************************************************//**
N * @file     core_cm3.h
N * @brief    CMSIS Cortex-M3 Core Peripheral Access Layer Header File
N * @version  V5.0.1
N * @date     30. January 2017
N ******************************************************************************/
N/*
N * Copyright (c) 2009-2016 ARM Limited. All rights reserved.
N *
N * SPDX-License-Identifier: Apache-2.0
N *
N * Licensed under the Apache License, Version 2.0 (the License); you may
N * not use this file except in compliance with the License.
N * You may obtain a copy of the License at
N *
N * www.apache.org/licenses/LICENSE-2.0
N *
N * Unless required by applicable law or agreed to in writing, software
N * distributed under the License is distributed on an AS IS BASIS, WITHOUT
N * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
N * See the License for the specific language governing permissions and
N * limitations under the License.
N */
N
N#if   defined ( __ICCARM__ )
X#if   0L
S #pragma system_include         /* treat file as system include file for MISRA check */
S#elif defined (__ARMCC_VERSION) && (__ARMCC_VERSION >= 6010050)
X#elif 1L && (5060528 >= 6010050)
S  #pragma clang system_header   /* treat file as system include file */
N#endif
N
N#ifndef __CORE_CM3_H_GENERIC
N#define __CORE_CM3_H_GENERIC
N
N#include <stdint.h>
L 1 "C:\Keil_v5\ARM\ARMCC\Bin\..\include\stdint.h" 1
N/* Copyright (C) ARM Ltd., 1999,2014 */
N/* All rights reserved */
N
N/*
N * RCS $Revision$
N * Checkin $Date$
N * Revising $Author: agrant $
N */
N
N#ifndef __stdint_h
N#define __stdint_h
N#define __ARMCLIB_VERSION 5060034
N
N  #ifdef __INT64_TYPE__
S    /* armclang predefines '__INT64_TYPE__' and '__INT64_C_SUFFIX__' */
S    #define __INT64 __INT64_TYPE__
N  #else
N    /* armcc has builtin '__int64' which can be used in --strict mode */
N    #define __INT64 __int64
N    #define __INT64_C_SUFFIX__ ll
N  #endif
N  #define __PASTE2(x, y) x ## y
N  #define __PASTE(x, y) __PASTE2(x, y)
N  #define __INT64_C(x)  __ESCAPE__(__PASTE(x, __INT64_C_SUFFIX__))
N  #define __UINT64_C(x)  __ESCAPE__(__PASTE(x ## u, __INT64_C_SUFFIX__))
N  #if defined(__clang__) || (defined(__ARMCC_VERSION) && !defined(__STRICT_ANSI__))
X  #if 0L || (1L && !0L)
N    /* armclang and non-strict armcc allow 'long long' in system headers */
N    #define __LONGLONG long long
N  #else
S    /* strict armcc has '__int64' */
S    #define __LONGLONG __int64
N  #endif
N
N  #ifndef __STDINT_DECLS
N  #define __STDINT_DECLS
N
N    #undef __CLIBNS
N
N    #ifdef __cplusplus
S      namespace std {
S          #define __CLIBNS std::
S          extern "C" {
N    #else
N      #define __CLIBNS
N    #endif  /* __cplusplus */
N
N
N/*
N * 'signed' is redundant below, except for 'signed char' and if
N * the typedef is used to declare a bitfield.
N */
N
N    /* 7.18.1.1 */
N
N    /* exact-width signed integer types */
Ntypedef   signed          char int8_t;
Ntypedef   signed short     int int16_t;
Ntypedef   signed           int int32_t;
Ntypedef   signed       __INT64 int64_t;
Xtypedef   signed       __int64 int64_t;
N
N    /* exact-width unsigned integer types */
Ntypedef unsigned          char uint8_t;
Ntypedef unsigned short     int uint16_t;
Ntypedef unsigned           int uint32_t;
Ntypedef unsigned       __INT64 uint64_t;
Xtypedef unsigned       __int64 uint64_t;
N
N    /* 7.18.1.2 */
N
N    /* smallest type of at least n bits */
N    /* minimum-width signed integer types */
Ntypedef   signed          char int_least8_t;
Ntypedef   signed short     int int_least16_t;
Ntypedef   signed           int int_least32_t;
Ntypedef   signed       __INT64 int_least64_t;
Xtypedef   signed       __int64 int_least64_t;
N
N    /* minimum-width unsigned integer types */
Ntypedef unsigned          char uint_least8_t;
Ntypedef unsigned short     int uint_least16_t;
Ntypedef unsigned           int uint_least32_t;
Ntypedef unsigned       __INT64 uint_least64_t;
Xtypedef unsigned       __int64 uint_least64_t;
N
N    /* 7.18.1.3 */
N
N    /* fastest minimum-width signed integer types */
Ntypedef   signed           int int_fast8_t;
Ntypedef   signed           int int_fast16_t;
Ntypedef   signed           int int_fast32_t;
Ntypedef   signed       __INT64 int_fast64_t;
Xtypedef   signed       __int64 int_fast64_t;
N
N    /* fastest minimum-width unsigned integer types */
Ntypedef unsigned           int uint_fast8_t;
Ntypedef unsigned           int uint_fast16_t;
Ntypedef unsigned           int uint_fast32_t;
Ntypedef unsigned       __INT64 uint_fast64_t;
Xtypedef unsigned       __int64 uint_fast64_t;
N
N    /* 7.18.1.4 integer types capable of holding object pointers */
N#if __sizeof_ptr == 8
X#if 4 == 8
Stypedef   signed       __INT64 intptr_t;
Stypedef unsigned       __INT64 uintptr_t;
N#else
Ntypedef   signed           int intptr_t;
Ntypedef unsigned           int uintptr_t;
N#endif
N
N    /* 7.18.1.5 greatest-width integer types */
Ntypedef   signed     __LONGLONG intmax_t;
Xtypedef   signed     long long intmax_t;
Ntypedef unsigned     __LONGLONG uintmax_t;
Xtypedef unsigned     long long uintmax_t;
N
N
N#if !defined(__cplusplus) || defined(__STDC_LIMIT_MACROS)
X#if !0L || 0L
N
N    /* 7.18.2.1 */
N
N    /* minimum values of exact-width signed integer types */
N#define INT8_MIN                   -128
N#define INT16_MIN                -32768
N#define INT32_MIN          (~0x7fffffff)   /* -2147483648 is unsigned */
N#define INT64_MIN  __INT64_C(~0x7fffffffffffffff) /* -9223372036854775808 is unsigned */
N
N    /* maximum values of exact-width signed integer types */
N#define INT8_MAX                    127
N#define INT16_MAX                 32767
N#define INT32_MAX            2147483647
N#define INT64_MAX  __INT64_C(9223372036854775807)
N
N    /* maximum values of exact-width unsigned integer types */
N#define UINT8_MAX                   255
N#define UINT16_MAX                65535
N#define UINT32_MAX           4294967295u
N#define UINT64_MAX __UINT64_C(18446744073709551615)
N
N    /* 7.18.2.2 */
N
N    /* minimum values of minimum-width signed integer types */
N#define INT_LEAST8_MIN                   -128
N#define INT_LEAST16_MIN                -32768
N#define INT_LEAST32_MIN          (~0x7fffffff)
N#define INT_LEAST64_MIN  __INT64_C(~0x7fffffffffffffff)
N
N    /* maximum values of minimum-width signed integer types */
N#define INT_LEAST8_MAX                    127
N#define INT_LEAST16_MAX                 32767
N#define INT_LEAST32_MAX            2147483647
N#define INT_LEAST64_MAX  __INT64_C(9223372036854775807)
N
N    /* maximum values of minimum-width unsigned integer types */
N#define UINT_LEAST8_MAX                   255
N#define UINT_LEAST16_MAX                65535
N#define UINT_LEAST32_MAX           4294967295u
N#define UINT_LEAST64_MAX __UINT64_C(18446744073709551615)
N
N    /* 7.18.2.3 */
N
N    /* minimum values of fastest minimum-width signed integer types */
N#define INT_FAST8_MIN           (~0x7fffffff)
N#define INT_FAST16_MIN          (~0x7fffffff)
N#define INT_FAST32_MIN          (~0x7fffffff)
N#define INT_FAST64_MIN  __INT64_C(~0x7fffffffffffffff)
N
N    /* maximum values of fastest minimum-width signed integer types */
N#define INT_FAST8_MAX             2147483647
N#define INT_FAST16_MAX            2147483647
N#define INT_FAST32_MAX            2147483647
N#define INT_FAST64_MAX  __INT64_C(9223372036854775807)
N
N    /* maximum values of fastest minimum-width unsigned integer types */
N#define UINT_FAST8_MAX            4294967295u
N#define UINT_FAST16_MAX           4294967295u
N#define UINT_FAST32_MAX           4294967295u
N#define UINT_FAST64_MAX __UINT64_C(18446744073709551615)
N
N    /* 7.18.2.4 */
N
N    /* minimum value of pointer-holding signed integer type */
N#if __sizeof_ptr == 8
X#if 4 == 8
S#define INTPTR_MIN INT64_MIN
N#else
N#define INTPTR_MIN INT32_MIN
N#endif
N
N    /* maximum value of pointer-holding signed integer type */
N#if __sizeof_ptr == 8
X#if 4 == 8
S#define INTPTR_MAX INT64_MAX
N#else
N#define INTPTR_MAX INT32_MAX
N#endif
N
N    /* maximum value of pointer-holding unsigned integer type */
N#if __sizeof_ptr == 8
X#if 4 == 8
S#define UINTPTR_MAX UINT64_MAX
N#else
N#define UINTPTR_MAX UINT32_MAX
N#endif
N
N    /* 7.18.2.5 */
N
N    /* minimum value of greatest-width signed integer type */
N#define INTMAX_MIN  __ESCAPE__(~0x7fffffffffffffffll)
N
N    /* maximum value of greatest-width signed integer type */
N#define INTMAX_MAX  __ESCAPE__(9223372036854775807ll)
N
N    /* maximum value of greatest-width unsigned integer type */
N#define UINTMAX_MAX __ESCAPE__(18446744073709551615ull)
N
N    /* 7.18.3 */
N
N    /* limits of ptrdiff_t */
N#if __sizeof_ptr == 8
X#if 4 == 8
S#define PTRDIFF_MIN INT64_MIN
S#define PTRDIFF_MAX INT64_MAX
N#else
N#define PTRDIFF_MIN INT32_MIN
N#define PTRDIFF_MAX INT32_MAX
N#endif
N
N    /* limits of sig_atomic_t */
N#define SIG_ATOMIC_MIN (~0x7fffffff)
N#define SIG_ATOMIC_MAX   2147483647
N
N    /* limit of size_t */
N#if __sizeof_ptr == 8
X#if 4 == 8
S#define SIZE_MAX UINT64_MAX
N#else
N#define SIZE_MAX UINT32_MAX
N#endif
N
N    /* limits of wchar_t */
N    /* NB we have to undef and redef because they're defined in both
N     * stdint.h and wchar.h */
N#undef WCHAR_MIN
N#undef WCHAR_MAX
N
N#if defined(__WCHAR32) || (defined(__ARM_SIZEOF_WCHAR_T) && __ARM_SIZEOF_WCHAR_T == 4)
X#if 0L || (0L && __ARM_SIZEOF_WCHAR_T == 4)
S  #define WCHAR_MIN   0
S  #define WCHAR_MAX   0xffffffffU
N#else
N  #define WCHAR_MIN   0
N  #define WCHAR_MAX   65535
N#endif
N
N    /* limits of wint_t */
N#define WINT_MIN (~0x7fffffff)
N#define WINT_MAX 2147483647
N
N#endif /* __STDC_LIMIT_MACROS */
N
N#if !defined(__cplusplus) || defined(__STDC_CONSTANT_MACROS)
X#if !0L || 0L
N
N    /* 7.18.4.1 macros for minimum-width integer constants */
N#define INT8_C(x)   (x)
N#define INT16_C(x)  (x)
N#define INT32_C(x)  (x)
N#define INT64_C(x)  __INT64_C(x)
N
N#define UINT8_C(x)  (x ## u)
N#define UINT16_C(x) (x ## u)
N#define UINT32_C(x) (x ## u)
N#define UINT64_C(x) __UINT64_C(x)
N
N    /* 7.18.4.2 macros for greatest-width integer constants */
N#define INTMAX_C(x)  __ESCAPE__(x ## ll)
N#define UINTMAX_C(x) __ESCAPE__(x ## ull)
N
N#endif /* __STDC_CONSTANT_MACROS */
N
N    #ifdef __cplusplus
S         }  /* extern "C" */
S      }  /* namespace std */
N    #endif /* __cplusplus */
N  #endif /* __STDINT_DECLS */
N
N  #ifdef __cplusplus
S    #ifndef __STDINT_NO_EXPORTS
S      using ::std::int8_t;
S      using ::std::int16_t;
S      using ::std::int32_t;
S      using ::std::int64_t;
S      using ::std::uint8_t;
S      using ::std::uint16_t;
S      using ::std::uint32_t;
S      using ::std::uint64_t;
S      using ::std::int_least8_t;
S      using ::std::int_least16_t;
S      using ::std::int_least32_t;
S      using ::std::int_least64_t;
S      using ::std::uint_least8_t;
S      using ::std::uint_least16_t;
S      using ::std::uint_least32_t;
S      using ::std::uint_least64_t;
S      using ::std::int_fast8_t;
S      using ::std::int_fast16_t;
S      using ::std::int_fast32_t;
S      using ::std::int_fast64_t;
S      using ::std::uint_fast8_t;
S      using ::std::uint_fast16_t;
S      using ::std::uint_fast32_t;
S      using ::std::uint_fast64_t;
S      using ::std::intptr_t;
S      using ::std::uintptr_t;
S      using ::std::intmax_t;
S      using ::std::uintmax_t;
S    #endif
N  #endif /* __cplusplus */
N
N#undef __INT64
N#undef __LONGLONG
N
N#endif /* __stdint_h */
N
N/* end of stdint.h */
L 35 "C:\Keil_v5\ARM\PACK\ARM\CMSIS\5.0.1\CMSIS\Include\core_cm3.h" 2
N
N#ifdef __cplusplus
S extern "C" {
N#endif
N
N/**
N  \page CMSIS_MISRA_Exceptions  MISRA-C:2004 Compliance Exceptions
N  CMSIS violates the following MISRA-C:2004 rules:
N
N   \li Required Rule 8.5, object/function definition in header file.<br>
N     Function definitions in header files are used to allow 'inlining'.
N
N   \li Required Rule 18.4, declaration of union type or object of union type: '{...}'.<br>
N     Unions are used for effective representation of core registers.
N
N   \li Advisory Rule 19.7, Function-like macro defined.<br>
N     Function-like macros are used to allow more efficient code.
N */
N
N
N/*******************************************************************************
N *                 CMSIS definitions
N ******************************************************************************/
N/**
N  \ingroup Cortex_M3
N  @{
N */
N
N/*  CMSIS CM3 definitions */
N#define __CM3_CMSIS_VERSION_MAIN  ( 5U)                                  /*!< [31:16] CMSIS HAL main version */
N#define __CM3_CMSIS_VERSION_SUB   ( 0U)                                  /*!< [15:0]  CMSIS HAL sub version */
N#define __CM3_CMSIS_VERSION       ((__CM3_CMSIS_VERSION_MAIN << 16U) | \
N                                    __CM3_CMSIS_VERSION_SUB           )  /*!< CMSIS HAL version number */
X#define __CM3_CMSIS_VERSION       ((__CM3_CMSIS_VERSION_MAIN << 16U) |                                     __CM3_CMSIS_VERSION_SUB           )   
N
N#define __CORTEX_M                (3U)                                   /*!< Cortex-M Core */
N
N/** __FPU_USED indicates whether an FPU is used or not.
N    This core does not support an FPU at all
N*/
N#define __FPU_USED       0U
N
N#if defined ( __CC_ARM )
X#if 1L
N  #if defined __TARGET_FPU_VFP
X  #if 0L
S    #error "Compiler generates FPU instructions for a device without an FPU (check __FPU_PRESENT)"
N  #endif
N
N#elif defined (__ARMCC_VERSION) && (__ARMCC_VERSION >= 6010050)
S  #if defined __ARM_PCS_VFP
S    #error "Compiler generates FPU instructions for a device without an FPU (check __FPU_PRESENT)"
S  #endif
S
S#elif defined ( __GNUC__ )
S  #if defined (__VFP_FP__) && !defined(__SOFTFP__)
S    #error "Compiler generates FPU instructions for a device without an FPU (check __FPU_PRESENT)"
S  #endif
S
S#elif defined ( __ICCARM__ )
S  #if defined __ARMVFP__
S    #error "Compiler generates FPU instructions for a device without an FPU (check __FPU_PRESENT)"
S  #endif
S
S#elif defined ( __TI_ARM__ )
S  #if defined __TI_VFP_SUPPORT__
S    #error "Compiler generates FPU instructions for a device without an FPU (check __FPU_PRESENT)"
S  #endif
S
S#elif defined ( __TASKING__ )
S  #if defined __FPU_VFP__
S    #error "Compiler generates FPU instructions for a device without an FPU (check __FPU_PRESENT)"
S  #endif
S
S#elif defined ( __CSMC__ )
S  #if ( __CSMC__ & 0x400U)
S    #error "Compiler generates FPU instructions for a device without an FPU (check __FPU_PRESENT)"
S  #endif
S
N#endif
N
N#include "cmsis_compiler.h"               /* CMSIS compiler specific defines */
L 1 "C:\Keil_v5\ARM\PACK\ARM\CMSIS\5.0.1\CMSIS\Include\cmsis_compiler.h" 1
N/**************************************************************************//**
N * @file     cmsis_compiler.h
N * @brief    CMSIS compiler generic header file
N * @version  V5.0.1
N * @date     30. January 2017
N ******************************************************************************/
N/*
N * Copyright (c) 2009-2017 ARM Limited. All rights reserved.
N *
N * SPDX-License-Identifier: Apache-2.0
N *
N * Licensed under the Apache License, Version 2.0 (the License); you may
N * not use this file except in compliance with the License.
N * You may obtain a copy of the License at
N *
N * www.apache.org/licenses/LICENSE-2.0
N *
N * Unless required by applicable law or agreed to in writing, software
N * distributed under the License is distributed on an AS IS BASIS, WITHOUT
N * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
N * See the License for the specific language governing permissions and
N * limitations under the License.
N */
N
N#ifndef __CMSIS_COMPILER_H
N#define __CMSIS_COMPILER_H
N
N#include <stdint.h>
N
N/*
N * ARM Compiler 4/5
N */
N#if   defined ( __CC_ARM )
X#if   1L
N  #include "cmsis_armcc.h"
L 1 "C:\Keil_v5\ARM\PACK\ARM\CMSIS\5.0.1\CMSIS\Include\cmsis_armcc.h" 1
N/**************************************************************************//**
N * @file     cmsis_armcc.h
N * @brief    CMSIS compiler ARMCC (ARM compiler V5) header file
N * @version  V5.0.1
N * @date     03. February 2017
N ******************************************************************************/
N/*
N * Copyright (c) 2009-2017 ARM Limited. All rights reserved.
N *
N * SPDX-License-Identifier: Apache-2.0
N *
N * Licensed under the Apache License, Version 2.0 (the License); you may
N * not use this file except in compliance with the License.
N * You may obtain a copy of the License at
N *
N * www.apache.org/licenses/LICENSE-2.0
N *
N * Unless required by applicable law or agreed to in writing, software
N * distributed under the License is distributed on an AS IS BASIS, WITHOUT
N * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
N * See the License for the specific language governing permissions and
N * limitations under the License.
N */
N
N#ifndef __CMSIS_ARMCC_H
N#define __CMSIS_ARMCC_H
N
N
N#if defined(__ARMCC_VERSION) && (__ARMCC_VERSION < 400677)
X#if 1L && (5060528 < 400677)
S  #error "Please use ARM Compiler Toolchain V4.0.677 or later!"
N#endif
N
N/* CMSIS compiler control architecture macros */
N#if ((defined (__TARGET_ARCH_6_M  ) && (__TARGET_ARCH_6_M   == 1)) || \
N     (defined (__TARGET_ARCH_6S_M ) && (__TARGET_ARCH_6S_M  == 1))   )
X#if ((0L && (__TARGET_ARCH_6_M   == 1)) ||      (0L && (__TARGET_ARCH_6S_M  == 1))   )
S  #define __ARM_ARCH_6M__           1
N#endif
N
N#if (defined (__TARGET_ARCH_7_M ) && (__TARGET_ARCH_7_M  == 1))
X#if (1L && (1  == 1))
N  #define __ARM_ARCH_7M__           1
N#endif
N
N#if (defined (__TARGET_ARCH_7E_M) && (__TARGET_ARCH_7E_M == 1))
X#if (0L && (__TARGET_ARCH_7E_M == 1))
S  #define __ARM_ARCH_7EM__          1
N#endif
N
N  /* __ARM_ARCH_8M_BASE__  not applicable */
N  /* __ARM_ARCH_8M_MAIN__  not applicable */
N
N
N/* CMSIS compiler specific defines */
N#ifndef   __ASM
N  #define __ASM                     __asm
N#endif
N#ifndef   __INLINE
N  #define __INLINE                  __inline
N#endif
N#ifndef   __STATIC_INLINE
N  #define __STATIC_INLINE           static __inline
N#endif
N#ifndef   __NO_RETURN
N  #define __NO_RETURN               __declspec(noreturn)
N#endif
N#ifndef   __USED
N  #define __USED                    __attribute__((used))
N#endif
N#ifndef   __WEAK
N  #define __WEAK                    __attribute__((weak))
N#endif
N#ifndef   __UNALIGNED_UINT32
N  #define __UNALIGNED_UINT32(x)     (*((__packed uint32_t *)(x)))
N#endif
N#ifndef   __ALIGNED
N  #define __ALIGNED(x)              __attribute__((aligned(x)))
N#endif
N#ifndef   __PACKED
N  #define __PACKED                  __attribute__((packed))
N#endif
N#ifndef   __PACKED_STRUCT
N  #define __PACKED_STRUCT           __packed struct
N#endif
N
N
N/* ###########################  Core Function Access  ########################### */
N/** \ingroup  CMSIS_Core_FunctionInterface
N    \defgroup CMSIS_Core_RegAccFunctions CMSIS Core Register Access Functions
N  @{
N */
N
N/**
N  \brief   Enable IRQ Interrupts
N  \details Enables IRQ interrupts by clearing the I-bit in the CPSR.
N           Can only be executed in Privileged modes.
N */
N/* intrinsic void __enable_irq();     */
N
N
N/**
N  \brief   Disable IRQ Interrupts
N  \details Disables IRQ interrupts by setting the I-bit in the CPSR.
N           Can only be executed in Privileged modes.
N */
N/* intrinsic void __disable_irq();    */
N
N/**
N  \brief   Get Control Register
N  \details Returns the content of the Control Register.
N  \return               Control Register value
N */
N__STATIC_INLINE uint32_t __get_CONTROL(void)
Xstatic __inline uint32_t __get_CONTROL(void)
N{
N  register uint32_t __regControl         __ASM("control");
X  register uint32_t __regControl         __asm("control");
N  return(__regControl);
N}
N
N
N/**
N  \brief   Set Control Register
N  \details Writes the given value to the Control Register.
N  \param [in]    control  Control Register value to set
N */
N__STATIC_INLINE void __set_CONTROL(uint32_t control)
Xstatic __inline void __set_CONTROL(uint32_t control)
N{
N  register uint32_t __regControl         __ASM("control");
X  register uint32_t __regControl         __asm("control");
N  __regControl = control;
N}
N
N
N/**
N  \brief   Get IPSR Register
N  \details Returns the content of the IPSR Register.
N  \return               IPSR Register value
N */
N__STATIC_INLINE uint32_t __get_IPSR(void)
Xstatic __inline uint32_t __get_IPSR(void)
N{
N  register uint32_t __regIPSR          __ASM("ipsr");
X  register uint32_t __regIPSR          __asm("ipsr");
N  return(__regIPSR);
N}
N
N
N/**
N  \brief   Get APSR Register
N  \details Returns the content of the APSR Register.
N  \return               APSR Register value
N */
N__STATIC_INLINE uint32_t __get_APSR(void)
Xstatic __inline uint32_t __get_APSR(void)
N{
N  register uint32_t __regAPSR          __ASM("apsr");
X  register uint32_t __regAPSR          __asm("apsr");
N  return(__regAPSR);
N}
N
N
N/**
N  \brief   Get xPSR Register
N  \details Returns the content of the xPSR Register.
N  \return               xPSR Register value
N */
N__STATIC_INLINE uint32_t __get_xPSR(void)
Xstatic __inline uint32_t __get_xPSR(void)
N{
N  register uint32_t __regXPSR          __ASM("xpsr");
X  register uint32_t __regXPSR          __asm("xpsr");
N  return(__regXPSR);
N}
N
N
N/**
N  \brief   Get Process Stack Pointer
N  \details Returns the current value of the Process Stack Pointer (PSP).
N  \return               PSP Register value
N */
N__STATIC_INLINE uint32_t __get_PSP(void)
Xstatic __inline uint32_t __get_PSP(void)
N{
N  register uint32_t __regProcessStackPointer  __ASM("psp");
X  register uint32_t __regProcessStackPointer  __asm("psp");
N  return(__regProcessStackPointer);
N}
N
N
N/**
N  \brief   Set Process Stack Pointer
N  \details Assigns the given value to the Process Stack Pointer (PSP).
N  \param [in]    topOfProcStack  Process Stack Pointer value to set
N */
N__STATIC_INLINE void __set_PSP(uint32_t topOfProcStack)
Xstatic __inline void __set_PSP(uint32_t topOfProcStack)
N{
N  register uint32_t __regProcessStackPointer  __ASM("psp");
X  register uint32_t __regProcessStackPointer  __asm("psp");
N  __regProcessStackPointer = topOfProcStack;
N}
N
N
N/**
N  \brief   Get Main Stack Pointer
N  \details Returns the current value of the Main Stack Pointer (MSP).
N  \return               MSP Register value
N */
N__STATIC_INLINE uint32_t __get_MSP(void)
Xstatic __inline uint32_t __get_MSP(void)
N{
N  register uint32_t __regMainStackPointer     __ASM("msp");
X  register uint32_t __regMainStackPointer     __asm("msp");
N  return(__regMainStackPointer);
N}
N
N
N/**
N  \brief   Set Main Stack Pointer
N  \details Assigns the given value to the Main Stack Pointer (MSP).
N  \param [in]    topOfMainStack  Main Stack Pointer value to set
N */
N__STATIC_INLINE void __set_MSP(uint32_t topOfMainStack)
Xstatic __inline void __set_MSP(uint32_t topOfMainStack)
N{
N  register uint32_t __regMainStackPointer     __ASM("msp");
X  register uint32_t __regMainStackPointer     __asm("msp");
N  __regMainStackPointer = topOfMainStack;
N}
N
N
N/**
N  \brief   Get Priority Mask
N  \details Returns the current state of the priority mask bit from the Priority Mask Register.
N  \return               Priority Mask value
N */
N__STATIC_INLINE uint32_t __get_PRIMASK(void)
Xstatic __inline uint32_t __get_PRIMASK(void)
N{
N  register uint32_t __regPriMask         __ASM("primask");
X  register uint32_t __regPriMask         __asm("primask");
N  return(__regPriMask);
N}
N
N
N/**
N  \brief   Set Priority Mask
N  \details Assigns the given value to the Priority Mask Register.
N  \param [in]    priMask  Priority Mask
N */
N__STATIC_INLINE void __set_PRIMASK(uint32_t priMask)
Xstatic __inline void __set_PRIMASK(uint32_t priMask)
N{
N  register uint32_t __regPriMask         __ASM("primask");
X  register uint32_t __regPriMask         __asm("primask");
N  __regPriMask = (priMask);
N}
N
N
N#if ((defined (__ARM_ARCH_7M__ ) && (__ARM_ARCH_7M__  == 1)) || \
N     (defined (__ARM_ARCH_7EM__) && (__ARM_ARCH_7EM__ == 1))     )
X#if ((1L && (1  == 1)) ||      (0L && (__ARM_ARCH_7EM__ == 1))     )
N
N/**
N  \brief   Enable FIQ
N  \details Enables FIQ interrupts by clearing the F-bit in the CPSR.
N           Can only be executed in Privileged modes.
N */
N#define __enable_fault_irq                __enable_fiq
N
N
N/**
N  \brief   Disable FIQ
N  \details Disables FIQ interrupts by setting the F-bit in the CPSR.
N           Can only be executed in Privileged modes.
N */
N#define __disable_fault_irq               __disable_fiq
N
N
N/**
N  \brief   Get Base Priority
N  \details Returns the current value of the Base Priority register.
N  \return               Base Priority register value
N */
N__STATIC_INLINE uint32_t  __get_BASEPRI(void)
Xstatic __inline uint32_t  __get_BASEPRI(void)
N{
N  register uint32_t __regBasePri         __ASM("basepri");
X  register uint32_t __regBasePri         __asm("basepri");
N  return(__regBasePri);
N}
N
N
N/**
N  \brief   Set Base Priority
N  \details Assigns the given value to the Base Priority register.
N  \param [in]    basePri  Base Priority value to set
N */
N__STATIC_INLINE void __set_BASEPRI(uint32_t basePri)
Xstatic __inline void __set_BASEPRI(uint32_t basePri)
N{
N  register uint32_t __regBasePri         __ASM("basepri");
X  register uint32_t __regBasePri         __asm("basepri");
N  __regBasePri = (basePri & 0xFFU);
N}
N
N
N/**
N  \brief   Set Base Priority with condition
N  \details Assigns the given value to the Base Priority register only if BASEPRI masking is disabled,
N           or the new value increases the BASEPRI priority level.
N  \param [in]    basePri  Base Priority value to set
N */
N__STATIC_INLINE void __set_BASEPRI_MAX(uint32_t basePri)
Xstatic __inline void __set_BASEPRI_MAX(uint32_t basePri)
N{
N  register uint32_t __regBasePriMax      __ASM("basepri_max");
X  register uint32_t __regBasePriMax      __asm("basepri_max");
N  __regBasePriMax = (basePri & 0xFFU);
N}
N
N
N/**
N  \brief   Get Fault Mask
N  \details Returns the current value of the Fault Mask register.
N  \return               Fault Mask register value
N */
N__STATIC_INLINE uint32_t __get_FAULTMASK(void)
Xstatic __inline uint32_t __get_FAULTMASK(void)
N{
N  register uint32_t __regFaultMask       __ASM("faultmask");
X  register uint32_t __regFaultMask       __asm("faultmask");
N  return(__regFaultMask);
N}
N
N
N/**
N  \brief   Set Fault Mask
N  \details Assigns the given value to the Fault Mask register.
N  \param [in]    faultMask  Fault Mask value to set
N */
N__STATIC_INLINE void __set_FAULTMASK(uint32_t faultMask)
Xstatic __inline void __set_FAULTMASK(uint32_t faultMask)
N{
N  register uint32_t __regFaultMask       __ASM("faultmask");
X  register uint32_t __regFaultMask       __asm("faultmask");
N  __regFaultMask = (faultMask & (uint32_t)1U);
N}
N
N#endif /* ((defined (__ARM_ARCH_7M__ ) && (__ARM_ARCH_7M__  == 1)) || \
N           (defined (__ARM_ARCH_7EM__) && (__ARM_ARCH_7EM__ == 1))     ) */
X#endif  
N
N
N#if ((defined (__ARM_ARCH_7EM__) && (__ARM_ARCH_7EM__ == 1))     )
X#if ((0L && (__ARM_ARCH_7EM__ == 1))     )
S
S/**
S  \brief   Get FPSCR
S  \details Returns the current value of the Floating Point Status/Control register.
S  \return               Floating Point Status/Control register value
S */
S__STATIC_INLINE uint32_t __get_FPSCR(void)
S{
S#if ((defined (__FPU_PRESENT) && (__FPU_PRESENT == 1U)) && \
S     (defined (__FPU_USED   ) && (__FPU_USED    == 1U))     )
X#if ((defined (__FPU_PRESENT) && (__FPU_PRESENT == 1U)) &&      (defined (__FPU_USED   ) && (__FPU_USED    == 1U))     )
S  register uint32_t __regfpscr         __ASM("fpscr");
S  return(__regfpscr);
S#else
S   return(0U);
S#endif
S}
S
S
S/**
S  \brief   Set FPSCR
S  \details Assigns the given value to the Floating Point Status/Control register.
S  \param [in]    fpscr  Floating Point Status/Control value to set
S */
S__STATIC_INLINE void __set_FPSCR(uint32_t fpscr)
S{
S#if ((defined (__FPU_PRESENT) && (__FPU_PRESENT == 1U)) && \
S     (defined (__FPU_USED   ) && (__FPU_USED    == 1U))     )
X#if ((defined (__FPU_PRESENT) && (__FPU_PRESENT == 1U)) &&      (defined (__FPU_USED   ) && (__FPU_USED    == 1U))     )
S  register uint32_t __regfpscr         __ASM("fpscr");
S  __regfpscr = (fpscr);
S#else
S  (void)fpscr;
S#endif
S}
S
N#endif /* ((defined (__ARM_ARCH_7EM__) && (__ARM_ARCH_7EM__ == 1))     ) */
N
N
N
N/*@} end of CMSIS_Core_RegAccFunctions */
N
N
N/* ##########################  Core Instruction Access  ######################### */
N/** \defgroup CMSIS_Core_InstructionInterface CMSIS Core Instruction Interface
N  Access to dedicated instructions
N  @{
N*/
N
N/**
N  \brief   No Operation
N  \details No Operation does nothing. This instruction can be used for code alignment purposes.
N */
N#define __NOP                             __nop
N
N
N/**
N  \brief   Wait For Interrupt
N  \details Wait For Interrupt is a hint instruction that suspends execution until one of a number of events occurs.
N */
N#define __WFI                             __wfi
N
N
N/**
N  \brief   Wait For Event
N  \details Wait For Event is a hint instruction that permits the processor to enter
N           a low-power state until one of a number of events occurs.
N */
N#define __WFE                             __wfe
N
N
N/**
N  \brief   Send Event
N  \details Send Event is a hint instruction. It causes an event to be signaled to the CPU.
N */
N#define __SEV                             __sev
N
N
N/**
N  \brief   Instruction Synchronization Barrier
N  \details Instruction Synchronization Barrier flushes the pipeline in the processor,
N           so that all instructions following the ISB are fetched from cache or memory,
N           after the instruction has been completed.
N */
N#define __ISB() do {\
N                   __schedule_barrier();\
N                   __isb(0xF);\
N                   __schedule_barrier();\
N                } while (0U)
X#define __ISB() do {                   __schedule_barrier();                   __isb(0xF);                   __schedule_barrier();                } while (0U)
N
N/**
N  \brief   Data Synchronization Barrier
N  \details Acts as a special kind of Data Memory Barrier.
N           It completes when all explicit memory accesses before this instruction complete.
N */
N#define __DSB() do {\
N                   __schedule_barrier();\
N                   __dsb(0xF);\
N                   __schedule_barrier();\
N                } while (0U)
X#define __DSB() do {                   __schedule_barrier();                   __dsb(0xF);                   __schedule_barrier();                } while (0U)
N
N/**
N  \brief   Data Memory Barrier
N  \details Ensures the apparent order of the explicit memory operations before
N           and after the instruction, without ensuring their completion.
N */
N#define __DMB() do {\
N                   __schedule_barrier();\
N                   __dmb(0xF);\
N                   __schedule_barrier();\
N                } while (0U)
X#define __DMB() do {                   __schedule_barrier();                   __dmb(0xF);                   __schedule_barrier();                } while (0U)
N
N/**
N  \brief   Reverse byte order (32 bit)
N  \details Reverses the byte order in integer value.
N  \param [in]    value  Value to reverse
N  \return               Reversed value
N */
N#define __REV                             __rev
N
N
N/**
N  \brief   Reverse byte order (16 bit)
N  \details Reverses the byte order in two unsigned short values.
N  \param [in]    value  Value to reverse
N  \return               Reversed value
N */
N#ifndef __NO_EMBEDDED_ASM
N__attribute__((section(".rev16_text"))) __STATIC_INLINE __ASM uint32_t __REV16(uint32_t value)
X__attribute__((section(".rev16_text"))) static __inline __asm uint32_t __REV16(uint32_t value)
N{
N  rev16 r0, r0
N  bx lr
N}
N#endif
N
N
N/**
N  \brief   Reverse byte order in signed short value
N  \details Reverses the byte order in a signed short value with sign extension to integer.
N  \param [in]    value  Value to reverse
N  \return               Reversed value
N */
N#ifndef __NO_EMBEDDED_ASM
N__attribute__((section(".revsh_text"))) __STATIC_INLINE __ASM int32_t __REVSH(int32_t value)
X__attribute__((section(".revsh_text"))) static __inline __asm int32_t __REVSH(int32_t value)
N{
N  revsh r0, r0
N  bx lr
N}
N#endif
N
N
N/**
N  \brief   Rotate Right in unsigned value (32 bit)
N  \details Rotate Right (immediate) provides the value of the contents of a register rotated by a variable number of bits.
N  \param [in]    op1  Value to rotate
N  \param [in]    op2  Number of Bits to rotate
N  \return               Rotated value
N */
N#define __ROR                             __ror
N
N
N/**
N  \brief   Breakpoint
N  \details Causes the processor to enter Debug state.
N           Debug tools can use this to investigate system state when the instruction at a particular address is reached.
N  \param [in]    value  is ignored by the processor.
N                 If required, a debugger can use it to store additional information about the breakpoint.
N */
N#define __BKPT(value)                       __breakpoint(value)
N
N
N/**
N  \brief   Reverse bit order of value
N  \details Reverses the bit order of the given value.
N  \param [in]    value  Value to reverse
N  \return               Reversed value
N */
N#if ((defined (__ARM_ARCH_7M__ ) && (__ARM_ARCH_7M__  == 1)) || \
N     (defined (__ARM_ARCH_7EM__) && (__ARM_ARCH_7EM__ == 1))     )
X#if ((1L && (1  == 1)) ||      (0L && (__ARM_ARCH_7EM__ == 1))     )
N  #define __RBIT                          __rbit
N#else
S__attribute__((always_inline)) __STATIC_INLINE uint32_t __RBIT(uint32_t value)
S{
S  uint32_t result;
S  int32_t s = (4 /*sizeof(v)*/ * 8) - 1; /* extra shift needed at end */
S
S  result = value;                      /* r will be reversed bits of v; first get LSB of v */
S  for (value >>= 1U; value; value >>= 1U)
S  {
S    result <<= 1U;
S    result |= value & 1U;
S    s--;
S  }
S  result <<= s;                        /* shift when v's highest bits are zero */
S  return(result);
S}
N#endif
N
N
N/**
N  \brief   Count leading zeros
N  \details Counts the number of leading zeros of a data value.
N  \param [in]  value  Value to count the leading zeros
N  \return             number of leading zeros in value
N */
N#define __CLZ                             __clz
N
N
N#if ((defined (__ARM_ARCH_7M__ ) && (__ARM_ARCH_7M__  == 1)) || \
N     (defined (__ARM_ARCH_7EM__) && (__ARM_ARCH_7EM__ == 1))     )
X#if ((1L && (1  == 1)) ||      (0L && (__ARM_ARCH_7EM__ == 1))     )
N
N/**
N  \brief   LDR Exclusive (8 bit)
N  \details Executes a exclusive LDR instruction for 8 bit value.
N  \param [in]    ptr  Pointer to data
N  \return             value of type uint8_t at (*ptr)
N */
N#if defined(__ARMCC_VERSION) && (__ARMCC_VERSION < 5060020)
X#if 1L && (5060528 < 5060020)
S  #define __LDREXB(ptr)                                                        ((uint8_t ) __ldrex(ptr))
N#else
N  #define __LDREXB(ptr)          _Pragma("push") _Pragma("diag_suppress 3731") ((uint8_t ) __ldrex(ptr))  _Pragma("pop")
N#endif
N
N
N/**
N  \brief   LDR Exclusive (16 bit)
N  \details Executes a exclusive LDR instruction for 16 bit values.
N  \param [in]    ptr  Pointer to data
N  \return        value of type uint16_t at (*ptr)
N */
N#if defined(__ARMCC_VERSION) && (__ARMCC_VERSION < 5060020)
X#if 1L && (5060528 < 5060020)
S  #define __LDREXH(ptr)                                                        ((uint16_t) __ldrex(ptr))
N#else
N  #define __LDREXH(ptr)          _Pragma("push") _Pragma("diag_suppress 3731") ((uint16_t) __ldrex(ptr))  _Pragma("pop")
N#endif
N
N
N/**
N  \brief   LDR Exclusive (32 bit)
N  \details Executes a exclusive LDR instruction for 32 bit values.
N  \param [in]    ptr  Pointer to data
N  \return        value of type uint32_t at (*ptr)
N */
N#if defined(__ARMCC_VERSION) && (__ARMCC_VERSION < 5060020)
X#if 1L && (5060528 < 5060020)
S  #define __LDREXW(ptr)                                                        ((uint32_t ) __ldrex(ptr))
N#else
N  #define __LDREXW(ptr)          _Pragma("push") _Pragma("diag_suppress 3731") ((uint32_t ) __ldrex(ptr))  _Pragma("pop")
N#endif
N
N
N/**
N  \brief   STR Exclusive (8 bit)
N  \details Executes a exclusive STR instruction for 8 bit values.
N  \param [in]  value  Value to store
N  \param [in]    ptr  Pointer to location
N  \return          0  Function succeeded
N  \return          1  Function failed
N */
N#if defined(__ARMCC_VERSION) && (__ARMCC_VERSION < 5060020)
X#if 1L && (5060528 < 5060020)
S  #define __STREXB(value, ptr)                                                 __strex(value, ptr)
N#else
N  #define __STREXB(value, ptr)   _Pragma("push") _Pragma("diag_suppress 3731") __strex(value, ptr)        _Pragma("pop")
N#endif
N
N
N/**
N  \brief   STR Exclusive (16 bit)
N  \details Executes a exclusive STR instruction for 16 bit values.
N  \param [in]  value  Value to store
N  \param [in]    ptr  Pointer to location
N  \return          0  Function succeeded
N  \return          1  Function failed
N */
N#if defined(__ARMCC_VERSION) && (__ARMCC_VERSION < 5060020)
X#if 1L && (5060528 < 5060020)
S  #define __STREXH(value, ptr)                                                 __strex(value, ptr)
N#else
N  #define __STREXH(value, ptr)   _Pragma("push") _Pragma("diag_suppress 3731") __strex(value, ptr)        _Pragma("pop")
N#endif
N
N
N/**
N  \brief   STR Exclusive (32 bit)
N  \details Executes a exclusive STR instruction for 32 bit values.
N  \param [in]  value  Value to store
N  \param [in]    ptr  Pointer to location
N  \return          0  Function succeeded
N  \return          1  Function failed
N */
N#if defined(__ARMCC_VERSION) && (__ARMCC_VERSION < 5060020)
X#if 1L && (5060528 < 5060020)
S  #define __STREXW(value, ptr)                                                 __strex(value, ptr)
N#else
N  #define __STREXW(value, ptr)   _Pragma("push") _Pragma("diag_suppress 3731") __strex(value, ptr)        _Pragma("pop")
N#endif
N
N
N/**
N  \brief   Remove the exclusive lock
N  \details Removes the exclusive lock which is created by LDREX.
N */
N#define __CLREX                           __clrex
N
N
N/**
N  \brief   Signed Saturate
N  \details Saturates a signed value.
N  \param [in]  value  Value to be saturated
N  \param [in]    sat  Bit position to saturate to (1..32)
N  \return             Saturated value
N */
N#define __SSAT                            __ssat
N
N
N/**
N  \brief   Unsigned Saturate
N  \details Saturates an unsigned value.
N  \param [in]  value  Value to be saturated
N  \param [in]    sat  Bit position to saturate to (0..31)
N  \return             Saturated value
N */
N#define __USAT                            __usat
N
N
N/**
N  \brief   Rotate Right with Extend (32 bit)
N  \details Moves each bit of a bitstring right by one bit.
N           The carry input is shifted in at the left end of the bitstring.
N  \param [in]    value  Value to rotate
N  \return               Rotated value
N */
N#ifndef __NO_EMBEDDED_ASM
N__attribute__((section(".rrx_text"))) __STATIC_INLINE __ASM uint32_t __RRX(uint32_t value)
X__attribute__((section(".rrx_text"))) static __inline __asm uint32_t __RRX(uint32_t value)
N{
N  rrx r0, r0
N  bx lr
N}
N#endif
N
N
N/**
N  \brief   LDRT Unprivileged (8 bit)
N  \details Executes a Unprivileged LDRT instruction for 8 bit value.
N  \param [in]    ptr  Pointer to data
N  \return             value of type uint8_t at (*ptr)
N */
N#define __LDRBT(ptr)                      ((uint8_t )  __ldrt(ptr))
N
N
N/**
N  \brief   LDRT Unprivileged (16 bit)
N  \details Executes a Unprivileged LDRT instruction for 16 bit values.
N  \param [in]    ptr  Pointer to data
N  \return        value of type uint16_t at (*ptr)
N */
N#define __LDRHT(ptr)                      ((uint16_t)  __ldrt(ptr))
N
N
N/**
N  \brief   LDRT Unprivileged (32 bit)
N  \details Executes a Unprivileged LDRT instruction for 32 bit values.
N  \param [in]    ptr  Pointer to data
N  \return        value of type uint32_t at (*ptr)
N */
N#define __LDRT(ptr)                       ((uint32_t ) __ldrt(ptr))
N
N
N/**
N  \brief   STRT Unprivileged (8 bit)
N  \details Executes a Unprivileged STRT instruction for 8 bit values.
N  \param [in]  value  Value to store
N  \param [in]    ptr  Pointer to location
N */
N#define __STRBT(value, ptr)               __strt(value, ptr)
N
N
N/**
N  \brief   STRT Unprivileged (16 bit)
N  \details Executes a Unprivileged STRT instruction for 16 bit values.
N  \param [in]  value  Value to store
N  \param [in]    ptr  Pointer to location
N */
N#define __STRHT(value, ptr)               __strt(value, ptr)
N
N
N/**
N  \brief   STRT Unprivileged (32 bit)
N  \details Executes a Unprivileged STRT instruction for 32 bit values.
N  \param [in]  value  Value to store
N  \param [in]    ptr  Pointer to location
N */
N#define __STRT(value, ptr)                __strt(value, ptr)
N
N#endif /* ((defined (__ARM_ARCH_7M__ ) && (__ARM_ARCH_7M__  == 1)) || \
N           (defined (__ARM_ARCH_7EM__) && (__ARM_ARCH_7EM__ == 1))     ) */
X#endif  
N
N/*@}*/ /* end of group CMSIS_Core_InstructionInterface */
N
N
N/* ###################  Compiler specific Intrinsics  ########################### */
N/** \defgroup CMSIS_SIMD_intrinsics CMSIS SIMD Intrinsics
N  Access to dedicated SIMD instructions
N  @{
N*/
N
N#if ((defined (__ARM_ARCH_7EM__) && (__ARM_ARCH_7EM__ == 1))     )
X#if ((0L && (__ARM_ARCH_7EM__ == 1))     )
S
S#define __SADD8                           __sadd8
S#define __QADD8                           __qadd8
S#define __SHADD8                          __shadd8
S#define __UADD8                           __uadd8
S#define __UQADD8                          __uqadd8
S#define __UHADD8                          __uhadd8
S#define __SSUB8                           __ssub8
S#define __QSUB8                           __qsub8
S#define __SHSUB8                          __shsub8
S#define __USUB8                           __usub8
S#define __UQSUB8                          __uqsub8
S#define __UHSUB8                          __uhsub8
S#define __SADD16                          __sadd16
S#define __QADD16                          __qadd16
S#define __SHADD16                         __shadd16
S#define __UADD16                          __uadd16
S#define __UQADD16                         __uqadd16
S#define __UHADD16                         __uhadd16
S#define __SSUB16                          __ssub16
S#define __QSUB16                          __qsub16
S#define __SHSUB16                         __shsub16
S#define __USUB16                          __usub16
S#define __UQSUB16                         __uqsub16
S#define __UHSUB16                         __uhsub16
S#define __SASX                            __sasx
S#define __QASX                            __qasx
S#define __SHASX                           __shasx
S#define __UASX                            __uasx
S#define __UQASX                           __uqasx
S#define __UHASX                           __uhasx
S#define __SSAX                            __ssax
S#define __QSAX                            __qsax
S#define __SHSAX                           __shsax
S#define __USAX                            __usax
S#define __UQSAX                           __uqsax
S#define __UHSAX                           __uhsax
S#define __USAD8                           __usad8
S#define __USADA8                          __usada8
S#define __SSAT16                          __ssat16
S#define __USAT16                          __usat16
S#define __UXTB16                          __uxtb16
S#define __UXTAB16                         __uxtab16
S#define __SXTB16                          __sxtb16
S#define __SXTAB16                         __sxtab16
S#define __SMUAD                           __smuad
S#define __SMUADX                          __smuadx
S#define __SMLAD                           __smlad
S#define __SMLADX                          __smladx
S#define __SMLALD                          __smlald
S#define __SMLALDX                         __smlaldx
S#define __SMUSD                           __smusd
S#define __SMUSDX                          __smusdx
S#define __SMLSD                           __smlsd
S#define __SMLSDX                          __smlsdx
S#define __SMLSLD                          __smlsld
S#define __SMLSLDX                         __smlsldx
S#define __SEL                             __sel
S#define __QADD                            __qadd
S#define __QSUB                            __qsub
S
S#define __PKHBT(ARG1,ARG2,ARG3)          ( ((((uint32_t)(ARG1))          ) & 0x0000FFFFUL) |  \
S                                           ((((uint32_t)(ARG2)) << (ARG3)) & 0xFFFF0000UL)  )
X#define __PKHBT(ARG1,ARG2,ARG3)          ( ((((uint32_t)(ARG1))          ) & 0x0000FFFFUL) |                                             ((((uint32_t)(ARG2)) << (ARG3)) & 0xFFFF0000UL)  )
S
S#define __PKHTB(ARG1,ARG2,ARG3)          ( ((((uint32_t)(ARG1))          ) & 0xFFFF0000UL) |  \
S                                           ((((uint32_t)(ARG2)) >> (ARG3)) & 0x0000FFFFUL)  )
X#define __PKHTB(ARG1,ARG2,ARG3)          ( ((((uint32_t)(ARG1))          ) & 0xFFFF0000UL) |                                             ((((uint32_t)(ARG2)) >> (ARG3)) & 0x0000FFFFUL)  )
S
S#define __SMMLA(ARG1,ARG2,ARG3)          ( (int32_t)((((int64_t)(ARG1) * (ARG2)) + \
S                                                      ((int64_t)(ARG3) << 32U)     ) >> 32U))
X#define __SMMLA(ARG1,ARG2,ARG3)          ( (int32_t)((((int64_t)(ARG1) * (ARG2)) +                                                       ((int64_t)(ARG3) << 32U)     ) >> 32U))
S
N#endif /* ((defined (__ARM_ARCH_7EM__) && (__ARM_ARCH_7EM__ == 1))     ) */
N/*@} end of group CMSIS_SIMD_intrinsics */
N
N
N#endif /* __CMSIS_ARMCC_H */
L 35 "C:\Keil_v5\ARM\PACK\ARM\CMSIS\5.0.1\CMSIS\Include\cmsis_compiler.h" 2
N
N
N/*
N * ARM Compiler 6 (armclang)
N */
N#elif defined (__ARMCC_VERSION) && (__ARMCC_VERSION >= 6010050)
S  #include "cmsis_armclang.h"
S
S
S/*
S * GNU Compiler
S */
S#elif defined ( __GNUC__ )
S  #include "cmsis_gcc.h"
S
S
S/*
S * IAR Compiler
S */
S#elif defined ( __ICCARM__ )
S
S  #ifndef   __ASM
S    #define __ASM                     __asm
S  #endif
S  #ifndef   __INLINE
S    #define __INLINE                  inline
S  #endif
S  #ifndef   __STATIC_INLINE
S    #define __STATIC_INLINE           static inline
S  #endif
S
S  #include <cmsis_iar.h>
S
S  #ifndef   __NO_RETURN
S    #define __NO_RETURN               __noreturn
S  #endif
S  #ifndef   __USED
S    #define __USED                    __root
S  #endif
S  #ifndef   __WEAK
S    #define __WEAK                    __weak
S  #endif
S  #ifndef   __UNALIGNED_UINT32
S    __packed struct T_UINT32 { uint32_t v; };
S      #define __UNALIGNED_UINT32(x)     (((struct T_UINT32 *)(x))->v)
S  #endif
S  #ifndef   __ALIGNED
S    #warning No compiler specific solution for __ALIGNED. __ALIGNED is ignored.
S    #define __ALIGNED(x)
S  #endif
S  #ifndef   __PACKED
S    #define __PACKED                  __packed
S  #endif
S  #ifndef   __PACKED_STRUCT
S    #define __PACKED_STRUCT           __packed struct
S  #endif
S
S
S/*
S * TI ARM Compiler
S */
S#elif defined ( __TI_ARM__ )
S  #include <cmsis_ccs.h>
S
S  #ifndef   __ASM
S    #define __ASM                     __asm
S  #endif
S  #ifndef   __INLINE
S    #define __INLINE                  inline
S  #endif
S  #ifndef   __STATIC_INLINE
S    #define __STATIC_INLINE           static inline
S  #endif
S  #ifndef   __NO_RETURN
S    #define __NO_RETURN               __attribute__((noreturn))
S  #endif
S  #ifndef   __USED
S    #define __USED                    __attribute__((used))
S  #endif
S  #ifndef   __WEAK
S    #define __WEAK                    __attribute__((weak))
S  #endif
S  #ifndef   __UNALIGNED_UINT32
S    struct __attribute__((packed)) T_UINT32 { uint32_t v; };
S    #define __UNALIGNED_UINT32(x)     (((struct T_UINT32 *)(x))->v)
S  #endif
S  #ifndef   __ALIGNED
S    #define __ALIGNED(x)              __attribute__((aligned(x)))
S  #endif
S  #ifndef   __PACKED
S    #define __PACKED                  __attribute__((packed))
S  #endif
S  #ifndef   __PACKED_STRUCT
S    #define __PACKED_STRUCT           struct __attribute__((packed))
S  #endif
S
S
S/*
S * TASKING Compiler
S */
S#elif defined ( __TASKING__ )
S  /*
S   * The CMSIS functions have been implemented as intrinsics in the compiler.
S   * Please use "carm -?i" to get an up to date list of all intrinsics,
S   * Including the CMSIS ones.
S   */
S
S  #ifndef   __ASM
S    #define __ASM                     __asm
S  #endif
S  #ifndef   __INLINE
S    #define __INLINE                  inline
S  #endif
S  #ifndef   __STATIC_INLINE
S    #define __STATIC_INLINE           static inline
S  #endif
S  #ifndef   __NO_RETURN
S    #define __NO_RETURN               __attribute__((noreturn))
S  #endif
S  #ifndef   __USED
S    #define __USED                    __attribute__((used))
S  #endif
S  #ifndef   __WEAK
S    #define __WEAK                    __attribute__((weak))
S  #endif
S  #ifndef   __UNALIGNED_UINT32
S    struct __packed__ T_UINT32 { uint32_t v; };
S    #define __UNALIGNED_UINT32(x)     (((struct T_UINT32 *)(x))->v)
S  #endif
S  #ifndef   __ALIGNED
S    #define __ALIGNED(x)              __align(x)
S  #endif
S  #ifndef   __PACKED
S    #define __PACKED                  __packed__
S  #endif
S  #ifndef   __PACKED_STRUCT
S    #define __PACKED_STRUCT           struct __packed__
S  #endif
S
S
S/*
S * COSMIC Compiler
S */
S#elif defined ( __CSMC__ )
S   #include <cmsis_csm.h>
S
S #ifndef   __ASM
S    #define __ASM                     _asm
S  #endif
S  #ifndef   __INLINE
S    #define __INLINE                  inline
S  #endif
S  #ifndef   __STATIC_INLINE
S    #define __STATIC_INLINE           static inline
S  #endif
S  #ifndef   __NO_RETURN
S    // NO RETURN is automatically detected hence no warning here
S    #define __NO_RETURN
S  #endif
S  #ifndef   __USED
S    #warning No compiler specific solution for __USED. __USED is ignored.
S    #define __USED
S  #endif
S  #ifndef   __WEAK
S    #define __WEAK                    __weak
S  #endif
S  #ifndef   __UNALIGNED_UINT32
S    @packed struct T_UINT32 { uint32_t v; };
S    #define __UNALIGNED_UINT32(x)     (((struct T_UINT32 *)(x))->v)
S  #endif
S  #ifndef   __ALIGNED
S    #warning No compiler specific solution for __ALIGNED. __ALIGNED is ignored.
S    #define __ALIGNED(x)
S  #endif
S  #ifndef   __PACKED
S    #define __PACKED                  @packed
S  #endif
S  #ifndef   __PACKED_STRUCT
S    #define __PACKED_STRUCT           @packed struct
S  #endif
S
S
S#else
S  #error Unknown compiler.
N#endif
N
N
N#endif /* __CMSIS_COMPILER_H */
N
L 114 "C:\Keil_v5\ARM\PACK\ARM\CMSIS\5.0.1\CMSIS\Include\core_cm3.h" 2
N
N
N#ifdef __cplusplus
S}
N#endif
N
N#endif /* __CORE_CM3_H_GENERIC */
N
N#ifndef __CMSIS_GENERIC
N
N#ifndef __CORE_CM3_H_DEPENDANT
N#define __CORE_CM3_H_DEPENDANT
N
N#ifdef __cplusplus
S extern "C" {
N#endif
N
N/* check device defines and use defaults */
N#if defined __CHECK_DEVICE_DEFINES
X#if 0L
S  #ifndef __CM3_REV
S    #define __CM3_REV               0x0200U
S    #warning "__CM3_REV not defined in device header file; using default!"
S  #endif
S
S  #ifndef __MPU_PRESENT
S    #define __MPU_PRESENT             0U
S    #warning "__MPU_PRESENT not defined in device header file; using default!"
S  #endif
S
S  #ifndef __NVIC_PRIO_BITS
S    #define __NVIC_PRIO_BITS          3U
S    #warning "__NVIC_PRIO_BITS not defined in device header file; using default!"
S  #endif
S
S  #ifndef __Vendor_SysTickConfig
S    #define __Vendor_SysTickConfig    0U
S    #warning "__Vendor_SysTickConfig not defined in device header file; using default!"
S  #endif
N#endif
N
N/* IO definitions (access restrictions to peripheral registers) */
N/**
N    \defgroup CMSIS_glob_defs CMSIS Global Defines
N
N    <strong>IO Type Qualifiers</strong> are used
N    \li to specify the access to peripheral variables.
N    \li for automatic generation of peripheral register debug information.
N*/
N#ifdef __cplusplus
S  #define   __I     volatile             /*!< Defines 'read only' permissions */
N#else
N  #define   __I     volatile const       /*!< Defines 'read only' permissions */
N#endif
N#define     __O     volatile             /*!< Defines 'write only' permissions */
N#define     __IO    volatile             /*!< Defines 'read / write' permissions */
N
N/* following defines should be used for structure members */
N#define     __IM     volatile const      /*! Defines 'read only' structure member permissions */
N#define     __OM     volatile            /*! Defines 'write only' structure member permissions */
N#define     __IOM    volatile            /*! Defines 'read / write' structure member permissions */
N
N/*@} end of group Cortex_M3 */
N
N
N
N/*******************************************************************************
N *                 Register Abstraction
N  Core Register contain:
N  - Core Register
N  - Core NVIC Register
N  - Core SCB Register
N  - Core SysTick Register
N  - Core Debug Register
N  - Core MPU Register
N ******************************************************************************/
N/**
N  \defgroup CMSIS_core_register Defines and Type Definitions
N  \brief Type definitions and defines for Cortex-M processor based devices.
N*/
N
N/**
N  \ingroup    CMSIS_core_register
N  \defgroup   CMSIS_CORE  Status and Control Registers
N  \brief      Core Register type definitions.
N  @{
N */
N
N/**
N  \brief  Union type to access the Application Program Status Register (APSR).
N */
Ntypedef union
N{
N  struct
N  {
N    uint32_t _reserved0:27;              /*!< bit:  0..26  Reserved */
N    uint32_t Q:1;                        /*!< bit:     27  Saturation condition flag */
N    uint32_t V:1;                        /*!< bit:     28  Overflow condition code flag */
N    uint32_t C:1;                        /*!< bit:     29  Carry condition code flag */
N    uint32_t Z:1;                        /*!< bit:     30  Zero condition code flag */
N    uint32_t N:1;                        /*!< bit:     31  Negative condition code flag */
N  } b;                                   /*!< Structure used for bit  access */
N  uint32_t w;                            /*!< Type      used for word access */
N} APSR_Type;
N
N/* APSR Register Definitions */
N#define APSR_N_Pos                         31U                                            /*!< APSR: N Position */
N#define APSR_N_Msk                         (1UL << APSR_N_Pos)                            /*!< APSR: N Mask */
N
N#define APSR_Z_Pos                         30U                                            /*!< APSR: Z Position */
N#define APSR_Z_Msk                         (1UL << APSR_Z_Pos)                            /*!< APSR: Z Mask */
N
N#define APSR_C_Pos                         29U                                            /*!< APSR: C Position */
N#define APSR_C_Msk                         (1UL << APSR_C_Pos)                            /*!< APSR: C Mask */
N
N#define APSR_V_Pos                         28U                                            /*!< APSR: V Position */
N#define APSR_V_Msk                         (1UL << APSR_V_Pos)                            /*!< APSR: V Mask */
N
N#define APSR_Q_Pos                         27U                                            /*!< APSR: Q Position */
N#define APSR_Q_Msk                         (1UL << APSR_Q_Pos)                            /*!< APSR: Q Mask */
N
N
N/**
N  \brief  Union type to access the Interrupt Program Status Register (IPSR).
N */
Ntypedef union
N{
N  struct
N  {
N    uint32_t ISR:9;                      /*!< bit:  0.. 8  Exception number */
N    uint32_t _reserved0:23;              /*!< bit:  9..31  Reserved */
N  } b;                                   /*!< Structure used for bit  access */
N  uint32_t w;                            /*!< Type      used for word access */
N} IPSR_Type;
N
N/* IPSR Register Definitions */
N#define IPSR_ISR_Pos                        0U                                            /*!< IPSR: ISR Position */
N#define IPSR_ISR_Msk                       (0x1FFUL /*<< IPSR_ISR_Pos*/)                  /*!< IPSR: ISR Mask */
N
N
N/**
N  \brief  Union type to access the Special-Purpose Program Status Registers (xPSR).
N */
Ntypedef union
N{
N  struct
N  {
N    uint32_t ISR:9;                      /*!< bit:  0.. 8  Exception number */
N    uint32_t _reserved0:1;               /*!< bit:      9  Reserved */
N    uint32_t ICI_IT_1:6;                 /*!< bit: 10..15  ICI/IT part 1 */
N    uint32_t _reserved1:8;               /*!< bit: 16..23  Reserved */
N    uint32_t T:1;                        /*!< bit:     24  Thumb bit */
N    uint32_t ICI_IT_2:2;                 /*!< bit: 25..26  ICI/IT part 2 */
N    uint32_t Q:1;                        /*!< bit:     27  Saturation condition flag */
N    uint32_t V:1;                        /*!< bit:     28  Overflow condition code flag */
N    uint32_t C:1;                        /*!< bit:     29  Carry condition code flag */
N    uint32_t Z:1;                        /*!< bit:     30  Zero condition code flag */
N    uint32_t N:1;                        /*!< bit:     31  Negative condition code flag */
N  } b;                                   /*!< Structure used for bit  access */
N  uint32_t w;                            /*!< Type      used for word access */
N} xPSR_Type;
N
N/* xPSR Register Definitions */
N#define xPSR_N_Pos                         31U                                            /*!< xPSR: N Position */
N#define xPSR_N_Msk                         (1UL << xPSR_N_Pos)                            /*!< xPSR: N Mask */
N
N#define xPSR_Z_Pos                         30U                                            /*!< xPSR: Z Position */
N#define xPSR_Z_Msk                         (1UL << xPSR_Z_Pos)                            /*!< xPSR: Z Mask */
N
N#define xPSR_C_Pos                         29U                                            /*!< xPSR: C Position */
N#define xPSR_C_Msk                         (1UL << xPSR_C_Pos)                            /*!< xPSR: C Mask */
N
N#define xPSR_V_Pos                         28U                                            /*!< xPSR: V Position */
N#define xPSR_V_Msk                         (1UL << xPSR_V_Pos)                            /*!< xPSR: V Mask */
N
N#define xPSR_Q_Pos                         27U                                            /*!< xPSR: Q Position */
N#define xPSR_Q_Msk                         (1UL << xPSR_Q_Pos)                            /*!< xPSR: Q Mask */
N
N#define xPSR_ICI_IT_2_Pos                  25U                                            /*!< xPSR: ICI/IT part 2 Position */
N#define xPSR_ICI_IT_2_Msk                  (3UL << xPSR_ICI_IT_2_Pos)                     /*!< xPSR: ICI/IT part 2 Mask */
N
N#define xPSR_T_Pos                         24U                                            /*!< xPSR: T Position */
N#define xPSR_T_Msk                         (1UL << xPSR_T_Pos)                            /*!< xPSR: T Mask */
N
N#define xPSR_ICI_IT_1_Pos                  10U                                            /*!< xPSR: ICI/IT part 1 Position */
N#define xPSR_ICI_IT_1_Msk                  (0x3FUL << xPSR_ICI_IT_1_Pos)                  /*!< xPSR: ICI/IT part 1 Mask */
N
N#define xPSR_ISR_Pos                        0U                                            /*!< xPSR: ISR Position */
N#define xPSR_ISR_Msk                       (0x1FFUL /*<< xPSR_ISR_Pos*/)                  /*!< xPSR: ISR Mask */
N
N
N/**
N  \brief  Union type to access the Control Registers (CONTROL).
N */
Ntypedef union
N{
N  struct
N  {
N    uint32_t nPRIV:1;                    /*!< bit:      0  Execution privilege in Thread mode */
N    uint32_t SPSEL:1;                    /*!< bit:      1  Stack to be used */
N    uint32_t _reserved1:30;              /*!< bit:  2..31  Reserved */
N  } b;                                   /*!< Structure used for bit  access */
N  uint32_t w;                            /*!< Type      used for word access */
N} CONTROL_Type;
N
N/* CONTROL Register Definitions */
N#define CONTROL_SPSEL_Pos                   1U                                            /*!< CONTROL: SPSEL Position */
N#define CONTROL_SPSEL_Msk                  (1UL << CONTROL_SPSEL_Pos)                     /*!< CONTROL: SPSEL Mask */
N
N#define CONTROL_nPRIV_Pos                   0U                                            /*!< CONTROL: nPRIV Position */
N#define CONTROL_nPRIV_Msk                  (1UL /*<< CONTROL_nPRIV_Pos*/)                 /*!< CONTROL: nPRIV Mask */
N
N/*@} end of group CMSIS_CORE */
N
N
N/**
N  \ingroup    CMSIS_core_register
N  \defgroup   CMSIS_NVIC  Nested Vectored Interrupt Controller (NVIC)
N  \brief      Type definitions for the NVIC Registers
N  @{
N */
N
N/**
N  \brief  Structure type to access the Nested Vectored Interrupt Controller (NVIC).
N */
Ntypedef struct
N{
N  __IOM uint32_t ISER[8U];               /*!< Offset: 0x000 (R/W)  Interrupt Set Enable Register */
X  volatile uint32_t ISER[8U];                
N        uint32_t RESERVED0[24U];
N  __IOM uint32_t ICER[8U];               /*!< Offset: 0x080 (R/W)  Interrupt Clear Enable Register */
X  volatile uint32_t ICER[8U];                
N        uint32_t RSERVED1[24U];
N  __IOM uint32_t ISPR[8U];               /*!< Offset: 0x100 (R/W)  Interrupt Set Pending Register */
X  volatile uint32_t ISPR[8U];                
N        uint32_t RESERVED2[24U];
N  __IOM uint32_t ICPR[8U];               /*!< Offset: 0x180 (R/W)  Interrupt Clear Pending Register */
X  volatile uint32_t ICPR[8U];                
N        uint32_t RESERVED3[24U];
N  __IOM uint32_t IABR[8U];               /*!< Offset: 0x200 (R/W)  Interrupt Active bit Register */
X  volatile uint32_t IABR[8U];                
N        uint32_t RESERVED4[56U];
N  __IOM uint8_t  IP[240U];               /*!< Offset: 0x300 (R/W)  Interrupt Priority Register (8Bit wide) */
X  volatile uint8_t  IP[240U];                
N        uint32_t RESERVED5[644U];
N  __OM  uint32_t STIR;                   /*!< Offset: 0xE00 ( /W)  Software Trigger Interrupt Register */
X  volatile  uint32_t STIR;                    
N}  NVIC_Type;
N
N/* Software Triggered Interrupt Register Definitions */
N#define NVIC_STIR_INTID_Pos                 0U                                         /*!< STIR: INTLINESNUM Position */
N#define NVIC_STIR_INTID_Msk                (0x1FFUL /*<< NVIC_STIR_INTID_Pos*/)        /*!< STIR: INTLINESNUM Mask */
N
N/*@} end of group CMSIS_NVIC */
N
N
N/**
N  \ingroup  CMSIS_core_register
N  \defgroup CMSIS_SCB     System Control Block (SCB)
N  \brief    Type definitions for the System Control Block Registers
N  @{
N */
N
N/**
N  \brief  Structure type to access the System Control Block (SCB).
N */
Ntypedef struct
N{
N  __IM  uint32_t CPUID;                  /*!< Offset: 0x000 (R/ )  CPUID Base Register */
X  volatile const  uint32_t CPUID;                   
N  __IOM uint32_t ICSR;                   /*!< Offset: 0x004 (R/W)  Interrupt Control and State Register */
X  volatile uint32_t ICSR;                    
N  __IOM uint32_t VTOR;                   /*!< Offset: 0x008 (R/W)  Vector Table Offset Register */
X  volatile uint32_t VTOR;                    
N  __IOM uint32_t AIRCR;                  /*!< Offset: 0x00C (R/W)  Application Interrupt and Reset Control Register */
X  volatile uint32_t AIRCR;                   
N  __IOM uint32_t SCR;                    /*!< Offset: 0x010 (R/W)  System Control Register */
X  volatile uint32_t SCR;                     
N  __IOM uint32_t CCR;                    /*!< Offset: 0x014 (R/W)  Configuration Control Register */
X  volatile uint32_t CCR;                     
N  __IOM uint8_t  SHP[12U];               /*!< Offset: 0x018 (R/W)  System Handlers Priority Registers (4-7, 8-11, 12-15) */
X  volatile uint8_t  SHP[12U];                
N  __IOM uint32_t SHCSR;                  /*!< Offset: 0x024 (R/W)  System Handler Control and State Register */
X  volatile uint32_t SHCSR;                   
N  __IOM uint32_t CFSR;                   /*!< Offset: 0x028 (R/W)  Configurable Fault Status Register */
X  volatile uint32_t CFSR;                    
N  __IOM uint32_t HFSR;                   /*!< Offset: 0x02C (R/W)  HardFault Status Register */
X  volatile uint32_t HFSR;                    
N  __IOM uint32_t DFSR;                   /*!< Offset: 0x030 (R/W)  Debug Fault Status Register */
X  volatile uint32_t DFSR;                    
N  __IOM uint32_t MMFAR;                  /*!< Offset: 0x034 (R/W)  MemManage Fault Address Register */
X  volatile uint32_t MMFAR;                   
N  __IOM uint32_t BFAR;                   /*!< Offset: 0x038 (R/W)  BusFault Address Register */
X  volatile uint32_t BFAR;                    
N  __IOM uint32_t AFSR;                   /*!< Offset: 0x03C (R/W)  Auxiliary Fault Status Register */
X  volatile uint32_t AFSR;                    
N  __IM  uint32_t PFR[2U];                /*!< Offset: 0x040 (R/ )  Processor Feature Register */
X  volatile const  uint32_t PFR[2U];                 
N  __IM  uint32_t DFR;                    /*!< Offset: 0x048 (R/ )  Debug Feature Register */
X  volatile const  uint32_t DFR;                     
N  __IM  uint32_t ADR;                    /*!< Offset: 0x04C (R/ )  Auxiliary Feature Register */
X  volatile const  uint32_t ADR;                     
N  __IM  uint32_t MMFR[4U];               /*!< Offset: 0x050 (R/ )  Memory Model Feature Register */
X  volatile const  uint32_t MMFR[4U];                
N  __IM  uint32_t ISAR[5U];               /*!< Offset: 0x060 (R/ )  Instruction Set Attributes Register */
X  volatile const  uint32_t ISAR[5U];                
N        uint32_t RESERVED0[5U];
N  __IOM uint32_t CPACR;                  /*!< Offset: 0x088 (R/W)  Coprocessor Access Control Register */
X  volatile uint32_t CPACR;                   
N} SCB_Type;
N
N/* SCB CPUID Register Definitions */
N#define SCB_CPUID_IMPLEMENTER_Pos          24U                                            /*!< SCB CPUID: IMPLEMENTER Position */
N#define SCB_CPUID_IMPLEMENTER_Msk          (0xFFUL << SCB_CPUID_IMPLEMENTER_Pos)          /*!< SCB CPUID: IMPLEMENTER Mask */
N
N#define SCB_CPUID_VARIANT_Pos              20U                                            /*!< SCB CPUID: VARIANT Position */
N#define SCB_CPUID_VARIANT_Msk              (0xFUL << SCB_CPUID_VARIANT_Pos)               /*!< SCB CPUID: VARIANT Mask */
N
N#define SCB_CPUID_ARCHITECTURE_Pos         16U                                            /*!< SCB CPUID: ARCHITECTURE Position */
N#define SCB_CPUID_ARCHITECTURE_Msk         (0xFUL << SCB_CPUID_ARCHITECTURE_Pos)          /*!< SCB CPUID: ARCHITECTURE Mask */
N
N#define SCB_CPUID_PARTNO_Pos                4U                                            /*!< SCB CPUID: PARTNO Position */
N#define SCB_CPUID_PARTNO_Msk               (0xFFFUL << SCB_CPUID_PARTNO_Pos)              /*!< SCB CPUID: PARTNO Mask */
N
N#define SCB_CPUID_REVISION_Pos              0U                                            /*!< SCB CPUID: REVISION Position */
N#define SCB_CPUID_REVISION_Msk             (0xFUL /*<< SCB_CPUID_REVISION_Pos*/)          /*!< SCB CPUID: REVISION Mask */
N
N/* SCB Interrupt Control State Register Definitions */
N#define SCB_ICSR_NMIPENDSET_Pos            31U                                            /*!< SCB ICSR: NMIPENDSET Position */
N#define SCB_ICSR_NMIPENDSET_Msk            (1UL << SCB_ICSR_NMIPENDSET_Pos)               /*!< SCB ICSR: NMIPENDSET Mask */
N
N#define SCB_ICSR_PENDSVSET_Pos             28U                                            /*!< SCB ICSR: PENDSVSET Position */
N#define SCB_ICSR_PENDSVSET_Msk             (1UL << SCB_ICSR_PENDSVSET_Pos)                /*!< SCB ICSR: PENDSVSET Mask */
N
N#define SCB_ICSR_PENDSVCLR_Pos             27U                                            /*!< SCB ICSR: PENDSVCLR Position */
N#define SCB_ICSR_PENDSVCLR_Msk             (1UL << SCB_ICSR_PENDSVCLR_Pos)                /*!< SCB ICSR: PENDSVCLR Mask */
N
N#define SCB_ICSR_PENDSTSET_Pos             26U                                            /*!< SCB ICSR: PENDSTSET Position */
N#define SCB_ICSR_PENDSTSET_Msk             (1UL << SCB_ICSR_PENDSTSET_Pos)                /*!< SCB ICSR: PENDSTSET Mask */
N
N#define SCB_ICSR_PENDSTCLR_Pos             25U                                            /*!< SCB ICSR: PENDSTCLR Position */
N#define SCB_ICSR_PENDSTCLR_Msk             (1UL << SCB_ICSR_PENDSTCLR_Pos)                /*!< SCB ICSR: PENDSTCLR Mask */
N
N#define SCB_ICSR_ISRPREEMPT_Pos            23U                                            /*!< SCB ICSR: ISRPREEMPT Position */
N#define SCB_ICSR_ISRPREEMPT_Msk            (1UL << SCB_ICSR_ISRPREEMPT_Pos)               /*!< SCB ICSR: ISRPREEMPT Mask */
N
N#define SCB_ICSR_ISRPENDING_Pos            22U                                            /*!< SCB ICSR: ISRPENDING Position */
N#define SCB_ICSR_ISRPENDING_Msk            (1UL << SCB_ICSR_ISRPENDING_Pos)               /*!< SCB ICSR: ISRPENDING Mask */
N
N#define SCB_ICSR_VECTPENDING_Pos           12U                                            /*!< SCB ICSR: VECTPENDING Position */
N#define SCB_ICSR_VECTPENDING_Msk           (0x1FFUL << SCB_ICSR_VECTPENDING_Pos)          /*!< SCB ICSR: VECTPENDING Mask */
N
N#define SCB_ICSR_RETTOBASE_Pos             11U                                            /*!< SCB ICSR: RETTOBASE Position */
N#define SCB_ICSR_RETTOBASE_Msk             (1UL << SCB_ICSR_RETTOBASE_Pos)                /*!< SCB ICSR: RETTOBASE Mask */
N
N#define SCB_ICSR_VECTACTIVE_Pos             0U                                            /*!< SCB ICSR: VECTACTIVE Position */
N#define SCB_ICSR_VECTACTIVE_Msk            (0x1FFUL /*<< SCB_ICSR_VECTACTIVE_Pos*/)       /*!< SCB ICSR: VECTACTIVE Mask */
N
N/* SCB Vector Table Offset Register Definitions */
N#if defined (__CM3_REV) && (__CM3_REV < 0x0201U)                   /* core r2p1 */
X#if 1L && (0x0102 < 0x0201U)                    
N#define SCB_VTOR_TBLBASE_Pos               29U                                            /*!< SCB VTOR: TBLBASE Position */
N#define SCB_VTOR_TBLBASE_Msk               (1UL << SCB_VTOR_TBLBASE_Pos)                  /*!< SCB VTOR: TBLBASE Mask */
N
N#define SCB_VTOR_TBLOFF_Pos                 7U                                            /*!< SCB VTOR: TBLOFF Position */
N#define SCB_VTOR_TBLOFF_Msk                (0x3FFFFFUL << SCB_VTOR_TBLOFF_Pos)            /*!< SCB VTOR: TBLOFF Mask */
N#else
S#define SCB_VTOR_TBLOFF_Pos                 7U                                            /*!< SCB VTOR: TBLOFF Position */
S#define SCB_VTOR_TBLOFF_Msk                (0x1FFFFFFUL << SCB_VTOR_TBLOFF_Pos)           /*!< SCB VTOR: TBLOFF Mask */
N#endif
N
N/* SCB Application Interrupt and Reset Control Register Definitions */
N#define SCB_AIRCR_VECTKEY_Pos              16U                                            /*!< SCB AIRCR: VECTKEY Position */
N#define SCB_AIRCR_VECTKEY_Msk              (0xFFFFUL << SCB_AIRCR_VECTKEY_Pos)            /*!< SCB AIRCR: VECTKEY Mask */
N
N#define SCB_AIRCR_VECTKEYSTAT_Pos          16U                                            /*!< SCB AIRCR: VECTKEYSTAT Position */
N#define SCB_AIRCR_VECTKEYSTAT_Msk          (0xFFFFUL << SCB_AIRCR_VECTKEYSTAT_Pos)        /*!< SCB AIRCR: VECTKEYSTAT Mask */
N
N#define SCB_AIRCR_ENDIANESS_Pos            15U                                            /*!< SCB AIRCR: ENDIANESS Position */
N#define SCB_AIRCR_ENDIANESS_Msk            (1UL << SCB_AIRCR_ENDIANESS_Pos)               /*!< SCB AIRCR: ENDIANESS Mask */
N
N#define SCB_AIRCR_PRIGROUP_Pos              8U                                            /*!< SCB AIRCR: PRIGROUP Position */
N#define SCB_AIRCR_PRIGROUP_Msk             (7UL << SCB_AIRCR_PRIGROUP_Pos)                /*!< SCB AIRCR: PRIGROUP Mask */
N
N#define SCB_AIRCR_SYSRESETREQ_Pos           2U                                            /*!< SCB AIRCR: SYSRESETREQ Position */
N#define SCB_AIRCR_SYSRESETREQ_Msk          (1UL << SCB_AIRCR_SYSRESETREQ_Pos)             /*!< SCB AIRCR: SYSRESETREQ Mask */
N
N#define SCB_AIRCR_VECTCLRACTIVE_Pos         1U                                            /*!< SCB AIRCR: VECTCLRACTIVE Position */
N#define SCB_AIRCR_VECTCLRACTIVE_Msk        (1UL << SCB_AIRCR_VECTCLRACTIVE_Pos)           /*!< SCB AIRCR: VECTCLRACTIVE Mask */
N
N#define SCB_AIRCR_VECTRESET_Pos             0U                                            /*!< SCB AIRCR: VECTRESET Position */
N#define SCB_AIRCR_VECTRESET_Msk            (1UL /*<< SCB_AIRCR_VECTRESET_Pos*/)           /*!< SCB AIRCR: VECTRESET Mask */
N
N/* SCB System Control Register Definitions */
N#define SCB_SCR_SEVONPEND_Pos               4U                                            /*!< SCB SCR: SEVONPEND Position */
N#define SCB_SCR_SEVONPEND_Msk              (1UL << SCB_SCR_SEVONPEND_Pos)                 /*!< SCB SCR: SEVONPEND Mask */
N
N#define SCB_SCR_SLEEPDEEP_Pos               2U                                            /*!< SCB SCR: SLEEPDEEP Position */
N#define SCB_SCR_SLEEPDEEP_Msk              (1UL << SCB_SCR_SLEEPDEEP_Pos)                 /*!< SCB SCR: SLEEPDEEP Mask */
N
N#define SCB_SCR_SLEEPONEXIT_Pos             1U                                            /*!< SCB SCR: SLEEPONEXIT Position */
N#define SCB_SCR_SLEEPONEXIT_Msk            (1UL << SCB_SCR_SLEEPONEXIT_Pos)               /*!< SCB SCR: SLEEPONEXIT Mask */
N
N/* SCB Configuration Control Register Definitions */
N#define SCB_CCR_STKALIGN_Pos                9U                                            /*!< SCB CCR: STKALIGN Position */
N#define SCB_CCR_STKALIGN_Msk               (1UL << SCB_CCR_STKALIGN_Pos)                  /*!< SCB CCR: STKALIGN Mask */
N
N#define SCB_CCR_BFHFNMIGN_Pos               8U                                            /*!< SCB CCR: BFHFNMIGN Position */
N#define SCB_CCR_BFHFNMIGN_Msk              (1UL << SCB_CCR_BFHFNMIGN_Pos)                 /*!< SCB CCR: BFHFNMIGN Mask */
N
N#define SCB_CCR_DIV_0_TRP_Pos               4U                                            /*!< SCB CCR: DIV_0_TRP Position */
N#define SCB_CCR_DIV_0_TRP_Msk              (1UL << SCB_CCR_DIV_0_TRP_Pos)                 /*!< SCB CCR: DIV_0_TRP Mask */
N
N#define SCB_CCR_UNALIGN_TRP_Pos             3U                                            /*!< SCB CCR: UNALIGN_TRP Position */
N#define SCB_CCR_UNALIGN_TRP_Msk            (1UL << SCB_CCR_UNALIGN_TRP_Pos)               /*!< SCB CCR: UNALIGN_TRP Mask */
N
N#define SCB_CCR_USERSETMPEND_Pos            1U                                            /*!< SCB CCR: USERSETMPEND Position */
N#define SCB_CCR_USERSETMPEND_Msk           (1UL << SCB_CCR_USERSETMPEND_Pos)              /*!< SCB CCR: USERSETMPEND Mask */
N
N#define SCB_CCR_NONBASETHRDENA_Pos          0U                                            /*!< SCB CCR: NONBASETHRDENA Position */
N#define SCB_CCR_NONBASETHRDENA_Msk         (1UL /*<< SCB_CCR_NONBASETHRDENA_Pos*/)        /*!< SCB CCR: NONBASETHRDENA Mask */
N
N/* SCB System Handler Control and State Register Definitions */
N#define SCB_SHCSR_USGFAULTENA_Pos          18U                                            /*!< SCB SHCSR: USGFAULTENA Position */
N#define SCB_SHCSR_USGFAULTENA_Msk          (1UL << SCB_SHCSR_USGFAULTENA_Pos)             /*!< SCB SHCSR: USGFAULTENA Mask */
N
N#define SCB_SHCSR_BUSFAULTENA_Pos          17U                                            /*!< SCB SHCSR: BUSFAULTENA Position */
N#define SCB_SHCSR_BUSFAULTENA_Msk          (1UL << SCB_SHCSR_BUSFAULTENA_Pos)             /*!< SCB SHCSR: BUSFAULTENA Mask */
N
N#define SCB_SHCSR_MEMFAULTENA_Pos          16U                                            /*!< SCB SHCSR: MEMFAULTENA Position */
N#define SCB_SHCSR_MEMFAULTENA_Msk          (1UL << SCB_SHCSR_MEMFAULTENA_Pos)             /*!< SCB SHCSR: MEMFAULTENA Mask */
N
N#define SCB_SHCSR_SVCALLPENDED_Pos         15U                                            /*!< SCB SHCSR: SVCALLPENDED Position */
N#define SCB_SHCSR_SVCALLPENDED_Msk         (1UL << SCB_SHCSR_SVCALLPENDED_Pos)            /*!< SCB SHCSR: SVCALLPENDED Mask */
N
N#define SCB_SHCSR_BUSFAULTPENDED_Pos       14U                                            /*!< SCB SHCSR: BUSFAULTPENDED Position */
N#define SCB_SHCSR_BUSFAULTPENDED_Msk       (1UL << SCB_SHCSR_BUSFAULTPENDED_Pos)          /*!< SCB SHCSR: BUSFAULTPENDED Mask */
N
N#define SCB_SHCSR_MEMFAULTPENDED_Pos       13U                                            /*!< SCB SHCSR: MEMFAULTPENDED Position */
N#define SCB_SHCSR_MEMFAULTPENDED_Msk       (1UL << SCB_SHCSR_MEMFAULTPENDED_Pos)          /*!< SCB SHCSR: MEMFAULTPENDED Mask */
N
N#define SCB_SHCSR_USGFAULTPENDED_Pos       12U                                            /*!< SCB SHCSR: USGFAULTPENDED Position */
N#define SCB_SHCSR_USGFAULTPENDED_Msk       (1UL << SCB_SHCSR_USGFAULTPENDED_Pos)          /*!< SCB SHCSR: USGFAULTPENDED Mask */
N
N#define SCB_SHCSR_SYSTICKACT_Pos           11U                                            /*!< SCB SHCSR: SYSTICKACT Position */
N#define SCB_SHCSR_SYSTICKACT_Msk           (1UL << SCB_SHCSR_SYSTICKACT_Pos)              /*!< SCB SHCSR: SYSTICKACT Mask */
N
N#define SCB_SHCSR_PENDSVACT_Pos            10U                                            /*!< SCB SHCSR: PENDSVACT Position */
N#define SCB_SHCSR_PENDSVACT_Msk            (1UL << SCB_SHCSR_PENDSVACT_Pos)               /*!< SCB SHCSR: PENDSVACT Mask */
N
N#define SCB_SHCSR_MONITORACT_Pos            8U                                            /*!< SCB SHCSR: MONITORACT Position */
N#define SCB_SHCSR_MONITORACT_Msk           (1UL << SCB_SHCSR_MONITORACT_Pos)              /*!< SCB SHCSR: MONITORACT Mask */
N
N#define SCB_SHCSR_SVCALLACT_Pos             7U                                            /*!< SCB SHCSR: SVCALLACT Position */
N#define SCB_SHCSR_SVCALLACT_Msk            (1UL << SCB_SHCSR_SVCALLACT_Pos)               /*!< SCB SHCSR: SVCALLACT Mask */
N
N#define SCB_SHCSR_USGFAULTACT_Pos           3U                                            /*!< SCB SHCSR: USGFAULTACT Position */
N#define SCB_SHCSR_USGFAULTACT_Msk          (1UL << SCB_SHCSR_USGFAULTACT_Pos)             /*!< SCB SHCSR: USGFAULTACT Mask */
N
N#define SCB_SHCSR_BUSFAULTACT_Pos           1U                                            /*!< SCB SHCSR: BUSFAULTACT Position */
N#define SCB_SHCSR_BUSFAULTACT_Msk          (1UL << SCB_SHCSR_BUSFAULTACT_Pos)             /*!< SCB SHCSR: BUSFAULTACT Mask */
N
N#define SCB_SHCSR_MEMFAULTACT_Pos           0U                                            /*!< SCB SHCSR: MEMFAULTACT Position */
N#define SCB_SHCSR_MEMFAULTACT_Msk          (1UL /*<< SCB_SHCSR_MEMFAULTACT_Pos*/)         /*!< SCB SHCSR: MEMFAULTACT Mask */
N
N/* SCB Configurable Fault Status Register Definitions */
N#define SCB_CFSR_USGFAULTSR_Pos            16U                                            /*!< SCB CFSR: Usage Fault Status Register Position */
N#define SCB_CFSR_USGFAULTSR_Msk            (0xFFFFUL << SCB_CFSR_USGFAULTSR_Pos)          /*!< SCB CFSR: Usage Fault Status Register Mask */
N
N#define SCB_CFSR_BUSFAULTSR_Pos             8U                                            /*!< SCB CFSR: Bus Fault Status Register Position */
N#define SCB_CFSR_BUSFAULTSR_Msk            (0xFFUL << SCB_CFSR_BUSFAULTSR_Pos)            /*!< SCB CFSR: Bus Fault Status Register Mask */
N
N#define SCB_CFSR_MEMFAULTSR_Pos             0U                                            /*!< SCB CFSR: Memory Manage Fault Status Register Position */
N#define SCB_CFSR_MEMFAULTSR_Msk            (0xFFUL /*<< SCB_CFSR_MEMFAULTSR_Pos*/)        /*!< SCB CFSR: Memory Manage Fault Status Register Mask */
N
N/* MemManage Fault Status Register (part of SCB Configurable Fault Status Register) */
N#define SCB_CFSR_MMARVALID_Pos             (SCB_SHCSR_MEMFAULTACT_Pos + 7U)               /*!< SCB CFSR (MMFSR): MMARVALID Position */
N#define SCB_CFSR_MMARVALID_Msk             (1UL << SCB_CFSR_MMARVALID_Pos)                /*!< SCB CFSR (MMFSR): MMARVALID Mask */
N
N#define SCB_CFSR_MSTKERR_Pos               (SCB_SHCSR_MEMFAULTACT_Pos + 4U)               /*!< SCB CFSR (MMFSR): MSTKERR Position */
N#define SCB_CFSR_MSTKERR_Msk               (1UL << SCB_CFSR_MSTKERR_Pos)                  /*!< SCB CFSR (MMFSR): MSTKERR Mask */
N
N#define SCB_CFSR_MUNSTKERR_Pos             (SCB_SHCSR_MEMFAULTACT_Pos + 3U)               /*!< SCB CFSR (MMFSR): MUNSTKERR Position */
N#define SCB_CFSR_MUNSTKERR_Msk             (1UL << SCB_CFSR_MUNSTKERR_Pos)                /*!< SCB CFSR (MMFSR): MUNSTKERR Mask */
N
N#define SCB_CFSR_DACCVIOL_Pos              (SCB_SHCSR_MEMFAULTACT_Pos + 1U)               /*!< SCB CFSR (MMFSR): DACCVIOL Position */
N#define SCB_CFSR_DACCVIOL_Msk              (1UL << SCB_CFSR_DACCVIOL_Pos)                 /*!< SCB CFSR (MMFSR): DACCVIOL Mask */
N
N#define SCB_CFSR_IACCVIOL_Pos              (SCB_SHCSR_MEMFAULTACT_Pos + 0U)               /*!< SCB CFSR (MMFSR): IACCVIOL Position */
N#define SCB_CFSR_IACCVIOL_Msk              (1UL /*<< SCB_CFSR_IACCVIOL_Pos*/)             /*!< SCB CFSR (MMFSR): IACCVIOL Mask */
N
N/* BusFault Status Register (part of SCB Configurable Fault Status Register) */
N#define SCB_CFSR_BFARVALID_Pos            (SCB_CFSR_BUSFAULTSR_Pos + 7U)                  /*!< SCB CFSR (BFSR): BFARVALID Position */
N#define SCB_CFSR_BFARVALID_Msk            (1UL << SCB_CFSR_BFARVALID_Pos)                 /*!< SCB CFSR (BFSR): BFARVALID Mask */
N
N#define SCB_CFSR_STKERR_Pos               (SCB_CFSR_BUSFAULTSR_Pos + 4U)                  /*!< SCB CFSR (BFSR): STKERR Position */
N#define SCB_CFSR_STKERR_Msk               (1UL << SCB_CFSR_STKERR_Pos)                    /*!< SCB CFSR (BFSR): STKERR Mask */
N
N#define SCB_CFSR_UNSTKERR_Pos             (SCB_CFSR_BUSFAULTSR_Pos + 3U)                  /*!< SCB CFSR (BFSR): UNSTKERR Position */
N#define SCB_CFSR_UNSTKERR_Msk             (1UL << SCB_CFSR_UNSTKERR_Pos)                  /*!< SCB CFSR (BFSR): UNSTKERR Mask */
N
N#define SCB_CFSR_IMPRECISERR_Pos          (SCB_CFSR_BUSFAULTSR_Pos + 2U)                  /*!< SCB CFSR (BFSR): IMPRECISERR Position */
N#define SCB_CFSR_IMPRECISERR_Msk          (1UL << SCB_CFSR_IMPRECISERR_Pos)               /*!< SCB CFSR (BFSR): IMPRECISERR Mask */
N
N#define SCB_CFSR_PRECISERR_Pos            (SCB_CFSR_BUSFAULTSR_Pos + 1U)                  /*!< SCB CFSR (BFSR): PRECISERR Position */
N#define SCB_CFSR_PRECISERR_Msk            (1UL << SCB_CFSR_PRECISERR_Pos)                 /*!< SCB CFSR (BFSR): PRECISERR Mask */
N
N#define SCB_CFSR_IBUSERR_Pos              (SCB_CFSR_BUSFAULTSR_Pos + 0U)                  /*!< SCB CFSR (BFSR): IBUSERR Position */
N#define SCB_CFSR_IBUSERR_Msk              (1UL << SCB_CFSR_IBUSERR_Pos)                   /*!< SCB CFSR (BFSR): IBUSERR Mask */
N
N/* UsageFault Status Register (part of SCB Configurable Fault Status Register) */
N#define SCB_CFSR_DIVBYZERO_Pos            (SCB_CFSR_USGFAULTSR_Pos + 9U)                  /*!< SCB CFSR (UFSR): DIVBYZERO Position */
N#define SCB_CFSR_DIVBYZERO_Msk            (1UL << SCB_CFSR_DIVBYZERO_Pos)                 /*!< SCB CFSR (UFSR): DIVBYZERO Mask */
N
N#define SCB_CFSR_UNALIGNED_Pos            (SCB_CFSR_USGFAULTSR_Pos + 8U)                  /*!< SCB CFSR (UFSR): UNALIGNED Position */
N#define SCB_CFSR_UNALIGNED_Msk            (1UL << SCB_CFSR_UNALIGNED_Pos)                 /*!< SCB CFSR (UFSR): UNALIGNED Mask */
N
N#define SCB_CFSR_NOCP_Pos                 (SCB_CFSR_USGFAULTSR_Pos + 3U)                  /*!< SCB CFSR (UFSR): NOCP Position */
N#define SCB_CFSR_NOCP_Msk                 (1UL << SCB_CFSR_NOCP_Pos)                      /*!< SCB CFSR (UFSR): NOCP Mask */
N
N#define SCB_CFSR_INVPC_Pos                (SCB_CFSR_USGFAULTSR_Pos + 2U)                  /*!< SCB CFSR (UFSR): INVPC Position */
N#define SCB_CFSR_INVPC_Msk                (1UL << SCB_CFSR_INVPC_Pos)                     /*!< SCB CFSR (UFSR): INVPC Mask */
N
N#define SCB_CFSR_INVSTATE_Pos             (SCB_CFSR_USGFAULTSR_Pos + 1U)                  /*!< SCB CFSR (UFSR): INVSTATE Position */
N#define SCB_CFSR_INVSTATE_Msk             (1UL << SCB_CFSR_INVSTATE_Pos)                  /*!< SCB CFSR (UFSR): INVSTATE Mask */
N
N#define SCB_CFSR_UNDEFINSTR_Pos           (SCB_CFSR_USGFAULTSR_Pos + 0U)                  /*!< SCB CFSR (UFSR): UNDEFINSTR Position */
N#define SCB_CFSR_UNDEFINSTR_Msk           (1UL << SCB_CFSR_UNDEFINSTR_Pos)                /*!< SCB CFSR (UFSR): UNDEFINSTR Mask */
N
N/* SCB Hard Fault Status Register Definitions */
N#define SCB_HFSR_DEBUGEVT_Pos              31U                                            /*!< SCB HFSR: DEBUGEVT Position */
N#define SCB_HFSR_DEBUGEVT_Msk              (1UL << SCB_HFSR_DEBUGEVT_Pos)                 /*!< SCB HFSR: DEBUGEVT Mask */
N
N#define SCB_HFSR_FORCED_Pos                30U                                            /*!< SCB HFSR: FORCED Position */
N#define SCB_HFSR_FORCED_Msk                (1UL << SCB_HFSR_FORCED_Pos)                   /*!< SCB HFSR: FORCED Mask */
N
N#define SCB_HFSR_VECTTBL_Pos                1U                                            /*!< SCB HFSR: VECTTBL Position */
N#define SCB_HFSR_VECTTBL_Msk               (1UL << SCB_HFSR_VECTTBL_Pos)                  /*!< SCB HFSR: VECTTBL Mask */
N
N/* SCB Debug Fault Status Register Definitions */
N#define SCB_DFSR_EXTERNAL_Pos               4U                                            /*!< SCB DFSR: EXTERNAL Position */
N#define SCB_DFSR_EXTERNAL_Msk              (1UL << SCB_DFSR_EXTERNAL_Pos)                 /*!< SCB DFSR: EXTERNAL Mask */
N
N#define SCB_DFSR_VCATCH_Pos                 3U                                            /*!< SCB DFSR: VCATCH Position */
N#define SCB_DFSR_VCATCH_Msk                (1UL << SCB_DFSR_VCATCH_Pos)                   /*!< SCB DFSR: VCATCH Mask */
N
N#define SCB_DFSR_DWTTRAP_Pos                2U                                            /*!< SCB DFSR: DWTTRAP Position */
N#define SCB_DFSR_DWTTRAP_Msk               (1UL << SCB_DFSR_DWTTRAP_Pos)                  /*!< SCB DFSR: DWTTRAP Mask */
N
N#define SCB_DFSR_BKPT_Pos                   1U                                            /*!< SCB DFSR: BKPT Position */
N#define SCB_DFSR_BKPT_Msk                  (1UL << SCB_DFSR_BKPT_Pos)                     /*!< SCB DFSR: BKPT Mask */
N
N#define SCB_DFSR_HALTED_Pos                 0U                                            /*!< SCB DFSR: HALTED Position */
N#define SCB_DFSR_HALTED_Msk                (1UL /*<< SCB_DFSR_HALTED_Pos*/)               /*!< SCB DFSR: HALTED Mask */
N
N/*@} end of group CMSIS_SCB */
N
N
N/**
N  \ingroup  CMSIS_core_register
N  \defgroup CMSIS_SCnSCB System Controls not in SCB (SCnSCB)
N  \brief    Type definitions for the System Control and ID Register not in the SCB
N  @{
N */
N
N/**
N  \brief  Structure type to access the System Control and ID Register not in the SCB.
N */
Ntypedef struct
N{
N        uint32_t RESERVED0[1U];
N  __IM  uint32_t ICTR;                   /*!< Offset: 0x004 (R/ )  Interrupt Controller Type Register */
X  volatile const  uint32_t ICTR;                    
N#if defined (__CM3_REV) && (__CM3_REV >= 0x200U)
X#if 1L && (0x0102 >= 0x200U)
S  __IOM uint32_t ACTLR;                  /*!< Offset: 0x008 (R/W)  Auxiliary Control Register */
N#else
N        uint32_t RESERVED1[1U];
N#endif
N} SCnSCB_Type;
N
N/* Interrupt Controller Type Register Definitions */
N#define SCnSCB_ICTR_INTLINESNUM_Pos         0U                                         /*!< ICTR: INTLINESNUM Position */
N#define SCnSCB_ICTR_INTLINESNUM_Msk        (0xFUL /*<< SCnSCB_ICTR_INTLINESNUM_Pos*/)  /*!< ICTR: INTLINESNUM Mask */
N
N/* Auxiliary Control Register Definitions */
N
N#define SCnSCB_ACTLR_DISFOLD_Pos            2U                                         /*!< ACTLR: DISFOLD Position */
N#define SCnSCB_ACTLR_DISFOLD_Msk           (1UL << SCnSCB_ACTLR_DISFOLD_Pos)           /*!< ACTLR: DISFOLD Mask */
N
N#define SCnSCB_ACTLR_DISDEFWBUF_Pos         1U                                         /*!< ACTLR: DISDEFWBUF Position */
N#define SCnSCB_ACTLR_DISDEFWBUF_Msk        (1UL << SCnSCB_ACTLR_DISDEFWBUF_Pos)        /*!< ACTLR: DISDEFWBUF Mask */
N
N#define SCnSCB_ACTLR_DISMCYCINT_Pos         0U                                         /*!< ACTLR: DISMCYCINT Position */
N#define SCnSCB_ACTLR_DISMCYCINT_Msk        (1UL /*<< SCnSCB_ACTLR_DISMCYCINT_Pos*/)    /*!< ACTLR: DISMCYCINT Mask */
N
N/*@} end of group CMSIS_SCnotSCB */
N
N
N/**
N  \ingroup  CMSIS_core_register
N  \defgroup CMSIS_SysTick     System Tick Timer (SysTick)
N  \brief    Type definitions for the System Timer Registers.
N  @{
N */
N
N/**
N  \brief  Structure type to access the System Timer (SysTick).
N */
Ntypedef struct
N{
N  __IOM uint32_t CTRL;                   /*!< Offset: 0x000 (R/W)  SysTick Control and Status Register */
X  volatile uint32_t CTRL;                    
N  __IOM uint32_t LOAD;                   /*!< Offset: 0x004 (R/W)  SysTick Reload Value Register */
X  volatile uint32_t LOAD;                    
N  __IOM uint32_t VAL;                    /*!< Offset: 0x008 (R/W)  SysTick Current Value Register */
X  volatile uint32_t VAL;                     
N  __IM  uint32_t CALIB;                  /*!< Offset: 0x00C (R/ )  SysTick Calibration Register */
X  volatile const  uint32_t CALIB;                   
N} SysTick_Type;
N
N/* SysTick Control / Status Register Definitions */
N#define SysTick_CTRL_COUNTFLAG_Pos         16U                                            /*!< SysTick CTRL: COUNTFLAG Position */
N#define SysTick_CTRL_COUNTFLAG_Msk         (1UL << SysTick_CTRL_COUNTFLAG_Pos)            /*!< SysTick CTRL: COUNTFLAG Mask */
N
N#define SysTick_CTRL_CLKSOURCE_Pos          2U                                            /*!< SysTick CTRL: CLKSOURCE Position */
N#define SysTick_CTRL_CLKSOURCE_Msk         (1UL << SysTick_CTRL_CLKSOURCE_Pos)            /*!< SysTick CTRL: CLKSOURCE Mask */
N
N#define SysTick_CTRL_TICKINT_Pos            1U                                            /*!< SysTick CTRL: TICKINT Position */
N#define SysTick_CTRL_TICKINT_Msk           (1UL << SysTick_CTRL_TICKINT_Pos)              /*!< SysTick CTRL: TICKINT Mask */
N
N#define SysTick_CTRL_ENABLE_Pos             0U                                            /*!< SysTick CTRL: ENABLE Position */
N#define SysTick_CTRL_ENABLE_Msk            (1UL /*<< SysTick_CTRL_ENABLE_Pos*/)           /*!< SysTick CTRL: ENABLE Mask */
N
N/* SysTick Reload Register Definitions */
N#define SysTick_LOAD_RELOAD_Pos             0U                                            /*!< SysTick LOAD: RELOAD Position */
N#define SysTick_LOAD_RELOAD_Msk            (0xFFFFFFUL /*<< SysTick_LOAD_RELOAD_Pos*/)    /*!< SysTick LOAD: RELOAD Mask */
N
N/* SysTick Current Register Definitions */
N#define SysTick_VAL_CURRENT_Pos             0U                                            /*!< SysTick VAL: CURRENT Position */
N#define SysTick_VAL_CURRENT_Msk            (0xFFFFFFUL /*<< SysTick_VAL_CURRENT_Pos*/)    /*!< SysTick VAL: CURRENT Mask */
N
N/* SysTick Calibration Register Definitions */
N#define SysTick_CALIB_NOREF_Pos            31U                                            /*!< SysTick CALIB: NOREF Position */
N#define SysTick_CALIB_NOREF_Msk            (1UL << SysTick_CALIB_NOREF_Pos)               /*!< SysTick CALIB: NOREF Mask */
N
N#define SysTick_CALIB_SKEW_Pos             30U                                            /*!< SysTick CALIB: SKEW Position */
N#define SysTick_CALIB_SKEW_Msk             (1UL << SysTick_CALIB_SKEW_Pos)                /*!< SysTick CALIB: SKEW Mask */
N
N#define SysTick_CALIB_TENMS_Pos             0U                                            /*!< SysTick CALIB: TENMS Position */
N#define SysTick_CALIB_TENMS_Msk            (0xFFFFFFUL /*<< SysTick_CALIB_TENMS_Pos*/)    /*!< SysTick CALIB: TENMS Mask */
N
N/*@} end of group CMSIS_SysTick */
N
N
N/**
N  \ingroup  CMSIS_core_register
N  \defgroup CMSIS_ITM     Instrumentation Trace Macrocell (ITM)
N  \brief    Type definitions for the Instrumentation Trace Macrocell (ITM)
N  @{
N */
N
N/**
N  \brief  Structure type to access the Instrumentation Trace Macrocell Register (ITM).
N */
Ntypedef struct
N{
N  __OM  union
X  volatile  union
N  {
N    __OM  uint8_t    u8;                 /*!< Offset: 0x000 ( /W)  ITM Stimulus Port 8-bit */
X    volatile  uint8_t    u8;                  
N    __OM  uint16_t   u16;                /*!< Offset: 0x000 ( /W)  ITM Stimulus Port 16-bit */
X    volatile  uint16_t   u16;                 
N    __OM  uint32_t   u32;                /*!< Offset: 0x000 ( /W)  ITM Stimulus Port 32-bit */
X    volatile  uint32_t   u32;                 
N  }  PORT [32U];                         /*!< Offset: 0x000 ( /W)  ITM Stimulus Port Registers */
N        uint32_t RESERVED0[864U];
N  __IOM uint32_t TER;                    /*!< Offset: 0xE00 (R/W)  ITM Trace Enable Register */
X  volatile uint32_t TER;                     
N        uint32_t RESERVED1[15U];
N  __IOM uint32_t TPR;                    /*!< Offset: 0xE40 (R/W)  ITM Trace Privilege Register */
X  volatile uint32_t TPR;                     
N        uint32_t RESERVED2[15U];
N  __IOM uint32_t TCR;                    /*!< Offset: 0xE80 (R/W)  ITM Trace Control Register */
X  volatile uint32_t TCR;                     
N        uint32_t RESERVED3[29U];
N  __OM  uint32_t IWR;                    /*!< Offset: 0xEF8 ( /W)  ITM Integration Write Register */
X  volatile  uint32_t IWR;                     
N  __IM  uint32_t IRR;                    /*!< Offset: 0xEFC (R/ )  ITM Integration Read Register */
X  volatile const  uint32_t IRR;                     
N  __IOM uint32_t IMCR;                   /*!< Offset: 0xF00 (R/W)  ITM Integration Mode Control Register */
X  volatile uint32_t IMCR;                    
N        uint32_t RESERVED4[43U];
N  __OM  uint32_t LAR;                    /*!< Offset: 0xFB0 ( /W)  ITM Lock Access Register */
X  volatile  uint32_t LAR;                     
N  __IM  uint32_t LSR;                    /*!< Offset: 0xFB4 (R/ )  ITM Lock Status Register */
X  volatile const  uint32_t LSR;                     
N        uint32_t RESERVED5[6U];
N  __IM  uint32_t PID4;                   /*!< Offset: 0xFD0 (R/ )  ITM Peripheral Identification Register #4 */
X  volatile const  uint32_t PID4;                    
N  __IM  uint32_t PID5;                   /*!< Offset: 0xFD4 (R/ )  ITM Peripheral Identification Register #5 */
X  volatile const  uint32_t PID5;                    
N  __IM  uint32_t PID6;                   /*!< Offset: 0xFD8 (R/ )  ITM Peripheral Identification Register #6 */
X  volatile const  uint32_t PID6;                    
N  __IM  uint32_t PID7;                   /*!< Offset: 0xFDC (R/ )  ITM Peripheral Identification Register #7 */
X  volatile const  uint32_t PID7;                    
N  __IM  uint32_t PID0;                   /*!< Offset: 0xFE0 (R/ )  ITM Peripheral Identification Register #0 */
X  volatile const  uint32_t PID0;                    
N  __IM  uint32_t PID1;                   /*!< Offset: 0xFE4 (R/ )  ITM Peripheral Identification Register #1 */
X  volatile const  uint32_t PID1;                    
N  __IM  uint32_t PID2;                   /*!< Offset: 0xFE8 (R/ )  ITM Peripheral Identification Register #2 */
X  volatile const  uint32_t PID2;                    
N  __IM  uint32_t PID3;                   /*!< Offset: 0xFEC (R/ )  ITM Peripheral Identification Register #3 */
X  volatile const  uint32_t PID3;                    
N  __IM  uint32_t CID0;                   /*!< Offset: 0xFF0 (R/ )  ITM Component  Identification Register #0 */
X  volatile const  uint32_t CID0;                    
N  __IM  uint32_t CID1;                   /*!< Offset: 0xFF4 (R/ )  ITM Component  Identification Register #1 */
X  volatile const  uint32_t CID1;                    
N  __IM  uint32_t CID2;                   /*!< Offset: 0xFF8 (R/ )  ITM Component  Identification Register #2 */
X  volatile const  uint32_t CID2;                    
N  __IM  uint32_t CID3;                   /*!< Offset: 0xFFC (R/ )  ITM Component  Identification Register #3 */
X  volatile const  uint32_t CID3;                    
N} ITM_Type;
N
N/* ITM Trace Privilege Register Definitions */
N#define ITM_TPR_PRIVMASK_Pos                0U                                            /*!< ITM TPR: PRIVMASK Position */
N#define ITM_TPR_PRIVMASK_Msk               (0xFUL /*<< ITM_TPR_PRIVMASK_Pos*/)            /*!< ITM TPR: PRIVMASK Mask */
N
N/* ITM Trace Control Register Definitions */
N#define ITM_TCR_BUSY_Pos                   23U                                            /*!< ITM TCR: BUSY Position */
N#define ITM_TCR_BUSY_Msk                   (1UL << ITM_TCR_BUSY_Pos)                      /*!< ITM TCR: BUSY Mask */
N
N#define ITM_TCR_TraceBusID_Pos             16U                                            /*!< ITM TCR: ATBID Position */
N#define ITM_TCR_TraceBusID_Msk             (0x7FUL << ITM_TCR_TraceBusID_Pos)             /*!< ITM TCR: ATBID Mask */
N
N#define ITM_TCR_GTSFREQ_Pos                10U                                            /*!< ITM TCR: Global timestamp frequency Position */
N#define ITM_TCR_GTSFREQ_Msk                (3UL << ITM_TCR_GTSFREQ_Pos)                   /*!< ITM TCR: Global timestamp frequency Mask */
N
N#define ITM_TCR_TSPrescale_Pos              8U                                            /*!< ITM TCR: TSPrescale Position */
N#define ITM_TCR_TSPrescale_Msk             (3UL << ITM_TCR_TSPrescale_Pos)                /*!< ITM TCR: TSPrescale Mask */
N
N#define ITM_TCR_SWOENA_Pos                  4U                                            /*!< ITM TCR: SWOENA Position */
N#define ITM_TCR_SWOENA_Msk                 (1UL << ITM_TCR_SWOENA_Pos)                    /*!< ITM TCR: SWOENA Mask */
N
N#define ITM_TCR_DWTENA_Pos                  3U                                            /*!< ITM TCR: DWTENA Position */
N#define ITM_TCR_DWTENA_Msk                 (1UL << ITM_TCR_DWTENA_Pos)                    /*!< ITM TCR: DWTENA Mask */
N
N#define ITM_TCR_SYNCENA_Pos                 2U                                            /*!< ITM TCR: SYNCENA Position */
N#define ITM_TCR_SYNCENA_Msk                (1UL << ITM_TCR_SYNCENA_Pos)                   /*!< ITM TCR: SYNCENA Mask */
N
N#define ITM_TCR_TSENA_Pos                   1U                                            /*!< ITM TCR: TSENA Position */
N#define ITM_TCR_TSENA_Msk                  (1UL << ITM_TCR_TSENA_Pos)                     /*!< ITM TCR: TSENA Mask */
N
N#define ITM_TCR_ITMENA_Pos                  0U                                            /*!< ITM TCR: ITM Enable bit Position */
N#define ITM_TCR_ITMENA_Msk                 (1UL /*<< ITM_TCR_ITMENA_Pos*/)                /*!< ITM TCR: ITM Enable bit Mask */
N
N/* ITM Integration Write Register Definitions */
N#define ITM_IWR_ATVALIDM_Pos                0U                                            /*!< ITM IWR: ATVALIDM Position */
N#define ITM_IWR_ATVALIDM_Msk               (1UL /*<< ITM_IWR_ATVALIDM_Pos*/)              /*!< ITM IWR: ATVALIDM Mask */
N
N/* ITM Integration Read Register Definitions */
N#define ITM_IRR_ATREADYM_Pos                0U                                            /*!< ITM IRR: ATREADYM Position */
N#define ITM_IRR_ATREADYM_Msk               (1UL /*<< ITM_IRR_ATREADYM_Pos*/)              /*!< ITM IRR: ATREADYM Mask */
N
N/* ITM Integration Mode Control Register Definitions */
N#define ITM_IMCR_INTEGRATION_Pos            0U                                            /*!< ITM IMCR: INTEGRATION Position */
N#define ITM_IMCR_INTEGRATION_Msk           (1UL /*<< ITM_IMCR_INTEGRATION_Pos*/)          /*!< ITM IMCR: INTEGRATION Mask */
N
N/* ITM Lock Status Register Definitions */
N#define ITM_LSR_ByteAcc_Pos                 2U                                            /*!< ITM LSR: ByteAcc Position */
N#define ITM_LSR_ByteAcc_Msk                (1UL << ITM_LSR_ByteAcc_Pos)                   /*!< ITM LSR: ByteAcc Mask */
N
N#define ITM_LSR_Access_Pos                  1U                                            /*!< ITM LSR: Access Position */
N#define ITM_LSR_Access_Msk                 (1UL << ITM_LSR_Access_Pos)                    /*!< ITM LSR: Access Mask */
N
N#define ITM_LSR_Present_Pos                 0U                                            /*!< ITM LSR: Present Position */
N#define ITM_LSR_Present_Msk                (1UL /*<< ITM_LSR_Present_Pos*/)               /*!< ITM LSR: Present Mask */
N
N/*@}*/ /* end of group CMSIS_ITM */
N
N
N/**
N  \ingroup  CMSIS_core_register
N  \defgroup CMSIS_DWT     Data Watchpoint and Trace (DWT)
N  \brief    Type definitions for the Data Watchpoint and Trace (DWT)
N  @{
N */
N
N/**
N  \brief  Structure type to access the Data Watchpoint and Trace Register (DWT).
N */
Ntypedef struct
N{
N  __IOM uint32_t CTRL;                   /*!< Offset: 0x000 (R/W)  Control Register */
X  volatile uint32_t CTRL;                    
N  __IOM uint32_t CYCCNT;                 /*!< Offset: 0x004 (R/W)  Cycle Count Register */
X  volatile uint32_t CYCCNT;                  
N  __IOM uint32_t CPICNT;                 /*!< Offset: 0x008 (R/W)  CPI Count Register */
X  volatile uint32_t CPICNT;                  
N  __IOM uint32_t EXCCNT;                 /*!< Offset: 0x00C (R/W)  Exception Overhead Count Register */
X  volatile uint32_t EXCCNT;                  
N  __IOM uint32_t SLEEPCNT;               /*!< Offset: 0x010 (R/W)  Sleep Count Register */
X  volatile uint32_t SLEEPCNT;                
N  __IOM uint32_t LSUCNT;                 /*!< Offset: 0x014 (R/W)  LSU Count Register */
X  volatile uint32_t LSUCNT;                  
N  __IOM uint32_t FOLDCNT;                /*!< Offset: 0x018 (R/W)  Folded-instruction Count Register */
X  volatile uint32_t FOLDCNT;                 
N  __IM  uint32_t PCSR;                   /*!< Offset: 0x01C (R/ )  Program Counter Sample Register */
X  volatile const  uint32_t PCSR;                    
N  __IOM uint32_t COMP0;                  /*!< Offset: 0x020 (R/W)  Comparator Register 0 */
X  volatile uint32_t COMP0;                   
N  __IOM uint32_t MASK0;                  /*!< Offset: 0x024 (R/W)  Mask Register 0 */
X  volatile uint32_t MASK0;                   
N  __IOM uint32_t FUNCTION0;              /*!< Offset: 0x028 (R/W)  Function Register 0 */
X  volatile uint32_t FUNCTION0;               
N        uint32_t RESERVED0[1U];
N  __IOM uint32_t COMP1;                  /*!< Offset: 0x030 (R/W)  Comparator Register 1 */
X  volatile uint32_t COMP1;                   
N  __IOM uint32_t MASK1;                  /*!< Offset: 0x034 (R/W)  Mask Register 1 */
X  volatile uint32_t MASK1;                   
N  __IOM uint32_t FUNCTION1;              /*!< Offset: 0x038 (R/W)  Function Register 1 */
X  volatile uint32_t FUNCTION1;               
N        uint32_t RESERVED1[1U];
N  __IOM uint32_t COMP2;                  /*!< Offset: 0x040 (R/W)  Comparator Register 2 */
X  volatile uint32_t COMP2;                   
N  __IOM uint32_t MASK2;                  /*!< Offset: 0x044 (R/W)  Mask Register 2 */
X  volatile uint32_t MASK2;                   
N  __IOM uint32_t FUNCTION2;              /*!< Offset: 0x048 (R/W)  Function Register 2 */
X  volatile uint32_t FUNCTION2;               
N        uint32_t RESERVED2[1U];
N  __IOM uint32_t COMP3;                  /*!< Offset: 0x050 (R/W)  Comparator Register 3 */
X  volatile uint32_t COMP3;                   
N  __IOM uint32_t MASK3;                  /*!< Offset: 0x054 (R/W)  Mask Register 3 */
X  volatile uint32_t MASK3;                   
N  __IOM uint32_t FUNCTION3;              /*!< Offset: 0x058 (R/W)  Function Register 3 */
X  volatile uint32_t FUNCTION3;               
N} DWT_Type;
N
N/* DWT Control Register Definitions */
N#define DWT_CTRL_NUMCOMP_Pos               28U                                         /*!< DWT CTRL: NUMCOMP Position */
N#define DWT_CTRL_NUMCOMP_Msk               (0xFUL << DWT_CTRL_NUMCOMP_Pos)             /*!< DWT CTRL: NUMCOMP Mask */
N
N#define DWT_CTRL_NOTRCPKT_Pos              27U                                         /*!< DWT CTRL: NOTRCPKT Position */
N#define DWT_CTRL_NOTRCPKT_Msk              (0x1UL << DWT_CTRL_NOTRCPKT_Pos)            /*!< DWT CTRL: NOTRCPKT Mask */
N
N#define DWT_CTRL_NOEXTTRIG_Pos             26U                                         /*!< DWT CTRL: NOEXTTRIG Position */
N#define DWT_CTRL_NOEXTTRIG_Msk             (0x1UL << DWT_CTRL_NOEXTTRIG_Pos)           /*!< DWT CTRL: NOEXTTRIG Mask */
N
N#define DWT_CTRL_NOCYCCNT_Pos              25U                                         /*!< DWT CTRL: NOCYCCNT Position */
N#define DWT_CTRL_NOCYCCNT_Msk              (0x1UL << DWT_CTRL_NOCYCCNT_Pos)            /*!< DWT CTRL: NOCYCCNT Mask */
N
N#define DWT_CTRL_NOPRFCNT_Pos              24U                                         /*!< DWT CTRL: NOPRFCNT Position */
N#define DWT_CTRL_NOPRFCNT_Msk              (0x1UL << DWT_CTRL_NOPRFCNT_Pos)            /*!< DWT CTRL: NOPRFCNT Mask */
N
N#define DWT_CTRL_CYCEVTENA_Pos             22U                                         /*!< DWT CTRL: CYCEVTENA Position */
N#define DWT_CTRL_CYCEVTENA_Msk             (0x1UL << DWT_CTRL_CYCEVTENA_Pos)           /*!< DWT CTRL: CYCEVTENA Mask */
N
N#define DWT_CTRL_FOLDEVTENA_Pos            21U                                         /*!< DWT CTRL: FOLDEVTENA Position */
N#define DWT_CTRL_FOLDEVTENA_Msk            (0x1UL << DWT_CTRL_FOLDEVTENA_Pos)          /*!< DWT CTRL: FOLDEVTENA Mask */
N
N#define DWT_CTRL_LSUEVTENA_Pos             20U                                         /*!< DWT CTRL: LSUEVTENA Position */
N#define DWT_CTRL_LSUEVTENA_Msk             (0x1UL << DWT_CTRL_LSUEVTENA_Pos)           /*!< DWT CTRL: LSUEVTENA Mask */
N
N#define DWT_CTRL_SLEEPEVTENA_Pos           19U                                         /*!< DWT CTRL: SLEEPEVTENA Position */
N#define DWT_CTRL_SLEEPEVTENA_Msk           (0x1UL << DWT_CTRL_SLEEPEVTENA_Pos)         /*!< DWT CTRL: SLEEPEVTENA Mask */
N
N#define DWT_CTRL_EXCEVTENA_Pos             18U                                         /*!< DWT CTRL: EXCEVTENA Position */
N#define DWT_CTRL_EXCEVTENA_Msk             (0x1UL << DWT_CTRL_EXCEVTENA_Pos)           /*!< DWT CTRL: EXCEVTENA Mask */
N
N#define DWT_CTRL_CPIEVTENA_Pos             17U                                         /*!< DWT CTRL: CPIEVTENA Position */
N#define DWT_CTRL_CPIEVTENA_Msk             (0x1UL << DWT_CTRL_CPIEVTENA_Pos)           /*!< DWT CTRL: CPIEVTENA Mask */
N
N#define DWT_CTRL_EXCTRCENA_Pos             16U                                         /*!< DWT CTRL: EXCTRCENA Position */
N#define DWT_CTRL_EXCTRCENA_Msk             (0x1UL << DWT_CTRL_EXCTRCENA_Pos)           /*!< DWT CTRL: EXCTRCENA Mask */
N
N#define DWT_CTRL_PCSAMPLENA_Pos            12U                                         /*!< DWT CTRL: PCSAMPLENA Position */
N#define DWT_CTRL_PCSAMPLENA_Msk            (0x1UL << DWT_CTRL_PCSAMPLENA_Pos)          /*!< DWT CTRL: PCSAMPLENA Mask */
N
N#define DWT_CTRL_SYNCTAP_Pos               10U                                         /*!< DWT CTRL: SYNCTAP Position */
N#define DWT_CTRL_SYNCTAP_Msk               (0x3UL << DWT_CTRL_SYNCTAP_Pos)             /*!< DWT CTRL: SYNCTAP Mask */
N
N#define DWT_CTRL_CYCTAP_Pos                 9U                                         /*!< DWT CTRL: CYCTAP Position */
N#define DWT_CTRL_CYCTAP_Msk                (0x1UL << DWT_CTRL_CYCTAP_Pos)              /*!< DWT CTRL: CYCTAP Mask */
N
N#define DWT_CTRL_POSTINIT_Pos               5U                                         /*!< DWT CTRL: POSTINIT Position */
N#define DWT_CTRL_POSTINIT_Msk              (0xFUL << DWT_CTRL_POSTINIT_Pos)            /*!< DWT CTRL: POSTINIT Mask */
N
N#define DWT_CTRL_POSTPRESET_Pos             1U                                         /*!< DWT CTRL: POSTPRESET Position */
N#define DWT_CTRL_POSTPRESET_Msk            (0xFUL << DWT_CTRL_POSTPRESET_Pos)          /*!< DWT CTRL: POSTPRESET Mask */
N
N#define DWT_CTRL_CYCCNTENA_Pos              0U                                         /*!< DWT CTRL: CYCCNTENA Position */
N#define DWT_CTRL_CYCCNTENA_Msk             (0x1UL /*<< DWT_CTRL_CYCCNTENA_Pos*/)       /*!< DWT CTRL: CYCCNTENA Mask */
N
N/* DWT CPI Count Register Definitions */
N#define DWT_CPICNT_CPICNT_Pos               0U                                         /*!< DWT CPICNT: CPICNT Position */
N#define DWT_CPICNT_CPICNT_Msk              (0xFFUL /*<< DWT_CPICNT_CPICNT_Pos*/)       /*!< DWT CPICNT: CPICNT Mask */
N
N/* DWT Exception Overhead Count Register Definitions */
N#define DWT_EXCCNT_EXCCNT_Pos               0U                                         /*!< DWT EXCCNT: EXCCNT Position */
N#define DWT_EXCCNT_EXCCNT_Msk              (0xFFUL /*<< DWT_EXCCNT_EXCCNT_Pos*/)       /*!< DWT EXCCNT: EXCCNT Mask */
N
N/* DWT Sleep Count Register Definitions */
N#define DWT_SLEEPCNT_SLEEPCNT_Pos           0U                                         /*!< DWT SLEEPCNT: SLEEPCNT Position */
N#define DWT_SLEEPCNT_SLEEPCNT_Msk          (0xFFUL /*<< DWT_SLEEPCNT_SLEEPCNT_Pos*/)   /*!< DWT SLEEPCNT: SLEEPCNT Mask */
N
N/* DWT LSU Count Register Definitions */
N#define DWT_LSUCNT_LSUCNT_Pos               0U                                         /*!< DWT LSUCNT: LSUCNT Position */
N#define DWT_LSUCNT_LSUCNT_Msk              (0xFFUL /*<< DWT_LSUCNT_LSUCNT_Pos*/)       /*!< DWT LSUCNT: LSUCNT Mask */
N
N/* DWT Folded-instruction Count Register Definitions */
N#define DWT_FOLDCNT_FOLDCNT_Pos             0U                                         /*!< DWT FOLDCNT: FOLDCNT Position */
N#define DWT_FOLDCNT_FOLDCNT_Msk            (0xFFUL /*<< DWT_FOLDCNT_FOLDCNT_Pos*/)     /*!< DWT FOLDCNT: FOLDCNT Mask */
N
N/* DWT Comparator Mask Register Definitions */
N#define DWT_MASK_MASK_Pos                   0U                                         /*!< DWT MASK: MASK Position */
N#define DWT_MASK_MASK_Msk                  (0x1FUL /*<< DWT_MASK_MASK_Pos*/)           /*!< DWT MASK: MASK Mask */
N
N/* DWT Comparator Function Register Definitions */
N#define DWT_FUNCTION_MATCHED_Pos           24U                                         /*!< DWT FUNCTION: MATCHED Position */
N#define DWT_FUNCTION_MATCHED_Msk           (0x1UL << DWT_FUNCTION_MATCHED_Pos)         /*!< DWT FUNCTION: MATCHED Mask */
N
N#define DWT_FUNCTION_DATAVADDR1_Pos        16U                                         /*!< DWT FUNCTION: DATAVADDR1 Position */
N#define DWT_FUNCTION_DATAVADDR1_Msk        (0xFUL << DWT_FUNCTION_DATAVADDR1_Pos)      /*!< DWT FUNCTION: DATAVADDR1 Mask */
N
N#define DWT_FUNCTION_DATAVADDR0_Pos        12U                                         /*!< DWT FUNCTION: DATAVADDR0 Position */
N#define DWT_FUNCTION_DATAVADDR0_Msk        (0xFUL << DWT_FUNCTION_DATAVADDR0_Pos)      /*!< DWT FUNCTION: DATAVADDR0 Mask */
N
N#define DWT_FUNCTION_DATAVSIZE_Pos         10U                                         /*!< DWT FUNCTION: DATAVSIZE Position */
N#define DWT_FUNCTION_DATAVSIZE_Msk         (0x3UL << DWT_FUNCTION_DATAVSIZE_Pos)       /*!< DWT FUNCTION: DATAVSIZE Mask */
N
N#define DWT_FUNCTION_LNK1ENA_Pos            9U                                         /*!< DWT FUNCTION: LNK1ENA Position */
N#define DWT_FUNCTION_LNK1ENA_Msk           (0x1UL << DWT_FUNCTION_LNK1ENA_Pos)         /*!< DWT FUNCTION: LNK1ENA Mask */
N
N#define DWT_FUNCTION_DATAVMATCH_Pos         8U                                         /*!< DWT FUNCTION: DATAVMATCH Position */
N#define DWT_FUNCTION_DATAVMATCH_Msk        (0x1UL << DWT_FUNCTION_DATAVMATCH_Pos)      /*!< DWT FUNCTION: DATAVMATCH Mask */
N
N#define DWT_FUNCTION_CYCMATCH_Pos           7U                                         /*!< DWT FUNCTION: CYCMATCH Position */
N#define DWT_FUNCTION_CYCMATCH_Msk          (0x1UL << DWT_FUNCTION_CYCMATCH_Pos)        /*!< DWT FUNCTION: CYCMATCH Mask */
N
N#define DWT_FUNCTION_EMITRANGE_Pos          5U                                         /*!< DWT FUNCTION: EMITRANGE Position */
N#define DWT_FUNCTION_EMITRANGE_Msk         (0x1UL << DWT_FUNCTION_EMITRANGE_Pos)       /*!< DWT FUNCTION: EMITRANGE Mask */
N
N#define DWT_FUNCTION_FUNCTION_Pos           0U                                         /*!< DWT FUNCTION: FUNCTION Position */
N#define DWT_FUNCTION_FUNCTION_Msk          (0xFUL /*<< DWT_FUNCTION_FUNCTION_Pos*/)    /*!< DWT FUNCTION: FUNCTION Mask */
N
N/*@}*/ /* end of group CMSIS_DWT */
N
N
N/**
N  \ingroup  CMSIS_core_register
N  \defgroup CMSIS_TPI     Trace Port Interface (TPI)
N  \brief    Type definitions for the Trace Port Interface (TPI)
N  @{
N */
N
N/**
N  \brief  Structure type to access the Trace Port Interface Register (TPI).
N */
Ntypedef struct
N{
N  __IOM uint32_t SSPSR;                  /*!< Offset: 0x000 (R/ )  Supported Parallel Port Size Register */
X  volatile uint32_t SSPSR;                   
N  __IOM uint32_t CSPSR;                  /*!< Offset: 0x004 (R/W)  Current Parallel Port Size Register */
X  volatile uint32_t CSPSR;                   
N        uint32_t RESERVED0[2U];
N  __IOM uint32_t ACPR;                   /*!< Offset: 0x010 (R/W)  Asynchronous Clock Prescaler Register */
X  volatile uint32_t ACPR;                    
N        uint32_t RESERVED1[55U];
N  __IOM uint32_t SPPR;                   /*!< Offset: 0x0F0 (R/W)  Selected Pin Protocol Register */
X  volatile uint32_t SPPR;                    
N        uint32_t RESERVED2[131U];
N  __IM  uint32_t FFSR;                   /*!< Offset: 0x300 (R/ )  Formatter and Flush Status Register */
X  volatile const  uint32_t FFSR;                    
N  __IOM uint32_t FFCR;                   /*!< Offset: 0x304 (R/W)  Formatter and Flush Control Register */
X  volatile uint32_t FFCR;                    
N  __IM  uint32_t FSCR;                   /*!< Offset: 0x308 (R/ )  Formatter Synchronization Counter Register */
X  volatile const  uint32_t FSCR;                    
N        uint32_t RESERVED3[759U];
N  __IM  uint32_t TRIGGER;                /*!< Offset: 0xEE8 (R/ )  TRIGGER */
X  volatile const  uint32_t TRIGGER;                 
N  __IM  uint32_t FIFO0;                  /*!< Offset: 0xEEC (R/ )  Integration ETM Data */
X  volatile const  uint32_t FIFO0;                   
N  __IM  uint32_t ITATBCTR2;              /*!< Offset: 0xEF0 (R/ )  ITATBCTR2 */
X  volatile const  uint32_t ITATBCTR2;               
N        uint32_t RESERVED4[1U];
N  __IM  uint32_t ITATBCTR0;              /*!< Offset: 0xEF8 (R/ )  ITATBCTR0 */
X  volatile const  uint32_t ITATBCTR0;               
N  __IM  uint32_t FIFO1;                  /*!< Offset: 0xEFC (R/ )  Integration ITM Data */
X  volatile const  uint32_t FIFO1;                   
N  __IOM uint32_t ITCTRL;                 /*!< Offset: 0xF00 (R/W)  Integration Mode Control */
X  volatile uint32_t ITCTRL;                  
N        uint32_t RESERVED5[39U];
N  __IOM uint32_t CLAIMSET;               /*!< Offset: 0xFA0 (R/W)  Claim tag set */
X  volatile uint32_t CLAIMSET;                
N  __IOM uint32_t CLAIMCLR;               /*!< Offset: 0xFA4 (R/W)  Claim tag clear */
X  volatile uint32_t CLAIMCLR;                
N        uint32_t RESERVED7[8U];
N  __IM  uint32_t DEVID;                  /*!< Offset: 0xFC8 (R/ )  TPIU_DEVID */
X  volatile const  uint32_t DEVID;                   
N  __IM  uint32_t DEVTYPE;                /*!< Offset: 0xFCC (R/ )  TPIU_DEVTYPE */
X  volatile const  uint32_t DEVTYPE;                 
N} TPI_Type;
N
N/* TPI Asynchronous Clock Prescaler Register Definitions */
N#define TPI_ACPR_PRESCALER_Pos              0U                                         /*!< TPI ACPR: PRESCALER Position */
N#define TPI_ACPR_PRESCALER_Msk             (0x1FFFUL /*<< TPI_ACPR_PRESCALER_Pos*/)    /*!< TPI ACPR: PRESCALER Mask */
N
N/* TPI Selected Pin Protocol Register Definitions */
N#define TPI_SPPR_TXMODE_Pos                 0U                                         /*!< TPI SPPR: TXMODE Position */
N#define TPI_SPPR_TXMODE_Msk                (0x3UL /*<< TPI_SPPR_TXMODE_Pos*/)          /*!< TPI SPPR: TXMODE Mask */
N
N/* TPI Formatter and Flush Status Register Definitions */
N#define TPI_FFSR_FtNonStop_Pos              3U                                         /*!< TPI FFSR: FtNonStop Position */
N#define TPI_FFSR_FtNonStop_Msk             (0x1UL << TPI_FFSR_FtNonStop_Pos)           /*!< TPI FFSR: FtNonStop Mask */
N
N#define TPI_FFSR_TCPresent_Pos              2U                                         /*!< TPI FFSR: TCPresent Position */
N#define TPI_FFSR_TCPresent_Msk             (0x1UL << TPI_FFSR_TCPresent_Pos)           /*!< TPI FFSR: TCPresent Mask */
N
N#define TPI_FFSR_FtStopped_Pos              1U                                         /*!< TPI FFSR: FtStopped Position */
N#define TPI_FFSR_FtStopped_Msk             (0x1UL << TPI_FFSR_FtStopped_Pos)           /*!< TPI FFSR: FtStopped Mask */
N
N#define TPI_FFSR_FlInProg_Pos               0U                                         /*!< TPI FFSR: FlInProg Position */
N#define TPI_FFSR_FlInProg_Msk              (0x1UL /*<< TPI_FFSR_FlInProg_Pos*/)        /*!< TPI FFSR: FlInProg Mask */
N
N/* TPI Formatter and Flush Control Register Definitions */
N#define TPI_FFCR_TrigIn_Pos                 8U                                         /*!< TPI FFCR: TrigIn Position */
N#define TPI_FFCR_TrigIn_Msk                (0x1UL << TPI_FFCR_TrigIn_Pos)              /*!< TPI FFCR: TrigIn Mask */
N
N#define TPI_FFCR_EnFCont_Pos                1U                                         /*!< TPI FFCR: EnFCont Position */
N#define TPI_FFCR_EnFCont_Msk               (0x1UL << TPI_FFCR_EnFCont_Pos)             /*!< TPI FFCR: EnFCont Mask */
N
N/* TPI TRIGGER Register Definitions */
N#define TPI_TRIGGER_TRIGGER_Pos             0U                                         /*!< TPI TRIGGER: TRIGGER Position */
N#define TPI_TRIGGER_TRIGGER_Msk            (0x1UL /*<< TPI_TRIGGER_TRIGGER_Pos*/)      /*!< TPI TRIGGER: TRIGGER Mask */
N
N/* TPI Integration ETM Data Register Definitions (FIFO0) */
N#define TPI_FIFO0_ITM_ATVALID_Pos          29U                                         /*!< TPI FIFO0: ITM_ATVALID Position */
N#define TPI_FIFO0_ITM_ATVALID_Msk          (0x3UL << TPI_FIFO0_ITM_ATVALID_Pos)        /*!< TPI FIFO0: ITM_ATVALID Mask */
N
N#define TPI_FIFO0_ITM_bytecount_Pos        27U                                         /*!< TPI FIFO0: ITM_bytecount Position */
N#define TPI_FIFO0_ITM_bytecount_Msk        (0x3UL << TPI_FIFO0_ITM_bytecount_Pos)      /*!< TPI FIFO0: ITM_bytecount Mask */
N
N#define TPI_FIFO0_ETM_ATVALID_Pos          26U                                         /*!< TPI FIFO0: ETM_ATVALID Position */
N#define TPI_FIFO0_ETM_ATVALID_Msk          (0x3UL << TPI_FIFO0_ETM_ATVALID_Pos)        /*!< TPI FIFO0: ETM_ATVALID Mask */
N
N#define TPI_FIFO0_ETM_bytecount_Pos        24U                                         /*!< TPI FIFO0: ETM_bytecount Position */
N#define TPI_FIFO0_ETM_bytecount_Msk        (0x3UL << TPI_FIFO0_ETM_bytecount_Pos)      /*!< TPI FIFO0: ETM_bytecount Mask */
N
N#define TPI_FIFO0_ETM2_Pos                 16U                                         /*!< TPI FIFO0: ETM2 Position */
N#define TPI_FIFO0_ETM2_Msk                 (0xFFUL << TPI_FIFO0_ETM2_Pos)              /*!< TPI FIFO0: ETM2 Mask */
N
N#define TPI_FIFO0_ETM1_Pos                  8U                                         /*!< TPI FIFO0: ETM1 Position */
N#define TPI_FIFO0_ETM1_Msk                 (0xFFUL << TPI_FIFO0_ETM1_Pos)              /*!< TPI FIFO0: ETM1 Mask */
N
N#define TPI_FIFO0_ETM0_Pos                  0U                                         /*!< TPI FIFO0: ETM0 Position */
N#define TPI_FIFO0_ETM0_Msk                 (0xFFUL /*<< TPI_FIFO0_ETM0_Pos*/)          /*!< TPI FIFO0: ETM0 Mask */
N
N/* TPI ITATBCTR2 Register Definitions */
N#define TPI_ITATBCTR2_ATREADY_Pos           0U                                         /*!< TPI ITATBCTR2: ATREADY Position */
N#define TPI_ITATBCTR2_ATREADY_Msk          (0x1UL /*<< TPI_ITATBCTR2_ATREADY_Pos*/)    /*!< TPI ITATBCTR2: ATREADY Mask */
N
N/* TPI Integration ITM Data Register Definitions (FIFO1) */
N#define TPI_FIFO1_ITM_ATVALID_Pos          29U                                         /*!< TPI FIFO1: ITM_ATVALID Position */
N#define TPI_FIFO1_ITM_ATVALID_Msk          (0x3UL << TPI_FIFO1_ITM_ATVALID_Pos)        /*!< TPI FIFO1: ITM_ATVALID Mask */
N
N#define TPI_FIFO1_ITM_bytecount_Pos        27U                                         /*!< TPI FIFO1: ITM_bytecount Position */
N#define TPI_FIFO1_ITM_bytecount_Msk        (0x3UL << TPI_FIFO1_ITM_bytecount_Pos)      /*!< TPI FIFO1: ITM_bytecount Mask */
N
N#define TPI_FIFO1_ETM_ATVALID_Pos          26U                                         /*!< TPI FIFO1: ETM_ATVALID Position */
N#define TPI_FIFO1_ETM_ATVALID_Msk          (0x3UL << TPI_FIFO1_ETM_ATVALID_Pos)        /*!< TPI FIFO1: ETM_ATVALID Mask */
N
N#define TPI_FIFO1_ETM_bytecount_Pos        24U                                         /*!< TPI FIFO1: ETM_bytecount Position */
N#define TPI_FIFO1_ETM_bytecount_Msk        (0x3UL << TPI_FIFO1_ETM_bytecount_Pos)      /*!< TPI FIFO1: ETM_bytecount Mask */
N
N#define TPI_FIFO1_ITM2_Pos                 16U                                         /*!< TPI FIFO1: ITM2 Position */
N#define TPI_FIFO1_ITM2_Msk                 (0xFFUL << TPI_FIFO1_ITM2_Pos)              /*!< TPI FIFO1: ITM2 Mask */
N
N#define TPI_FIFO1_ITM1_Pos                  8U                                         /*!< TPI FIFO1: ITM1 Position */
N#define TPI_FIFO1_ITM1_Msk                 (0xFFUL << TPI_FIFO1_ITM1_Pos)              /*!< TPI FIFO1: ITM1 Mask */
N
N#define TPI_FIFO1_ITM0_Pos                  0U                                         /*!< TPI FIFO1: ITM0 Position */
N#define TPI_FIFO1_ITM0_Msk                 (0xFFUL /*<< TPI_FIFO1_ITM0_Pos*/)          /*!< TPI FIFO1: ITM0 Mask */
N
N/* TPI ITATBCTR0 Register Definitions */
N#define TPI_ITATBCTR0_ATREADY_Pos           0U                                         /*!< TPI ITATBCTR0: ATREADY Position */
N#define TPI_ITATBCTR0_ATREADY_Msk          (0x1UL /*<< TPI_ITATBCTR0_ATREADY_Pos*/)    /*!< TPI ITATBCTR0: ATREADY Mask */
N
N/* TPI Integration Mode Control Register Definitions */
N#define TPI_ITCTRL_Mode_Pos                 0U                                         /*!< TPI ITCTRL: Mode Position */
N#define TPI_ITCTRL_Mode_Msk                (0x1UL /*<< TPI_ITCTRL_Mode_Pos*/)          /*!< TPI ITCTRL: Mode Mask */
N
N/* TPI DEVID Register Definitions */
N#define TPI_DEVID_NRZVALID_Pos             11U                                         /*!< TPI DEVID: NRZVALID Position */
N#define TPI_DEVID_NRZVALID_Msk             (0x1UL << TPI_DEVID_NRZVALID_Pos)           /*!< TPI DEVID: NRZVALID Mask */
N
N#define TPI_DEVID_MANCVALID_Pos            10U                                         /*!< TPI DEVID: MANCVALID Position */
N#define TPI_DEVID_MANCVALID_Msk            (0x1UL << TPI_DEVID_MANCVALID_Pos)          /*!< TPI DEVID: MANCVALID Mask */
N
N#define TPI_DEVID_PTINVALID_Pos             9U                                         /*!< TPI DEVID: PTINVALID Position */
N#define TPI_DEVID_PTINVALID_Msk            (0x1UL << TPI_DEVID_PTINVALID_Pos)          /*!< TPI DEVID: PTINVALID Mask */
N
N#define TPI_DEVID_MinBufSz_Pos              6U                                         /*!< TPI DEVID: MinBufSz Position */
N#define TPI_DEVID_MinBufSz_Msk             (0x7UL << TPI_DEVID_MinBufSz_Pos)           /*!< TPI DEVID: MinBufSz Mask */
N
N#define TPI_DEVID_AsynClkIn_Pos             5U                                         /*!< TPI DEVID: AsynClkIn Position */
N#define TPI_DEVID_AsynClkIn_Msk            (0x1UL << TPI_DEVID_AsynClkIn_Pos)          /*!< TPI DEVID: AsynClkIn Mask */
N
N#define TPI_DEVID_NrTraceInput_Pos          0U                                         /*!< TPI DEVID: NrTraceInput Position */
N#define TPI_DEVID_NrTraceInput_Msk         (0x1FUL /*<< TPI_DEVID_NrTraceInput_Pos*/)  /*!< TPI DEVID: NrTraceInput Mask */
N
N/* TPI DEVTYPE Register Definitions */
N#define TPI_DEVTYPE_MajorType_Pos           4U                                         /*!< TPI DEVTYPE: MajorType Position */
N#define TPI_DEVTYPE_MajorType_Msk          (0xFUL << TPI_DEVTYPE_MajorType_Pos)        /*!< TPI DEVTYPE: MajorType Mask */
N
N#define TPI_DEVTYPE_SubType_Pos             0U                                         /*!< TPI DEVTYPE: SubType Position */
N#define TPI_DEVTYPE_SubType_Msk            (0xFUL /*<< TPI_DEVTYPE_SubType_Pos*/)      /*!< TPI DEVTYPE: SubType Mask */
N
N/*@}*/ /* end of group CMSIS_TPI */
N
N
N#if defined (__MPU_PRESENT) && (__MPU_PRESENT == 1U)
X#if 1L && (1 == 1U)
N/**
N  \ingroup  CMSIS_core_register
N  \defgroup CMSIS_MPU     Memory Protection Unit (MPU)
N  \brief    Type definitions for the Memory Protection Unit (MPU)
N  @{
N */
N
N/**
N  \brief  Structure type to access the Memory Protection Unit (MPU).
N */
Ntypedef struct
N{
N  __IM  uint32_t TYPE;                   /*!< Offset: 0x000 (R/ )  MPU Type Register */
X  volatile const  uint32_t TYPE;                    
N  __IOM uint32_t CTRL;                   /*!< Offset: 0x004 (R/W)  MPU Control Register */
X  volatile uint32_t CTRL;                    
N  __IOM uint32_t RNR;                    /*!< Offset: 0x008 (R/W)  MPU Region RNRber Register */
X  volatile uint32_t RNR;                     
N  __IOM uint32_t RBAR;                   /*!< Offset: 0x00C (R/W)  MPU Region Base Address Register */
X  volatile uint32_t RBAR;                    
N  __IOM uint32_t RASR;                   /*!< Offset: 0x010 (R/W)  MPU Region Attribute and Size Register */
X  volatile uint32_t RASR;                    
N  __IOM uint32_t RBAR_A1;                /*!< Offset: 0x014 (R/W)  MPU Alias 1 Region Base Address Register */
X  volatile uint32_t RBAR_A1;                 
N  __IOM uint32_t RASR_A1;                /*!< Offset: 0x018 (R/W)  MPU Alias 1 Region Attribute and Size Register */
X  volatile uint32_t RASR_A1;                 
N  __IOM uint32_t RBAR_A2;                /*!< Offset: 0x01C (R/W)  MPU Alias 2 Region Base Address Register */
X  volatile uint32_t RBAR_A2;                 
N  __IOM uint32_t RASR_A2;                /*!< Offset: 0x020 (R/W)  MPU Alias 2 Region Attribute and Size Register */
X  volatile uint32_t RASR_A2;                 
N  __IOM uint32_t RBAR_A3;                /*!< Offset: 0x024 (R/W)  MPU Alias 3 Region Base Address Register */
X  volatile uint32_t RBAR_A3;                 
N  __IOM uint32_t RASR_A3;                /*!< Offset: 0x028 (R/W)  MPU Alias 3 Region Attribute and Size Register */
X  volatile uint32_t RASR_A3;                 
N} MPU_Type;
N
N/* MPU Type Register Definitions */
N#define MPU_TYPE_IREGION_Pos               16U                                            /*!< MPU TYPE: IREGION Position */
N#define MPU_TYPE_IREGION_Msk               (0xFFUL << MPU_TYPE_IREGION_Pos)               /*!< MPU TYPE: IREGION Mask */
N
N#define MPU_TYPE_DREGION_Pos                8U                                            /*!< MPU TYPE: DREGION Position */
N#define MPU_TYPE_DREGION_Msk               (0xFFUL << MPU_TYPE_DREGION_Pos)               /*!< MPU TYPE: DREGION Mask */
N
N#define MPU_TYPE_SEPARATE_Pos               0U                                            /*!< MPU TYPE: SEPARATE Position */
N#define MPU_TYPE_SEPARATE_Msk              (1UL /*<< MPU_TYPE_SEPARATE_Pos*/)             /*!< MPU TYPE: SEPARATE Mask */
N
N/* MPU Control Register Definitions */
N#define MPU_CTRL_PRIVDEFENA_Pos             2U                                            /*!< MPU CTRL: PRIVDEFENA Position */
N#define MPU_CTRL_PRIVDEFENA_Msk            (1UL << MPU_CTRL_PRIVDEFENA_Pos)               /*!< MPU CTRL: PRIVDEFENA Mask */
N
N#define MPU_CTRL_HFNMIENA_Pos               1U                                            /*!< MPU CTRL: HFNMIENA Position */
N#define MPU_CTRL_HFNMIENA_Msk              (1UL << MPU_CTRL_HFNMIENA_Pos)                 /*!< MPU CTRL: HFNMIENA Mask */
N
N#define MPU_CTRL_ENABLE_Pos                 0U                                            /*!< MPU CTRL: ENABLE Position */
N#define MPU_CTRL_ENABLE_Msk                (1UL /*<< MPU_CTRL_ENABLE_Pos*/)               /*!< MPU CTRL: ENABLE Mask */
N
N/* MPU Region Number Register Definitions */
N#define MPU_RNR_REGION_Pos                  0U                                            /*!< MPU RNR: REGION Position */
N#define MPU_RNR_REGION_Msk                 (0xFFUL /*<< MPU_RNR_REGION_Pos*/)             /*!< MPU RNR: REGION Mask */
N
N/* MPU Region Base Address Register Definitions */
N#define MPU_RBAR_ADDR_Pos                   5U                                            /*!< MPU RBAR: ADDR Position */
N#define MPU_RBAR_ADDR_Msk                  (0x7FFFFFFUL << MPU_RBAR_ADDR_Pos)             /*!< MPU RBAR: ADDR Mask */
N
N#define MPU_RBAR_VALID_Pos                  4U                                            /*!< MPU RBAR: VALID Position */
N#define MPU_RBAR_VALID_Msk                 (1UL << MPU_RBAR_VALID_Pos)                    /*!< MPU RBAR: VALID Mask */
N
N#define MPU_RBAR_REGION_Pos                 0U                                            /*!< MPU RBAR: REGION Position */
N#define MPU_RBAR_REGION_Msk                (0xFUL /*<< MPU_RBAR_REGION_Pos*/)             /*!< MPU RBAR: REGION Mask */
N
N/* MPU Region Attribute and Size Register Definitions */
N#define MPU_RASR_ATTRS_Pos                 16U                                            /*!< MPU RASR: MPU Region Attribute field Position */
N#define MPU_RASR_ATTRS_Msk                 (0xFFFFUL << MPU_RASR_ATTRS_Pos)               /*!< MPU RASR: MPU Region Attribute field Mask */
N
N#define MPU_RASR_XN_Pos                    28U                                            /*!< MPU RASR: ATTRS.XN Position */
N#define MPU_RASR_XN_Msk                    (1UL << MPU_RASR_XN_Pos)                       /*!< MPU RASR: ATTRS.XN Mask */
N
N#define MPU_RASR_AP_Pos                    24U                                            /*!< MPU RASR: ATTRS.AP Position */
N#define MPU_RASR_AP_Msk                    (0x7UL << MPU_RASR_AP_Pos)                     /*!< MPU RASR: ATTRS.AP Mask */
N
N#define MPU_RASR_TEX_Pos                   19U                                            /*!< MPU RASR: ATTRS.TEX Position */
N#define MPU_RASR_TEX_Msk                   (0x7UL << MPU_RASR_TEX_Pos)                    /*!< MPU RASR: ATTRS.TEX Mask */
N
N#define MPU_RASR_S_Pos                     18U                                            /*!< MPU RASR: ATTRS.S Position */
N#define MPU_RASR_S_Msk                     (1UL << MPU_RASR_S_Pos)                        /*!< MPU RASR: ATTRS.S Mask */
N
N#define MPU_RASR_C_Pos                     17U                                            /*!< MPU RASR: ATTRS.C Position */
N#define MPU_RASR_C_Msk                     (1UL << MPU_RASR_C_Pos)                        /*!< MPU RASR: ATTRS.C Mask */
N
N#define MPU_RASR_B_Pos                     16U                                            /*!< MPU RASR: ATTRS.B Position */
N#define MPU_RASR_B_Msk                     (1UL << MPU_RASR_B_Pos)                        /*!< MPU RASR: ATTRS.B Mask */
N
N#define MPU_RASR_SRD_Pos                    8U                                            /*!< MPU RASR: Sub-Region Disable Position */
N#define MPU_RASR_SRD_Msk                   (0xFFUL << MPU_RASR_SRD_Pos)                   /*!< MPU RASR: Sub-Region Disable Mask */
N
N#define MPU_RASR_SIZE_Pos                   1U                                            /*!< MPU RASR: Region Size Field Position */
N#define MPU_RASR_SIZE_Msk                  (0x1FUL << MPU_RASR_SIZE_Pos)                  /*!< MPU RASR: Region Size Field Mask */
N
N#define MPU_RASR_ENABLE_Pos                 0U                                            /*!< MPU RASR: Region enable bit Position */
N#define MPU_RASR_ENABLE_Msk                (1UL /*<< MPU_RASR_ENABLE_Pos*/)               /*!< MPU RASR: Region enable bit Disable Mask */
N
N/*@} end of group CMSIS_MPU */
N#endif
N
N
N/**
N  \ingroup  CMSIS_core_register
N  \defgroup CMSIS_CoreDebug       Core Debug Registers (CoreDebug)
N  \brief    Type definitions for the Core Debug Registers
N  @{
N */
N
N/**
N  \brief  Structure type to access the Core Debug Register (CoreDebug).
N */
Ntypedef struct
N{
N  __IOM uint32_t DHCSR;                  /*!< Offset: 0x000 (R/W)  Debug Halting Control and Status Register */
X  volatile uint32_t DHCSR;                   
N  __OM  uint32_t DCRSR;                  /*!< Offset: 0x004 ( /W)  Debug Core Register Selector Register */
X  volatile  uint32_t DCRSR;                   
N  __IOM uint32_t DCRDR;                  /*!< Offset: 0x008 (R/W)  Debug Core Register Data Register */
X  volatile uint32_t DCRDR;                   
N  __IOM uint32_t DEMCR;                  /*!< Offset: 0x00C (R/W)  Debug Exception and Monitor Control Register */
X  volatile uint32_t DEMCR;                   
N} CoreDebug_Type;
N
N/* Debug Halting Control and Status Register Definitions */
N#define CoreDebug_DHCSR_DBGKEY_Pos         16U                                            /*!< CoreDebug DHCSR: DBGKEY Position */
N#define CoreDebug_DHCSR_DBGKEY_Msk         (0xFFFFUL << CoreDebug_DHCSR_DBGKEY_Pos)       /*!< CoreDebug DHCSR: DBGKEY Mask */
N
N#define CoreDebug_DHCSR_S_RESET_ST_Pos     25U                                            /*!< CoreDebug DHCSR: S_RESET_ST Position */
N#define CoreDebug_DHCSR_S_RESET_ST_Msk     (1UL << CoreDebug_DHCSR_S_RESET_ST_Pos)        /*!< CoreDebug DHCSR: S_RESET_ST Mask */
N
N#define CoreDebug_DHCSR_S_RETIRE_ST_Pos    24U                                            /*!< CoreDebug DHCSR: S_RETIRE_ST Position */
N#define CoreDebug_DHCSR_S_RETIRE_ST_Msk    (1UL << CoreDebug_DHCSR_S_RETIRE_ST_Pos)       /*!< CoreDebug DHCSR: S_RETIRE_ST Mask */
N
N#define CoreDebug_DHCSR_S_LOCKUP_Pos       19U                                            /*!< CoreDebug DHCSR: S_LOCKUP Position */
N#define CoreDebug_DHCSR_S_LOCKUP_Msk       (1UL << CoreDebug_DHCSR_S_LOCKUP_Pos)          /*!< CoreDebug DHCSR: S_LOCKUP Mask */
N
N#define CoreDebug_DHCSR_S_SLEEP_Pos        18U                                            /*!< CoreDebug DHCSR: S_SLEEP Position */
N#define CoreDebug_DHCSR_S_SLEEP_Msk        (1UL << CoreDebug_DHCSR_S_SLEEP_Pos)           /*!< CoreDebug DHCSR: S_SLEEP Mask */
N
N#define CoreDebug_DHCSR_S_HALT_Pos         17U                                            /*!< CoreDebug DHCSR: S_HALT Position */
N#define CoreDebug_DHCSR_S_HALT_Msk         (1UL << CoreDebug_DHCSR_S_HALT_Pos)            /*!< CoreDebug DHCSR: S_HALT Mask */
N
N#define CoreDebug_DHCSR_S_REGRDY_Pos       16U                                            /*!< CoreDebug DHCSR: S_REGRDY Position */
N#define CoreDebug_DHCSR_S_REGRDY_Msk       (1UL << CoreDebug_DHCSR_S_REGRDY_Pos)          /*!< CoreDebug DHCSR: S_REGRDY Mask */
N
N#define CoreDebug_DHCSR_C_SNAPSTALL_Pos     5U                                            /*!< CoreDebug DHCSR: C_SNAPSTALL Position */
N#define CoreDebug_DHCSR_C_SNAPSTALL_Msk    (1UL << CoreDebug_DHCSR_C_SNAPSTALL_Pos)       /*!< CoreDebug DHCSR: C_SNAPSTALL Mask */
N
N#define CoreDebug_DHCSR_C_MASKINTS_Pos      3U                                            /*!< CoreDebug DHCSR: C_MASKINTS Position */
N#define CoreDebug_DHCSR_C_MASKINTS_Msk     (1UL << CoreDebug_DHCSR_C_MASKINTS_Pos)        /*!< CoreDebug DHCSR: C_MASKINTS Mask */
N
N#define CoreDebug_DHCSR_C_STEP_Pos          2U                                            /*!< CoreDebug DHCSR: C_STEP Position */
N#define CoreDebug_DHCSR_C_STEP_Msk         (1UL << CoreDebug_DHCSR_C_STEP_Pos)            /*!< CoreDebug DHCSR: C_STEP Mask */
N
N#define CoreDebug_DHCSR_C_HALT_Pos          1U                                            /*!< CoreDebug DHCSR: C_HALT Position */
N#define CoreDebug_DHCSR_C_HALT_Msk         (1UL << CoreDebug_DHCSR_C_HALT_Pos)            /*!< CoreDebug DHCSR: C_HALT Mask */
N
N#define CoreDebug_DHCSR_C_DEBUGEN_Pos       0U                                            /*!< CoreDebug DHCSR: C_DEBUGEN Position */
N#define CoreDebug_DHCSR_C_DEBUGEN_Msk      (1UL /*<< CoreDebug_DHCSR_C_DEBUGEN_Pos*/)     /*!< CoreDebug DHCSR: C_DEBUGEN Mask */
N
N/* Debug Core Register Selector Register Definitions */
N#define CoreDebug_DCRSR_REGWnR_Pos         16U                                            /*!< CoreDebug DCRSR: REGWnR Position */
N#define CoreDebug_DCRSR_REGWnR_Msk         (1UL << CoreDebug_DCRSR_REGWnR_Pos)            /*!< CoreDebug DCRSR: REGWnR Mask */
N
N#define CoreDebug_DCRSR_REGSEL_Pos          0U                                            /*!< CoreDebug DCRSR: REGSEL Position */
N#define CoreDebug_DCRSR_REGSEL_Msk         (0x1FUL /*<< CoreDebug_DCRSR_REGSEL_Pos*/)     /*!< CoreDebug DCRSR: REGSEL Mask */
N
N/* Debug Exception and Monitor Control Register Definitions */
N#define CoreDebug_DEMCR_TRCENA_Pos         24U                                            /*!< CoreDebug DEMCR: TRCENA Position */
N#define CoreDebug_DEMCR_TRCENA_Msk         (1UL << CoreDebug_DEMCR_TRCENA_Pos)            /*!< CoreDebug DEMCR: TRCENA Mask */
N
N#define CoreDebug_DEMCR_MON_REQ_Pos        19U                                            /*!< CoreDebug DEMCR: MON_REQ Position */
N#define CoreDebug_DEMCR_MON_REQ_Msk        (1UL << CoreDebug_DEMCR_MON_REQ_Pos)           /*!< CoreDebug DEMCR: MON_REQ Mask */
N
N#define CoreDebug_DEMCR_MON_STEP_Pos       18U                                            /*!< CoreDebug DEMCR: MON_STEP Position */
N#define CoreDebug_DEMCR_MON_STEP_Msk       (1UL << CoreDebug_DEMCR_MON_STEP_Pos)          /*!< CoreDebug DEMCR: MON_STEP Mask */
N
N#define CoreDebug_DEMCR_MON_PEND_Pos       17U                                            /*!< CoreDebug DEMCR: MON_PEND Position */
N#define CoreDebug_DEMCR_MON_PEND_Msk       (1UL << CoreDebug_DEMCR_MON_PEND_Pos)          /*!< CoreDebug DEMCR: MON_PEND Mask */
N
N#define CoreDebug_DEMCR_MON_EN_Pos         16U                                            /*!< CoreDebug DEMCR: MON_EN Position */
N#define CoreDebug_DEMCR_MON_EN_Msk         (1UL << CoreDebug_DEMCR_MON_EN_Pos)            /*!< CoreDebug DEMCR: MON_EN Mask */
N
N#define CoreDebug_DEMCR_VC_HARDERR_Pos     10U                                            /*!< CoreDebug DEMCR: VC_HARDERR Position */
N#define CoreDebug_DEMCR_VC_HARDERR_Msk     (1UL << CoreDebug_DEMCR_VC_HARDERR_Pos)        /*!< CoreDebug DEMCR: VC_HARDERR Mask */
N
N#define CoreDebug_DEMCR_VC_INTERR_Pos       9U                                            /*!< CoreDebug DEMCR: VC_INTERR Position */
N#define CoreDebug_DEMCR_VC_INTERR_Msk      (1UL << CoreDebug_DEMCR_VC_INTERR_Pos)         /*!< CoreDebug DEMCR: VC_INTERR Mask */
N
N#define CoreDebug_DEMCR_VC_BUSERR_Pos       8U                                            /*!< CoreDebug DEMCR: VC_BUSERR Position */
N#define CoreDebug_DEMCR_VC_BUSERR_Msk      (1UL << CoreDebug_DEMCR_VC_BUSERR_Pos)         /*!< CoreDebug DEMCR: VC_BUSERR Mask */
N
N#define CoreDebug_DEMCR_VC_STATERR_Pos      7U                                            /*!< CoreDebug DEMCR: VC_STATERR Position */
N#define CoreDebug_DEMCR_VC_STATERR_Msk     (1UL << CoreDebug_DEMCR_VC_STATERR_Pos)        /*!< CoreDebug DEMCR: VC_STATERR Mask */
N
N#define CoreDebug_DEMCR_VC_CHKERR_Pos       6U                                            /*!< CoreDebug DEMCR: VC_CHKERR Position */
N#define CoreDebug_DEMCR_VC_CHKERR_Msk      (1UL << CoreDebug_DEMCR_VC_CHKERR_Pos)         /*!< CoreDebug DEMCR: VC_CHKERR Mask */
N
N#define CoreDebug_DEMCR_VC_NOCPERR_Pos      5U                                            /*!< CoreDebug DEMCR: VC_NOCPERR Position */
N#define CoreDebug_DEMCR_VC_NOCPERR_Msk     (1UL << CoreDebug_DEMCR_VC_NOCPERR_Pos)        /*!< CoreDebug DEMCR: VC_NOCPERR Mask */
N
N#define CoreDebug_DEMCR_VC_MMERR_Pos        4U                                            /*!< CoreDebug DEMCR: VC_MMERR Position */
N#define CoreDebug_DEMCR_VC_MMERR_Msk       (1UL << CoreDebug_DEMCR_VC_MMERR_Pos)          /*!< CoreDebug DEMCR: VC_MMERR Mask */
N
N#define CoreDebug_DEMCR_VC_CORERESET_Pos    0U                                            /*!< CoreDebug DEMCR: VC_CORERESET Position */
N#define CoreDebug_DEMCR_VC_CORERESET_Msk   (1UL /*<< CoreDebug_DEMCR_VC_CORERESET_Pos*/)  /*!< CoreDebug DEMCR: VC_CORERESET Mask */
N
N/*@} end of group CMSIS_CoreDebug */
N
N
N/**
N  \ingroup    CMSIS_core_register
N  \defgroup   CMSIS_core_bitfield     Core register bit field macros
N  \brief      Macros for use with bit field definitions (xxx_Pos, xxx_Msk).
N  @{
N */
N
N/**
N  \brief   Mask and shift a bit field value for use in a register bit range.
N  \param[in] field  Name of the register bit field.
N  \param[in] value  Value of the bit field. This parameter is interpreted as an uint32_t type.
N  \return           Masked and shifted value.
N*/
N#define _VAL2FLD(field, value)    (((uint32_t)(value) << field ## _Pos) & field ## _Msk)
N
N/**
N  \brief     Mask and shift a register value to extract a bit filed value.
N  \param[in] field  Name of the register bit field.
N  \param[in] value  Value of register. This parameter is interpreted as an uint32_t type.
N  \return           Masked and shifted bit field value.
N*/
N#define _FLD2VAL(field, value)    (((uint32_t)(value) & field ## _Msk) >> field ## _Pos)
N
N/*@} end of group CMSIS_core_bitfield */
N
N
N/**
N  \ingroup    CMSIS_core_register
N  \defgroup   CMSIS_core_base     Core Definitions
N  \brief      Definitions for base addresses, unions, and structures.
N  @{
N */
N
N/* Memory mapping of Core Hardware */
N#define SCS_BASE            (0xE000E000UL)                            /*!< System Control Space Base Address */
N#define ITM_BASE            (0xE0000000UL)                            /*!< ITM Base Address */
N#define DWT_BASE            (0xE0001000UL)                            /*!< DWT Base Address */
N#define TPI_BASE            (0xE0040000UL)                            /*!< TPI Base Address */
N#define CoreDebug_BASE      (0xE000EDF0UL)                            /*!< Core Debug Base Address */
N#define SysTick_BASE        (SCS_BASE +  0x0010UL)                    /*!< SysTick Base Address */
N#define NVIC_BASE           (SCS_BASE +  0x0100UL)                    /*!< NVIC Base Address */
N#define SCB_BASE            (SCS_BASE +  0x0D00UL)                    /*!< System Control Block Base Address */
N
N#define SCnSCB              ((SCnSCB_Type    *)     SCS_BASE      )   /*!< System control Register not in SCB */
N#define SCB                 ((SCB_Type       *)     SCB_BASE      )   /*!< SCB configuration struct */
N#define SysTick             ((SysTick_Type   *)     SysTick_BASE  )   /*!< SysTick configuration struct */
N#define NVIC                ((NVIC_Type      *)     NVIC_BASE     )   /*!< NVIC configuration struct */
N#define ITM                 ((ITM_Type       *)     ITM_BASE      )   /*!< ITM configuration struct */
N#define DWT                 ((DWT_Type       *)     DWT_BASE      )   /*!< DWT configuration struct */
N#define TPI                 ((TPI_Type       *)     TPI_BASE      )   /*!< TPI configuration struct */
N#define CoreDebug           ((CoreDebug_Type *)     CoreDebug_BASE)   /*!< Core Debug configuration struct */
N
N#if defined (__MPU_PRESENT) && (__MPU_PRESENT == 1U)
X#if 1L && (1 == 1U)
N  #define MPU_BASE          (SCS_BASE +  0x0D90UL)                    /*!< Memory Protection Unit */
N  #define MPU               ((MPU_Type       *)     MPU_BASE      )   /*!< Memory Protection Unit */
N#endif
N
N/*@} */
N
N
N
N/*******************************************************************************
N *                Hardware Abstraction Layer
N  Core Function Interface contains:
N  - Core NVIC Functions
N  - Core SysTick Functions
N  - Core Debug Functions
N  - Core Register Access Functions
N ******************************************************************************/
N/**
N  \defgroup CMSIS_Core_FunctionInterface Functions and Instructions Reference
N*/
N
N
N
N/* ##########################   NVIC functions  #################################### */
N/**
N  \ingroup  CMSIS_Core_FunctionInterface
N  \defgroup CMSIS_Core_NVICFunctions NVIC Functions
N  \brief    Functions that manage interrupts and exceptions via the NVIC.
N  @{
N */
N
N#ifdef CMSIS_NVIC_VIRTUAL
S  #ifndef CMSIS_NVIC_VIRTUAL_HEADER_FILE
S    #define CMSIS_NVIC_VIRTUAL_HEADER_FILE "cmsis_nvic_virtual.h"
S  #endif
S  #include CMSIS_NVIC_VIRTUAL_HEADER_FILE
N#else
N  #define NVIC_SetPriorityGrouping    __NVIC_SetPriorityGrouping
N  #define NVIC_GetPriorityGrouping    __NVIC_GetPriorityGrouping
N  #define NVIC_EnableIRQ              __NVIC_EnableIRQ
N  #define NVIC_GetEnableIRQ           __NVIC_GetEnableIRQ
N  #define NVIC_DisableIRQ             __NVIC_DisableIRQ
N  #define NVIC_GetPendingIRQ          __NVIC_GetPendingIRQ
N  #define NVIC_SetPendingIRQ          __NVIC_SetPendingIRQ
N  #define NVIC_ClearPendingIRQ        __NVIC_ClearPendingIRQ
N  #define NVIC_GetActive              __NVIC_GetActive
N  #define NVIC_SetPriority            __NVIC_SetPriority
N  #define NVIC_GetPriority            __NVIC_GetPriority
N  #define NVIC_SystemReset            __NVIC_SystemReset
N#endif /* CMSIS_NVIC_VIRTUAL */
N
N#ifdef CMSIS_VECTAB_VIRTUAL
S  #ifndef CMSIS_VECTAB_VIRTUAL_HEADER_FILE
S   #define CMSIS_VECTAB_VIRTUAL_HEADER_FILE "cmsis_vectab_virtual.h"
S  #endif
S  #include CMSIS_VECTAB_VIRTUAL_HEADER_FILE
N#else
N  #define NVIC_SetVector              __NVIC_SetVector
N  #define NVIC_GetVector              __NVIC_GetVector
N#endif  /* (CMSIS_VECTAB_VIRTUAL) */
N
N#define NVIC_USER_IRQ_OFFSET          16
N
N
N
N/**
N  \brief   Set Priority Grouping
N  \details Sets the priority grouping field using the required unlock sequence.
N           The parameter PriorityGroup is assigned to the field SCB->AIRCR [10:8] PRIGROUP field.
N           Only values from 0..7 are used.
N           In case of a conflict between priority grouping and available
N           priority bits (__NVIC_PRIO_BITS), the smallest possible priority group is set.
N  \param [in]      PriorityGroup  Priority grouping field.
N */
N__STATIC_INLINE void __NVIC_SetPriorityGrouping(uint32_t PriorityGroup)
Xstatic __inline void __NVIC_SetPriorityGrouping(uint32_t PriorityGroup)
N{
N  uint32_t reg_value;
N  uint32_t PriorityGroupTmp = (PriorityGroup & (uint32_t)0x07UL);             /* only values 0..7 are used          */
N
N  reg_value  =  SCB->AIRCR;                                                   /* read old register configuration    */
X  reg_value  =  ((SCB_Type *) ((0xE000E000UL) + 0x0D00UL) )->AIRCR;                                                    
N  reg_value &= ~((uint32_t)(SCB_AIRCR_VECTKEY_Msk | SCB_AIRCR_PRIGROUP_Msk)); /* clear bits to change               */
X  reg_value &= ~((uint32_t)((0xFFFFUL << 16U) | (7UL << 8U)));  
N  reg_value  =  (reg_value                                   |
N                ((uint32_t)0x5FAUL << SCB_AIRCR_VECTKEY_Pos) |
X                ((uint32_t)0x5FAUL << 16U) |
N                (PriorityGroupTmp << 8U)                      );              /* Insert write key and priorty group */
N  SCB->AIRCR =  reg_value;
X  ((SCB_Type *) ((0xE000E000UL) + 0x0D00UL) )->AIRCR =  reg_value;
N}
N
N
N/**
N  \brief   Get Priority Grouping
N  \details Reads the priority grouping field from the NVIC Interrupt Controller.
N  \return                Priority grouping field (SCB->AIRCR [10:8] PRIGROUP field).
N */
N__STATIC_INLINE uint32_t __NVIC_GetPriorityGrouping(void)
Xstatic __inline uint32_t __NVIC_GetPriorityGrouping(void)
N{
N  return ((uint32_t)((SCB->AIRCR & SCB_AIRCR_PRIGROUP_Msk) >> SCB_AIRCR_PRIGROUP_Pos));
X  return ((uint32_t)((((SCB_Type *) ((0xE000E000UL) + 0x0D00UL) )->AIRCR & (7UL << 8U)) >> 8U));
N}
N
N
N/**
N  \brief   Enable Interrupt
N  \details Enables a device specific interrupt in the NVIC interrupt controller.
N  \param [in]      IRQn  Device specific interrupt number.
N  \note    IRQn must not be negative.
N */
N__STATIC_INLINE void __NVIC_EnableIRQ(IRQn_Type IRQn)
Xstatic __inline void __NVIC_EnableIRQ(IRQn_Type IRQn)
N{
N  if ((int32_t)(IRQn) >= 0)
N  {
N    NVIC->ISER[(((uint32_t)(int32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)(int32_t)IRQn) & 0x1FUL));
X    ((NVIC_Type *) ((0xE000E000UL) + 0x0100UL) )->ISER[(((uint32_t)(int32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)(int32_t)IRQn) & 0x1FUL));
N  }
N}
N
N
N/**
N  \brief   Get Interrupt Enable status
N  \details Returns a device specific interrupt enable status from the NVIC interrupt controller.
N  \param [in]      IRQn  Device specific interrupt number.
N  \return             0  Interrupt is not enabled.
N  \return             1  Interrupt is enabled.
N  \note    IRQn must not be negative.
N */
N__STATIC_INLINE uint32_t __NVIC_GetEnableIRQ(IRQn_Type IRQn)
Xstatic __inline uint32_t __NVIC_GetEnableIRQ(IRQn_Type IRQn)
N{
N  if ((int32_t)(IRQn) >= 0)
N  {
N    return((uint32_t)(((NVIC->ISER[(((uint32_t)(int32_t)IRQn) >> 5UL)] & (1UL << (((uint32_t)(int32_t)IRQn) & 0x1FUL))) != 0UL) ? 1UL : 0UL));
X    return((uint32_t)(((((NVIC_Type *) ((0xE000E000UL) + 0x0100UL) )->ISER[(((uint32_t)(int32_t)IRQn) >> 5UL)] & (1UL << (((uint32_t)(int32_t)IRQn) & 0x1FUL))) != 0UL) ? 1UL : 0UL));
N  }
N  else
N  {
N    return(0U);
N  }
N}
N
N
N/**
N  \brief   Disable Interrupt
N  \details Disables a device specific interrupt in the NVIC interrupt controller.
N  \param [in]      IRQn  Device specific interrupt number.
N  \note    IRQn must not be negative.
N */
N__STATIC_INLINE void __NVIC_DisableIRQ(IRQn_Type IRQn)
Xstatic __inline void __NVIC_DisableIRQ(IRQn_Type IRQn)
N{
N  if ((int32_t)(IRQn) >= 0)
N  {
N    NVIC->ICER[(((uint32_t)(int32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)(int32_t)IRQn) & 0x1FUL));
X    ((NVIC_Type *) ((0xE000E000UL) + 0x0100UL) )->ICER[(((uint32_t)(int32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)(int32_t)IRQn) & 0x1FUL));
N    __DSB();
X    do { __schedule_barrier(); __dsb(0xF); __schedule_barrier(); } while (0U);
N    __ISB();
X    do { __schedule_barrier(); __isb(0xF); __schedule_barrier(); } while (0U);
N  }
N}
N
N
N/**
N  \brief   Get Pending Interrupt
N  \details Reads the NVIC pending register and returns the pending bit for the specified device specific interrupt.
N  \param [in]      IRQn  Device specific interrupt number.
N  \return             0  Interrupt status is not pending.
N  \return             1  Interrupt status is pending.
N  \note    IRQn must not be negative.
N */
N__STATIC_INLINE uint32_t __NVIC_GetPendingIRQ(IRQn_Type IRQn)
Xstatic __inline uint32_t __NVIC_GetPendingIRQ(IRQn_Type IRQn)
N{
N  if ((int32_t)(IRQn) >= 0)
N  {
N    return((uint32_t)(((NVIC->ISPR[(((uint32_t)(int32_t)IRQn) >> 5UL)] & (1UL << (((uint32_t)(int32_t)IRQn) & 0x1FUL))) != 0UL) ? 1UL : 0UL));
X    return((uint32_t)(((((NVIC_Type *) ((0xE000E000UL) + 0x0100UL) )->ISPR[(((uint32_t)(int32_t)IRQn) >> 5UL)] & (1UL << (((uint32_t)(int32_t)IRQn) & 0x1FUL))) != 0UL) ? 1UL : 0UL));
N  }
N  else
N  {
N    return(0U);
N  }
N}
N
N
N/**
N  \brief   Set Pending Interrupt
N  \details Sets the pending bit of a device specific interrupt in the NVIC pending register.
N  \param [in]      IRQn  Device specific interrupt number.
N  \note    IRQn must not be negative.
N */
N__STATIC_INLINE void __NVIC_SetPendingIRQ(IRQn_Type IRQn)
Xstatic __inline void __NVIC_SetPendingIRQ(IRQn_Type IRQn)
N{
N  if ((int32_t)(IRQn) >= 0)
N  {
N    NVIC->ISPR[(((uint32_t)(int32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)(int32_t)IRQn) & 0x1FUL));
X    ((NVIC_Type *) ((0xE000E000UL) + 0x0100UL) )->ISPR[(((uint32_t)(int32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)(int32_t)IRQn) & 0x1FUL));
N  }
N}
N
N
N/**
N  \brief   Clear Pending Interrupt
N  \details Clears the pending bit of a device specific interrupt in the NVIC pending register.
N  \param [in]      IRQn  Device specific interrupt number.
N  \note    IRQn must not be negative.
N */
N__STATIC_INLINE void __NVIC_ClearPendingIRQ(IRQn_Type IRQn)
Xstatic __inline void __NVIC_ClearPendingIRQ(IRQn_Type IRQn)
N{
N  if ((int32_t)(IRQn) >= 0)
N  {
N    NVIC->ICPR[(((uint32_t)(int32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)(int32_t)IRQn) & 0x1FUL));
X    ((NVIC_Type *) ((0xE000E000UL) + 0x0100UL) )->ICPR[(((uint32_t)(int32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)(int32_t)IRQn) & 0x1FUL));
N  }
N}
N
N
N/**
N  \brief   Get Active Interrupt
N  \details Reads the active register in the NVIC and returns the active bit for the device specific interrupt.
N  \param [in]      IRQn  Device specific interrupt number.
N  \return             0  Interrupt status is not active.
N  \return             1  Interrupt status is active.
N  \note    IRQn must not be negative.
N */
N__STATIC_INLINE uint32_t __NVIC_GetActive(IRQn_Type IRQn)
Xstatic __inline uint32_t __NVIC_GetActive(IRQn_Type IRQn)
N{
N  if ((int32_t)(IRQn) >= 0)
N  {
N    return((uint32_t)(((NVIC->IABR[(((uint32_t)(int32_t)IRQn) >> 5UL)] & (1UL << (((uint32_t)(int32_t)IRQn) & 0x1FUL))) != 0UL) ? 1UL : 0UL));
X    return((uint32_t)(((((NVIC_Type *) ((0xE000E000UL) + 0x0100UL) )->IABR[(((uint32_t)(int32_t)IRQn) >> 5UL)] & (1UL << (((uint32_t)(int32_t)IRQn) & 0x1FUL))) != 0UL) ? 1UL : 0UL));
N  }
N  else
N  {
N    return(0U);
N  }
N}
N
N
N/**
N  \brief   Set Interrupt Priority
N  \details Sets the priority of a device specific interrupt or a processor exception.
N           The interrupt number can be positive to specify a device specific interrupt,
N           or negative to specify a processor exception.
N  \param [in]      IRQn  Interrupt number.
N  \param [in]  priority  Priority to set.
N  \note    The priority cannot be set for every processor exception.
N */
N__STATIC_INLINE void __NVIC_SetPriority(IRQn_Type IRQn, uint32_t priority)
Xstatic __inline void __NVIC_SetPriority(IRQn_Type IRQn, uint32_t priority)
N{
N  if ((int32_t)(IRQn) >= 0)
N  {
N    NVIC->IP[((uint32_t)(int32_t)IRQn)]               = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
X    ((NVIC_Type *) ((0xE000E000UL) + 0x0100UL) )->IP[((uint32_t)(int32_t)IRQn)]               = (uint8_t)((priority << (8U - 3)) & (uint32_t)0xFFUL);
N  }
N  else
N  {
N    SCB->SHP[(((uint32_t)(int32_t)IRQn) & 0xFUL)-4UL] = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
X    ((SCB_Type *) ((0xE000E000UL) + 0x0D00UL) )->SHP[(((uint32_t)(int32_t)IRQn) & 0xFUL)-4UL] = (uint8_t)((priority << (8U - 3)) & (uint32_t)0xFFUL);
N  }
N}
N
N
N/**
N  \brief   Get Interrupt Priority
N  \details Reads the priority of a device specific interrupt or a processor exception.
N           The interrupt number can be positive to specify a device specific interrupt,
N           or negative to specify a processor exception.
N  \param [in]   IRQn  Interrupt number.
N  \return             Interrupt Priority.
N                      Value is aligned automatically to the implemented priority bits of the microcontroller.
N */
N__STATIC_INLINE uint32_t __NVIC_GetPriority(IRQn_Type IRQn)
Xstatic __inline uint32_t __NVIC_GetPriority(IRQn_Type IRQn)
N{
N
N  if ((int32_t)(IRQn) >= 0)
N  {
N    return(((uint32_t)NVIC->IP[((uint32_t)(int32_t)IRQn)]               >> (8U - __NVIC_PRIO_BITS)));
X    return(((uint32_t)((NVIC_Type *) ((0xE000E000UL) + 0x0100UL) )->IP[((uint32_t)(int32_t)IRQn)]               >> (8U - 3)));
N  }
N  else
N  {
N    return(((uint32_t)SCB->SHP[(((uint32_t)(int32_t)IRQn) & 0xFUL)-4UL] >> (8U - __NVIC_PRIO_BITS)));
X    return(((uint32_t)((SCB_Type *) ((0xE000E000UL) + 0x0D00UL) )->SHP[(((uint32_t)(int32_t)IRQn) & 0xFUL)-4UL] >> (8U - 3)));
N  }
N}
N
N
N/**
N  \brief   Encode Priority
N  \details Encodes the priority for an interrupt with the given priority group,
N           preemptive priority value, and subpriority value.
N           In case of a conflict between priority grouping and available
N           priority bits (__NVIC_PRIO_BITS), the smallest possible priority group is set.
N  \param [in]     PriorityGroup  Used priority group.
N  \param [in]   PreemptPriority  Preemptive priority value (starting from 0).
N  \param [in]       SubPriority  Subpriority value (starting from 0).
N  \return                        Encoded priority. Value can be used in the function \ref NVIC_SetPriority().
N */
N__STATIC_INLINE uint32_t NVIC_EncodePriority (uint32_t PriorityGroup, uint32_t PreemptPriority, uint32_t SubPriority)
Xstatic __inline uint32_t NVIC_EncodePriority (uint32_t PriorityGroup, uint32_t PreemptPriority, uint32_t SubPriority)
N{
N  uint32_t PriorityGroupTmp = (PriorityGroup & (uint32_t)0x07UL);   /* only values 0..7 are used          */
N  uint32_t PreemptPriorityBits;
N  uint32_t SubPriorityBits;
N
N  PreemptPriorityBits = ((7UL - PriorityGroupTmp) > (uint32_t)(__NVIC_PRIO_BITS)) ? (uint32_t)(__NVIC_PRIO_BITS) : (uint32_t)(7UL - PriorityGroupTmp);
X  PreemptPriorityBits = ((7UL - PriorityGroupTmp) > (uint32_t)(3)) ? (uint32_t)(3) : (uint32_t)(7UL - PriorityGroupTmp);
N  SubPriorityBits     = ((PriorityGroupTmp + (uint32_t)(__NVIC_PRIO_BITS)) < (uint32_t)7UL) ? (uint32_t)0UL : (uint32_t)((PriorityGroupTmp - 7UL) + (uint32_t)(__NVIC_PRIO_BITS));
X  SubPriorityBits     = ((PriorityGroupTmp + (uint32_t)(3)) < (uint32_t)7UL) ? (uint32_t)0UL : (uint32_t)((PriorityGroupTmp - 7UL) + (uint32_t)(3));
N
N  return (
N           ((PreemptPriority & (uint32_t)((1UL << (PreemptPriorityBits)) - 1UL)) << SubPriorityBits) |
N           ((SubPriority     & (uint32_t)((1UL << (SubPriorityBits    )) - 1UL)))
N         );
N}
N
N
N/**
N  \brief   Decode Priority
N  \details Decodes an interrupt priority value with a given priority group to
N           preemptive priority value and subpriority value.
N           In case of a conflict between priority grouping and available
N           priority bits (__NVIC_PRIO_BITS) the smallest possible priority group is set.
N  \param [in]         Priority   Priority value, which can be retrieved with the function \ref NVIC_GetPriority().
N  \param [in]     PriorityGroup  Used priority group.
N  \param [out] pPreemptPriority  Preemptive priority value (starting from 0).
N  \param [out]     pSubPriority  Subpriority value (starting from 0).
N */
N__STATIC_INLINE void NVIC_DecodePriority (uint32_t Priority, uint32_t PriorityGroup, uint32_t* const pPreemptPriority, uint32_t* const pSubPriority)
Xstatic __inline void NVIC_DecodePriority (uint32_t Priority, uint32_t PriorityGroup, uint32_t* const pPreemptPriority, uint32_t* const pSubPriority)
N{
N  uint32_t PriorityGroupTmp = (PriorityGroup & (uint32_t)0x07UL);   /* only values 0..7 are used          */
N  uint32_t PreemptPriorityBits;
N  uint32_t SubPriorityBits;
N
N  PreemptPriorityBits = ((7UL - PriorityGroupTmp) > (uint32_t)(__NVIC_PRIO_BITS)) ? (uint32_t)(__NVIC_PRIO_BITS) : (uint32_t)(7UL - PriorityGroupTmp);
X  PreemptPriorityBits = ((7UL - PriorityGroupTmp) > (uint32_t)(3)) ? (uint32_t)(3) : (uint32_t)(7UL - PriorityGroupTmp);
N  SubPriorityBits     = ((PriorityGroupTmp + (uint32_t)(__NVIC_PRIO_BITS)) < (uint32_t)7UL) ? (uint32_t)0UL : (uint32_t)((PriorityGroupTmp - 7UL) + (uint32_t)(__NVIC_PRIO_BITS));
X  SubPriorityBits     = ((PriorityGroupTmp + (uint32_t)(3)) < (uint32_t)7UL) ? (uint32_t)0UL : (uint32_t)((PriorityGroupTmp - 7UL) + (uint32_t)(3));
N
N  *pPreemptPriority = (Priority >> SubPriorityBits) & (uint32_t)((1UL << (PreemptPriorityBits)) - 1UL);
N  *pSubPriority     = (Priority                   ) & (uint32_t)((1UL << (SubPriorityBits    )) - 1UL);
N}
N
N
N/**
N  \brief   Set Interrupt Vector
N  \details Sets an interrupt vector in SRAM based interrupt vector table.
N           The interrupt number can be positive to specify a device specific interrupt,
N           or negative to specify a processor exception.
N           VTOR must been relocated to SRAM before.
N  \param [in]   IRQn      Interrupt number
N  \param [in]   vector    Address of interrupt handler function
N */
N__STATIC_INLINE void __NVIC_SetVector(IRQn_Type IRQn, uint32_t vector)
Xstatic __inline void __NVIC_SetVector(IRQn_Type IRQn, uint32_t vector)
N{
N  uint32_t *vectors = (uint32_t *)SCB->VTOR;
X  uint32_t *vectors = (uint32_t *)((SCB_Type *) ((0xE000E000UL) + 0x0D00UL) )->VTOR;
N  vectors[(int32_t)IRQn + NVIC_USER_IRQ_OFFSET] = vector;
X  vectors[(int32_t)IRQn + 16] = vector;
N}
N
N
N/**
N  \brief   Get Interrupt Vector
N  \details Reads an interrupt vector from interrupt vector table.
N           The interrupt number can be positive to specify a device specific interrupt,
N           or negative to specify a processor exception.
N  \param [in]   IRQn      Interrupt number.
N  \return                 Address of interrupt handler function
N */
N__STATIC_INLINE uint32_t __NVIC_GetVector(IRQn_Type IRQn)
Xstatic __inline uint32_t __NVIC_GetVector(IRQn_Type IRQn)
N{
N  uint32_t *vectors = (uint32_t *)SCB->VTOR;
X  uint32_t *vectors = (uint32_t *)((SCB_Type *) ((0xE000E000UL) + 0x0D00UL) )->VTOR;
N  return vectors[(int32_t)IRQn + NVIC_USER_IRQ_OFFSET];
X  return vectors[(int32_t)IRQn + 16];
N}
N
N
N/**
N  \brief   System Reset
N  \details Initiates a system reset request to reset the MCU.
N */
N__STATIC_INLINE void __NVIC_SystemReset(void)
Xstatic __inline void __NVIC_SystemReset(void)
N{
N  __DSB();                                                          /* Ensure all outstanding memory accesses included
X  do { __schedule_barrier(); __dsb(0xF); __schedule_barrier(); } while (0U);                                                          
N                                                                       buffered write are completed before reset */
N  SCB->AIRCR  = (uint32_t)((0x5FAUL << SCB_AIRCR_VECTKEY_Pos)    |
X  ((SCB_Type *) ((0xE000E000UL) + 0x0D00UL) )->AIRCR  = (uint32_t)((0x5FAUL << 16U)    |
N                           (SCB->AIRCR & SCB_AIRCR_PRIGROUP_Msk) |
X                           (((SCB_Type *) ((0xE000E000UL) + 0x0D00UL) )->AIRCR & (7UL << 8U)) |
N                            SCB_AIRCR_SYSRESETREQ_Msk    );         /* Keep priority group unchanged */
X                            (1UL << 2U)    );          
N  __DSB();                                                          /* Ensure completion of memory access */
X  do { __schedule_barrier(); __dsb(0xF); __schedule_barrier(); } while (0U);                                                           
N
N  for(;;)                                                           /* wait until reset */
N  {
N    __NOP();
X    __nop();
N  }
N}
N
N/*@} end of CMSIS_Core_NVICFunctions */
N
N
N/* ##########################  FPU functions  #################################### */
N/**
N  \ingroup  CMSIS_Core_FunctionInterface
N  \defgroup CMSIS_Core_FpuFunctions FPU Functions
N  \brief    Function that provides FPU type.
N  @{
N */
N
N/**
N  \brief   get FPU type
N  \details returns the FPU type
N  \returns
N   - \b  0: No FPU
N   - \b  1: Single precision FPU
N   - \b  2: Double + Single precision FPU
N */
N__STATIC_INLINE uint32_t SCB_GetFPUType(void)
Xstatic __inline uint32_t SCB_GetFPUType(void)
N{
N    return 0U;           /* No FPU */
N}
N
N
N/*@} end of CMSIS_Core_FpuFunctions */
N
N
N
N/* ##################################    SysTick function  ############################################ */
N/**
N  \ingroup  CMSIS_Core_FunctionInterface
N  \defgroup CMSIS_Core_SysTickFunctions SysTick Functions
N  \brief    Functions that configure the System.
N  @{
N */
N
N#if defined (__Vendor_SysTickConfig) && (__Vendor_SysTickConfig == 0U)
X#if 1L && (0 == 0U)
N
N/**
N  \brief   System Tick Configuration
N  \details Initializes the System Timer and its interrupt, and starts the System Tick Timer.
N           Counter is in free running mode to generate periodic interrupts.
N  \param [in]  ticks  Number of ticks between two interrupts.
N  \return          0  Function succeeded.
N  \return          1  Function failed.
N  \note    When the variable <b>__Vendor_SysTickConfig</b> is set to 1, then the
N           function <b>SysTick_Config</b> is not included. In this case, the file <b><i>device</i>.h</b>
N           must contain a vendor-specific implementation of this function.
N */
N__STATIC_INLINE uint32_t SysTick_Config(uint32_t ticks)
Xstatic __inline uint32_t SysTick_Config(uint32_t ticks)
N{
N  if ((ticks - 1UL) > SysTick_LOAD_RELOAD_Msk)
X  if ((ticks - 1UL) > (0xFFFFFFUL ))
N  {
N    return (1UL);                                                   /* Reload value impossible */
N  }
N
N  SysTick->LOAD  = (uint32_t)(ticks - 1UL);                         /* set reload register */
X  ((SysTick_Type *) ((0xE000E000UL) + 0x0010UL) )->LOAD  = (uint32_t)(ticks - 1UL);                          
N  NVIC_SetPriority (SysTick_IRQn, (1UL << __NVIC_PRIO_BITS) - 1UL); /* set Priority for Systick Interrupt */
X  __NVIC_SetPriority (SysTick_IRQn, (1UL << 3) - 1UL);  
N  SysTick->VAL   = 0UL;                                             /* Load the SysTick Counter Value */
X  ((SysTick_Type *) ((0xE000E000UL) + 0x0010UL) )->VAL   = 0UL;                                              
N  SysTick->CTRL  = SysTick_CTRL_CLKSOURCE_Msk |
X  ((SysTick_Type *) ((0xE000E000UL) + 0x0010UL) )->CTRL  = (1UL << 2U) |
N                   SysTick_CTRL_TICKINT_Msk   |
X                   (1UL << 1U)   |
N                   SysTick_CTRL_ENABLE_Msk;                         /* Enable SysTick IRQ and SysTick Timer */
X                   (1UL );                          
N  return (0UL);                                                     /* Function successful */
N}
N
N#endif
N
N/*@} end of CMSIS_Core_SysTickFunctions */
N
N
N
N/* ##################################### Debug In/Output function ########################################### */
N/**
N  \ingroup  CMSIS_Core_FunctionInterface
N  \defgroup CMSIS_core_DebugFunctions ITM Functions
N  \brief    Functions that access the ITM debug interface.
N  @{
N */
N
Nextern volatile int32_t ITM_RxBuffer;                              /*!< External variable to receive characters. */
N#define                 ITM_RXBUFFER_EMPTY  ((int32_t)0x5AA55AA5U) /*!< Value identifying \ref ITM_RxBuffer is ready for next character. */
N
N
N/**
N  \brief   ITM Send Character
N  \details Transmits a character via the ITM channel 0, and
N           \li Just returns when no debugger is connected that has booked the output.
N           \li Is blocking when a debugger is connected, but the previous character sent has not been transmitted.
N  \param [in]     ch  Character to transmit.
N  \returns            Character to transmit.
N */
N__STATIC_INLINE uint32_t ITM_SendChar (uint32_t ch)
Xstatic __inline uint32_t ITM_SendChar (uint32_t ch)
N{
N  if (((ITM->TCR & ITM_TCR_ITMENA_Msk) != 0UL) &&      /* ITM enabled */
X  if (((((ITM_Type *) (0xE0000000UL) )->TCR & (1UL )) != 0UL) &&       
N      ((ITM->TER & 1UL               ) != 0UL)   )     /* ITM Port #0 enabled */
X      ((((ITM_Type *) (0xE0000000UL) )->TER & 1UL               ) != 0UL)   )      
N  {
N    while (ITM->PORT[0U].u32 == 0UL)
X    while (((ITM_Type *) (0xE0000000UL) )->PORT[0U].u32 == 0UL)
N    {
N      __NOP();
X      __nop();
N    }
N    ITM->PORT[0U].u8 = (uint8_t)ch;
X    ((ITM_Type *) (0xE0000000UL) )->PORT[0U].u8 = (uint8_t)ch;
N  }
N  return (ch);
N}
N
N
N/**
N  \brief   ITM Receive Character
N  \details Inputs a character via the external variable \ref ITM_RxBuffer.
N  \return             Received character.
N  \return         -1  No character pending.
N */
N__STATIC_INLINE int32_t ITM_ReceiveChar (void)
Xstatic __inline int32_t ITM_ReceiveChar (void)
N{
N  int32_t ch = -1;                           /* no character available */
N
N  if (ITM_RxBuffer != ITM_RXBUFFER_EMPTY)
X  if (ITM_RxBuffer != ((int32_t)0x5AA55AA5U))
N  {
N    ch = ITM_RxBuffer;
N    ITM_RxBuffer = ITM_RXBUFFER_EMPTY;       /* ready for next character */
X    ITM_RxBuffer = ((int32_t)0x5AA55AA5U);        
N  }
N
N  return (ch);
N}
N
N
N/**
N  \brief   ITM Check Character
N  \details Checks whether a character is pending for reading in the variable \ref ITM_RxBuffer.
N  \return          0  No character available.
N  \return          1  Character available.
N */
N__STATIC_INLINE int32_t ITM_CheckChar (void)
Xstatic __inline int32_t ITM_CheckChar (void)
N{
N
N  if (ITM_RxBuffer == ITM_RXBUFFER_EMPTY)
X  if (ITM_RxBuffer == ((int32_t)0x5AA55AA5U))
N  {
N    return (0);                              /* no character available */
N  }
N  else
N  {
N    return (1);                              /*    character available */
N  }
N}
N
N/*@} end of CMSIS_core_DebugFunctions */
N
N
N
N
N#ifdef __cplusplus
S}
N#endif
N
N#endif /* __CORE_CM3_H_DEPENDANT */
N
N#endif /* __CMSIS_GENERIC */
L 80 "C:\Keil_v5\ARM\PACK\Keil\MDR1986BExx\1.5.3\Libraries\CMSIS\CM3\DeviceSupport\MDR32F9Qx\inc\MDR32Fx.h" 2
N#include "system_MDR32F9Qx.h"
L 1 ".\RTE\Device\MDR1986BE92\system_MDR32F9Qx.h" 1
N/**
N  ******************************************************************************
N  * @file    system_MDR32F9Qx.h
N  * @author  Phyton Application Team
N  * @version V1.3.0
N  * @date    11/06/2010
N  * @brief   CMSIS Cortex-M3 Device Peripheral Access Layer System Header File.
N  ******************************************************************************
N  * <br><br>
N  *
N  * THE PRESENT FIRMWARE WHICH IS FOR GUIDANCE ONLY AIMS AT PROVIDING CUSTOMERS
N  * WITH CODING INFORMATION REGARDING THEIR PRODUCTS IN ORDER FOR THEM TO SAVE
N  * TIME. AS A RESULT, PHYTON SHALL NOT BE HELD LIABLE FOR ANY DIRECT, INDIRECT
N  * OR CONSEQUENTIAL DAMAGES WITH RESPECT TO ANY CLAIMS ARISING
N  * FROM THE CONTENT OF SUCH FIRMWARE AND/OR THE USE MADE BY CUSTOMERS OF THE
N  * CODING INFORMATION CONTAINED HEREIN IN CONNECTION WITH THEIR PRODUCTS.
N  *
N  * <h2><center>&copy; COPYRIGHT 2010 Phyton</center></h2>
N  ******************************************************************************
N  * FILE system_MDR32F9Qx.h
N  */
N
N/** @addtogroup __CMSIS CMSIS
N  * @{
N  */
N
N/** @defgroup MDR1986VE9x
N *  @{
N */
N
N/** @defgroup __MDR32F9QX MDR32F9QX System
N  * @{
N  */
N
N/* Define to prevent recursive inclusion -------------------------------------*/
N#ifndef __SYSTEM_MDR32F9Qx_H
N#define __SYSTEM_MDR32F9Qx_H
N
N/** @addtogroup __MDR32F9QX_System_Exported_Variables MDR32F9QX System Exported Variables
N  * @{
N  */
N
Nextern uint32_t SystemCoreClock;          /*!< System Clock Frequency (Core Clock)
N                                           *   default value */
N
N/** @} */ /* End of group __MDR32F9QX_System_Exported_Variables */
N
N/** @addtogroup __MDR32F9QX_System_Exported_Functions MDR32F9QX System Exported Functions
N  * @{
N  */
N
Nextern void SystemInit(void);
Nextern void SystemCoreClockUpdate(void);
N
N/** @} */ /* End of group __MDR32F9QX_System_Exported_Functions */
N
N#endif /*__SYSTEM_MDR32F9Qx_H */
N
N/** @} */ /* End of group __MDR32F9QX */
N
N/** @} */ /* End of group MDR1986VE9x */
N
N/** @} */ /* End of group __CMSIS */
N
N/******************* (C) COPYRIGHT 2010 Phyton *********************************
N*
N* END OF FILE system_MDR32F9Qx.h */
L 81 "C:\Keil_v5\ARM\PACK\Keil\MDR1986BExx\1.5.3\Libraries\CMSIS\CM3\DeviceSupport\MDR32F9Qx\inc\MDR32Fx.h" 2
N
N/** @defgroup __Exported_types Exported types
N  * @{
N  */
N
Ntypedef enum {RESET = 0, SET = !RESET} FlagStatus, ITStatus, BitStatus;
N
N#define IS_BIT_STATUS(STATUS)	(((STATUS) == RESET) || ((STATE) == SET))
N
Ntypedef enum {DISABLE = 0, ENABLE = !DISABLE} FunctionalState;
N#define IS_FUNCTIONAL_STATE(STATE) (((STATE) == DISABLE) || ((STATE) == ENABLE))
N
Ntypedef enum {ERROR = 0, SUCCESS = !ERROR} ErrorStatus;
N
N/** @} */ /* End of group __Exported_types */
N
N/** @addtogroup __MDR32Fx_Peripheral_Units MDR32F9Qx Peripheral Units
N  * @{
N  */
N
N/** @defgroup MDR32Fx_Periph_CAN CAN
N  * @{
N  */
N
N/** @defgroup MDR32Fx_Periph_CAN_Data_Structures Data Structures
N  * @{
N  */
N
N/* MDR_CAN_BUF_TypeDef structure */
Ntypedef struct
N{
N  __IO uint32_t ID;
X  volatile uint32_t ID;
N  __IO uint32_t DLC;
X  volatile uint32_t DLC;
N  __IO uint32_t DATAL;
X  volatile uint32_t DATAL;
N  __IO uint32_t DATAH;
X  volatile uint32_t DATAH;
N}MDR_CAN_BUF_TypeDef;
N
N/* MDR_CAN_BUF_FILTER_TypeDef structure */
Ntypedef struct
N{
N  __IO uint32_t MASK;
X  volatile uint32_t MASK;
N  __IO uint32_t FILTER;
X  volatile uint32_t FILTER;
N}MDR_CAN_BUF_FILTER_TypeDef;
N
N/* MDR_CAN_TypeDef structure */
Ntypedef struct
N{
N  __IO uint32_t CONTROL;
X  volatile uint32_t CONTROL;
N  __IO uint32_t STATUS;
X  volatile uint32_t STATUS;
N  __IO uint32_t BITTMNG;
X  volatile uint32_t BITTMNG;
N       uint32_t RESERVED0;
N  __IO uint32_t INT_EN;
X  volatile uint32_t INT_EN;
N       uint32_t RESERVED1[2];
N  __IO uint32_t OVER;
X  volatile uint32_t OVER;
N  __IO uint32_t RXID;
X  volatile uint32_t RXID;
N  __IO uint32_t RXDLC;
X  volatile uint32_t RXDLC;
N  __IO uint32_t RXDATAL;
X  volatile uint32_t RXDATAL;
N  __IO uint32_t RXDATAH;
X  volatile uint32_t RXDATAH;
N  __IO uint32_t TXID;
X  volatile uint32_t TXID;
N  __IO uint32_t TXDLC;
X  volatile uint32_t TXDLC;
N  __IO uint32_t DATAL;
X  volatile uint32_t DATAL;
N  __IO uint32_t DATAH;
X  volatile uint32_t DATAH;
N  __IO uint32_t BUF_CON[32];
X  volatile uint32_t BUF_CON[32];
N  __IO uint32_t INT_RX;
X  volatile uint32_t INT_RX;
N  __IO uint32_t RX;
X  volatile uint32_t RX;
N  __IO uint32_t INT_TX;
X  volatile uint32_t INT_TX;
N  __IO uint32_t TX;
X  volatile uint32_t TX;
N       uint32_t RESERVED2[76];
N    MDR_CAN_BUF_TypeDef CAN_BUF[32];
N       uint32_t RESERVED3[64];
N    MDR_CAN_BUF_FILTER_TypeDef CAN_BUF_FILTER[32];
N}MDR_CAN_TypeDef;
N
N/** @} */ /* End of group MDR32Fx_Periph_CAN_Data_Structures */
N
N/** @defgroup MDR32Fx_Periph_CAN_Defines Defines
N  * @{
N  */
N
N/** @defgroup Periph_CAN_CONTROL	CAN CONTROL
N  * @{
N  */ 
N
N/*-- CAN_CONTROL: CAN Control Register -----------------------------*/
N/* Bit field positions: */
N#define CAN_CONTROL_CAN_EN_Pos                  0
N#define CAN_CONTROL_ROM_Pos                     1
N#define CAN_CONTROL_STM_Pos                     2
N#define CAN_CONTROL_SAP_Pos                     3
N#define CAN_CONTROL_ROP_Pos                     4
N
N/* Bit field masks: */
N#define CAN_CONTROL_CAN_EN                      ((uint32_t)0x00000001)
N#define CAN_CONTROL_ROM                         ((uint32_t)0x00000002)
N#define CAN_CONTROL_STM                         ((uint32_t)0x00000004)
N#define CAN_CONTROL_SAP                         ((uint32_t)0x00000008)
N#define CAN_CONTROL_ROP                         ((uint32_t)0x00000010)
N
N/** @} */ /* End of group CAN_CONTROL */
N
N/** @defgroup Periph_CAN_STATUS	CAN STATUS
N  * @{
N  */ 
N
N/*-- CAN_STATUS: CAN Status Register -------------------------------*/
N/* Bit field positions: */
N#define CAN_STATUS_RX_READY_Pos                 0
N#define CAN_STATUS_TX_READY_Pos                 1
N#define CAN_STATUS_ERROR_OVER_Pos               2
N#define CAN_STATUS_BIT_ERR_Pos                  3
N#define CAN_STATUS_BIT_STUFF_ERR_Pos            4
N#define CAN_STATUS_CRC_ERR_Pos                  5
N#define CAN_STATUS_FRAME_ERR_Pos                6
N#define CAN_STATUS_ACK_ERR_Pos                  7
N#define CAN_STATUS_IDLOWER_Pos                  8
N#define CAN_STATUS_ERR_STATUS_Pos               9
N#define CAN_STATUS_RX_ERR_CNT8_Pos              11
N#define CAN_STATUS_TX_ERR_CNT8_Pos              12
N#define CAN_STATUS_RX_ERR_CNT_Pos               16
N#define CAN_STATUS_TX_ERR_CNT_Pos               24
N
N/* Bit field masks: */
N#define CAN_STATUS_RX_READY                     ((uint32_t)0x00000001)
N#define CAN_STATUS_TX_READY                     ((uint32_t)0x00000002)
N#define CAN_STATUS_ERROR_OVER                   ((uint32_t)0x00000004)
N#define CAN_STATUS_BIT_ERR                      ((uint32_t)0x00000008)
N#define CAN_STATUS_BIT_STUFF_ERR                ((uint32_t)0x00000010)
N#define CAN_STATUS_CRC_ERR                      ((uint32_t)0x00000020)
N#define CAN_STATUS_FRAME_ERR                    ((uint32_t)0x00000040)
N#define CAN_STATUS_ACK_ERR                      ((uint32_t)0x00000080)
N#define CAN_STATUS_IDLOWER                      ((uint32_t)0x00000100)
N#define CAN_STATUS_ERR_STATUS_Msk               ((uint32_t)0x00000600)
N#define CAN_STATUS_RX_ERR_CNT8                  ((uint32_t)0x00000800)
N#define CAN_STATUS_TX_ERR_CNT8                  ((uint32_t)0x00001000)
N#define CAN_STATUS_RX_ERR_CNT_Msk               ((uint32_t)0x00FF0000)
N#define CAN_STATUS_TX_ERR_CNT_Msk               ((uint32_t)0xFF000000)
N
N/** @} */ /* End of group CAN_STATUS */
N
N/** @defgroup Periph_CAN_BITTMNG	CAN BITTMNG
N  * @{
N  */ 
N
N/*-- CAN_BITTMNG: CAN Bittiming Register ---------------------------*/
N/* Bit field positions: */
N#define CAN_BITTMNG_BRP_Pos                     0
N#define CAN_BITTMNG_PSEG_Pos                    16
N#define CAN_BITTMNG_SEG1_Pos                    19
N#define CAN_BITTMNG_SEG2_Pos                    22
N#define CAN_BITTMNG_SJW_Pos                     25
N#define CAN_BITTMNG_SB_Pos                      27
N
N/* Bit field masks: */
N#define CAN_BITTMNG_BRP_Msk                     ((uint32_t)0x0000FFFF)
N#define CAN_BITTMNG_PSEG_Msk                    ((uint32_t)0x00070000)
N#define CAN_BITTMNG_SEG1_Msk                    ((uint32_t)0x00380000)
N#define CAN_BITTMNG_SEG2_Msk                    ((uint32_t)0x01C00000)
N#define CAN_BITTMNG_SJW_Msk                     ((uint32_t)0x06000000)
N#define CAN_BITTMNG_SB                          ((uint32_t)0x08000000)
N
N/** @} */ /* End of group CAN_BITTMNG */
N
N/** @defgroup Periph_CAN_INT_EN	CAN INT EN
N  * @{
N  */ 
N
N/*-- CAN_INT_EN: CAN Interrupt enable Register ---------------------*/
N/* Bit field positions: */
N#define CAN_INT_EN_GLB_INT_EN_Pos               0
N#define CAN_INT_EN_RX_INT_EN_Pos                1
N#define CAN_INT_EN_TX_INT_EN_Pos                2
N#define CAN_INT_EN_ERR_INT_EN_Pos               3
N#define CAN_INT_EN_ERR_OVER_INT_EN_Pos          4
N
N/* Bit field masks: */
N#define CAN_INT_EN_GLB_INT_EN                   ((uint32_t)0x00000001)
N#define CAN_INT_EN_RX_INT_EN                    ((uint32_t)0x00000002)
N#define CAN_INT_EN_TX_INT_EN                    ((uint32_t)0x00000004)
N#define CAN_INT_EN_ERR_INT_EN                   ((uint32_t)0x00000008)
N#define CAN_INT_EN_ERR_OVER_INT_EN              ((uint32_t)0x00000010)
N
N/** @} */ /* End of group CAN_INT_EN */
N
N/** @defgroup Periph_CAN_RXID	CAN RXID
N  * @{
N  */ 
N
N/*-- CAN_RXID:   CAN Receive ID Register ---------------------------*/
N/*-- CAN_TXID:   CAN Transmit ID Register --------------------------*/
N/*-- CAN_BUF_ID: CAN Buffer ID Register ----------------------------*/
N/* Bit field positions: */
N#define CAN_ID_EID_Pos                          0
N#define CAN_ID_SID_Pos                          18
N
N/* Bit field masks: */
N#define CAN_ID_EID_Msk                          ((uint32_t)0x0003FFFF)
N#define CAN_ID_SID_Msk                          ((uint32_t)0x1FFC0000)
N
N/** @} */ /* End of group CAN_RXID */
N
N/** @defgroup Periph_CAN_RXDLC	CAN RXDLC
N  * @{
N  */ 
N
N/*-- CAN_RXDLC:   CAN Receive DLC Register -------------------------*/
N/*-- CAN_TXDLC:   CAN Transmit DLC Register ------------------------*/
N/*-- CAN_BUF_DLC: CAN Buffer DLC Register --------------------------*/
N/* Bit field positions: */
N#define CAN_DLC_Pos                             0
N#define CAN_DLC_RTR_Pos                         8
N#define CAN_DLC_R1_Pos                          9
N#define CAN_DLC_R0_Pos                          10
N#define CAN_DLC_SSR_Pos                         11
N#define CAN_DLC_IDE_Pos                         12
N
N/* Bit field masks: */
N#define CAN_DLC_Msk                             ((uint32_t)0x0000000F)
N#define CAN_DLC_RTR                             ((uint32_t)0x00000100)
N#define CAN_DLC_R1                              ((uint32_t)0x00000200)
N#define CAN_DLC_R0                              ((uint32_t)0x00000400)
N#define CAN_DLC_SSR                             ((uint32_t)0x00000800)
N#define CAN_DLC_IDE                             ((uint32_t)0x00001000)
N
N/** @} */ /* End of group CAN_RXDLC */
N
N/** @defgroup Periph_CAN_RXDATAL	CAN RXDATAL
N  * @{
N  */ 
N
N/*-- CAN_RXDATAL:   CAN Receive Data low Register ------------------*/
N/*-- CAN_DATAL:     CAN Transmit Data low Register -----------------*/
N/*-- CAN_BUF_DATAL: CAN Buffer Data low Register -------------------*/
N/* Bit field positions: */
N#define CAN_DATAL_DB0_Pos                       0
N#define CAN_DATAL_DB1_Pos                       8
N#define CAN_DATAL_DB2_Pos                       16
N#define CAN_DATAL_DB3_Pos                       24
N
N/* Bit field masks: */
N#define CAN_DATAL_DB0_Msk                       ((uint32_t)0x000000FF)
N#define CAN_DATAL_DB1_Msk                       ((uint32_t)0x0000FF00)
N#define CAN_DATAL_DB2_Msk                       ((uint32_t)0x00FF0000)
N#define CAN_DATAL_DB3_Msk                       ((uint32_t)0xFF000000)
N
N/** @} */ /* End of group CAN_RXDATAL */
N
N/** @defgroup Periph_CAN_RXDATAH	CAN RXDATAH
N  * @{
N  */ 
N
N/*-- CAN_RXDATAH:   CAN Receive Data high Register -----------------*/
N/*-- CAN_DATAH:     CAN Transmit Data high Register ----------------*/
N/*-- CAN_BUF_DATAH: CAN Buffer Data high Register ------------------*/
N/* Bit field positions: */
N#define CAN_DATAH_DB4_Pos                       0
N#define CAN_DATAH_DB5_Pos                       8
N#define CAN_DATAH_DB6_Pos                       16
N#define CAN_DATAH_DB7_Pos                       24
N
N/* Bit field masks: */
N#define CAN_DATAH_DB4_Msk                       ((uint32_t)0x000000FF)
N#define CAN_DATAH_DB5_Msk                       ((uint32_t)0x0000FF00)
N#define CAN_DATAH_DB6_Msk                       ((uint32_t)0x00FF0000)
N#define CAN_DATAH_DB7_Msk                       ((uint32_t)0xFF000000)
N
N/** @} */ /* End of group CAN_RXDATAH */
N
N/** @defgroup Periph_CAN_BUF_CON	CAN BUF CON
N  * @{
N  */ 
N
N/*-- CAN_BUF_CON: CAN Buffer Connection Register -------------------*/
N/* Bit field positions: */
N#define CAN_BUF_CON_EN_Pos                      0
N#define CAN_BUF_CON_RX_TXN_Pos                  1
N#define CAN_BUF_CON_OVER_EN_Pos                 2
N#define CAN_BUF_CON_RTR_EN_Pos                  3
N#define CAN_BUF_CON_PRIOR_0_Pos                 4
N#define CAN_BUF_CON_TX_REQ_Pos                  5
N#define CAN_BUF_CON_RX_FULL_Pos                 6
N#define CAN_BUF_CON_OVER_WR_Pos                 7
N
N/* Bit field masks: */
N#define CAN_BUF_CON_EN                          ((uint32_t)0x00000001)
N#define CAN_BUF_CON_RX_TXN                      ((uint32_t)0x00000002)
N#define CAN_BUF_CON_OVER_EN                     ((uint32_t)0x00000004)
N#define CAN_BUF_CON_RTR_EN                      ((uint32_t)0x00000008)
N#define CAN_BUF_CON_PRIOR_0                     ((uint32_t)0x00000010)
N#define CAN_BUF_CON_TX_REQ                      ((uint32_t)0x00000020)
N#define CAN_BUF_CON_RX_FULL                     ((uint32_t)0x00000040)
N#define CAN_BUF_CON_OVER_WR                     ((uint32_t)0x00000080)
N
N/** @} */ /* End of group CAN_BUF_CON */
N
N/** @} */ /* End of group MDR32Fx_Periph_CAN_Defines */
N
N/** @} */ /* End of group MDR32Fx_Periph_CAN */
N
N/** @defgroup MDR32Fx_Periph_USB USB
N  * @{
N  */
N
N/** @defgroup MDR32Fx_Periph_USB_Data_Structures Data Structures
N  * @{
N  */
N
N/* MDR_USB_SEP_TypeDef structure */
Ntypedef struct
N{
N  __IO uint32_t CTRL;
X  volatile uint32_t CTRL;
N  __IO uint32_t STS;
X  volatile uint32_t STS;
N  __IO uint32_t TS;
X  volatile uint32_t TS;
N  __IO uint32_t NTS;
X  volatile uint32_t NTS;
N}MDR_USB_SEP_TypeDef;
N
N/* MDR_USB_SEP_FIFO_TypeDef structure */
Ntypedef struct
N{
N  __IO uint32_t RXFD;
X  volatile uint32_t RXFD;
N       uint32_t RESERVED0;
N  __IO uint32_t RXFDC_L;
X  volatile uint32_t RXFDC_L;
N  __IO uint32_t RXFDC_H;
X  volatile uint32_t RXFDC_H;
N  __IO uint32_t RXFC;
X  volatile uint32_t RXFC;
N       uint32_t RESERVED1[11];
N  __IO uint32_t TXFD;
X  volatile uint32_t TXFD;
N       uint32_t RESERVED2[3];
N  __IO uint32_t TXFDC;
X  volatile uint32_t TXFDC;
N       uint32_t RESERVED3[11];
N}MDR_USB_SEP_FIFO_TypeDef;
N
N/* MDR_USB_TypeDef structure */
Ntypedef struct
N{
N  __IO uint32_t HTXC;
X  volatile uint32_t HTXC;
N  __IO uint32_t HTXT;
X  volatile uint32_t HTXT;
N  __IO uint32_t HTXLC;
X  volatile uint32_t HTXLC;
N  __IO uint32_t HTXSE;
X  volatile uint32_t HTXSE;
N  __IO uint32_t HTXA;
X  volatile uint32_t HTXA;
N  __IO uint32_t HTXE;
X  volatile uint32_t HTXE;
N  __IO uint32_t HFN_L;
X  volatile uint32_t HFN_L;
N  __IO uint32_t HFN_H;
X  volatile uint32_t HFN_H;
N  __IO uint32_t HIS;
X  volatile uint32_t HIS;
N  __IO uint32_t HIM;
X  volatile uint32_t HIM;
N  __IO uint32_t HRXS;
X  volatile uint32_t HRXS;
N  __IO uint32_t HRXP;
X  volatile uint32_t HRXP;
N  __IO uint32_t HRXA;
X  volatile uint32_t HRXA;
N  __IO uint32_t HRXE;
X  volatile uint32_t HRXE;
N  __IO uint32_t HRXCS;
X  volatile uint32_t HRXCS;
N  __IO uint32_t HSTM;
X  volatile uint32_t HSTM;
N       uint32_t RESERVED0[16];
N  __IO uint32_t HRXFD;
X  volatile uint32_t HRXFD;
N       uint32_t RESERVED1;
N  __IO uint32_t HRXFDC_L;
X  volatile uint32_t HRXFDC_L;
N  __IO uint32_t HRXFDC_H;
X  volatile uint32_t HRXFDC_H;
N  __IO uint32_t HRXFC;
X  volatile uint32_t HRXFC;
N       uint32_t RESERVED2[11];
N  __IO uint32_t HTXFD;
X  volatile uint32_t HTXFD;
N       uint32_t RESERVED3[3];
N  __IO uint32_t HTXFC;
X  volatile uint32_t HTXFC;
N       uint32_t RESERVED4[11];
N    MDR_USB_SEP_TypeDef USB_SEP[4];
N  __IO uint32_t SC;
X  volatile uint32_t SC;
N  __IO uint32_t SLS;
X  volatile uint32_t SLS;
N  __IO uint32_t SIS;
X  volatile uint32_t SIS;
N  __IO uint32_t SIM;
X  volatile uint32_t SIM;
N  __IO uint32_t SA;
X  volatile uint32_t SA;
N  __IO uint32_t SFN_L;
X  volatile uint32_t SFN_L;
N  __IO uint32_t SFN_H;
X  volatile uint32_t SFN_H;
N       uint32_t RESERVED5[9];
N    MDR_USB_SEP_FIFO_TypeDef USB_SEP_FIFO[4];
N  __IO uint32_t HSCR;
X  volatile uint32_t HSCR;
N  __IO uint32_t HSVR;
X  volatile uint32_t HSVR;
N}MDR_USB_TypeDef;
N
N/** @} */ /* End of group MDR32Fx_Periph_USB_Data_Structures */
N
N/** @defgroup MDR32Fx_Periph_USB_Defines Defines
N  * @{
N  */
N
N/** @defgroup Periph_USB_HTXC	USB HTXC
N  * @{
N  */ 
N
N/*-- USB_HTXC: USB HTXC Register -----------------------------------*/
N/* Bit field positions: */
N#define USB_HTXC_TREQ_Pos                       0
N#define USB_HTXC_SOFS_Pos                       1
N#define USB_HTXC_PREEN_Pos                      2
N#define USB_HTXC_ISOEN_Pos                      3
N
N/* Bit field masks: */
N#define USB_HTXC_TREQ                           ((uint32_t)0x00000001)
N#define USB_HTXC_SOFS                           ((uint32_t)0x00000002)
N#define USB_HTXC_PREEN                          ((uint32_t)0x00000004)
N#define USB_HTXC_ISOEN                          ((uint32_t)0x00000008)
N
N/** @} */ /* End of group USB_HTXC */
N
N/** @defgroup Periph_USB_HTXLC	USB HTXLC
N  * @{
N  */ 
N
N/*-- USB_HTXLC: USB HTXLC Register ---------------------------------*/
N/* Bit field positions: */
N#define USB_HTXLC_Pos                           0
N#define USB_HTXLC_DC_Pos                        2
N#define USB_HTXLC_FSPL_Pos                      3
N#define USB_HTXLC_FSLR_Pos                      4
N
N/* Bit field masks: */
N#define USB_HTXLC_Msk                           ((uint32_t)0x00000003)
N#define USB_HTXLC_DC                            ((uint32_t)0x00000004)
N#define USB_HTXLC_FSPL                          ((uint32_t)0x00000008)
N#define USB_HTXLC_FSLR                          ((uint32_t)0x00000010)
N
N/** @} */ /* End of group USB_HTXLC */
N
N/** @defgroup Periph_USB_HIS	USB HIS
N  * @{
N  */ 
N
N/*-- USB_HIS: USB_HIS Register -------------------------------------*/
N/* Bit field positions: */
N#define USB_HIS_TDONE_Pos                       0
N#define USB_HIS_RESUME_Pos                      1
N#define USB_HIS_CONEV_Pos                       2
N#define USB_HIS_SOFS_Pos                        3
N
N/* Bit field masks: */
N#define USB_HIS_TDONE                           ((uint32_t)0x00000001)
N#define USB_HIS_RESUME                          ((uint32_t)0x00000002)
N#define USB_HIS_CONEV                           ((uint32_t)0x00000004)
N#define USB_HIS_SOFS                            ((uint32_t)0x00000008)
N
N/** @} */ /* End of group USB_HIS */
N
N/** @defgroup Periph_USB_HIM	USB HIM
N  * @{
N  */ 
N
N/*-- USB_HIM: USB_HIM Register -------------------------------------*/
N/* Bit field positions: */
N#define USB_HIM_TDONEIE_Pos                     0
N#define USB_HIM_RESUMEIE_Pos                    1
N#define USB_HIM_CONEVIE_Pos                     2
N#define USB_HIM_SOFIE_Pos                       3
N
N/* Bit field masks: */
N#define USB_HIM_TDONEIE                         ((uint32_t)0x00000001)
N#define USB_HIM_RESUMEIE                        ((uint32_t)0x00000002)
N#define USB_HIM_CONEVIE                         ((uint32_t)0x00000004)
N#define USB_HIM_SOFIE                           ((uint32_t)0x00000008)
N
N/** @} */ /* End of group USB_HIM */
N
N/** @defgroup Periph_USB_HRXS	USB HRXS
N  * @{
N  */ 
N
N/*-- USB_HRXS: USB_HRXS Register -----------------------------------*/
N/* Bit field positions: */
N#define USB_HRXS_CRCERR_Pos                     0
N#define USB_HRXS_BSERR_Pos                      1
N#define USB_HRXS_RXOF_Pos                       2
N#define USB_HRXS_RXTO_Pos                       3
N#define USB_HRXS_NAKRXED_Pos                    4
N#define USB_HRXS_STALLRXED_Pos                  5
N#define USB_HRXS_ACKRXED_Pos                    6
N#define USB_HRXS_DATASEQ_Pos                    7
N
N/* Bit field masks: */
N#define USB_HRXS_CRCERR                         ((uint32_t)0x00000001)
N#define USB_HRXS_BSERR                          ((uint32_t)0x00000002)
N#define USB_HRXS_RXOF                           ((uint32_t)0x00000004)
N#define USB_HRXS_RXTO                           ((uint32_t)0x00000008)
N#define USB_HRXS_NAKRXED                        ((uint32_t)0x00000010)
N#define USB_HRXS_STALLRXED                      ((uint32_t)0x00000020)
N#define USB_HRXS_ACKRXED                        ((uint32_t)0x00000040)
N#define USB_HRXS_DATASEQ                        ((uint32_t)0x00000080)
N
N/** @} */ /* End of group USB_HRXS */
N
N/** @defgroup Periph_USB_SEP_CTRL	USB SEP CTRL
N  * @{
N  */ 
N
N/*-- USB_SEP_CTRL: USB_SEP Control Register ------------------------*/
N/* Bit field positions: */
N#define USB_SEP_CTRL_EPEN_Pos                   0
N#define USB_SEP_CTRL_EPRDY_Pos                  1
N#define USB_SEP_CTRL_EPDATASEQ_Pos              2
N#define USB_SEP_CTRL_EPSSTALL_Pos               3
N#define USB_SEP_CTRL_EPISOEN_Pos                4
N
N/* Bit field masks: */
N#define USB_SEP_CTRL_EPEN                       ((uint32_t)0x00000001)
N#define USB_SEP_CTRL_EPRDY                      ((uint32_t)0x00000002)
N#define USB_SEP_CTRL_EPDATASEQ                  ((uint32_t)0x00000004)
N#define USB_SEP_CTRL_EPSSTALL                   ((uint32_t)0x00000008)
N#define USB_SEP_CTRL_EPISOEN                    ((uint32_t)0x00000010)
N
N/** @} */ /* End of group USB_SEP_CTRL */
N
N/** @defgroup Periph_USB_SEP_STS	USB SEP STS
N  * @{
N  */ 
N
N/*-- USB_SEP_STS: USB_SEP Status Register --------------------------*/
N/* Bit field positions: */
N#define USB_SEP_STS_SCCRCERR_Pos                0
N#define USB_SEP_STS_SCBSERR_Pos                 1
N#define USB_SEP_STS_SCRXOF_Pos                  2
N#define USB_SEP_STS_SCRXTO_Pos                  3
N#define USB_SEP_STS_SCNAKSENT_Pos               4
N#define USB_SEP_STS_SCSTALLSENT_Pos             5
N#define USB_SEP_STS_SCACKRXED_Pos               6
N#define USB_SEP_STS_SCDATASEQ_Pos               7
N
N/* Bit field masks: */
N#define USB_SEP_STS_SCCRCERR                    ((uint32_t)0x00000001)
N#define USB_SEP_STS_SCBSERR                     ((uint32_t)0x00000002)
N#define USB_SEP_STS_SCRXOF                      ((uint32_t)0x00000004)
N#define USB_SEP_STS_SCRXTO                      ((uint32_t)0x00000008)
N#define USB_SEP_STS_SCNAKSENT                   ((uint32_t)0x00000010)
N#define USB_SEP_STS_SCSTALLSENT                 ((uint32_t)0x00000020)
N#define USB_SEP_STS_SCACKRXED                   ((uint32_t)0x00000040)
N#define USB_SEP_STS_SCDATASEQ                   ((uint32_t)0x00000080)
N
N/** @} */ /* End of group USB_SEP_STS */
N
N/** @defgroup Periph_USB_SC	USB SC
N  * @{
N  */ 
N
N/*-- USB_SC: USB_SC Register ---------------------------------------*/
N/* Bit field positions: */
N#define USB_SCGEN_Pos                           0
N#define USB_SCTXLS_Pos                          1
N#define USB_SCDC_Pos                            3
N#define USB_SCFSP_Pos                           4
N#define USB_SCFSR_Pos                           5
N
N/* Bit field masks: */
N#define USB_SCGEN                               ((uint32_t)0x00000001)
N#define USB_SCTXLS_Msk                          ((uint32_t)0x00000006)
N#define USB_SCDC                                ((uint32_t)0x00000008)
N#define USB_SCFSP                               ((uint32_t)0x00000010)
N#define USB_SCFSR                               ((uint32_t)0x00000020)
N
N/** @} */ /* End of group USB_SC */
N
N/** @defgroup Periph_USB_SIS	USB SIS
N  * @{
N  */ 
N
N/*-- USB_SIS: USB_SIS Register -------------------------------------*/
N/* Bit field positions: */
N#define USB_SIS_SCTDONE_Pos                     0
N#define USB_SIS_SCRESUME_Pos                    1
N#define USB_SIS_SCRESETEV_Pos                   2
N#define USB_SIS_SCSOFREC_Pos                    3
N#define USB_SIS_SCNAKSENT_Pos                   4
N
N/* Bit field masks: */
N#define USB_SIS_SCTDONE                         ((uint32_t)0x00000001)
N#define USB_SIS_SCRESUME                        ((uint32_t)0x00000002)
N#define USB_SIS_SCRESETEV                       ((uint32_t)0x00000004)
N#define USB_SIS_SCSOFREC                        ((uint32_t)0x00000008)
N#define USB_SIS_SCNAKSENT                       ((uint32_t)0x00000010)
N
N/** @} */ /* End of group USB_SIS */
N
N/** @defgroup Periph_USB_SIM	USB SIM
N  * @{
N  */ 
N
N/*-- USB_SIM: USB_SIM Register -------------------------------------*/
N/* Bit field positions: */
N#define USB_SIM_SCTDONEIE_Pos                   0
N#define USB_SIM_SCRESUMEIE_Pos                  1
N#define USB_SIM_SCRESETEVIE_Pos                 2
N#define USB_SIM_SCSOFRECIE_Pos                  3
N#define USB_SIM_SCNAKSENTIE_Pos                 4
N
N/* Bit field masks: */
N#define USB_SIM_SCTDONEIE                       ((uint32_t)0x00000001)
N#define USB_SIM_SCRESUMEIE                      ((uint32_t)0x00000002)
N#define USB_SIM_SCRESETEVIE                     ((uint32_t)0x00000004)
N#define USB_SIM_SCSOFRECIE                      ((uint32_t)0x00000008)
N#define USB_SIM_SCNAKSENTIE                     ((uint32_t)0x00000010)
N
N/** @} */ /* End of group USB_SIM */
N
N/** @defgroup Periph_USB_HSCR	USB HSCR
N  * @{
N  */ 
N
N/*-- USB_HSCR: USB_HSCR Register -----------------------------------*/
N/* Bit field positions: */
N#define USB_HSCR_HOST_MODE_Pos                  0
N#define USB_HSCR_RESET_CORE_Pos                 1
N#define USB_HSCR_EN_TX_Pos                      2
N#define USB_HSCR_EN_RX_Pos                      3
N#define USB_HSCR_DP_PULLUP_Pos                  4
N#define USB_HSCR_DP_PULLDOWN_Pos                5
N#define USB_HSCR_DM_PULLUP_Pos                  6
N#define USB_HSCR_DM_PULLDOWN_Pos                7
N
N/* Bit field masks: */
N#define USB_HSCR_HOST_MODE                      ((uint32_t)0x00000001)
N#define USB_HSCR_RESET_CORE                     ((uint32_t)0x00000002)
N#define USB_HSCR_EN_TX                          ((uint32_t)0x00000004)
N#define USB_HSCR_EN_RX                          ((uint32_t)0x00000008)
N#define USB_HSCR_DP_PULLUP                      ((uint32_t)0x00000010)
N#define USB_HSCR_DP_PULLDOWN                    ((uint32_t)0x00000020)
N#define USB_HSCR_DM_PULLUP                      ((uint32_t)0x00000040)
N#define USB_HSCR_DM_PULLDOWN                    ((uint32_t)0x00000080)
N
N/** @} */ /* End of group USB_HSCR */
N
N/** @defgroup Periph_USB_HSVR	USB HSVR
N  * @{
N  */ 
N
N/*-- USB_HSVR: USB_HSVR Register -----------------------------------*/
N/* Bit field positions: */
N#define USB_HSVR_VERSION_Pos                    0
N#define USB_HSVR_REVISION_Pos                   4
N
N/* Bit field masks: */
N#define USB_HSVR_VERSION_Msk                    ((uint32_t)0x0000000F)
N#define USB_HSVR_REVISION_Msk                   ((uint32_t)0x000000F0)
N
N/** @} */ /* End of group USB_HSVR */
N
N/** @} */ /* End of group MDR32Fx_Periph_USB_Defines */
N
N/** @} */ /* End of group MDR32Fx_Periph_USB */
N
N/** @defgroup MDR32Fx_Periph_EEPROM EEPROM
N  * @{
N  */
N
N/** @defgroup MDR32Fx_Periph_EEPROM_Data_Structures Data Structures
N  * @{
N  */
N
N/* MDR_EEPROM_TypeDef structure */
Ntypedef struct
N{
N  __IO uint32_t CMD;
X  volatile uint32_t CMD;
N  __IO uint32_t ADR;
X  volatile uint32_t ADR;
N  __IO uint32_t DI;
X  volatile uint32_t DI;
N  __IO uint32_t DO;
X  volatile uint32_t DO;
N  __IO uint32_t KEY;
X  volatile uint32_t KEY;
N}MDR_EEPROM_TypeDef;
N
N/** @} */ /* End of group MDR32Fx_Periph_EEPROM_Data_Structures */
N
N/** @defgroup MDR32Fx_Periph_EEPROM_Defines Defines
N  * @{
N  */
N
N/** @defgroup Periph_EEPROM_CMD	EEPROM CMD
N  * @{
N  */ 
N
N/*-- EEPROM_CMD: EEPROM Command Register ---------------------------*/
N/* Bit field positions: */
N#define EEPROM_CMD_CON_Pos                      0
N#define EEPROM_CMD_WR_Pos                       1
N#define EEPROM_CMD_RD_Pos                       2
N#define EEPROM_CMD_DELAY_Pos                    3
N#define EEPROM_CMD_XE_Pos                       6
N#define EEPROM_CMD_YE_Pos                       7
N#define EEPROM_CMD_SE_Pos                       8
N#define EEPROM_CMD_IFREN_Pos                    9
N#define EEPROM_CMD_ERASE_Pos                    10
N#define EEPROM_CMD_MAS1_Pos                     11
N#define EEPROM_CMD_PROG_Pos                     12
N#define EEPROM_CMD_NVSTR_Pos                    13
N
N/* Bit field masks: */
N#define EEPROM_CMD_CON                          ((uint32_t)0x00000001)
N#define EEPROM_CMD_WR                           ((uint32_t)0x00000002)
N#define EEPROM_CMD_RD                           ((uint32_t)0x00000004)
N#define EEPROM_CMD_DELAY_Msk                    ((uint32_t)0x00000038)
N#define EEPROM_CMD_XE                           ((uint32_t)0x00000040)
N#define EEPROM_CMD_YE                           ((uint32_t)0x00000080)
N#define EEPROM_CMD_SE                           ((uint32_t)0x00000100)
N#define EEPROM_CMD_IFREN                        ((uint32_t)0x00000200)
N#define EEPROM_CMD_ERASE                        ((uint32_t)0x00000400)
N#define EEPROM_CMD_MAS1                         ((uint32_t)0x00000800)
N#define EEPROM_CMD_PROG                         ((uint32_t)0x00001000)
N#define EEPROM_CMD_NVSTR                        ((uint32_t)0x00002000)
N
N/** @} */ /* End of group EEPROM_CMD */
N
N/** @} */ /* End of group MDR32Fx_Periph_EEPROM_Defines */
N
N/** @} */ /* End of group MDR32Fx_Periph_EEPROM */
N
N/** @defgroup MDR32Fx_Periph_RST_CLK RST_CLK
N  * @{
N  */
N
N/** @defgroup MDR32Fx_Periph_RST_CLK_Data_Structures Data Structures
N  * @{
N  */
N
N/* MDR_RST_CLK_TypeDef structure */
Ntypedef struct
N{
N  __IO uint32_t CLOCK_STATUS;
X  volatile uint32_t CLOCK_STATUS;
N  __IO uint32_t PLL_CONTROL;
X  volatile uint32_t PLL_CONTROL;
N  __IO uint32_t HS_CONTROL;
X  volatile uint32_t HS_CONTROL;
N  __IO uint32_t CPU_CLOCK;
X  volatile uint32_t CPU_CLOCK;
N  __IO uint32_t USB_CLOCK;
X  volatile uint32_t USB_CLOCK;
N  __IO uint32_t ADC_MCO_CLOCK;
X  volatile uint32_t ADC_MCO_CLOCK;
N  __IO uint32_t RTC_CLOCK;
X  volatile uint32_t RTC_CLOCK;
N  __IO uint32_t PER_CLOCK;
X  volatile uint32_t PER_CLOCK;
N  __IO uint32_t CAN_CLOCK;
X  volatile uint32_t CAN_CLOCK;
N  __IO uint32_t TIM_CLOCK;
X  volatile uint32_t TIM_CLOCK;
N  __IO uint32_t UART_CLOCK;
X  volatile uint32_t UART_CLOCK;
N  __IO uint32_t SSP_CLOCK;
X  volatile uint32_t SSP_CLOCK;
N}MDR_RST_CLK_TypeDef;
N
N/** @} */ /* End of group MDR32Fx_Periph_RST_CLK_Data_Structures */
N
N/** @defgroup MDR32Fx_Periph_RST_CLK_Defines Defines
N  * @{
N  */
N
N/** @defgroup Periph_RST_CLK_CLOCK_STATUS	RST CLK CLOCK STATUS
N  * @{
N  */ 
N
N/*-- RST_CLK_CLOCK_STATUS: Clock Status Register -------------------*/
N/* Bit field positions: */
N#define RST_CLK_CLOCK_STATUS_PLL_USB_RDY_Pos    0
N#define RST_CLK_CLOCK_STATUS_PLL_CPU_RDY_Pos    1
N#define RST_CLK_CLOCK_STATUS_HSE_RDY_Pos        2
N
N/* Bit field masks: */
N#define RST_CLK_CLOCK_STATUS_PLL_USB_RDY        ((uint32_t)0x00000001)
N#define RST_CLK_CLOCK_STATUS_PLL_CPU_RDY        ((uint32_t)0x00000002)
N#define RST_CLK_CLOCK_STATUS_HSE_RDY            ((uint32_t)0x00000004)
N
N/** @} */ /* End of group RST_CLK_CLOCK_STATUS */
N
N/** @defgroup Periph_RST_CLK_PLL_CONTROL	RST CLK PLL CONTROL
N  * @{
N  */ 
N
N/*-- RST_CLK_PLL_CONTROL: PLL Control Register ---------------------*/
N/* Bit field positions: */
N#define RST_CLK_PLL_CONTROL_PLL_USB_ON_Pos      0
N#define RST_CLK_PLL_CONTROL_PLL_USB_RLD_Pos     1
N#define RST_CLK_PLL_CONTROL_PLL_CPU_ON_Pos      2
N#define RST_CLK_PLL_CONTROL_PLL_CPU_PLD_Pos     3
N#define RST_CLK_PLL_CONTROL_PLL_USB_MUL_Pos     4
N#define RST_CLK_PLL_CONTROL_PLL_CPU_MUL_Pos     8
N
N/* Bit field masks: */
N#define RST_CLK_PLL_CONTROL_PLL_USB_ON          ((uint32_t)0x00000001)
N#define RST_CLK_PLL_CONTROL_PLL_USB_RLD         ((uint32_t)0x00000002)
N#define RST_CLK_PLL_CONTROL_PLL_CPU_ON          ((uint32_t)0x00000004)
N#define RST_CLK_PLL_CONTROL_PLL_CPU_PLD         ((uint32_t)0x00000008)
N#define RST_CLK_PLL_CONTROL_PLL_USB_MUL_Msk     ((uint32_t)0x000000F0)
N#define RST_CLK_PLL_CONTROL_PLL_CPU_MUL_Msk     ((uint32_t)0x00000F00)
N
N/** @} */ /* End of group RST_CLK_PLL_CONTROL */
N
N/** @defgroup Periph_RST_CLK_HS_CONTROL	RST CLK HS CONTROL
N  * @{
N  */ 
N
N/*-- RST_CLK_HS_CONTROL: HS Control Register -----------------------*/
N/* Bit field positions: */
N#define RST_CLK_HS_CONTROL_HSE_ON_Pos           0
N#define RST_CLK_HS_CONTROL_HSE_BYP_Pos          1
N
N/* Bit field masks: */
N#define RST_CLK_HS_CONTROL_HSE_ON               ((uint32_t)0x00000001)
N#define RST_CLK_HS_CONTROL_HSE_BYP              ((uint32_t)0x00000002)
N
N/** @} */ /* End of group RST_CLK_HS_CONTROL */
N
N/** @defgroup Periph_RST_CLK_CPU_CLOCK	RST CLK CPU CLOCK
N  * @{
N  */ 
N
N/*-- RST_CLK_CPU_CLOCK: CPU Clock Register -------------------------*/
N/* Bit field positions: */
N#define RST_CLK_CPU_CLOCK_CPU_C1_SEL_Pos        0
N#define RST_CLK_CPU_CLOCK_CPU_C2_SEL_Pos        2
N#define RST_CLK_CPU_CLOCK_CPU_C3_SEL_Pos        4
N#define RST_CLK_CPU_CLOCK_HCLK_SEL_Pos          8
N
N/* Bit field masks: */
N#define RST_CLK_CPU_CLOCK_CPU_C1_SEL_Msk        ((uint32_t)0x00000003)
N#define RST_CLK_CPU_CLOCK_CPU_C2_SEL            ((uint32_t)0x00000004)
N#define RST_CLK_CPU_CLOCK_CPU_C3_SEL_Msk        ((uint32_t)0x000000F0)
N#define RST_CLK_CPU_CLOCK_HCLK_SEL_Msk          ((uint32_t)0x00000300)
N
N/** @} */ /* End of group RST_CLK_CPU_CLOCK */
N
N/** @defgroup Periph_RST_CLK_USB_CLOCK	RST CLK USB CLOCK
N  * @{
N  */ 
N
N/*-- RST_CLK_USB_CLOCK: USB Clock Register -------------------------*/
N/* Bit field positions: */
N#define RST_CLK_USB_CLOCK_USB_C1_SEL_Pos        0
N#define RST_CLK_USB_CLOCK_USB_C2_SEL_Pos        2
N#define RST_CLK_USB_CLOCK_USB_C3_SEL_Pos        4
N#define RST_CLK_USB_CLOCK_USB_CLK_EN_Pos        8
N
N/* Bit field masks: */
N#define RST_CLK_USB_CLOCK_USB_C1_SEL_Msk        ((uint32_t)0x00000003)
N#define RST_CLK_USB_CLOCK_USB_C2_SEL            ((uint32_t)0x00000004)
N#define RST_CLK_USB_CLOCK_USB_C3_SEL	        ((uint32_t)0x00000010)
N#define RST_CLK_USB_CLOCK_USB_CLK_EN            ((uint32_t)0x00000100)
N
N/** @} */ /* End of group RST_CLK_USB_CLOCK */
N
N/** @defgroup Periph_RST_CLK_ADC_MCO_CLOCK	RST CLK ADC MCO CLOCK
N  * @{
N  */ 
N
N/*-- RST_CLK_ADC_MCO_CLOCK: ADC Clock Register ---------------------*/
N/* Bit field positions: */
N#define RST_CLK_ADC_MCO_CLOCK_ADC_C1_SEL_Pos    0
N#define RST_CLK_ADC_MCO_CLOCK_ADC_C2_SEL_Pos    4
N#define RST_CLK_ADC_MCO_CLOCK_ADC_C3_SEL_Pos    8
N#define RST_CLK_ADC_MCO_CLOCK_ADC_CLK_EN_Pos    13
N
N/* Bit field masks: */
N#define RST_CLK_ADC_MCO_CLOCK_ADC_C1_SEL_Msk    ((uint32_t)0x00000003)
N#define RST_CLK_ADC_MCO_CLOCK_ADC_C2_SEL_Msk    ((uint32_t)0x00000030)
N#define RST_CLK_ADC_MCO_CLOCK_ADC_C3_SEL_Msk    ((uint32_t)0x00000F00)
N#define RST_CLK_ADC_MCO_CLOCK_ADC_CLK_EN        ((uint32_t)0x00002000)
N
N/** @} */ /* End of group RST_CLK_ADC_MCO_CLOCK */
N
N/** @defgroup Periph_RST_CLK_RTC_CLOCK	RST CLK RTC CLOCK
N  * @{
N  */ 
N
N/*-- RST_CLK_RTC_CLOCK: RTC Clock Register -------------------------*/
N/* Bit field positions: */
N#define RST_CLK_RTC_CLOCK_HSE_SEL_Pos           0
N#define RST_CLK_RTC_CLOCK_HSI_SEL_Pos           4
N#define RST_CLK_RTC_CLOCK_HSE_RTC_EN_Pos        8
N#define RST_CLK_RTC_CLOCK_HSI_RTC_EN_Pos        9
N
N/* Bit field masks: */
N#define RST_CLK_RTC_CLOCK_HSE_SEL_Msk           ((uint32_t)0x0000000F)
N#define RST_CLK_RTC_CLOCK_HSI_SEL_Msk           ((uint32_t)0x000000F0)
N#define RST_CLK_RTC_CLOCK_HSE_RTC_EN            ((uint32_t)0x00000100)
N#define RST_CLK_RTC_CLOCK_HSI_RTC_EN            ((uint32_t)0x00000200)
N
N/** @} */ /* End of group RST_CLK_RTC_CLOCK */
N
N/** @defgroup Periph_RST_CLK_CAN_CLOCK	RST CLK CAN CLOCK
N  * @{
N  */ 
N
N/*-- RST_CLK_CAN_CLOCK: CAN Clock Register -------------------------*/
N/* Bit field positions: */
N#define RST_CLK_CAN_CLOCK_CAN1_BRG_Pos          0
N#define RST_CLK_CAN_CLOCK_CAN2_BRG_Pos          8
N#define RST_CLK_CAN_CLOCK_CAN1_CLK_EN_Pos       24
N#define RST_CLK_CAN_CLOCK_CAN2_CLK_EN_Pos       25
N
N/* Bit field masks: */
N#define RST_CLK_CAN_CLOCK_CAN1_BRG_Msk          ((uint32_t)0x000000FF)
N#define RST_CLK_CAN_CLOCK_CAN2_BRG_Msk          ((uint32_t)0x0000FF00)
N#define RST_CLK_CAN_CLOCK_CAN1_CLK_EN           ((uint32_t)0x01000000)
N#define RST_CLK_CAN_CLOCK_CAN2_CLK_EN           ((uint32_t)0x02000000)
N
N/** @} */ /* End of group RST_CLK_CAN_CLOCK */
N
N/** @defgroup Periph_RST_CLK_TIM_CLOCK	RST CLK TIM CLOCK
N  * @{
N  */ 
N
N/*-- RST_CLK_TIM_CLOCK: Timer Clock Register -----------------------*/
N/* Bit field positions: */
N#define RST_CLK_TIM_CLOCK_TIM1_BRG_Pos          0
N#define RST_CLK_TIM_CLOCK_TIM2_BRG_Pos          8
N#define RST_CLK_TIM_CLOCK_TIM3_BRG_Pos          16
N#define RST_CLK_TIM_CLOCK_TIM1_CLK_EN_Pos       24
N#define RST_CLK_TIM_CLOCK_TIM2_CLK_EN_Pos       25
N#define RST_CLK_TIM_CLOCK_TIM3_CLK_EN_Pos       26
N
N/* Bit field masks: */
N#define RST_CLK_TIM_CLOCK_TIM1_BRG_Msk          ((uint32_t)0x000000FF)
N#define RST_CLK_TIM_CLOCK_TIM2_BRG_Msk          ((uint32_t)0x0000FF00)
N#define RST_CLK_TIM_CLOCK_TIM3_BRG_Msk          ((uint32_t)0x00FF0000)
N#define RST_CLK_TIM_CLOCK_TIM1_CLK_EN           ((uint32_t)0x01000000)
N#define RST_CLK_TIM_CLOCK_TIM2_CLK_EN           ((uint32_t)0x02000000)
N#define RST_CLK_TIM_CLOCK_TIM3_CLK_EN           ((uint32_t)0x04000000)
N
N/** @} */ /* End of group RST_CLK_TIM_CLOCK */
N
N/** @defgroup Periph_RST_CLK_UART_CLOCK	RST CLK UART CLOCK
N  * @{
N  */ 
N
N/*-- RST_CLK_UART_CLOCK: UART Clock Register -----------------------*/
N/* Bit field positions: */
N#define RST_CLK_UART_CLOCK_UART1_BRG_Pos        0
N#define RST_CLK_UART_CLOCK_UART2_BRG_Pos        8
N#define RST_CLK_UART_CLOCK_UART1_CLK_EN_Pos     24
N#define RST_CLK_UART_CLOCK_UART2_CLK_EN_Pos     25
N
N/* Bit field masks: */
N#define RST_CLK_UART_CLOCK_UART1_BRG_Msk        ((uint32_t)0x000000FF)
N#define RST_CLK_UART_CLOCK_UART2_BRG_Msk        ((uint32_t)0x0000FF00)
N#define RST_CLK_UART_CLOCK_UART1_CLK_EN         ((uint32_t)0x01000000)
N#define RST_CLK_UART_CLOCK_UART2_CLK_EN         ((uint32_t)0x02000000)
N
N/** @} */ /* End of group RST_CLK_UART_CLOCK */
N
N/** @defgroup Periph_RST_CLK_SSP_CLOCK	RST CLK SSP CLOCK
N  * @{
N  */ 
N
N/*-- RST_CLK_SSP_CLOCK: SSP Clock Register -------------------------*/
N/* Bit field positions: */
N#define RST_CLK_SSP_CLOCK_SSP1_BRG_Pos          0
N#define RST_CLK_SSP_CLOCK_SSP2_BRG_Pos          8
N#define RST_CLK_SSP_CLOCK_SSP1_CLK_EN_Pos       24
N#define RST_CLK_SSP_CLOCK_SSP2_CLK_EN_Pos       25
N
N/* Bit field masks: */
N#define RST_CLK_SSP_CLOCK_SSP1_BRG_Msk          ((uint32_t)0x000000FF)
N#define RST_CLK_SSP_CLOCK_SSP2_BRG_Msk          ((uint32_t)0x0000FF00)
N#define RST_CLK_SSP_CLOCK_SSP1_CLK_EN           ((uint32_t)0x01000000)
N#define RST_CLK_SSP_CLOCK_SSP2_CLK_EN           ((uint32_t)0x02000000)
N
N/** @} */ /* End of group RST_CLK_SSP_CLOCK */
N
N/** @} */ /* End of group MDR32Fx_Periph_RST_CLK_Defines */
N
N/** @} */ /* End of group MDR32Fx_Periph_RST_CLK */
N
N/** @defgroup MDR32Fx_Periph_DMA DMA
N  * @{
N  */
N
N/** @defgroup MDR32Fx_Periph_DMA_Data_Structures Data Structures
N  * @{
N  */
N
N/* MDR_DMA_TypeDef structure */
Ntypedef struct
N{
N  __IO uint32_t STATUS;
X  volatile uint32_t STATUS;
N  __IO uint32_t CFG;
X  volatile uint32_t CFG;
N  __IO uint32_t CTRL_BASE_PTR;
X  volatile uint32_t CTRL_BASE_PTR;
N  __IO uint32_t ALT_CTRL_BASE_PTR;
X  volatile uint32_t ALT_CTRL_BASE_PTR;
N  __IO uint32_t WAITONREQ_STATUS;
X  volatile uint32_t WAITONREQ_STATUS;
N  __IO uint32_t CHNL_SW_REQUEST;
X  volatile uint32_t CHNL_SW_REQUEST;
N  __IO uint32_t CHNL_USEBURST_SET;
X  volatile uint32_t CHNL_USEBURST_SET;
N  __IO uint32_t CHNL_USEBURST_CLR;
X  volatile uint32_t CHNL_USEBURST_CLR;
N  __IO uint32_t CHNL_REQ_MASK_SET;
X  volatile uint32_t CHNL_REQ_MASK_SET;
N  __IO uint32_t CHNL_REQ_MASK_CLR;
X  volatile uint32_t CHNL_REQ_MASK_CLR;
N  __IO uint32_t CHNL_ENABLE_SET;
X  volatile uint32_t CHNL_ENABLE_SET;
N  __IO uint32_t CHNL_ENABLE_CLR;
X  volatile uint32_t CHNL_ENABLE_CLR;
N  __IO uint32_t CHNL_PRI_ALT_SET;
X  volatile uint32_t CHNL_PRI_ALT_SET;
N  __IO uint32_t CHNL_PRI_ALT_CLR;
X  volatile uint32_t CHNL_PRI_ALT_CLR;
N  __IO uint32_t CHNL_PRIORITY_SET;
X  volatile uint32_t CHNL_PRIORITY_SET;
N  __IO uint32_t CHNL_PRIORITY_CLR;
X  volatile uint32_t CHNL_PRIORITY_CLR;
N       uint32_t RESERVED0[3];
N  __IO uint32_t ERR_CLR;
X  volatile uint32_t ERR_CLR;
N}MDR_DMA_TypeDef;
N
N/** @} */ /* End of group MDR32Fx_Periph_DMA_Data_Structures */
N
N/** @defgroup MDR32Fx_Periph_DMA_Defines Defines
N  * @{
N  */
N
N/** @defgroup Periph_DMA_STATUS	DMA STATUS
N  * @{
N  */ 
N
N/*-- DMA_STATUS: DMA Status Register -------------------------------*/
N/* Bit field positions: */
N#define DMA_STATUS_MASTER_ENABLE_Pos            0
N#define DMA_STATUS_STATE_Pos                    4
N#define DMA_STATUS_CHNLS_MINUS1_Pos             16
N#define DMA_STATUS_TEST_STATUS_Pos              28
N
N/* Bit field masks: */
N#define DMA_STATUS_MASTER_ENABLE                ((uint32_t)0x00000001)
N#define DMA_STATUS_STATE_Msk                    ((uint32_t)0x000000F0)
N#define DMA_STATUS_CHNLS_MINUS1_Msk             ((uint32_t)0x001F0000)
N#define DMA_STATUS_TEST_STATUS_Msk              ((uint32_t)0xF0000000)
N
N/** @} */ /* End of group DMA_STATUS */
N
N/** @defgroup Periph_DMA_CFG	DMA CFG
N  * @{
N  */ 
N
N/*-- DMA_CFG: DMA Configuration Register ---------------------------*/
N/* Bit field positions: */
N#define DMA_CFG_MASTER_ENABLE_Pos               0
N#define DMA_CFG_CHNL_PROT_CTRL_Pos              5
N
N/* Bit field masks: */
N#define DMA_CFG_MASTER_ENABLE                   ((uint32_t)0x00000001)
N#define DMA_CFG_CHNL_PROT_CTRL_Msk              ((uint32_t)0x000000E0)
N
N/** @} */ /* End of group DMA_CFG */
N
N/** @} */ /* End of group MDR32Fx_Periph_DMA_Defines */
N
N/** @} */ /* End of group MDR32Fx_Periph_DMA */
N
N/** @defgroup MDR32Fx_Periph_UART UART
N  * @{
N  */
N
N/** @defgroup MDR32Fx_Periph_UART_Data_Structures Data Structures
N  * @{
N  */
N
N/* MDR_UART_TypeDef structure */
Ntypedef struct
N{
N  __IO uint32_t DR;
X  volatile uint32_t DR;
N  __IO uint32_t RSR_ECR;
X  volatile uint32_t RSR_ECR;
N       uint32_t RESERVED0[4];
N  __IO uint32_t FR;
X  volatile uint32_t FR;
N       uint32_t RESERVED1;
N  __IO uint32_t ILPR;
X  volatile uint32_t ILPR;
N  __IO uint32_t IBRD;
X  volatile uint32_t IBRD;
N  __IO uint32_t FBRD;
X  volatile uint32_t FBRD;
N  __IO uint32_t LCR_H;
X  volatile uint32_t LCR_H;
N  __IO uint32_t CR;
X  volatile uint32_t CR;
N  __IO uint32_t IFLS;
X  volatile uint32_t IFLS;
N  __IO uint32_t IMSC;
X  volatile uint32_t IMSC;
N  __IO uint32_t RIS;
X  volatile uint32_t RIS;
N  __IO uint32_t MIS;
X  volatile uint32_t MIS;
N  __IO uint32_t ICR;
X  volatile uint32_t ICR;
N  __IO uint32_t DMACR;
X  volatile uint32_t DMACR;
N}MDR_UART_TypeDef;
N
N/** @} */ /* End of group MDR32Fx_Periph_UART_Data_Structures */
N
N/** @defgroup MDR32Fx_Periph_UART_Defines Defines
N  * @{
N  */
N
N/** @defgroup Periph_UART_DR	UART DR
N  * @{
N  */ 
N
N/*-- UART_DR: UART Data Register -----------------------------------*/
N/* Bit field positions: */
N#define UART_DR_DATA_Pos                        0
N#define UART_DR_FE_Pos                          8
N#define UART_DR_PE_Pos                          9
N#define UART_DR_BE_Pos                          10
N#define UART_DR_OE_Pos                          11
N
N/* Bit field masks: */
N#define UART_DR_DATA_Msk                        ((uint32_t)0x000000FF)
N#define UART_DR_FE                              ((uint32_t)0x00000100)
N#define UART_DR_PE                              ((uint32_t)0x00000200)
N#define UART_DR_BE                              ((uint32_t)0x00000400)
N#define UART_DR_OE                              ((uint32_t)0x00000800)
N
N/** @} */ /* End of group UART_DR */
N
N/** @defgroup Periph_UART_RSR_ECR	UART RSR ECR
N  * @{
N  */ 
N
N/*-- UART_RSR_ECR: UART RSR Register -------------------------------*/
N/* Bit field positions: */
N#define UART_RSR_ECR_FE_Pos                     0
N#define UART_RSR_ECR_PE_Pos                     1
N#define UART_RSR_ECR_BE_Pos                     2
N#define UART_RSR_ECR_OE_Pos                     3
N
N/* Bit field masks: */
N#define UART_RSR_ECR_FE                         ((uint32_t)0x00000001)
N#define UART_RSR_ECR_PE                         ((uint32_t)0x00000002)
N#define UART_RSR_ECR_BE                         ((uint32_t)0x00000004)
N#define UART_RSR_ECR_OE                         ((uint32_t)0x00000008)
N
N/** @} */ /* End of group UART_RSR_ECR */
N
N/** @defgroup Periph_UART_FR	UART FR
N  * @{
N  */ 
N
N/*-- UART_FR: UART Flag Register -----------------------------------*/
N/* Bit field positions: */
N#define UART_FR_CTS_Pos                         0
N#define UART_FR_DSR_Pos                         1
N#define UART_FR_DCD_Pos                         2
N#define UART_FR_BUSY_Pos                        3
N#define UART_FR_RXFE_Pos                        4
N#define UART_FR_TXFF_Pos                        5
N#define UART_FR_RXFF_Pos                        6
N#define UART_FR_TXFE_Pos                        7
N#define UART_FR_RI_Pos                          8
N
N/* Bit field masks: */
N#define UART_FR_CTS                             ((uint32_t)0x00000001)
N#define UART_FR_DSR                             ((uint32_t)0x00000002)
N#define UART_FR_DCD                             ((uint32_t)0x00000004)
N#define UART_FR_BUSY                            ((uint32_t)0x00000008)
N#define UART_FR_RXFE                            ((uint32_t)0x00000010)
N#define UART_FR_TXFF                            ((uint32_t)0x00000020)
N#define UART_FR_RXFF                            ((uint32_t)0x00000040)
N#define UART_FR_TXFE                            ((uint32_t)0x00000080)
N#define UART_FR_RI                              ((uint32_t)0x00000100)
N
N/** @} */ /* End of group UART_FR */
N
N/** @defgroup Periph_UART_LCR_H	UART LCR H
N  * @{
N  */ 
N
N/*-- UART_LCR_H: UART LCR_H Register -------------------------------*/
N/* Bit field positions: */
N#define UART_LCR_H_BRK_Pos                      0
N#define UART_LCR_H_PEN_Pos                      1
N#define UART_LCR_H_EPS_Pos                      2
N#define UART_LCR_H_STP2_Pos                     3
N#define UART_LCR_H_FEN_Pos                      4
N#define UART_LCR_H_WLEN_Pos                     5
N#define UART_LCR_H_SPS_Pos                      7
N
N/* Bit field masks: */
N#define UART_LCR_H_BRK                          ((uint32_t)0x00000001)
N#define UART_LCR_H_PEN                          ((uint32_t)0x00000002)
N#define UART_LCR_H_EPS                          ((uint32_t)0x00000004)
N#define UART_LCR_H_STP2                         ((uint32_t)0x00000008)
N#define UART_LCR_H_FEN                          ((uint32_t)0x00000010)
N#define UART_LCR_H_WLEN_Msk                     ((uint32_t)0x00000060)
N#define UART_LCR_H_SPS                          ((uint32_t)0x00000080)
N
N/** @} */ /* End of group UART_LCR_H */
N
N/** @defgroup Periph_UART_CR	UART CR
N  * @{
N  */ 
N
N/*-- UART_CR: UART Command Register --------------------------------*/
N/* Bit field positions: */
N#define UART_CR_UARTEN_Pos                      0
N#define UART_CR_SIREN_Pos                       1
N#define UART_CR_SIRLP_Pos                       2
N#define UART_CR_LBE_Pos                         7
N#define UART_CR_TXE_Pos                         8
N#define UART_CR_RXE_Pos                         9
N#define UART_CR_DTR_Pos                         10
N#define UART_CR_RTS_Pos                         11
N#define UART_CR_OUT1_Pos                        12
N#define UART_CR_OUT2_Pos                        13
N#define UART_CR_RTSEN_Pos                       14
N#define UART_CR_CTSEN_Pos                       15
N
N/* Bit field masks: */
N#define UART_CR_UARTEN                          ((uint32_t)0x00000001)
N#define UART_CR_SIREN                           ((uint32_t)0x00000002)
N#define UART_CR_SIRLP                           ((uint32_t)0x00000004)
N#define UART_CR_LBE                             ((uint32_t)0x00000080)
N#define UART_CR_TXE                             ((uint32_t)0x00000100)
N#define UART_CR_RXE                             ((uint32_t)0x00000200)
N#define UART_CR_DTR                             ((uint32_t)0x00000400)
N#define UART_CR_RTS                             ((uint32_t)0x00000800)
N#define UART_CR_OUT1                            ((uint32_t)0x00001000)
N#define UART_CR_OUT2                            ((uint32_t)0x00002000)
N#define UART_CR_RTSEN                           ((uint32_t)0x00004000)
N#define UART_CR_CTSEN                           ((uint32_t)0x00008000)
N
N/** @} */ /* End of group UART_CR */
N
N/** @defgroup Periph_UART_IFLS	UART IFLS
N  * @{
N  */ 
N
N/*-- UART_IFLS: UART IFLS Register ---------------------------------*/
N/* Bit field positions: */
N#define UART_IFLS_TXIFLSEL_Pos                  0
N#define UART_IFLS_RXIFLSEL_Pos                  3
N
N/* Bit field masks: */
N#define UART_IFLS_TXIFLSEL_Msk                  ((uint32_t)0x00000007)
N#define UART_IFLS_RXIFLSEL_Msk                  ((uint32_t)0x00000038)
N
N/** @} */ /* End of group UART_IFLS */
N
N/** @defgroup Periph_UART_IMSC	UART IMSC
N  * @{
N  */ 
N
N/*-- UART_IMSC: UART Interrupt Mask Register -----------------------*/
N/* Bit field positions: */
N#define UART_IMSC_RIMIM_Pos                     0
N#define UART_IMSC_CTSMIM_Pos                    1
N#define UART_IMSC_DCDMIM_Pos                    2
N#define UART_IMSC_DSRMIM_Pos                    3
N#define UART_IMSC_RXIM_Pos                      4
N#define UART_IMSC_TXIM_Pos                      5
N#define UART_IMSC_RTIM_Pos                      6
N#define UART_IMSC_FEIM_Pos                      7
N#define UART_IMSC_PEIM_Pos                      8
N#define UART_IMSC_BEIM_Pos                      9
N#define UART_IMSC_OEIM_Pos                      10
N
N/* Bit field masks: */
N#define UART_IMSC_RIMIM                         ((uint32_t)0x00000001)
N#define UART_IMSC_CTSMIM                        ((uint32_t)0x00000002)
N#define UART_IMSC_DCDMIM                        ((uint32_t)0x00000004)
N#define UART_IMSC_DSRMIM                        ((uint32_t)0x00000008)
N#define UART_IMSC_RXIM                          ((uint32_t)0x00000010)
N#define UART_IMSC_TXIM                          ((uint32_t)0x00000020)
N#define UART_IMSC_RTIM                          ((uint32_t)0x00000040)
N#define UART_IMSC_FEIM                          ((uint32_t)0x00000080)
N#define UART_IMSC_PEIM                          ((uint32_t)0x00000100)
N#define UART_IMSC_BEIM                          ((uint32_t)0x00000200)
N#define UART_IMSC_OEIM                          ((uint32_t)0x00000400)
N
N/** @} */ /* End of group UART_IMSC */
N
N/** @defgroup Periph_UART_RIS	UART RIS
N  * @{
N  */ 
N
N/*-- UART_RIS: UART Interrupt Pending Register ---------------------*/
N/* Bit field positions: */
N#define UART_RIS_RIRMIS_Pos                     0
N#define UART_RIS_CTSRMIS_Pos                    1
N#define UART_RIS_DCDRMIS_Pos                    2
N#define UART_RIS_DSRRMIS_Pos                    3
N#define UART_RIS_RXRIS_Pos                      4
N#define UART_RIS_TXRIS_Pos                      5
N#define UART_RIS_RTRIS_Pos                      6
N#define UART_RIS_FERIS_Pos                      7
N#define UART_RIS_PERIS_Pos                      8
N#define UART_RIS_BERIS_Pos                      9
N#define UART_RIS_OERIS_Pos                      10
N
N/* Bit field masks: */
N#define UART_RIS_RIRMIS                         ((uint32_t)0x00000001)
N#define UART_RIS_CTSRMIS                        ((uint32_t)0x00000002)
N#define UART_RIS_DCDRMIS                        ((uint32_t)0x00000004)
N#define UART_RIS_DSRRMIS                        ((uint32_t)0x00000008)
N#define UART_RIS_RXRIS                          ((uint32_t)0x00000010)
N#define UART_RIS_TXRIS                          ((uint32_t)0x00000020)
N#define UART_RIS_RTRIS                          ((uint32_t)0x00000040)
N#define UART_RIS_FERIS                          ((uint32_t)0x00000080)
N#define UART_RIS_PERIS                          ((uint32_t)0x00000100)
N#define UART_RIS_BERIS                          ((uint32_t)0x00000200)
N#define UART_RIS_OERIS                          ((uint32_t)0x00000400)
N
N/** @} */ /* End of group UART_RIS */
N
N/** @defgroup Periph_UART_MIS	UART MIS
N  * @{
N  */ 
N
N/*-- UART_MIS: UART Masked Interrupt Pending Register --------------*/
N/* Bit field positions: */
N#define UART_MIS_RIMMIS_Pos                     0
N#define UART_MIS_CTSMMIS_Pos                    1
N#define UART_MIS_DCDMMIS_Pos                    2
N#define UART_MIS_DSRMMIS_Pos                    3
N#define UART_MIS_RXMIS_Pos                      4
N#define UART_MIS_TXMIS_Pos                      5
N#define UART_MIS_RTMIS_Pos                      6
N#define UART_MIS_FEMIS_Pos                      7
N#define UART_MIS_PEMIS_Pos                      8
N#define UART_MIS_BEMIS_Pos                      9
N#define UART_MIS_OEMIS_Pos                      10
N
N/* Bit field masks: */
N#define UART_MIS_RIMMIS                         ((uint32_t)0x00000001)
N#define UART_MIS_CTSMMIS                        ((uint32_t)0x00000002)
N#define UART_MIS_DCDMMIS                        ((uint32_t)0x00000004)
N#define UART_MIS_DSRMMIS                        ((uint32_t)0x00000008)
N#define UART_MIS_RXMIS                          ((uint32_t)0x00000010)
N#define UART_MIS_TXMIS                          ((uint32_t)0x00000020)
N#define UART_MIS_RTMIS                          ((uint32_t)0x00000040)
N#define UART_MIS_FEMIS                          ((uint32_t)0x00000080)
N#define UART_MIS_PEMIS                          ((uint32_t)0x00000100)
N#define UART_MIS_BEMIS                          ((uint32_t)0x00000200)
N#define UART_MIS_OEMIS                          ((uint32_t)0x00000400)
N
N/** @} */ /* End of group UART_MIS */
N
N/** @defgroup Periph_UART_ICR	UART ICR
N  * @{
N  */ 
N
N/*-- UART_ICR: UART Interrupt Clear Register -----------------------*/
N/* Bit field positions: */
N#define UART_ICR_RIMIC_Pos                      0
N#define UART_ICR_CTSMIC_Pos                     1
N#define UART_ICR_DCDMIC_Pos                     2
N#define UART_ICR_DSRMIC_Pos                     3
N#define UART_ICR_RXIC_Pos                       4
N#define UART_ICR_TXIC_Pos                       5
N#define UART_ICR_RTIC_Pos                       6
N#define UART_ICR_FEIC_Pos                       7
N#define UART_ICR_PEIC_Pos                       8
N#define UART_ICR_BEIC_Pos                       9
N#define UART_ICR_OEIC_Pos                       10
N
N/* Bit field masks: */
N#define UART_ICR_RIMIC                          ((uint32_t)0x00000001)
N#define UART_ICR_CTSMIC                         ((uint32_t)0x00000002)
N#define UART_ICR_DCDMIC                         ((uint32_t)0x00000004)
N#define UART_ICR_DSRMIC                         ((uint32_t)0x00000008)
N#define UART_ICR_RXIC                           ((uint32_t)0x00000010)
N#define UART_ICR_TXIC                           ((uint32_t)0x00000020)
N#define UART_ICR_RTIC                           ((uint32_t)0x00000040)
N#define UART_ICR_FEIC                           ((uint32_t)0x00000080)
N#define UART_ICR_PEIC                           ((uint32_t)0x00000100)
N#define UART_ICR_BEIC                           ((uint32_t)0x00000200)
N#define UART_ICR_OEIC                           ((uint32_t)0x00000400)
N
N/** @} */ /* End of group UART_ICR */
N
N/** @defgroup Periph_UART_DMACR	UART DMACR
N  * @{
N  */ 
N
N/*-- UART_DMACR: UART DMA Control Register -------------------------*/
N/* Bit field positions: */
N#define UART_DMACR_RXDMAE_Pos                   0
N#define UART_DMACR_TXDMAE_Pos                   1
N#define UART_DMACR_DMAONERR_Pos                 2
N
N/* Bit field masks: */
N#define UART_DMACR_RXDMAE                       ((uint32_t)0x00000001)
N#define UART_DMACR_TXDMAE                       ((uint32_t)0x00000002)
N#define UART_DMACR_DMAONERR                     ((uint32_t)0x00000004)
N
N/** @} */ /* End of group UART_DMACR */
N
N/** @} */ /* End of group MDR32Fx_Periph_UART_Defines */
N
N/** @} */ /* End of group MDR32Fx_Periph_UART */
N
N/** @defgroup MDR32Fx_Periph_SSP SSP
N  * @{
N  */
N
N/** @defgroup MDR32Fx_Periph_SSP_Data_Structures Data Structures
N  * @{
N  */
N
N/* MDR_SSP_TypeDef structure */
Ntypedef struct
N{
N  __IO uint32_t CR0;
X  volatile uint32_t CR0;
N  __IO uint32_t CR1;
X  volatile uint32_t CR1;
N  __IO uint32_t DR;
X  volatile uint32_t DR;
N  __IO uint32_t SR;
X  volatile uint32_t SR;
N  __IO uint32_t CPSR;
X  volatile uint32_t CPSR;
N  __IO uint32_t IMSC;
X  volatile uint32_t IMSC;
N  __IO uint32_t RIS;
X  volatile uint32_t RIS;
N  __IO uint32_t MIS;
X  volatile uint32_t MIS;
N  __IO uint32_t ICR;
X  volatile uint32_t ICR;
N  __IO uint32_t DMACR;
X  volatile uint32_t DMACR;
N}MDR_SSP_TypeDef;
N
N/** @} */ /* End of group MDR32Fx_Periph_SSP_Data_Structures */
N
N/** @defgroup MDR32Fx_Periph_SSP_Defines Defines
N  * @{
N  */
N
N/** @defgroup Periph_SSP_CR0	SSP CR0
N  * @{
N  */ 
N
N/*-- SSP_CR0: SSP Control0 Register --------------------------------*/
N/* Bit field positions: */
N#define SSP_CR0_DSS_Pos                         0
N#define SSP_CR0_FRF_Pos                         4
N#define SSP_CR0_SPO_Pos                         6
N#define SSP_CR0_SPH_Pos                         7
N#define SSP_CR0_SCR_Pos                         8
N
N/* Bit field masks: */
N#define SSP_CR0_DSS_Msk                         ((uint32_t)0x0000000F)
N#define SSP_CR0_FRF_Msk                         ((uint32_t)0x00000030)
N#define SSP_CR0_SPO                             ((uint32_t)0x00000040)
N#define SSP_CR0_SPH                             ((uint32_t)0x00000080)
N#define SSP_CR0_SCR_Msk                         ((uint32_t)0x0000FF00)
N
N/** @} */ /* End of group SSP_CR0 */
N
N/** @defgroup Periph_SSP_CR1	SSP CR1
N  * @{
N  */ 
N
N/*-- SSP_CR1: SSP Control1 Register --------------------------------*/
N/* Bit field positions: */
N#define SSP_CR1_LBM_Pos                         0
N#define SSP_CR1_SSE_Pos                         1
N#define SSP_CR1_MS_Pos                          2
N#define SSP_CR1_SOD_Pos                         3
N
N/* Bit field masks: */
N#define SSP_CR1_LBM                             ((uint32_t)0x00000001)
N#define SSP_CR1_SSE                             ((uint32_t)0x00000002)
N#define SSP_CR1_MS                              ((uint32_t)0x00000004)
N#define SSP_CR1_SOD                             ((uint32_t)0x00000008)
N
N/** @} */ /* End of group SSP_CR1 */
N
N/** @defgroup Periph_SSP_SR	SSP SR
N  * @{
N  */ 
N
N/*-- SSP_SR: SSP Status Register -----------------------------------*/
N/* Bit field positions: */
N#define SSP_SR_TFE_Pos                          0
N#define SSP_SR_TNF_Pos                          1
N#define SSP_SR_RNE_Pos                          2
N#define SSP_SR_RFF_Pos                          3
N#define SSP_SR_BSY_Pos                          4
N
N/* Bit field masks: */
N#define SSP_SR_TFE                              ((uint32_t)0x00000001)
N#define SSP_SR_TNF                              ((uint32_t)0x00000002)
N#define SSP_SR_RNE                              ((uint32_t)0x00000004)
N#define SSP_SR_RFF                              ((uint32_t)0x00000008)
N#define SSP_SR_BSY                              ((uint32_t)0x00000010)
N
N/** @} */ /* End of group SSP_SR */
N
N/** @defgroup Periph_SSP_IMSC	SSP IMSC
N  * @{
N  */ 
N
N/*-- SSP_IMSC: SSP Interrupt Mask Register -------------------------*/
N/* Bit field positions: */
N#define SSP_IMSC_RORIM_Pos                      0
N#define SSP_IMSC_RTIM_Pos                       1
N#define SSP_IMSC_RXIM_Pos                       2
N#define SSP_IMSC_TXIM_Pos                       3
N
N/* Bit field masks: */
N#define SSP_IMSC_RORIM                          ((uint32_t)0x00000001)
N#define SSP_IMSC_RTIM                           ((uint32_t)0x00000002)
N#define SSP_IMSC_RXIM                           ((uint32_t)0x00000004)
N#define SSP_IMSC_TXIM                           ((uint32_t)0x00000008)
N
N/** @} */ /* End of group SSP_IMSC */
N
N/** @defgroup Periph_SSP_RIS	SSP RIS
N  * @{
N  */ 
N
N/*-- SSP_RIS: SSP Interrupt Pending Register -----------------------*/
N/* Bit field positions: */
N#define SSP_RIS_RORRIS_Pos                      0
N#define SSP_RIS_RTRIS_Pos                       1
N#define SSP_RIS_RXRIS_Pos                       2
N#define SSP_RIS_TXRIS_Pos                       3
N
N/* Bit field masks: */
N#define SSP_RIS_RORRIS                          ((uint32_t)0x00000001)
N#define SSP_RIS_RTRIS                           ((uint32_t)0x00000002)
N#define SSP_RIS_RXRIS                           ((uint32_t)0x00000004)
N#define SSP_RIS_TXRIS                           ((uint32_t)0x00000008)
N
N/** @} */ /* End of group SSP_RIS */
N
N/** @defgroup Periph_SSP_MIS	SSP MIS
N  * @{
N  */ 
N
N/*-- SSP_MIS: SSP Masked Interrupt Pending Register ----------------*/
N/* Bit field positions: */
N#define SSP_MIS_RORMIS_Pos                      0
N#define SSP_MIS_RTMIS_Pos                       1
N#define SSP_MIS_RXMIS_Pos                       2
N#define SSP_MIS_TXMIS_Pos                       3
N
N/* Bit field masks: */
N#define SSP_MIS_RORMIS                          ((uint32_t)0x00000001)
N#define SSP_MIS_RTMIS                           ((uint32_t)0x00000002)
N#define SSP_MIS_RXMIS                           ((uint32_t)0x00000004)
N#define SSP_MIS_TXMIS                           ((uint32_t)0x00000008)
N
N/** @} */ /* End of group SSP_MIS */
N
N/** @defgroup Periph_SSP_ICR	SSP ICR
N  * @{
N  */ 
N
N/*-- SSP_ICR: SSP Interrupt Clear Register -------------------------*/
N/* Bit field positions: */
N#define SSP_ICR_RORIC_Pos                       0
N#define SSP_ICR_RTIC_Pos                        1
N
N/* Bit field masks: */
N#define SSP_ICR_RORIC                           ((uint32_t)0x00000001)
N#define SSP_ICR_RTIC                            ((uint32_t)0x00000002)
N
N/** @} */ /* End of group SSP_ICR */
N
N/** @defgroup Periph_SSP_DMACR	SSP DMACR
N  * @{
N  */ 
N
N/*-- SSP_DMACR: SSP DMA Control Register ---------------------------*/
N/* Bit field positions: */
N#define SSP_DMACR_RXDMAE_Pos                    0
N#define SSP_DMACR_TXDMAE_Pos                    1
N
N/* Bit field masks: */
N#define SSP_DMACR_RXDMAE                        ((uint32_t)0x00000001)
N#define SSP_DMACR_TXDMAE                        ((uint32_t)0x00000002)
N
N/** @} */ /* End of group SSP_DMACR */
N
N/** @} */ /* End of group MDR32Fx_Periph_SSP_Defines */
N
N/** @} */ /* End of group MDR32Fx_Periph_SSP */
N
N/** @defgroup MDR32Fx_Periph_I2C I2C
N  * @{
N  */
N
N/** @defgroup MDR32Fx_Periph_I2C_Data_Structures Data Structures
N  * @{
N  */
N
N/* MDR_I2C_TypeDef structure */
Ntypedef struct
N{
N  __IO uint32_t PRL;
X  volatile uint32_t PRL;
N  __IO uint32_t PRH;
X  volatile uint32_t PRH;
N  __IO uint32_t CTR;
X  volatile uint32_t CTR;
N  __IO uint32_t RXD;
X  volatile uint32_t RXD;
N  __IO uint32_t STA;
X  volatile uint32_t STA;
N  __IO uint32_t TXD;
X  volatile uint32_t TXD;
N  __IO uint32_t CMD;
X  volatile uint32_t CMD;
N}MDR_I2C_TypeDef;
N
N/** @} */ /* End of group MDR32Fx_Periph_I2C_Data_Structures */
N
N/** @defgroup MDR32Fx_Periph_I2C_Defines Defines
N  * @{
N  */
N
N/** @defgroup Periph_I2C_CTR	I2C CTR
N  * @{
N  */ 
N
N/*-- I2C_CTR: I2C Control Register ---------------------------------*/
N/* Bit field positions: */
N#define I2C_CTR_S_I2C_Pos                       5
N#define I2C_CTR_EN_INT_Pos                      6
N#define I2C_CTR_EN_I2C_Pos                      7
N
N/* Bit field masks: */
N#define I2C_CTR_S_I2C                           ((uint32_t)0x00000020)
N#define I2C_CTR_EN_INT                          ((uint32_t)0x00000040)
N#define I2C_CTR_EN_I2C                          ((uint32_t)0x00000080)
N
N/** @} */ /* End of group I2C_CTR */
N
N/** @defgroup Periph_I2C_STA	I2C STA
N  * @{
N  */ 
N
N/*-- I2C_STA: I2C Status Register ----------------------------------*/
N/* Bit field positions: */
N#define I2C_STA_INT_Pos                         0
N#define I2C_STA_TR_PROG_Pos                     1
N#define I2C_STA_LOST_ARB_Pos                    5
N#define I2C_STA_BUSY_Pos                        6
N#define I2C_STA_RX_ACK_Pos                      7
N
N/* Bit field masks: */
N#define I2C_STA_INT                             ((uint32_t)0x00000001)
N#define I2C_STA_TR_PROG                         ((uint32_t)0x00000002)
N#define I2C_STA_LOST_ARB                        ((uint32_t)0x00000020)
N#define I2C_STA_BUSY                            ((uint32_t)0x00000040)
N#define I2C_STA_RX_ACK                          ((uint32_t)0x00000080)
N
N/** @} */ /* End of group I2C_STA */
N
N/** @defgroup Periph_I2C_CMD	I2C CMD
N  * @{
N  */ 
N
N/*-- I2C_CMD: I2C Command Register ---------------------------------*/
N/* Bit field positions: */
N#define I2C_CMD_CLRINT_Pos                      0
N#define I2C_CMD_ACK_Pos                         3
N#define I2C_CMD_WR_Pos                          4
N#define I2C_CMD_RD_Pos                          5
N#define I2C_CMD_STOP_Pos                        6
N#define I2C_CMD_START_Pos                       7
N
N/* Bit field masks: */
N#define I2C_CMD_CLRINT                          ((uint32_t)0x00000001)
N#define I2C_CMD_ACK                             ((uint32_t)0x00000008)
N#define I2C_CMD_WR                              ((uint32_t)0x00000010)
N#define I2C_CMD_RD                              ((uint32_t)0x00000020)
N#define I2C_CMD_STOP                            ((uint32_t)0x00000040)
N#define I2C_CMD_START                           ((uint32_t)0x00000080)
N
N/** @} */ /* End of group I2C_CMD */
N
N/** @} */ /* End of group MDR32Fx_Periph_I2C_Defines */
N
N/** @} */ /* End of group MDR32Fx_Periph_I2C */
N
N/** @defgroup MDR32Fx_Periph_POWER POWER
N  * @{
N  */
N
N/** @defgroup MDR32Fx_Periph_POWER_Data_Structures Data Structures
N  * @{
N  */
N
N/* MDR_POWER_TypeDef structure */
Ntypedef struct
N{
N  __IO uint32_t PVDCS;
X  volatile uint32_t PVDCS;
N}MDR_POWER_TypeDef;
N
N/** @} */ /* End of group MDR32Fx_Periph_POWER_Data_Structures */
N
N/** @defgroup MDR32Fx_Periph_POWER_Defines Defines
N  * @{
N  */
N
N/** @defgroup Periph_POWER_PVDCS	POWER PVDCS
N  * @{
N  */ 
N
N/*-- POWER_PVDCS: POWER Power Detector Control/Status Register -----*/
N/* Bit field positions: */
N#define POWER_PVDCS_PVDEN_Pos                   0
N#define POWER_PVDCS_PBLS_Pos                    1
N#define POWER_PVDCS_PLS_Pos                     3
N#define POWER_PVDCS_PVBD_Pos                    6
N#define POWER_PVDCS_PVD_Pos                     7
N#define POWER_PVDCS_IEPVBD_Pos                  8
N#define POWER_PVDCS_IEPVD_Pos                   9
N#define POWER_PVDCS_INVB_Pos                    10
N#define POWER_PVDCS_INV_Pos                     11
N
N/* Bit field masks: */
N#define POWER_PVDCS_PVDEN                       ((uint32_t)0x00000001)
N#define POWER_PVDCS_PBLS_Msk                    ((uint32_t)0x00000006)
N#define POWER_PVDCS_PLS_Msk                     ((uint32_t)0x00000038)
N#define POWER_PVDCS_PVBD                        ((uint32_t)0x00000040)
N#define POWER_PVDCS_PVD                         ((uint32_t)0x00000080)
N#define POWER_PVDCS_IEPVBD                      ((uint32_t)0x00000100)
N#define POWER_PVDCS_IEPVD                       ((uint32_t)0x00000200)
N#define POWER_PVDCS_INVB                        ((uint32_t)0x00000400)
N#define POWER_PVDCS_INV                         ((uint32_t)0x00000800)
N
N/** @} */ /* End of group POWER_PVDCS */
N
N/** @} */ /* End of group MDR32Fx_Periph_POWER_Defines */
N
N/** @} */ /* End of group MDR32Fx_Periph_POWER */
N
N/** @defgroup MDR32Fx_Periph_WWDG WWDG
N  * @{
N  */
N
N/** @defgroup MDR32Fx_Periph_WWDG_Data_Structures Data Structures
N  * @{
N  */
N
N/* MDR_WWDG_TypeDef structure */
Ntypedef struct
N{
N  __IO uint32_t CR;
X  volatile uint32_t CR;
N  __IO uint32_t CFR;
X  volatile uint32_t CFR;
N  __IO uint32_t SR;
X  volatile uint32_t SR;
N}MDR_WWDG_TypeDef;
N
N/** @} */ /* End of group MDR32Fx_Periph_WWDG_Data_Structures */
N
N/** @defgroup MDR32Fx_Periph_WWDG_Defines Defines
N  * @{
N  */
N
N/** @defgroup Periph_WWDG_CR	WWDG CR
N  * @{
N  */ 
N
N/*-- WWDG_CR: WWDG Command Register --------------------------------*/
N/* Bit field positions: */
N#define WWDG_CR_T_Pos                           0
N#define WWDG_CR_WDGA_Pos                        7
N
N/* Bit field masks: */
N#define WWDG_CR_T_Msk                           ((uint32_t)0x0000007F)
N#define WWDG_CR_WDGA                            ((uint32_t)0x00000080)
N
N/** @} */ /* End of group WWDG_CR */
N
N/** @defgroup Periph_WWDG_CFR	WWDG CFR
N  * @{
N  */ 
N
N/*-- WWDG_CFR: WWDG Configuration Register -------------------------*/
N/* Bit field positions: */
N#define WWDG_CFR_W_Pos                          0
N#define WWDG_CFR_WGTB_Pos                       7
N#define WWDG_CFR_EWI_Pos                        9
N
N/* Bit field masks: */
N#define WWDG_CFR_W_Msk                          ((uint32_t)0x0000007F)
N#define WWDG_CFR_WGTB_Msk                       ((uint32_t)0x00000180)
N#define WWDG_CFR_EWI                            ((uint32_t)0x00000200)
N
N/** @} */ /* End of group WWDG_CFR */
N
N/** @} */ /* End of group MDR32Fx_Periph_WWDG_Defines */
N
N/** @} */ /* End of group MDR32Fx_Periph_WWDG */
N
N/** @defgroup MDR32Fx_Periph_IWDG IWDG
N  * @{
N  */
N
N/** @defgroup MDR32Fx_Periph_IWDG_Data_Structures Data Structures
N  * @{
N  */
N
N/* MDR_IWDG_TypeDef structure */
Ntypedef struct
N{
N  __IO uint32_t KR;
X  volatile uint32_t KR;
N  __IO uint32_t PR;
X  volatile uint32_t PR;
N  __IO uint32_t RLR;
X  volatile uint32_t RLR;
N  __IO uint32_t SR;
X  volatile uint32_t SR;
N}MDR_IWDG_TypeDef;
N
N/** @} */ /* End of group MDR32Fx_Periph_IWDG_Data_Structures */
N
N/** @defgroup MDR32Fx_Periph_IWDG_Defines Defines
N  * @{
N  */
N
N/** @defgroup Periph_IWDG_SR	IWDG SR
N  * @{
N  */ 
N
N/*-- IWDG_SR: IWDG Status Register ---------------------------------*/
N/* Bit field positions: */
N#define IWDG_SR_PVU_Pos                         0
N#define IWDG_SR_RVU_Pos                         1
N
N/* Bit field masks: */
N#define IWDG_SR_PVU                             ((uint32_t)0x00000001)
N#define IWDG_SR_RVU                             ((uint32_t)0x00000002)
N
N/** @} */ /* End of group IWDG_SR */
N
N/** @} */ /* End of group MDR32Fx_Periph_IWDG_Defines */
N
N/** @} */ /* End of group MDR32Fx_Periph_IWDG */
N
N/** @defgroup MDR32Fx_Periph_TIMER TIMER
N  * @{
N  */
N
N/** @defgroup MDR32Fx_Periph_TIMER_Data_Structures Data Structures
N  * @{
N  */
N
N/* MDR_TIMER_TypeDef structure */
Ntypedef struct
N{
N  __IO uint32_t CNT;
X  volatile uint32_t CNT;
N  __IO uint32_t PSG;
X  volatile uint32_t PSG;
N  __IO uint32_t ARR;
X  volatile uint32_t ARR;
N  __IO uint32_t CNTRL;
X  volatile uint32_t CNTRL;
N  __IO uint32_t CCR1;
X  volatile uint32_t CCR1;
N  __IO uint32_t CCR2;
X  volatile uint32_t CCR2;
N  __IO uint32_t CCR3;
X  volatile uint32_t CCR3;
N  __IO uint32_t CCR4;
X  volatile uint32_t CCR4;
N  __IO uint32_t CH1_CNTRL;
X  volatile uint32_t CH1_CNTRL;
N  __IO uint32_t CH2_CNTRL;
X  volatile uint32_t CH2_CNTRL;
N  __IO uint32_t CH3_CNTRL;
X  volatile uint32_t CH3_CNTRL;
N  __IO uint32_t CH4_CNTRL;
X  volatile uint32_t CH4_CNTRL;
N  __IO uint32_t CH1_CNTRL1;
X  volatile uint32_t CH1_CNTRL1;
N  __IO uint32_t CH2_CNTRL1;
X  volatile uint32_t CH2_CNTRL1;
N  __IO uint32_t CH3_CNTRL1;
X  volatile uint32_t CH3_CNTRL1;
N  __IO uint32_t CH4_CNTRL1;
X  volatile uint32_t CH4_CNTRL1;
N  __IO uint32_t CH1_DTG;
X  volatile uint32_t CH1_DTG;
N  __IO uint32_t CH2_DTG;
X  volatile uint32_t CH2_DTG;
N  __IO uint32_t CH3_DTG;
X  volatile uint32_t CH3_DTG;
N  __IO uint32_t CH4_DTG;
X  volatile uint32_t CH4_DTG;
N  __IO uint32_t BRKETR_CNTRL;
X  volatile uint32_t BRKETR_CNTRL;
N  __IO uint32_t STATUS;
X  volatile uint32_t STATUS;
N  __IO uint32_t IE;
X  volatile uint32_t IE;
N  __IO uint32_t DMA_RE;
X  volatile uint32_t DMA_RE;
N  __IO uint32_t CH1_CNTRL2;
X  volatile uint32_t CH1_CNTRL2;
N  __IO uint32_t CH2_CNTRL2;
X  volatile uint32_t CH2_CNTRL2;
N  __IO uint32_t CH3_CNTRL2;
X  volatile uint32_t CH3_CNTRL2;
N  __IO uint32_t CH4_CNTRL2;
X  volatile uint32_t CH4_CNTRL2;
N  __IO uint32_t CCR11;
X  volatile uint32_t CCR11;
N  __IO uint32_t CCR21;
X  volatile uint32_t CCR21;
N  __IO uint32_t CCR31;
X  volatile uint32_t CCR31;
N  __IO uint32_t CCR41;
X  volatile uint32_t CCR41;
N}MDR_TIMER_TypeDef;
N
N/** @} */ /* End of group MDR32Fx_Periph_TIMER_Data_Structures */
N
N/** @defgroup MDR32Fx_Periph_TIMER_Defines Defines
N  * @{
N  */
N
N/** @defgroup Periph_TIMER_CNTRL	TIMER CNTRL
N  * @{
N  */ 
N
N/*-- TIMER_CNTRL: Timer Control Register ---------------------------*/
N/* Bit field positions: */
N#define TIMER_CNTRL_CNT_EN_Pos                  0
N#define TIMER_CNTRL_ARRB_EN_Pos                 1
N#define TIMER_CNTRL_WR_CMPL_Pos                 2
N#define TIMER_CNTRL_DIR_Pos                     3
N#define TIMER_CNTRL_FDTS_Pos                    4
N#define TIMER_CNTRL_CNT_MODE_Pos                6
N#define TIMER_CNTRL_EVENT_SEL_Pos               8
N
N/* Bit field masks: */
N#define TIMER_CNTRL_CNT_EN                      ((uint32_t)0x00000001)
N#define TIMER_CNTRL_ARRB_EN                     ((uint32_t)0x00000002)
N#define TIMER_CNTRL_WR_CMPL                     ((uint32_t)0x00000004)
N#define TIMER_CNTRL_DIR                         ((uint32_t)0x00000008)
N#define TIMER_CNTRL_FDTS_Msk                    ((uint32_t)0x00000030)
N#define TIMER_CNTRL_CNT_MODE_Msk                ((uint32_t)0x000000C0)
N#define TIMER_CNTRL_EVENT_SEL_Msk               ((uint32_t)0x00000F00)
N
N/** @} */ /* End of group TIMER_CNTRL */
N
N/** @defgroup Periph_TIMER_CH_CNTRL	TIMER CH CNTRL
N  * @{
N  */ 
N
N/*-- TIMER_CH_CNTRL: Timer Channel Control Register ----------------*/
N/* Bit field positions: */
N#define TIMER_CH_CNTRL_CHFLTR_Pos               0
N#define TIMER_CH_CNTRL_CHSEL_Pos                4
N#define TIMER_CH_CNTRL_CHPSC_Pos                6
N#define TIMER_CH_CNTRL_OCCE_Pos                 8
N#define TIMER_CH_CNTRL_OCCM_Pos                 9
N#define TIMER_CH_CNTRL_BRKEN_Pos                12
N#define TIMER_CH_CNTRL_ETREN_Pos                13
N#define TIMER_CH_CNTRL_WR_CMPL_Pos              14
N#define TIMER_CH_CNTRL_CAP_NPWM_Pos             15
N
N/* Bit field masks: */
N#define TIMER_CH_CNTRL_CHFLTR_Msk               ((uint32_t)0x0000000F)
N#define TIMER_CH_CNTRL_CHSEL_Msk                ((uint32_t)0x00000030)
N#define TIMER_CH_CNTRL_CHPSC_Msk                ((uint32_t)0x000000C0)
N#define TIMER_CH_CNTRL_OCCE                     ((uint32_t)0x00000100)
N#define TIMER_CH_CNTRL_OCCM_Msk                 ((uint32_t)0x00000E00)
N#define TIMER_CH_CNTRL_BRKEN                    ((uint32_t)0x00001000)
N#define TIMER_CH_CNTRL_ETREN                    ((uint32_t)0x00002000)
N#define TIMER_CH_CNTRL_WR_CMPL                  ((uint32_t)0x00004000)
N#define TIMER_CH_CNTRL_CAP_NPWM                 ((uint32_t)0x00008000)
N
N/** @} */ /* End of group TIMER_CH_CNTRL */
N
N/** @defgroup Periph_TIMER_CH_CNTRL1	TIMER CH CNTRL1
N  * @{
N  */ 
N
N/*-- TIMER_CH_CNTRL1: Timer Channel Control1 Register --------------*/
N/* Bit field positions: */
N#define TIMER_CH_CNTRL1_SELOE_Pos               0
N#define TIMER_CH_CNTRL1_SELO_Pos                2
N#define TIMER_CH_CNTRL1_INV_Pos                 4
N#define TIMER_CH_CNTRL1_NSELOE_Pos              8
N#define TIMER_CH_CNTRL1_NSELO_Pos               10
N#define TIMER_CH_CNTRL1_NINV_Pos                12
N
N/* Bit field masks: */
N#define TIMER_CH_CNTRL1_SELOE_Msk               ((uint32_t)0x00000003)
N#define TIMER_CH_CNTRL1_SELO_Msk                ((uint32_t)0x0000000C)
N#define TIMER_CH_CNTRL1_INV                     ((uint32_t)0x00000010)
N#define TIMER_CH_CNTRL1_NSELOE_Msk              ((uint32_t)0x00000300)
N#define TIMER_CH_CNTRL1_NSELO_Msk               ((uint32_t)0x00000C00)
N#define TIMER_CH_CNTRL1_NINV                    ((uint32_t)0x00001000)
N
N/** @} */ /* End of group TIMER_CH_CNTRL1 */
N
N/** @defgroup Periph_TIMER_CH_DTG	TIMER CH DTG
N  * @{
N  */ 
N
N/*-- TIMER_CH_DTG: Timer Channel DTG Register ----------------------*/
N/* Bit field positions: */
N#define TIMER_CH_DTGX_Pos                       0
N#define TIMER_CH_DTG_EDTS_Pos                   4
N#define TIMER_CH_DTG_Pos                        8
N
N/* Bit field masks: */
N#define TIMER_CH_DTGX_Msk                       ((uint32_t)0x0000000F)
N#define TIMER_CH_DTG_EDTS                       ((uint32_t)0x00000010)
N#define TIMER_CH_DTG_Msk                        ((uint32_t)0x0000FF00)
N
N/** @} */ /* End of group TIMER_CH_DTG */
N
N/** @defgroup Periph_TIMER_BRKETR_CNTRL	TIMER BRKETR CNTRL
N  * @{
N  */ 
N
N/*-- TIMER_BRKETR_CNTRL: Timer BRK/ETR Control Register ------------*/
N/* Bit field positions: */
N#define TIMER_BRKETR_CNTRL_BRK_INV_Pos          0
N#define TIMER_BRKETR_CNTRL_ETR_INV_Pos          1
N#define TIMER_BRKETR_CNTRL_ETR_PSC_Pos          2
N#define TIMER_BRKETR_CNTRL_ETR_FILTER_Pos       4
N
N/* Bit field masks: */
N#define TIMER_BRKETR_CNTRL_BRK_INV              ((uint32_t)0x00000001)
N#define TIMER_BRKETR_CNTRL_ETR_INV              ((uint32_t)0x00000002)
N#define TIMER_BRKETR_CNTRL_ETR_PSC_Msk          ((uint32_t)0x0000000C)
N#define TIMER_BRKETR_CNTRL_ETR_FILTER_Msk       ((uint32_t)0x000000F0)
N
N/** @} */ /* End of group TIMER_BRKETR_CNTRL */
N
N/** @defgroup Periph_TIMER_STATUS	TIMER STATUS
N  * @{
N  */ 
N
N/*-- TIMER_STATUS: Timer Status Register ---------------------------*/
N/* Bit field positions: */
N#define TIMER_STATUS_CNT_ZERO_EVENT_Pos         0
N#define TIMER_STATUS_CNT_ARR_EVENT_Pos          1
N#define TIMER_STATUS_ETR_RE_EVENT_Pos           2
N#define TIMER_STATUS_ETR_FE_EVENT_Pos           3
N#define TIMER_STATUS_BRK_EVENT_Pos              4
N#define TIMER_STATUS_CCR_CAP_EVENT_Pos          5
N#define TIMER_STATUS_CCR_REF_EVENT_Pos          9
N#define TIMER_STATUS_CCR1_CAP_EVENT_Pos         13
N
N/* Bit field masks: */
N#define TIMER_STATUS_CNT_ZERO_EVENT             ((uint32_t)0x00000001)
N#define TIMER_STATUS_CNT_ARR_EVENT              ((uint32_t)0x00000002)
N#define TIMER_STATUS_ETR_RE_EVENT               ((uint32_t)0x00000004)
N#define TIMER_STATUS_ETR_FE_EVENT               ((uint32_t)0x00000008)
N#define TIMER_STATUS_BRK_EVENT                  ((uint32_t)0x00000010)
N#define TIMER_STATUS_CCR_CAP_EVENT_Msk          ((uint32_t)0x000001E0)
N#define TIMER_STATUS_CCR_REF_EVENT_Msk          ((uint32_t)0x00001E00)
N#define TIMER_STATUS_CCR1_CAP_EVENT_Msk         ((uint32_t)0x0001E000)
N
N/** @} */ /* End of group TIMER_STATUS */
N
N/** @defgroup Periph_TIMER_IE	TIMER IE
N  * @{
N  */ 
N
N/*-- TIMER_IE: Timer Interrupt Enable Register ---------------------*/
N/* Bit field positions: */
N#define TIMER_IE_CNT_ZERO_EVENT_IE_Pos          0
N#define TIMER_IE_CNT_ARR_EVENT_IE_Pos           1
N#define TIMER_IE_ETR_RE_EVENT_IE_Pos            2
N#define TIMER_IE_ETR_FE_EVENT_IE_Pos            3
N#define TIMER_IE_BRK_EVENT_IE_Pos               4
N#define TIMER_IE_CCR_CAP_EVENT_IE_Pos           5
N#define TIMER_IE_CCR_REF_EVENT_IE_Pos           9
N#define TIMER_IE_CCR1_CAP_EVENT_IE_Pos          13
N
N/* Bit field masks: */
N#define TIMER_IE_CNT_ZERO_EVENT_IE              ((uint32_t)0x00000001)
N#define TIMER_IE_CNT_ARR_EVENT_IE               ((uint32_t)0x00000002)
N#define TIMER_IE_ETR_RE_EVENT_IE                ((uint32_t)0x00000004)
N#define TIMER_IE_ETR_FE_EVENT_IE                ((uint32_t)0x00000008)
N#define TIMER_IE_BRK_EVENT_IE                   ((uint32_t)0x00000010)
N#define TIMER_IE_CCR_CAP_EVENT_IE_Msk           ((uint32_t)0x000001E0)
N#define TIMER_IE_CCR_REF_EVENT_IE_Msk           ((uint32_t)0x00001E00)
N#define TIMER_IE_CCR1_CAP_EVENT_IE_Msk          ((uint32_t)0x0001E000)
N
N/** @} */ /* End of group TIMER_IE */
N
N/** @defgroup Periph_TIMER_DMA_RE	TIMER DMA RE
N  * @{
N  */ 
N
N/*-- TIMER_DMA_RE: Timer DMA Request Enable Register ---------------*/
N/* Bit field positions: */
N#define TIMER_DMA_RE_CNT_ZERO_EVENT_RE_Pos      0
N#define TIMER_DMA_RE_CNT_ARR_EVENT_RE_Pos       1
N#define TIMER_DMA_RE_ETR_RE_EVENT_RE_Pos        2
N#define TIMER_DMA_RE_ETR_FE_EVENT_RE_Pos        3
N#define TIMER_DMA_RE_BRK_EVENT_RE_Pos           4
N#define TIMER_DMA_RE_CCR_CAP_EVENT_RE_Pos       5
N#define TIMER_DMA_RE_CCR_REF_EVENT_RE_Pos       9
N#define TIMER_DMA_RE_CCR1_CAP_EVENT_RE_Pos      13
N
N/* Bit field masks: */
N#define TIMER_DMA_RE_CNT_ZERO_EVENT_RE          ((uint32_t)0x00000001)
N#define TIMER_DMA_RE_CNT_ARR_EVENT_RE           ((uint32_t)0x00000002)
N#define TIMER_DMA_RE_ETR_RE_EVENT_RE            ((uint32_t)0x00000004)
N#define TIMER_DMA_RE_ETR_FE_EVENT_RE            ((uint32_t)0x00000008)
N#define TIMER_DMA_RE_BRK_EVENT_RE               ((uint32_t)0x00000010)
N#define TIMER_DMA_RE_CCR_CAP_EVENT_RE_Msk       ((uint32_t)0x000001E0)
N#define TIMER_DMA_RE_CCR_REF_EVENT_RE_Msk       ((uint32_t)0x00001E00)
N#define TIMER_DMA_RE_CCR1_CAP_EVENT_RE_Msk      ((uint32_t)0x0001E000)
N
N/** @} */ /* End of group TIMER_DMA_RE */
N
N/** @defgroup Periph_TIMER_CH_CNTRL2	TIMER CH CNTRL2
N  * @{
N  */ 
N
N/*-- TIMER_CH_CNTRL2: Timer Channel Control2 Register --------------*/
N/* Bit field positions: */
N#define TIMER_CH_CNTRL2_CHSEL1_Pos              0
N#define TIMER_CH_CNTRL2_CCR1_EN_Pos             2
N#define TIMER_CH_CNTRL2_CCRRLD_Pos              3
N
N/* Bit field masks: */
N#define TIMER_CH_CNTRL2_CHSEL1_Msk              ((uint32_t)0x00000003)
N#define TIMER_CH_CNTRL2_CCR1_EN                 ((uint32_t)0x00000004)
N#define TIMER_CH_CNTRL2_CCRRLD                  ((uint32_t)0x00000008)
N
N/** @} */ /* End of group TIMER_CH_CNTRL2 */
N
N/** @} */ /* End of group MDR32Fx_Periph_TIMER_Defines */
N
N/** @} */ /* End of group MDR32Fx_Periph_TIMER */
N
N/** @defgroup MDR32Fx_Periph_ADC ADC
N  * @{
N  */
N
N/** @defgroup MDR32Fx_Periph_ADC_Data_Structures Data Structures
N  * @{
N  */
N
N/* MDR_ADC_TypeDef structure */
Ntypedef struct
N{
N  __IO uint32_t ADC1_CFG;
X  volatile uint32_t ADC1_CFG;
N  __IO uint32_t ADC2_CFG;
X  volatile uint32_t ADC2_CFG;
N  __IO uint32_t ADC1_H_LEVEL;
X  volatile uint32_t ADC1_H_LEVEL;
N  __IO uint32_t ADC2_H_LEVEL;
X  volatile uint32_t ADC2_H_LEVEL;
N  __IO uint32_t ADC1_L_LEVEL;
X  volatile uint32_t ADC1_L_LEVEL;
N  __IO uint32_t ADC2_L_LEVEL;
X  volatile uint32_t ADC2_L_LEVEL;
N  __IO uint32_t ADC1_RESULT;
X  volatile uint32_t ADC1_RESULT;
N  __IO uint32_t ADC2_RESULT;
X  volatile uint32_t ADC2_RESULT;
N  __IO uint32_t ADC1_STATUS;
X  volatile uint32_t ADC1_STATUS;
N  __IO uint32_t ADC2_STATUS;
X  volatile uint32_t ADC2_STATUS;
N  __IO uint32_t ADC1_CHSEL;
X  volatile uint32_t ADC1_CHSEL;
N  __IO uint32_t ADC2_CHSEL;
X  volatile uint32_t ADC2_CHSEL;
N}MDR_ADC_TypeDef;
N
N/** @} */ /* End of group MDR32Fx_Periph_ADC_Data_Structures */
N
N/** @defgroup MDR32Fx_Periph_ADC_Defines Defines
N  * @{
N  */
N
N/** @defgroup Periph_ADC1_CFG	ADC1 CFG
N  * @{
N  */ 
N
N/*-- ADC1_CFG: ADC1 Configuration Register -------------------------*/
N/* Bit field positions: */
N#define ADC1_CFG_REG_ADON_Pos                   0
N#define ADC1_CFG_REG_GO_Pos                     1
N#define ADC1_CFG_REG_CLKS_Pos                   2
N#define ADC1_CFG_REG_SAMPLE_Pos                 3
N#define ADC1_CFG_REG_CHS_Pos                    4
N#define ADC1_CFG_REG_CHCH_Pos                   9
N#define ADC1_CFG_REG_RNGC_Pos                   10
N#define ADC1_CFG_M_REF_Pos                      11
N#define ADC1_CFG_REG_DIVCLK_Pos                 12
N#define ADC1_CFG_SYNC_CONVER_Pos                16
N#define ADC1_CFG_TS_EN_Pos                      17
N#define ADC1_CFG_TS_BUF_EN_Pos                  18
N#define ADC1_CFG_SEL_TS_Pos                     19
N#define ADC1_CFG_SEL_VREF_Pos                   20
N#define ADC1_CFG_TR_Pos                         21
N#define ADC1_CFG_DELAY_GO_Pos                   25
N#define ADC1_CFG_DELAY_ADC_Pos                  28
N
N/* Bit field masks: */
N#define ADC1_CFG_REG_ADON                       ((uint32_t)0x00000001)
N#define ADC1_CFG_REG_GO                         ((uint32_t)0x00000002)
N#define ADC1_CFG_REG_CLKS                       ((uint32_t)0x00000004)
N#define ADC1_CFG_REG_SAMPLE                     ((uint32_t)0x00000008)
N#define ADC1_CFG_REG_CHS_Msk                    ((uint32_t)0x000001F0)
N#define ADC1_CFG_REG_CHCH                       ((uint32_t)0x00000200)
N#define ADC1_CFG_REG_RNGC                       ((uint32_t)0x00000400)
N#define ADC1_CFG_M_REF                          ((uint32_t)0x00000800)
N#define ADC1_CFG_REG_DIVCLK_Msk                 ((uint32_t)0x0000F000)
N#define ADC1_CFG_SYNC_CONVER                    ((uint32_t)0x00010000)
N#define ADC1_CFG_TS_EN                          ((uint32_t)0x00020000)
N#define ADC1_CFG_TS_BUF_EN                      ((uint32_t)0x00040000)
N#define ADC1_CFG_SEL_TS                         ((uint32_t)0x00080000)
N#define ADC1_CFG_SEL_VREF                       ((uint32_t)0x00100000)
N#define ADC1_CFG_TR_Msk                         ((uint32_t)0x01E00000)
N#define ADC1_CFG_DELAY_GO_Msk                   ((uint32_t)0x0E000000)
N#define ADC1_CFG_DELAY_ADC_Msk                  ((uint32_t)0xF0000000)
N
N/** @} */ /* End of group ADC1_CFG */
N
N/** @defgroup Periph_ADC2_CFG	ADC2 CFG
N  * @{
N  */ 
N
N/*-- ADC2_CFG: ADC2 Configuration Register -------------------------*/
N/* Bit field positions: */
N#define ADC2_CFG_REG_ADON_Pos                   0
N#define ADC2_CFG_REG_GO_Pos                     1
N#define ADC2_CFG_REG_CLKS_Pos                   2
N#define ADC2_CFG_REG_SAMPLE_Pos                 3
N#define ADC2_CFG_REG_CHS_Pos                    4
N#define ADC2_CFG_REG_CHCH_Pos                   9
N#define ADC2_CFG_REG_RNGC_Pos                   10
N#define ADC2_CFG_M_REF_Pos                      11
N#define ADC2_CFG_REG_DIVCLK_Pos                 12
N#define ADC2_CFG_ADC1_OP_Pos                    17
N#define ADC2_CFG_ADC2_OP_Pos                    18
N#define ADC2_CFG_DELAY_GO_Pos                   25
N
N/* Bit field masks: */
N#define ADC2_CFG_REG_ADON                       ((uint32_t)0x00000001)
N#define ADC2_CFG_REG_GO                         ((uint32_t)0x00000002)
N#define ADC2_CFG_REG_CLKS                       ((uint32_t)0x00000004)
N#define ADC2_CFG_REG_SAMPLE                     ((uint32_t)0x00000008)
N#define ADC2_CFG_REG_CHS_Msk                    ((uint32_t)0x000001F0)
N#define ADC2_CFG_REG_CHCH                       ((uint32_t)0x00000200)
N#define ADC2_CFG_REG_RNGC                       ((uint32_t)0x00000400)
N#define ADC2_CFG_M_REF                          ((uint32_t)0x00000800)
N#define ADC2_CFG_REG_DIVCLK_Msk                 ((uint32_t)0x0000F000)
N#define ADC2_CFG_ADC1_OP                        ((uint32_t)0x00020000)
N#define ADC2_CFG_ADC2_OP                        ((uint32_t)0x00040000)
N#define ADC2_CFG_DELAY_GO_Msk                   ((uint32_t)0x0E000000)
N
N/** @} */ /* End of group ADC2_CFG */
N
N/** @defgroup Periph_ADC1_RESULT	ADC1 RESULT
N  * @{
N  */ 
N
N/*-- ADC1_RESULT: ADC1 Result Register -----------------------------*/
N/*-- ADC2_RESULT: ADC2 Result Register -----------------------------*/
N/* Bit field positions: */
N#define ADC_RESULT_Pos                          0
N#define ADC_RESULT_CHANNEL_Pos                  16
N
N/* Bit field masks: */
N#define ADC_RESULT_Msk                          ((uint32_t)0x00000FFF)
N#define ADC_RESULT_CHANNEL_Msk                  ((uint32_t)0x0FFF0000)
N
N/** @} */ /* End of group ADC1_RESULT */
N
N/** @defgroup Periph_ADC1_STATUS	ADC1 STATUS
N  * @{
N  */ 
N
N/*-- ADC1_STATUS: ADC1 Status Register -----------------------------*/
N/*-- ADC2_STATUS: ADC2 Status Register -----------------------------*/
N/* Bit field positions: */
N#define ADC_STATUS_FLG_REG_OVERWRITE_Pos        0
N#define ADC_STATUS_FLG_REG_AWOIFEN_Pos          1
N#define ADC_STATUS_FLG_REG_EOCIF_Pos            2
N#define ADC_STATUS_AWOIF_IE_Pos                 3
N#define ADC_STATUS_ECOIF_IE_Pos                 4
N
N/* Bit field masks: */
N#define ADC_STATUS_FLG_REG_OVERWRITE            ((uint32_t)0x00000001)
N#define ADC_STATUS_FLG_REG_AWOIFEN              ((uint32_t)0x00000002)
N#define ADC_STATUS_FLG_REG_EOCIF                ((uint32_t)0x00000004)
N#define ADC_STATUS_AWOIF_IE                     ((uint32_t)0x00000008)
N#define ADC_STATUS_ECOIF_IE                     ((uint32_t)0x00000010)
N
N/** @} */ /* End of group ADC1_STATUS */
N
N/** @} */ /* End of group MDR32Fx_Periph_ADC_Defines */
N
N/** @} */ /* End of group MDR32Fx_Periph_ADC */
N
N/** @defgroup MDR32Fx_Periph_DAC DAC
N  * @{
N  */
N
N/** @defgroup MDR32Fx_Periph_DAC_Data_Structures Data Structures
N  * @{
N  */
N
N/* MDR_DAC_TypeDef structure */
Ntypedef struct
N{
N  __IO uint32_t CFG;
X  volatile uint32_t CFG;
N  __IO uint32_t DAC1_DATA;
X  volatile uint32_t DAC1_DATA;
N  __IO uint32_t DAC2_DATA;
X  volatile uint32_t DAC2_DATA;
N}MDR_DAC_TypeDef;
N
N/** @} */ /* End of group MDR32Fx_Periph_DAC_Data_Structures */
N
N/** @defgroup MDR32Fx_Periph_DAC_Defines Defines
N  * @{
N  */
N
N/** @defgroup Periph_DAC_CFG	DAC CFG
N  * @{
N  */ 
N
N/*-- DAC_CFG: DAC Configuration Register ---------------------------*/
N/* Bit field positions: */
N#define DAC_CFG_M_REF0_Pos                      0
N#define DAC_CFG_M_REF1_Pos                      1
N#define DAC_CFG_ON_DAC0_Pos                     2
N#define DAC_CFG_ON_DAC1_Pos                     3
N#define DAC_CFG_SYNC_A_Pos                      4
N
N/* Bit field masks: */
N#define DAC_CFG_M_REF0                          ((uint32_t)0x00000001)
N#define DAC_CFG_M_REF1                          ((uint32_t)0x00000002)
N#define DAC_CFG_ON_DAC0                         ((uint32_t)0x00000004)
N#define DAC_CFG_ON_DAC1                         ((uint32_t)0x00000008)
N#define DAC_CFG_SYNC_A                          ((uint32_t)0x00000010)
N
N/** @} */ /* End of group DAC_CFG */
N
N/** @defgroup Periph_DAC1_DATA	DAC1 DATA
N  * @{
N  */ 
N
N/*-- DAC1_DATA: DAC1 Data Register ---------------------------------*/
N/* Bit field positions: */
N#define DAC1_DATA_DAC0DATA_Pos                  0
N#define DAC1_DATA_DAC1DATA_Pos                  16
N
N/* Bit field masks: */
N#define DAC1_DATA_DAC0DATA_Msk                  ((uint32_t)0x00000FFF)
N#define DAC1_DATA_DAC1DATA_Msk                  ((uint32_t)0x0FFF0000)
N
N/** @} */ /* End of group DAC1_DATA */
N
N/** @defgroup Periph_DAC2_DATA	DAC2 DATA
N  * @{
N  */ 
N
N/*-- DAC2_DATA: DAC2 Data Register ---------------------------------*/
N/* Bit field positions: */
N#define DAC2_DATA_DAC1DATA_Pos                  0
N#define DAC2_DATA_DAC0DATA_Pos                  16
N
N/* Bit field masks: */
N#define DAC2_DATA_DAC1DATA_Msk                  ((uint32_t)0x00000FFF)
N#define DAC2_DATA_DAC0DATA_Msk                  ((uint32_t)0x0FFF0000)
N
N/** @} */ /* End of group DAC2_DATA */
N
N/** @} */ /* End of group MDR32Fx_Periph_DAC_Defines */
N
N/** @} */ /* End of group MDR32Fx_Periph_DAC */
N
N/** @defgroup MDR32Fx_Periph_COMP COMP
N  * @{
N  */
N
N/** @defgroup MDR32Fx_Periph_COMP_Data_Structures Data Structures
N  * @{
N  */
N
N/* MDR_COMP_TypeDef structure */
Ntypedef struct
N{
N  __IO uint32_t CFG;
X  volatile uint32_t CFG;
N  __IO uint32_t RESULT;
X  volatile uint32_t RESULT;
N  __IO uint32_t RESULT_LATCH;
X  volatile uint32_t RESULT_LATCH;
N}MDR_COMP_TypeDef;
N
N/** @} */ /* End of group MDR32Fx_Periph_COMP_Data_Structures */
N
N/** @defgroup MDR32Fx_Periph_COMP_Defines Defines
N  * @{
N  */
N
N/** @defgroup Periph_COMP_CFG	COMP CFG
N  * @{
N  */ 
N
N/*-- COMP_CFG: COMP Configuration Register -------------------------*/
N/* Bit field positions: */
N#define COMP_CFG_ON_Pos                         0
N#define COMP_CFG_CVRR_Pos                       1
N#define COMP_CFG_CVRSS_Pos                      2
N#define COMP_CFG_CVREN_Pos                      3
N#define COMP_CFG_CVR_Pos                        4
N#define COMP_CFG_CREF_Pos                       8
N#define COMP_CFG_CCH_Pos                        9
N#define COMP_CFG_INV_Pos                        11
N#define COMP_CFG_READY_Pos                      12
N#define COMP_CFG_CMPIE_Pos                      13
N
N/* Bit field masks: */
N#define COMP_CFG_ON                             ((uint32_t)0x00000001)
N#define COMP_CFG_CVRR                           ((uint32_t)0x00000002)
N#define COMP_CFG_CVRSS                          ((uint32_t)0x00000004)
N#define COMP_CFG_CVREN                          ((uint32_t)0x00000008)
N#define COMP_CFG_CVR_Msk                        ((uint32_t)0x000000F0)
N#define COMP_CFG_CREF                           ((uint32_t)0x00000100)
N#define COMP_CFG_CCH_Msk                        ((uint32_t)0x00000600)
N#define COMP_CFG_INV                            ((uint32_t)0x00000800)
N#define COMP_CFG_READY                          ((uint32_t)0x00001000)
N#define COMP_CFG_CMPIE                          ((uint32_t)0x00002000)
N
N/** @} */ /* End of group COMP_CFG */
N
N/** @defgroup Periph_COMP_RESULT	COMP RESULT
N  * @{
N  */ 
N
N/*-- COMP_RESULT: COMP Result Register -----------------------------*/
N/* Bit field positions: */
N#define COMP_RESULT_RSLT_SY_Pos                 0
N#define COMP_RESULT_RSLT_AS_Pos                 1
N#define COMP_RESULT_RST_LCH_Pos                 2
N
N/* Bit field masks: */
N#define COMP_RESULT_RSLT_SY                     ((uint32_t)0x00000001)
N#define COMP_RESULT_RSLT_AS                     ((uint32_t)0x00000002)
N#define COMP_RESULT_RST_LCH                     ((uint32_t)0x00000004)
N
N/** @} */ /* End of group COMP_RESULT */
N
N/** @} */ /* End of group MDR32Fx_Periph_COMP_Defines */
N
N/** @} */ /* End of group MDR32Fx_Periph_COMP */
N
N/** @defgroup MDR32Fx_Periph_PORT PORT
N  * @{
N  */
N
N/** @defgroup MDR32Fx_Periph_PORT_Data_Structures Data Structures
N  * @{
N  */
N
N/* MDR_PORT_TypeDef structure */
Ntypedef struct
N{
N  __IO uint32_t RXTX;
X  volatile uint32_t RXTX;
N  __IO uint32_t OE;
X  volatile uint32_t OE;
N  __IO uint32_t FUNC;
X  volatile uint32_t FUNC;
N  __IO uint32_t ANALOG;
X  volatile uint32_t ANALOG;
N  __IO uint32_t PULL;
X  volatile uint32_t PULL;
N  __IO uint32_t PD;
X  volatile uint32_t PD;
N  __IO uint32_t PWR;
X  volatile uint32_t PWR;
N  __IO uint32_t GFEN;
X  volatile uint32_t GFEN;
N}MDR_PORT_TypeDef;
N
N/** @} */ /* End of group MDR32Fx_Periph_PORT_Data_Structures */
N
N/** @defgroup MDR32Fx_Periph_PORT_Defines Defines
N  * @{
N  */
N
N/** @defgroup Periph_PORT_FUNC	PORT FUNC
N  * @{
N  */ 
N
N/*-- PORT_FUNC: PORT Function Register -----------------------------*/
N/* Bit field positions: */
N#define PORT_FUNC_MODE0_Pos                     0
N#define PORT_FUNC_MODE1_Pos                     2
N#define PORT_FUNC_MODE2_Pos                     4
N#define PORT_FUNC_MODE3_Pos                     6
N#define PORT_FUNC_MODE4_Pos                     8
N#define PORT_FUNC_MODE5_Pos                     10
N#define PORT_FUNC_MODE6_Pos                     12
N#define PORT_FUNC_MODE7_Pos                     14
N#define PORT_FUNC_MODE8_Pos                     16
N#define PORT_FUNC_MODE9_Pos                     18
N#define PORT_FUNC_MODE10_Pos                    20
N#define PORT_FUNC_MODE11_Pos                    22
N#define PORT_FUNC_MODE12_Pos                    24
N#define PORT_FUNC_MODE13_Pos                    26
N#define PORT_FUNC_MODE14_Pos                    28
N#define PORT_FUNC_MODE15_Pos                    30
N
N/* Bit field masks: */
N#define PORT_FUNC_MODE0_Msk                     ((uint32_t)0x00000003)
N#define PORT_FUNC_MODE1_Msk                     ((uint32_t)0x0000000C)
N#define PORT_FUNC_MODE2_Msk                     ((uint32_t)0x00000030)
N#define PORT_FUNC_MODE3_Msk                     ((uint32_t)0x000000C0)
N#define PORT_FUNC_MODE4_Msk                     ((uint32_t)0x00000300)
N#define PORT_FUNC_MODE5_Msk                     ((uint32_t)0x00000C00)
N#define PORT_FUNC_MODE6_Msk                     ((uint32_t)0x00003000)
N#define PORT_FUNC_MODE7_Msk                     ((uint32_t)0x0000C000)
N#define PORT_FUNC_MODE8_Msk                     ((uint32_t)0x00030000)
N#define PORT_FUNC_MODE9_Msk                     ((uint32_t)0x000C0000)
N#define PORT_FUNC_MODE10_Msk                    ((uint32_t)0x00300000)
N#define PORT_FUNC_MODE11_Msk                    ((uint32_t)0x00C00000)
N#define PORT_FUNC_MODE12_Msk                    ((uint32_t)0x03000000)
N#define PORT_FUNC_MODE13_Msk                    ((uint32_t)0x0C000000)
N#define PORT_FUNC_MODE14_Msk                    ((uint32_t)0x30000000)
N#define PORT_FUNC_MODE15_Msk                    ((uint32_t)0xC0000000)
N
N/** @} */ /* End of group PORT_FUNC */
N
N/** @defgroup Periph_PORT_PULL	PORT PULL
N  * @{
N  */ 
N
N/*-- PORT_PULL: PORT Pull Up/Down Register -------------------------*/
N/* Bit field positions: */
N#define PORT_PULL_DOWN_Pos                      0
N#define PORT_PULL_UP_Pos                        16
N
N/* Bit field masks: */
N#define PORT_PULL_DOWN_Msk                      ((uint32_t)0x0000FFFF)
N#define PORT_PULL_UP_Msk                        ((uint32_t)0xFFFF0000)
N
N/** @} */ /* End of group PORT_PULL */
N
N/** @defgroup Periph_PORT_PD	PORT PD
N  * @{
N  */ 
N
N/*-- PORT_PD: PORT Driver Mode Register ----------------------------*/
N/* Bit field positions: */
N#define PORT_PD_Pos                             0
N#define PORT_PD_SHM_Pos                         16
N
N/* Bit field masks: */
N#define PORT_PD_Msk                             ((uint32_t)0x0000FFFF)
N#define PORT_PD_SHM_Msk                         ((uint32_t)0xFFFF0000)
N
N/** @} */ /* End of group PORT_PD */
N
N/** @defgroup Periph_PORT_PWR	PORT PWR
N  * @{
N  */ 
N
N/*-- PORT_PWR: PORT Power Register ---------------------------------*/
N/* Bit field positions: */
N#define PORT_PWR0_Pos                           0
N#define PORT_PWR1_Pos                           2
N#define PORT_PWR2_Pos                           4
N#define PORT_PWR3_Pos                           6
N#define PORT_PWR4_Pos                           8
N#define PORT_PWR5_Pos                           10
N#define PORT_PWR6_Pos                           12
N#define PORT_PWR7_Pos                           14
N#define PORT_PWR8_Pos                           16
N#define PORT_PWR9_Pos                           18
N#define PORT_PWR10_Pos                          20
N#define PORT_PWR11_Pos                          22
N#define PORT_PWR12_Pos                          24
N#define PORT_PWR13_Pos                          26
N#define PORT_PWR14_Pos                          28
N#define PORT_PWR15_Pos                          30
N
N/* Bit field masks: */
N#define PORT_PWR0_Msk                           ((uint32_t)0x00000003)
N#define PORT_PWR1_Msk                           ((uint32_t)0x0000000C)
N#define PORT_PWR2_Msk                           ((uint32_t)0x00000030)
N#define PORT_PWR3_Msk                           ((uint32_t)0x000000C0)
N#define PORT_PWR4_Msk                           ((uint32_t)0x00000300)
N#define PORT_PWR5_Msk                           ((uint32_t)0x00000C00)
N#define PORT_PWR6_Msk                           ((uint32_t)0x00003000)
N#define PORT_PWR7_Msk                           ((uint32_t)0x0000C000)
N#define PORT_PWR8_Msk                           ((uint32_t)0x00030000)
N#define PORT_PWR9_Msk                           ((uint32_t)0x000C0000)
N#define PORT_PWR10_Msk                          ((uint32_t)0x00300000)
N#define PORT_PWR11_Msk                          ((uint32_t)0x00C00000)
N#define PORT_PWR12_Msk                          ((uint32_t)0x03000000)
N#define PORT_PWR13_Msk                          ((uint32_t)0x0C000000)
N#define PORT_PWR14_Msk                          ((uint32_t)0x30000000)
N#define PORT_PWR15_Msk                          ((uint32_t)0xC0000000)
N
N/** @} */ /* End of group PORT_PWR */
N
N/** @} */ /* End of group MDR32Fx_Periph_PORT_Defines */
N
N/** @} */ /* End of group MDR32Fx_Periph_PORT */
N
N/** @defgroup MDR32Fx_Periph_BKP BKP
N  * @{
N  */
N
N/** @defgroup MDR32Fx_Periph_BKP_Data_Structures Data Structures
N  * @{
N  */
N
N/* MDR_BKP_TypeDef structure */
Ntypedef struct
N{
N  __IO uint32_t REG_00;
X  volatile uint32_t REG_00;
N  __IO uint32_t REG_01;
X  volatile uint32_t REG_01;
N  __IO uint32_t REG_02;
X  volatile uint32_t REG_02;
N  __IO uint32_t REG_03;
X  volatile uint32_t REG_03;
N  __IO uint32_t REG_04;
X  volatile uint32_t REG_04;
N  __IO uint32_t REG_05;
X  volatile uint32_t REG_05;
N  __IO uint32_t REG_06;
X  volatile uint32_t REG_06;
N  __IO uint32_t REG_07;
X  volatile uint32_t REG_07;
N  __IO uint32_t REG_08;
X  volatile uint32_t REG_08;
N  __IO uint32_t REG_09;
X  volatile uint32_t REG_09;
N  __IO uint32_t REG_0A;
X  volatile uint32_t REG_0A;
N  __IO uint32_t REG_0B;
X  volatile uint32_t REG_0B;
N  __IO uint32_t REG_0C;
X  volatile uint32_t REG_0C;
N  __IO uint32_t REG_0D;
X  volatile uint32_t REG_0D;
N  __IO uint32_t REG_0E;
X  volatile uint32_t REG_0E;
N  __IO uint32_t REG_0F;
X  volatile uint32_t REG_0F;
N  __IO uint32_t RTC_CNT;
X  volatile uint32_t RTC_CNT;
N  __IO uint32_t RTC_DIV;
X  volatile uint32_t RTC_DIV;
N  __IO uint32_t RTC_PRL;
X  volatile uint32_t RTC_PRL;
N  __IO uint32_t RTC_ALRM;
X  volatile uint32_t RTC_ALRM;
N  __IO uint32_t RTC_CS;
X  volatile uint32_t RTC_CS;
N}MDR_BKP_TypeDef;
N
N/** @} */ /* End of group MDR32Fx_Periph_BKP_Data_Structures */
N
N/** @defgroup MDR32Fx_Periph_BKP_Defines Defines
N  * @{
N  */
N
N/** @defgroup Periph_BKP_REG_0E	BKP REG 0E
N  * @{
N  */ 
N
N/*-- BKP_REG_0E: Backup Register 14 --------------------------------*/
N/* Bit field positions: */
N#define BKP_REG_0E_LOW_Pos                      0
N#define BKP_REG_0E_SELECTRI_Pos                 3
N#define BKP_REG_0E_JTAGA_Pos                    6
N#define BKP_REG_0E_JTAGB_Pos                    7
N#define BKP_REG_0E_TRIM_Pos                     8
N#define BKP_REG_0E_FPOR_Pos                     11
N#define BKP_REG_0E_BKP_REG_Pos                  12
N
N/* Bit field masks: */
N#define BKP_REG_0E_LOW_Msk                      ((uint32_t)0x00000007)
N#define BKP_REG_0E_SELECTRI_Msk                 ((uint32_t)0x00000038)
N#define BKP_REG_0E_JTAGA                        ((uint32_t)0x00000040)
N#define BKP_REG_0E_JTAGB                        ((uint32_t)0x00000080)
N#define BKP_REG_0E_TRIM_Msk                     ((uint32_t)0x00000700)
N#define BKP_REG_0E_FPOR                         ((uint32_t)0x00000800)
N#define BKP_REG_0E_BKP_REG_Msk                  ((uint32_t)0xFFFFF000)
N
N/** @} */ /* End of group BKP_REG_0E */
N
N/** @defgroup Periph_BKP_REG_0F	BKP REG 0F
N  * @{
N  */ 
N
N/*-- BKP_REG_0F: Backup Register 15 --------------------------------*/
N/* Bit field positions: */
N#define BKP_REG_0F_LSE_ON_Pos                   0
N#define BKP_REG_0F_LSE_BYP_Pos                  1
N#define BKP_REG_0F_RTC_SEL_Pos                  2
N#define BKP_REG_0F_RTC_EN_Pos                   4
N#define BKP_REG_0F_CAL_Pos                      5
N#define BKP_REG_0F_LSE_RDY_Pos                  13
N#define BKP_REG_0F_BKP_REG_Pos                  14
N#define BKP_REG_0F_LSI_ON_Pos                   15
N#define BKP_REG_0F_LSI_TRIM_Pos                 16
N#define BKP_REG_0F_LSI_RDY_Pos                  21
N#define BKP_REG_0F_HSI_ON_Pos                   22
N#define BKP_REG_0F_HSI_RDY_Pos                  23
N#define BKP_REG_0F_HSI_TRIM_Pos                 24
N#define BKP_REG_0F_STANDBY_Pos                  30
N#define BKP_REG_0F_RTC_RESET_Pos                31
N
N/* Bit field masks: */
N#define BKP_REG_0F_LSE_ON                       ((uint32_t)0x00000001)
N#define BKP_REG_0F_LSE_BYP                      ((uint32_t)0x00000002)
N#define BKP_REG_0F_RTC_SEL_Msk                  ((uint32_t)0x0000000C)
N#define BKP_REG_0F_RTC_EN                       ((uint32_t)0x00000010)
N#define BKP_REG_0F_CAL_Msk                      ((uint32_t)0x00001FE0)
N#define BKP_REG_0F_LSE_RDY                      ((uint32_t)0x00002000)
N#define BKP_REG_0F_BKP_REG                      ((uint32_t)0x00004000)
N#define BKP_REG_0F_LSI_ON                       ((uint32_t)0x00008000)
N#define BKP_REG_0F_LSI_TRIM_Msk                 ((uint32_t)0x001F0000)
N#define BKP_REG_0F_LSI_RDY                      ((uint32_t)0x00200000)
N#define BKP_REG_0F_HSI_ON                       ((uint32_t)0x00400000)
N#define BKP_REG_0F_HSI_RDY                      ((uint32_t)0x00800000)
N#define BKP_REG_0F_HSI_TRIM_Msk                 ((uint32_t)0x3F000000)
N#define BKP_REG_0F_STANDBY                      ((uint32_t)0x40000000)
N#define BKP_REG_0F_RTC_RESET                    ((uint32_t)0x80000000)
N
N/** @} */ /* End of group BKP_REG_0F */
N
N/** @defgroup Periph_BKP_RTC_CS	BKP RTC CS
N  * @{
N  */ 
N
N/*-- BKP_RTC_CS: Backup Realtime clock Register --------------------*/
N/* Bit field positions: */
N#define BKP_RTC_CS_OWF_Pos                      0
N#define BKP_RTC_CS_SECF_Pos                     1
N#define BKP_RTC_CS_ALRF_Pos                     2
N#define BKP_RTC_CS_OWF_IE_Pos                   3
N#define BKP_RTC_CS_SECF_IE_Pos                  4
N#define BKP_RTC_CS_ALRF_IE_Pos                  5
N#define BKP_RTC_CS_WEC_Pos                      6
N
N/* Bit field masks: */
N#define BKP_RTC_CS_OWF                          ((uint32_t)0x00000001)
N#define BKP_RTC_CS_SECF                         ((uint32_t)0x00000002)
N#define BKP_RTC_CS_ALRF                         ((uint32_t)0x00000004)
N#define BKP_RTC_CS_OWF_IE                       ((uint32_t)0x00000008)
N#define BKP_RTC_CS_SECF_IE                      ((uint32_t)0x00000010)
N#define BKP_RTC_CS_ALRF_IE                      ((uint32_t)0x00000020)
N#define BKP_RTC_CS_WEC                          ((uint32_t)0x00000040)
N
N/** @} */ /* End of group BKP_RTC_CS */
N
N/** @} */ /* End of group MDR32Fx_Periph_BKP_Defines */
N
N/** @} */ /* End of group MDR32Fx_Periph_BKP */
N
N/** @defgroup MDR32Fx_Periph_EBC EBC
N  * @{
N  */
N
N/** @defgroup MDR32Fx_Periph_EBC_Data_Structures Data Structures
N  * @{
N  */
N
N/* MDR_EBC_TypeDef structure */
Ntypedef struct
N{
N       uint32_t RESERVED0[20];
N  __IO uint32_t NAND_CYCLES;
X  volatile uint32_t NAND_CYCLES;
N  __IO uint32_t CONTROL;
X  volatile uint32_t CONTROL;
N#if defined (USE_MDR1986VE94)
X#if 0L
S  __IO uint32_t MEM_REGION[4];
N#endif
N}MDR_EBC_TypeDef;
N
N/** @} */ /* End of group MDR32Fx_Periph_EBC_Data_Structures */
N
N/** @defgroup MDR32Fx_Periph_EBC_Defines Defines
N  * @{
N  */
N
N/** @defgroup Periph_EBC_NAND_CYCLES	EBC NAND CYCLES
N  * @{
N  */ 
N
N/*-- EBC_NAND_CYCLES: EBC NAND Timing Register ---------------------*/
N/* Bit field positions: */
N#define EBC_NAND_CYCLES_TRC_Pos                 0
N#define EBC_NAND_CYCLES_TWC_Pos                 4
N#define EBC_NAND_CYCLES_TREA_Pos                8
N#define EBC_NAND_CYCLES_TWP_Pos                 12
N#define EBC_NAND_CYCLES_TWHR_Pos                16
N#define EBC_NAND_CYCLES_TALEA_Pos               20
N#define EBC_NAND_CYCLES_TRR_Pos                 24
N
N/* Bit field masks: */
N#define EBC_NAND_CYCLES_TRC_Msk                 ((uint32_t)0x0000000F)
N#define EBC_NAND_CYCLES_TWC_Msk                 ((uint32_t)0x000000F0)
N#define EBC_NAND_CYCLES_TREA_Msk                ((uint32_t)0x00000F00)
N#define EBC_NAND_CYCLES_TWP_Msk                 ((uint32_t)0x0000F000)
N#define EBC_NAND_CYCLES_TWHR_Msk                ((uint32_t)0x000F0000)
N#define EBC_NAND_CYCLES_TALEA_Msk               ((uint32_t)0x00F00000)
N#define EBC_NAND_CYCLES_TRR_Msk                 ((uint32_t)0x0F000000)
N
N/** @} */ /* End of group EBC_NAND_CYCLES */
N
N/** @defgroup Periph_EBC_CONTROL	EBC CONTROL
N  * @{
N  */ 
N
N/*-- EBC_CONTROL: EBC Control Register -----------------------------*/
N/* Bit field positions: */
N#define EBC_CONTROL_ROM_Pos                     0
N#define EBC_CONTROL_RAM_Pos                     1
N#define EBC_CONTROL_NAND_Pos                    2
N#define EBC_CONTROL_CPOL_Pos                    3
N#define EBC_CONTROL_BUSY_Pos                    7
N#define EBC_CONTROL_WAIT_STATE_Pos              12
N#if defined (USE_MDR1986VE94)
X#if 0L
S	#define EBC_CONTROL_FS_RDY_Pos					16
S	#define EBC_CONTROL_FF_RDY_Pos					17
N#endif
N
N/* Bit field masks: */
N#define EBC_CONTROL_ROM                         ((uint32_t)0x00000001)
N#define EBC_CONTROL_RAM                         ((uint32_t)0x00000002)
N#define EBC_CONTROL_NAND                        ((uint32_t)0x00000004)
N#define EBC_CONTROL_CPOL                        ((uint32_t)0x00000008)
N#define EBC_CONTROL_BUSY                        ((uint32_t)0x00000080)
N#define EBC_CONTROL_WAIT_STATE_Msk              ((uint32_t)0x0000F000)
N#if defined (USE_MDR1986VE94)
X#if 0L
S	#define EBC_CONTROL_FS_RDY					((uint32_t)0x00010000)
S	#define EBC_CONTROL_FF_RDY					((uint32_t)0x00020000)
N#endif
N
N
N/** @} */ /* End of group EBC_CONTROL */
N
N#if defined (USE_MDR1986VE94)
X#if 0L
S
S/** @defgroup Periph_EBC_RAM_CYCLESx	EBC RAM CYCLESx
S  * @{
S  */
S
S/*-- EBC_RAM_CYCLESx: Register customization options exchange with RAM -------*/
S/* Bit field positions: */
S#define EBC_RAM_CYCLES_ENABLE_TUNE_Pos			0
S#define EBC_RAM_CYCLES_WS_ACTIVE_Pos			1
S#define EBC_RAM_CYCLES_WS_SETUP_Pos				8
S#define EBC_RAM_CYCLES_WS_HOLD_Pos				11
S#define EBC_RAM_CYCLES_USE_READY_Pos			14
S
S/* Bit field masks: */
S#define EBC_RAM_CYCLES_ENABLE_TUNE				((uint32_t)0x00000001)
S#define EBC_RAM_CYCLES_WS_ACTIVE_Msk			((uint32_t)0x000000FE)
S#define EBC_RAM_CYCLES_WS_SETUP_Msk				((uint32_t)0x00000700)
S#define EBC_RAM_CYCLES_WS_HOLD_Msk				((uint32_t)0x00003200)
S#define EBC_RAM_CYCLES_USE_READY				((uint32_t)0x00004000)
S
S/** @} */ /* End of group EBC_RAM_CYCLESx */
N#endif
N
N/** @} */ /* End of group MDR32Fx_Periph_EBC_Defines */
N
N/** @} */ /* End of group MDR32Fx_Periph_EBC */
N
N/** @} */ /* End of group __MDR32Fx_Peripheral_Units */
N
N
N/** @defgroup __Peripheral_Memory_Map Peripheral Memory Map
N  * @{
N  */
N
N#define MDR_CAN1_BASE       (0x40000000)
N#define MDR_CAN2_BASE       (0x40008000)
N#define MDR_USB_BASE        (0x40010000)
N#define MDR_EEPROM_BASE     (0x40018000)
N#define MDR_RST_CLK_BASE    (0x40020000)
N#define MDR_DMA_BASE        (0x40028000)
N#define MDR_UART1_BASE      (0x40030000)
N#define MDR_UART2_BASE      (0x40038000)
N#define MDR_SSP1_BASE       (0x40040000)
N#define MDR_I2C_BASE        (0x40050000)
N#define MDR_POWER_BASE      (0x40058000)
N#define MDR_WWDG_BASE       (0x40060000)
N#define MDR_IWDG_BASE       (0x40068000)
N#define MDR_TIMER1_BASE     (0x40070000)
N#define MDR_TIMER2_BASE     (0x40078000)
N#define MDR_TIMER3_BASE     (0x40080000)
N#define MDR_ADC_BASE        (0x40088000)
N#define MDR_DAC_BASE        (0x40090000)
N#define MDR_COMP_BASE       (0x40098000)
N#define MDR_SSP2_BASE       (0x400A0000)
N#define MDR_PORTA_BASE      (0x400A8000)
N#define MDR_PORTB_BASE      (0x400B0000)
N#define MDR_PORTC_BASE      (0x400B8000)
N#define MDR_PORTD_BASE      (0x400C0000)
N#define MDR_PORTE_BASE      (0x400C8000)
N#define MDR_BKP_BASE        (0x400D8000)
N#define MDR_PORTF_BASE      (0x400E8000)
N#define MDR_EBC_BASE        (0x400F0000)
N
N/** @} */ /* End of group __Peripheral_Memory_Map */
N
N/** @defgroup __Peripheral_declaration Peripheral declaration
N  * @{
N  */
N
N#define MDR_CAN1            ((MDR_CAN_TypeDef     *) MDR_CAN1_BASE)
N#define MDR_CAN2            ((MDR_CAN_TypeDef     *) MDR_CAN2_BASE)
N#define MDR_USB             ((MDR_USB_TypeDef     *) MDR_USB_BASE)
N#define MDR_EEPROM          ((MDR_EEPROM_TypeDef  *) MDR_EEPROM_BASE)
N#define MDR_RST_CLK         ((MDR_RST_CLK_TypeDef *) MDR_RST_CLK_BASE)
N#define MDR_DMA             ((MDR_DMA_TypeDef     *) MDR_DMA_BASE)
N#define MDR_UART1           ((MDR_UART_TypeDef    *) MDR_UART1_BASE)
N#define MDR_UART2           ((MDR_UART_TypeDef    *) MDR_UART2_BASE)
N#define MDR_SSP1            ((MDR_SSP_TypeDef     *) MDR_SSP1_BASE)
N#define MDR_I2C             ((MDR_I2C_TypeDef     *) MDR_I2C_BASE)
N#define MDR_POWER           ((MDR_POWER_TypeDef   *) MDR_POWER_BASE)
N#define MDR_WWDG            ((MDR_WWDG_TypeDef    *) MDR_WWDG_BASE)
N#define MDR_IWDG            ((MDR_IWDG_TypeDef    *) MDR_IWDG_BASE)
N#define MDR_TIMER1          ((MDR_TIMER_TypeDef   *) MDR_TIMER1_BASE)
N#define MDR_TIMER2          ((MDR_TIMER_TypeDef   *) MDR_TIMER2_BASE)
N#define MDR_TIMER3          ((MDR_TIMER_TypeDef   *) MDR_TIMER3_BASE)
N#define MDR_ADC             ((MDR_ADC_TypeDef     *) MDR_ADC_BASE)
N#define MDR_DAC             ((MDR_DAC_TypeDef     *) MDR_DAC_BASE)
N#define MDR_COMP            ((MDR_COMP_TypeDef    *) MDR_COMP_BASE)
N#define MDR_SSP2            ((MDR_SSP_TypeDef     *) MDR_SSP2_BASE)
N#define MDR_PORTA           ((MDR_PORT_TypeDef    *) MDR_PORTA_BASE)
N#define MDR_PORTB           ((MDR_PORT_TypeDef    *) MDR_PORTB_BASE)
N#define MDR_PORTC           ((MDR_PORT_TypeDef    *) MDR_PORTC_BASE)
N#define MDR_PORTD           ((MDR_PORT_TypeDef    *) MDR_PORTD_BASE)
N#define MDR_PORTE           ((MDR_PORT_TypeDef    *) MDR_PORTE_BASE)
N#define MDR_BKP             ((MDR_BKP_TypeDef     *) MDR_BKP_BASE)
N#define MDR_PORTF           ((MDR_PORT_TypeDef    *) MDR_PORTF_BASE)
N#define MDR_EBC             ((MDR_EBC_TypeDef     *) MDR_EBC_BASE)
N
N/** @} */ /* End of group __Peripheral_declaration */
N
N#ifdef __cplusplus
S}
N#endif
N
N/** @} */ /* End of group __MDR32Fx_Peripheral */
N
N/** @} */ /* End of group MDR1986VE9x */
N
N/** @} */ /* End of group __CMSIS */
N
N#endif /* __MDR32FX_H */
N
N/*
N*
N* END OF FILE MDR32Fx.h */
L 12 "adc.c" 2
N/* Подключение заголовочного файла с конфигурацией 
N   Standard Peripheral Library (SPL) для К1986ВЕ92QI(MDR32F9Q2I) */
N#include <MDR32F9Qx_config.h>
L 1 ".\RTE\Device\MDR1986BE92\MDR32F9Qx_config.h" 1
N/**
N  ******************************************************************************
N  * @file    MDR32F9Qx_Demo\Project\Demo\MDR32F9Qx_config.h
N  * @author  Milandr Application Team
N  * @version V1.2.0
N  * @date    10/07/2010
N  * @brief   Library configuration file.
N  ******************************************************************************
N  * <br><br>
N  * THE PRESENT FIRMWARE WHICH IS FOR GUIDANCE ONLY AIMS AT PROVIDING CUSTOMERS
N  * WITH CODING INFORMATION REGARDING THEIR PRODUCTS IN ORDER FOR THEM TO SAVE
N  * TIME. AS A RESULT, MILANDR SHALL NOT BE HELD LIABLE FOR ANY
N  * DIRECT, INDIRECT OR CONSEQUENTIAL DAMAGES WITH RESPECT TO ANY CLAIMS ARISING
N  * FROM THE CONTENT OF SUCH FIRMWARE AND/OR THE USE MADE BY CUSTOMERS OF THE
N  * CODING INFORMATION CONTAINED HEREIN IN CONNECTION WITH THEIR PRODUCTS.
N  *
N  * <h2><center>&copy; COPYRIGHT 2014 Milandr</center></h2>
N  */
N
N/**
N * @mainpage MDR32F9Qx Standard Peripherals Library.
N * MDR32F9Qx Standard Peripherals Library is a package consisting of
N * all standard peripheral device drivers for 1986BE9x, K1986BE9x, MDR32F9Qx,
N * 1986VE1T, 1986VE3T, 1986VE7T microcontrollers.
N * This library is a firmware package which contains a collection of routines,
N * data structures and macros covering the features of Milandr MDR32F9Qx
N * peripherals. It includes a description of the device drivers plus a set of
N * examples for each peripheral. The firmware library allows any device to be
N * used in the user application without the need for in-depth study of each
N * peripherals specifications. Using the Standard Peripherals Library has two
N * advantages: it saves significant time that would otherwise be spent in
N * coding, while simultaneously reducing application development and
N * integration costs.
N *
N * The MDR32F9Qx Standard Peripherals Library is compatible with Milandr
N * 1986BE9x evaluation boards, Milandr evaluation board for MC 1986VE1T
N * (EVAL 22.0 B) and evaluation board for MC 1986VE3T.
N *
N * The MDR32F9Qx Standard Peripherals Library is full CMSIS compliant.
N */
N
N/* Define to prevent recursive inclusion -------------------------------------*/
N#ifndef __MDR32F9Qx_CONFIG_H
N#define __MDR32F9Qx_CONFIG_H
N
N#if ((__CC_ARM == 0) || (__ARMCC_VERSION < 5000000))
X#if ((1 == 0) || (5060528 < 5000000))
S	#include "MDR32F9Qx_board.h"
N#endif
N//#include "MDR32F9Qx_lib.h"  -         ,   
N#include <stdint.h>
N
N#if defined (USE_MDR32F9Q1_Rev0) || defined (USE_MDR32F9Q1_Rev1) ||\
N    defined (USE_MDR32F9Q2_Rev0) || defined (USE_MDR32F9Q2_Rev1) ||\
N    defined (USE_MDR32F9Q3_Rev0) || defined (USE_MDR32F9Q3_Rev1) ||\
N    defined (USE_MDR1986VE94)
X#if 0L || 0L ||    0L || 1L ||    0L || 0L ||    0L
N	#define USE_MDR1986VE9x
N#endif
N
N#if defined (USE_MDR1986BE7T)
X#if 0L
S	#define USE_MDR1986VE1T
N#endif
N
N/* Selet the header file for target microcontroller */
N#if defined ( USE_MDR1986VE9x )
X#if 1L
N	#include "MDR32Fx.h"
N#elif defined (USE_MDR1986VE1T)
S	#include "MDR1986VE1T.h"
S#elif defined ( USE_MDR1986VE3 )
S	#include "MDR1986VE3.h"
S#elif defined ( USE_MDR1901VC1T )
S	#include "MDR1901VC1T.h"
S#elif defined (USE_MDR1986BE4)
S	#include "MDR1986BE4.h"
N#endif
N
N/* Uncomment the line(s) below to define used JTAG port(s). Leave all commented
N * if there is no JTAG ports */
N#if (defined(USE_MDR1986VE9x) || defined (USE_MDR1901VC1T))
X#if (1L || 0L)
N //#define USE_JTAG_A 
N #define USE_JTAG_B 
N#endif
N
N/* Target system parameters */
N/* RST_CLK generators frequencies in HZ */
N#define HSI_Value       ((uint32_t)8000000)
N#define HSE_Value       ((uint32_t)8000000)
N#define HSE2_Value      ((uint32_t)25000000)
N#define LSI_Value       ((uint32_t)40000)
N#define LSE_Value       ((uint32_t)32768)
N
N/* RST_CLK frequencies startup timeouts settings */
N#define HSEonTimeOut    ((uint16_t)0x0600)
N#define HSE2onTimeOut	((uint16_t)0x8000)
N#define LSEonTimeOut    ((uint16_t)0x0600)
N#define HSIonTimeOut    ((uint16_t)0x0600)
N#define LSIonTimeOut    ((uint16_t)0x0600)
N#define PLLCPUonTimeOut ((uint16_t)0x0600)
N#define PLLUSBonTimeOut ((uint16_t)0x0600)
N#define PLLDSPonTimeOut ((uint16_t)0x0600)
N
N#define FLASH_PROG_FREQ_MHZ     (8.0)
N/* Use debug uart */
N//#define _USE_DEBUG_UART_
N
N#if defined (_USE_DEBUG_UART_)
X#if 0L
S
S#if defined (USE_MDR1986VE3)
S	#define DEBUG_UART 					MDR_UART2
S	#define DEBUG_UART_PORT				MDR_PORTD
S	#define DEBUG_UART_PINS				(PORT_Pin_13 | PORT_Pin_14)
S	#define DEBUG_UART_PINS_FUNCTION	PORT_FUNC_MAIN
S	#define DEBUG_BAUD_RATE				115200
S#elif defined (USE_MDR1986VE1T)
S	#define DEBUG_UART 					MDR_UART1
S	#define DEBUG_UART_PORT				MDR_PORTC
S	#define DEBUG_UART_PINS				(PORT_Pin_3 | PORT_Pin_4)
S	#define DEBUG_UART_PINS_FUNCTION	PORT_FUNC_MAIN
S	#define DEBUG_BAUD_RATE				115200
S#elif defined (USE_MDR1986VE9x)
S	#define DEBUG_UART 					MDR_UART2
S	#define DEBUG_UART_PORT				MDR_PORTF
S	#define DEBUG_UART_PINS				(PORT_Pin_0 | PORT_Pin_1)
S	#define DEBUG_UART_PINS_FUNCTION	PORT_FUNC_OVERRID
S	#define DEBUG_BAUD_RATE				115200
S#elif defined (USE_MDR1901VC1T)
S	#define DEBUG_UART 			MDR_UART3
S	#define DEBUG_UART_PORT			MDR_PORTF
S	#define DEBUG_UART_PINS			(PORT_Pin_0 | PORT_Pin_1)
S	#define DEBUG_UART_PINS_FUNCTION	PORT_FUNC_ALTER
S	#define DEBUG_BAUD_RATE			115200
S#endif
S
S//#define PRINTF_FORMAT_FULL
S//#define PRINTF_FORMAT_LARGE
S
N#endif /* #if defined (_USE_DEBUG_UART_) */
N
N#if defined ( USE_MDR1986VE3 ) || defined ( USE_MDR1986VE1T )
X#if 0L || 0L
S	#define MIL_STD_1553_TERMINAL_ADDRESS	0x01
N#endif /* #if defined ( USE_MDR1986VE3 ) || defined ( USE_MDR1986VE1T ) */
N
N/* RTC configuration parameters */
N#define RTC_CalibratorValue   	0
N#define RTC_PRESCALER_VALUE		32768
N
N/* DMA configuration parameters */
N/* Number of DMA channels to use */
N#define DMA_Channels_Number   32          /* This parameter is in range 1..32 */
N
N/* Alternate Control Data Structure Usage */
N/* This parameter can be a value of:
N    0 = DMA_ALternateDataDisabled;
N    1 = DMA_ALternateDataEnabled; */
N/*#define DMA_AlternateData   0 */          /* DMA_AlternateDataDisabled */
N#define DMA_AlternateData   1             /* DMA_AlternateDataEnabled */
N
N/* USB configuration parameters ----------------------------------------------*/
N/* Uncomment one of the lines below to select the Device Class. Leave all commented
N * if the desired device class is not currently supported by USB library */
N#define USB_DEVICE_CLASS  USB_DEVICE_CLASS_CDC
N
N/* USB Device management */
N/* Uncomment the line below to enable appropriate functionality. */
N/* #define USB_REMOTE_WAKEUP_SUPPORTED */
N/* #define USB_SELF_POWERED_SUPPORTED */
N
N/* Uncomment the line below to let the library provide USB interrupt handler.
N * Leave this line commented if you are willing to implement the handler yourself. */
N#define USB_INT_HANDLE_REQUIRED
N
N/* USB CDC management */
N/* Uncomment the lines below to enable appropriate functionality. */
N/* #define USB_CDC_STATE_REPORTING_SUPPORTED 	*/
N/* #define USB_CDC_ENCAPSULATION_SUPPORTED 	*/
N/* #define USB_CDC_COMM_FEATURE_SUPPORTED 	*/
N#define USB_CDC_LINE_CODING_SUPPORTED 	
N/* #define USB_CDC_CONTROL_LINE_STATE_SUPPORTED */
N/* #define USB_CDC_LINE_BREAK_SUPPORTED 	*/
N
N/* VCOM Echo example flags */
N
N/* Uncomment USB_VCOM_SYNC to enable "reliable delivery" mode: no new data
N * would be received (EP3 will reply NAK) until all previous data is sent
N * to host. */
N//#define USB_VCOM_SYNC
N
N/* Uncomment USB_DEBUG_PROTO to utilize the ring buffer for received setup
N * packets and send/receive byte counters (for debug purposes). */
N//#define USB_DEBUG_PROTO
N
N/* Known errors workaround control -------------------------------------------*/
N/* MDR32F9Qx Series Errata Notice, Error 0002 */
N#define WORKAROUND_MDR32F9QX_ERROR_0002
N
N/* Parameter run-time check support ------------------------------------------*/
N
N/* Select one of the following values of USE_ASSERT_INFO macro to control
N   parameter checking in the Standard Peripheral Library drivers:
N     0 - no parameter checks ("assert_param" macro is disabled);
N     1 - check enabled, source file ID and line number are available;
N     2 - check enabled, source file ID, line number and checking expression
N         (as string) are available (increased code size).
N*/
N #define USE_ASSERT_INFO    0 
N/* #define USE_ASSERT_INFO    1 */
N/* #define USE_ASSERT_INFO    2 */
N
N/**
N  * @brief  The assert_param macro is used for function's parameters check.
N  * @param  expr: If expr is false, it calls assert_failed user's function
N  *   which gets the source file ID (see MDR32F9Qx_lib.h), line number and
N  *   expression text (if USE_ASSERT_INFO == 2) of the call that failed. That
N  *   function should not return. If expr is true, nothing is done.
N  * @retval None
N  */
N#if (USE_ASSERT_INFO == 0)
X#if (0 == 0)
N  #define assert_param(expr) ((void)0)
N#elif (USE_ASSERT_INFO == 1)
S  #define assert_param(expr) ((expr) ? (void)0 : assert_failed(ASSERT_INFO_FILE_ID, __LINE__))
S  void assert_failed(uint32_t file_id, uint32_t line);
S#elif (USE_ASSERT_INFO == 2)
S  #define assert_param(expr) ((expr) ? (void)0 : assert_failed(ASSERT_INFO_FILE_ID, __LINE__, #expr))
S  void assert_failed(uint32_t file_id, uint32_t line, const uint8_t* expr);
S#else
S  #error "Unsupported USE_ASSERT_INFO level"
N#endif /* USE_ASSERT_INFO */
N
N#if defined (__ICCARM__)
X#if 0L
S	#define __attribute__(name_section)
S	#if defined (USE_MDR1986VE3) || defined (USE_MDR1986VE1T)
S		#pragma section = "EXECUTABLE_MEMORY_SECTION"
S		#define IAR_SECTION(section) @ section
S	#elif defined (USE_MDR1986VE9x)
S		#define IAR_SECTION(section)
S	#endif
N#endif
N#if defined (__CMCARM__)
X#if 0L
S		#define __attribute__(name_section)
S		#define IAR_SECTION(section)
N#endif
N
N#if defined (__CC_ARM)
X#if 1L
N	#define IAR_SECTION(section)
N#endif
N
N#endif /* __MDR32F9Qx_CONFIG_H */
N
N/******************* (C) COPYRIGHT 2011 Milandr *********************************
N*
N* END OF FILE MDR32F9Qx_config.h */
L 15 "adc.c" 2
N/* Подключение функций управления портами */
N#include <MDR32F9Qx_port.h>
L 1 "C:\Keil_v5\ARM\PACK\Keil\MDR1986BExx\1.5.3\Libraries\MDR32F9Qx_StdPeriph_Driver\inc\MDR32F9Qx_port.h" 1
N/**
N  * FILE MDR32F9Qx_port.h
N  */
N
N/* Define to prevent recursive inclusion -------------------------------------*/
N#ifndef __MDR32F9Qx_PORT_H
N#define __MDR32F9Qx_PORT_H
N
N#ifdef __cplusplus
Sextern "C" {
N#endif
N
N/* Includes ------------------------------------------------------------------*/
N#include "MDR32F9Qx_config.h"
N#include "MDR32F9Qx_lib.h"
L 1 "C:\Keil_v5\ARM\PACK\Keil\MDR1986BExx\1.5.3\Libraries\MDR32F9Qx_StdPeriph_Driver\inc\MDR32F9Qx_lib.h" 1
N/**
N  * FILE MDR32F9Qx_lib.h
N  */
N
N/* Define to prevent recursive inclusion -------------------------------------*/
N#ifndef __MDR32F9QX_LIB_H
N#define __MDR32F9QX_LIB_H
N
N#ifdef __cplusplus
Sextern "C" {
N#endif
N
N#define FILEID__MDR32F9X_CAN_C					1
N#define FILEID__MDR32F9X_USB_C					2
N#define FILEID__MDR32F9X_EEPROM_C				3
N#define FILEID__MDR32F9X_RST_CLK_C				4
N#define FILEID__MDR32F9X_DMA_C					5
N#define FILEID__MDR32F9X_UART_C					6
N#define FILEID__MDR32F9X_SSP_C					7
N#define FILEID__MDR32F9X_I2C_C					8
N#define FILEID__MDR32F9X_POWER_C				9
N#define FILEID__MDR32F9X_WWDG_C					10
N#define FILEID__MDR32F9X_IWDG_C					11
N#define FILEID__MDR32F9X_TIMER_C				12
N#define FILEID__MDR32F9X_ADC_C					13
N#define FILEID__MDR32F9X_DAC_C					14
N#define FILEID__MDR32F9X_COMP_C					15
N#define FILEID__MDR32F9X_PORT_C					16
N#define FILEID__MDR32F9X_BKP_C					17
N#define FILEID__MDR32F9X_EBC_C					18
N#define FILEID__MDR32F9X_USB_DEVICE_C			19
N#define FILEID__MDR32F9X_USB_CDC_C				20
N#define FILEID__MDR32F9X_MIL_STD1553_C			21
N#define FILEID__MDR32F9X_ARINC429R_C			22
N#define FILEID__MDR32F9X_ARINC429T_C			23
N#define FILEID__MDR32F9X_ETH_C					24
N#define FILEID__MDR32F9Qx_AUDIO_C				25
N#define FILEID__MDR32F9Qx_KEYPAD_C				26
N#define FILEID__MDR32F9Qx_LED_C					27
N#define FILEID__MDR32F9Qx_SDIO_C				28
N#define FILEID__MDR32F9Qx_DSP_C					29
N
N#define  FILEID__USER_LO                    	100
N
N/* Supported USB Device Classes */
N#define USB_DEVICE_CLASS_CDC 2
N
N#ifdef __cplusplus
S} // extern "C" block end
N#endif
N
N#endif /* __MDR32F9QX_LIB_H */
N
N/*
N*
N* END OF FILE MDR32F9Qx_lib.h */
L 16 "C:\Keil_v5\ARM\PACK\Keil\MDR1986BExx\1.5.3\Libraries\MDR32F9Qx_StdPeriph_Driver\inc\MDR32F9Qx_port.h" 2
N
N
N/** @addtogroup __MDR32F9Qx_StdPeriph_Driver MDR32F9Qx Standard Peripherial Driver
N  * @{
N  */
N
N/** @addtogroup PORT
N  * @{
N  */
N
N/** @defgroup PORT_Exported_Types PORT Exported Types
N  * @{
N  */
N
N#if defined (USE_MDR1986VE9x) || defined (USE_MDR1986VE1T) || defined (USE_MDR1901VC1T)
X#if 1L || 0L || 0L
N#define IS_PORT_ALL_PERIPH(PERIPH) (((PERIPH) == MDR_PORTA) || \
N                                    ((PERIPH) == MDR_PORTB) || \
N                                    ((PERIPH) == MDR_PORTC) || \
N                                    ((PERIPH) == MDR_PORTD) || \
N                                    ((PERIPH) == MDR_PORTE) || \
N                                    ((PERIPH) == MDR_PORTF))
X#define IS_PORT_ALL_PERIPH(PERIPH) (((PERIPH) == MDR_PORTA) ||                                     ((PERIPH) == MDR_PORTB) ||                                     ((PERIPH) == MDR_PORTC) ||                                     ((PERIPH) == MDR_PORTD) ||                                     ((PERIPH) == MDR_PORTE) ||                                     ((PERIPH) == MDR_PORTF))
N#endif
N#if defined (USE_MDR1986VE3)
X#if 0L
S#define IS_PORT_ALL_PERIPH(PERIPH) (((PERIPH) == MDR_PORTA) || \
S                                    ((PERIPH) == MDR_PORTB) || \
S                                    ((PERIPH) == MDR_PORTC) || \
S                                    ((PERIPH) == MDR_PORTD) || \
S                                    ((PERIPH) == MDR_PORTE) || \
S                                    ((PERIPH) == MDR_PORTF) || \
S                                    ((PERIPH) == MDR_PORTG) || \
S                                    ((PERIPH) == MDR_PORTH) || \
S                                    ((PERIPH) == MDR_PORTI))
X#define IS_PORT_ALL_PERIPH(PERIPH) (((PERIPH) == MDR_PORTA) ||                                     ((PERIPH) == MDR_PORTB) ||                                     ((PERIPH) == MDR_PORTC) ||                                     ((PERIPH) == MDR_PORTD) ||                                     ((PERIPH) == MDR_PORTE) ||                                     ((PERIPH) == MDR_PORTF) ||                                     ((PERIPH) == MDR_PORTG) ||                                     ((PERIPH) == MDR_PORTH) ||                                     ((PERIPH) == MDR_PORTI))
N#endif
N
N/**
N  * @brief  Configuration OE enumeration
N  */
N
Ntypedef enum
N{
N  PORT_OE_IN            = 0x0,
N  PORT_OE_OUT           = 0x1
N}PORT_OE_TypeDef;
N
N#define IS_PORT_OE(OE) (((OE) == PORT_OE_IN) || ((OE) == PORT_OE_OUT))
N
N
N/**
N  * @brief  Configuration Mode enumeration
N  */
N
Ntypedef enum
N{
N  PORT_MODE_ANALOG      = 0x0,
N  PORT_MODE_DIGITAL     = 0x1
N}PORT_MODE_TypeDef;
N
N#define IS_PORT_MODE(MODE) (((MODE) == PORT_MODE_ANALOG) || ((MODE) == PORT_MODE_DIGITAL))
N
N
N/**
N  * @brief  Configuration PULL_UP enumeration
N  */
N
Ntypedef enum
N{
N  PORT_PULL_UP_OFF      = 0x0,
N  PORT_PULL_UP_ON       = 0x1
N}PORT_PULL_UP_TypeDef;
N
N#define IS_PORT_PULL_UP(PULL_UP) (((PULL_UP) == PORT_PULL_UP_OFF) || ((PULL_UP) == PORT_PULL_UP_ON))
N
N
N/**
N  * @brief  Configuration PULL_DOWN enumeration
N  */
N
Ntypedef enum
N{
N  PORT_PULL_DOWN_OFF    = 0x0,
N  PORT_PULL_DOWN_ON     = 0x1
N}PORT_PULL_DOWN_TypeDef;
N
N#define IS_PORT_PULL_DOWN(PULL_DOWN) (((PULL_DOWN) == PORT_PULL_DOWN_ON) || \
N                                      ((PULL_DOWN) == PORT_PULL_DOWN_OFF))
X#define IS_PORT_PULL_DOWN(PULL_DOWN) (((PULL_DOWN) == PORT_PULL_DOWN_ON) ||                                       ((PULL_DOWN) == PORT_PULL_DOWN_OFF))
N
N/**
N  * @brief  Configuration PD_SHM enumeration
N  */
N
Ntypedef enum
N{
N  PORT_PD_SHM_OFF       = 0x0,
N  PORT_PD_SHM_ON        = 0x1
N}PORT_PD_SHM_TypeDef;
N
N#define IS_PORT_PD_SHM(PORT_PD_SHM) (((PORT_PD_SHM) == PORT_PD_SHM_OFF) || \
N                                     ((PORT_PD_SHM) == PORT_PD_SHM_ON))
X#define IS_PORT_PD_SHM(PORT_PD_SHM) (((PORT_PD_SHM) == PORT_PD_SHM_OFF) ||                                      ((PORT_PD_SHM) == PORT_PD_SHM_ON))
N
N
N/**
N  * @brief  Configuration PD_PD enumeration
N  */
N
Ntypedef enum
N{
N  PORT_PD_DRIVER        = 0x0,
N  PORT_PD_OPEN          = 0x1
N}PORT_PD_TypeDef;
N
N#define IS_PORT_PD(PORT_PD) (((PORT_PD) == PORT_PD_DRIVER) || ((PORT_PD) == PORT_PD_OPEN))
N
N/**
N  * @brief  Configuration GFEN enumeration
N  */
N
Ntypedef enum
N{
N  PORT_GFEN_OFF         = 0x0,
N  PORT_GFEN_ON          = 0x1
N}PORT_GFEN_TypeDef;
N
N#define IS_PORT_GFEN(PORT_GFEN) (((PORT_GFEN) == PORT_GFEN_OFF) || ((PORT_GFEN) == PORT_GFEN_ON))
N
N
N/**
N  * @brief  Configuration Function enumeration
N  */
N
Ntypedef enum
N{
N  PORT_FUNC_PORT        = 0x0,
N  PORT_FUNC_MAIN        = 0x1,
N  PORT_FUNC_ALTER       = 0x2,
N  PORT_FUNC_OVERRID     = 0x3
N}PORT_FUNC_TypeDef;
N
N#define IS_PORT_FUNC(FUNC) (((FUNC) == PORT_FUNC_PORT)  || ((FUNC) == PORT_FUNC_MAIN) || \
N                            ((FUNC) == PORT_FUNC_ALTER) || ((FUNC) == PORT_FUNC_OVERRID))
X#define IS_PORT_FUNC(FUNC) (((FUNC) == PORT_FUNC_PORT)  || ((FUNC) == PORT_FUNC_MAIN) ||                             ((FUNC) == PORT_FUNC_ALTER) || ((FUNC) == PORT_FUNC_OVERRID))
N
N/**
N  * @brief  Configuration Speed enumeration
N  */
N
Ntypedef enum
N{
N  PORT_OUTPUT_OFF       = 0x0,
N  PORT_SPEED_SLOW       = 0x1,
N  PORT_SPEED_FAST       = 0x2,
N  PORT_SPEED_MAXFAST    = 0x3
N}PORT_SPEED_TypeDef;
N
N#define IS_PORT_SPEED(SPEED) (((SPEED) == PORT_OUTPUT_OFF) || ((SPEED) == PORT_SPEED_SLOW) || \
N                              ((SPEED) == PORT_SPEED_FAST) || ((SPEED) == PORT_SPEED_MAXFAST))
X#define IS_PORT_SPEED(SPEED) (((SPEED) == PORT_OUTPUT_OFF) || ((SPEED) == PORT_SPEED_SLOW) ||                               ((SPEED) == PORT_SPEED_FAST) || ((SPEED) == PORT_SPEED_MAXFAST))
N
N
N/**
N  * @brief  PORT Init structure definition
N  */
N
Ntypedef struct
N{
N  uint16_t PORT_Pin;                     /*!< Specifies PORT pins to be configured.
N                                              This parameter is a mask of @ref PORT_pins_define values. */
N  PORT_OE_TypeDef PORT_OE;               /*!< Specifies in/out mode for the selected pins.
N                                              This parameter is one of @ref PORT_OE_TypeDef values. */
N  PORT_PULL_UP_TypeDef PORT_PULL_UP;     /*!< Specifies pull up state for the selected pins.
N                                              This parameter is one of @ref PORT_PULL_UP_TypeDef values. */
N  PORT_PULL_DOWN_TypeDef PORT_PULL_DOWN; /*!< Specifies pull down state for the selected pins.
N                                              This parameter is one of @ref PORT_PULL_DOWN_TypeDef values. */
N  PORT_PD_SHM_TypeDef PORT_PD_SHM;       /*!< Specifies SHM state for the selected pins.
N                                              This parameter is one of @ref PORT_PD_SHM_TypeDef values. */
N  PORT_PD_TypeDef PORT_PD;               /*!< Specifies PD state for the selected pins.
N                                              This parameter is one of @ref PORT_PD_TypeDef values. */
N  PORT_GFEN_TypeDef PORT_GFEN;           /*!< Specifies GFEN state for the selected pins.
N                                              This parameter is one of @ref PORT_GFEN_TypeDef values. */
N  PORT_FUNC_TypeDef PORT_FUNC;           /*!< Specifies operating function for the selected pins.
N                                              This parameter is one of @ref PORT_FUNC_TypeDef values. */
N  PORT_SPEED_TypeDef PORT_SPEED;         /*!< Specifies the speed for the selected pins.
N                                              This parameter is one of @ref PORT_SPEED_TypeDef values. */
N  PORT_MODE_TypeDef PORT_MODE;           /*!< Specifies the operating mode for the selected pins.
N                                              This parameter is one of @ref PORT_MODE_TypeDef values. */
N}PORT_InitTypeDef;
N
N
N/**
N  * @brief  Bit_SET and Bit_RESET enumeration
N  */
N
Ntypedef enum
N{
N  Bit_RESET = 0,
N  Bit_SET
N}BitAction;
N
N#define IS_PORT_BIT_ACTION(ACTION) (((ACTION) == Bit_RESET) || ((ACTION) == Bit_SET))
N
N/** @} */ /* End of group PORT_Exported_Types */
N
N/** @defgroup PORT_Exported_Constants PORT Exported Constants
N  * @{
N  */
N
N/** @defgroup PORT_JTAG_define PORT JTAG define
N  * @{
N  */
N
N#if defined (USE_JTAG_A)
X#if 0L
S#define PORT_JTAG                   MDR_PORTB    /*!< Port containing JTAG interface */
S#define PORT_JTAG_Msk               0x001FU      /*!< JTAG pins */
S
N#elif defined (USE_JTAG_B)
X#elif 1L
N#define PORT_JTAG                   MDR_PORTD    /*!< Port containing JTAG interface */
N#define PORT_JTAG_Msk               0x001FU      /*!< JTAG pins */
N
N#endif
N
N#if defined (PORT_JTAG)
X#if 1L
N#define JTAG_PINS(PORT)             (((PORT) == PORT_JTAG) ? PORT_JTAG_Msk : 0)
N
N#else
S#define JTAG_PINS(PORT)             0
S
N#endif
N
N#define IS_NOT_JTAG_PIN(PORT, PIN)  (((PIN) & JTAG_PINS(PORT)) == 0x00)
N
N
N/** @} */ /* End of group PORT_JTAG_define */
N
N/** @defgroup PORT_pins_define PORT pins define
N  * @{
N  */
N
N#define PORT_Pin_0                  0x0001U  /*!< Pin 0 selected */
N#define PORT_Pin_1                  0x0002U  /*!< Pin 1 selected */
N#define PORT_Pin_2                  0x0004U  /*!< Pin 2 selected */
N#define PORT_Pin_3                  0x0008U  /*!< Pin 3 selected */
N#define PORT_Pin_4                  0x0010U  /*!< Pin 4 selected */
N#define PORT_Pin_5                  0x0020U  /*!< Pin 5 selected */
N#define PORT_Pin_6                  0x0040U  /*!< Pin 6 selected */
N#define PORT_Pin_7                  0x0080U  /*!< Pin 7 selected */
N#define PORT_Pin_8                  0x0100U  /*!< Pin 8 selected */
N#define PORT_Pin_9                  0x0200U  /*!< Pin 9 selected */
N#define PORT_Pin_10                 0x0400U  /*!< Pin 10 selected */
N#define PORT_Pin_11                 0x0800U  /*!< Pin 11 selected */
N#define PORT_Pin_12                 0x1000U  /*!< Pin 12 selected */
N#define PORT_Pin_13                 0x2000U  /*!< Pin 13 selected */
N#define PORT_Pin_14                 0x4000U  /*!< Pin 14 selected */
N#define PORT_Pin_15                 0x8000U  /*!< Pin 15 selected */
N#define PORT_Pin_All                0xFFFFU  /*!< All pins selected */
N
N#define IS_PORT_PIN(PIN)            ((((PIN) & (uint32_t)0xFFFF0000UL) == 0x00) && \
N                                     ((PIN) != 0x00))
X#define IS_PORT_PIN(PIN)            ((((PIN) & (uint32_t)0xFFFF0000UL) == 0x00) &&                                      ((PIN) != 0x00))
N
N#define IS_GET_PORT_PIN(PIN)        (((PIN) == PORT_Pin_0 ) || \
N                                     ((PIN) == PORT_Pin_1 ) || \
N                                     ((PIN) == PORT_Pin_2 ) || \
N                                     ((PIN) == PORT_Pin_3 ) || \
N                                     ((PIN) == PORT_Pin_4 ) || \
N                                     ((PIN) == PORT_Pin_5 ) || \
N                                     ((PIN) == PORT_Pin_6 ) || \
N                                     ((PIN) == PORT_Pin_7 ) || \
N                                     ((PIN) == PORT_Pin_8 ) || \
N                                     ((PIN) == PORT_Pin_9 ) || \
N                                     ((PIN) == PORT_Pin_10) || \
N                                     ((PIN) == PORT_Pin_11) || \
N                                     ((PIN) == PORT_Pin_12) || \
N                                     ((PIN) == PORT_Pin_13) || \
N                                     ((PIN) == PORT_Pin_14) || \
N                                     ((PIN) == PORT_Pin_15))
X#define IS_GET_PORT_PIN(PIN)        (((PIN) == PORT_Pin_0 ) ||                                      ((PIN) == PORT_Pin_1 ) ||                                      ((PIN) == PORT_Pin_2 ) ||                                      ((PIN) == PORT_Pin_3 ) ||                                      ((PIN) == PORT_Pin_4 ) ||                                      ((PIN) == PORT_Pin_5 ) ||                                      ((PIN) == PORT_Pin_6 ) ||                                      ((PIN) == PORT_Pin_7 ) ||                                      ((PIN) == PORT_Pin_8 ) ||                                      ((PIN) == PORT_Pin_9 ) ||                                      ((PIN) == PORT_Pin_10) ||                                      ((PIN) == PORT_Pin_11) ||                                      ((PIN) == PORT_Pin_12) ||                                      ((PIN) == PORT_Pin_13) ||                                      ((PIN) == PORT_Pin_14) ||                                      ((PIN) == PORT_Pin_15))
N
N/** @} */ /* End of group PORT_pins_define */
N
N/** @} */ /* End of group PORT_Exported_Constants */
N
N/** @defgroup PORT_Exported_Macros PORT Exported Macros
N  * @{
N  */
N
N/** @} */ /* End of group PORT_Exported_Macros */
N
N/** @defgroup PORT_Exported_Functions PORT Exported Functions
N  * @{
N  */
N
Nvoid PORT_DeInit(MDR_PORT_TypeDef* PORTx);
Nvoid PORT_Init(MDR_PORT_TypeDef* PORTx, const PORT_InitTypeDef* PORT_InitStruct);
Nvoid PORT_StructInit(PORT_InitTypeDef* PORT_InitStruct);
N
Nuint8_t PORT_ReadInputDataBit(MDR_PORT_TypeDef* PORTx, uint32_t PORT_Pin);
Nuint32_t PORT_ReadInputData(MDR_PORT_TypeDef* PORTx);
N
Nvoid PORT_SetBits(MDR_PORT_TypeDef* PORTx, uint32_t PORT_Pin);
Nvoid PORT_ResetBits(MDR_PORT_TypeDef* PORTx, uint32_t PORT_Pin);
Nvoid PORT_WriteBit(MDR_PORT_TypeDef* PORTx, uint32_t PORT_Pin, BitAction BitVal);
Nvoid PORT_Write(MDR_PORT_TypeDef* PORTx, uint32_t PortVal);
N
N/** @} */ /* End of group PORT_Exported_Functions */
N
N/** @} */ /* End of group PORT */
N
N/** @} */ /* End of group __MDR32F9Qx_StdPeriph_Driver */
N
N#ifdef __cplusplus
S} // extern "C" block end
N#endif
N
N#endif /* __MDR32F9Qx_PORT_H */
N
N/*
N*
N* END OF FILE MDR32F9Qx_port.h */
L 17 "adc.c" 2
N/* Подключение функций управления тактированием */
N#include <MDR32F9Qx_rst_clk.h>
L 1 "C:\Keil_v5\ARM\PACK\Keil\MDR1986BExx\1.5.3\Libraries\MDR32F9Qx_StdPeriph_Driver\inc\MDR32F9Qx_rst_clk.h" 1
N/**
N  * FILE MDR32F9Qx_rst_clk.h
N  */
N
N/* Define to prevent recursive inclusion -------------------------------------*/
N#ifndef __MDR32F9Qx_RST_CLK_H
N#define __MDR32F9Qx_RST_CLK_H
N
N#ifdef __cplusplus
Sextern "C" {
N#endif
N
N/* Includes ------------------------------------------------------------------*/
N#include "MDR32F9Qx_config.h"
N#include "MDR32F9Qx_lib.h"
N
N/** @addtogroup __MDR32F9Qx_StdPeriph_Driver MDR32F9Qx Standard Peripherial Driver
N  * @{
N  */
N
N/** @addtogroup RST_CLK
N  * @{
N  */
N
N/** @defgroup RST_CLK_Exported_Types RST_CLK Exported Types
N  * @{
N  */
N
N/**
N  * @brief Structure type for modules clocks frequencies expressed in Hz
N  */
N
Ntypedef struct
N{
N  uint32_t CPU_CLK_Frequency;
N  uint32_t USB_CLK_Frequency;
N  uint32_t ADC_CLK_Frequency;
N  uint32_t RTCHSI_Frequency;
N  uint32_t RTCHSE_Frequency;
N}RST_CLK_FreqTypeDef;
N
N/**
N  * @brief RST_CLK unit non-volatile settings init structure
N  */
N
Ntypedef struct {
N     uint32_t REG_0F;
N} Init_NonVolatile_RST_CLK_TypeDef;
N
N/** @} */ /* End of group RST_CLK_Exported_Types */
N
N/** @defgroup RST_CLK_Exported_Constants RST_CLK Exported Constants
N  * @{
N  */
N
N/** @defgroup HSE_configuration HSE configuration
N  * @{
N  */
N
N/**
N  * @brief RST_CLK HSE (High Speed External) clock mode and source selection constants
N  */
N
N#define RST_CLK_HSE_OFF                      ((uint32_t)0x00000000)
N#define RST_CLK_HSE_ON                       ((uint32_t)0x00000001)
N#define RST_CLK_HSE_Bypass                   ((uint32_t)0x00000002)
N
N#define IS_RST_CLK_HSE(HSE)                  (((HSE) == RST_CLK_HSE_OFF) || \
N                                              ((HSE) == RST_CLK_HSE_ON)  || \
N                                              ((HSE) == RST_CLK_HSE_Bypass))
X#define IS_RST_CLK_HSE(HSE)                  (((HSE) == RST_CLK_HSE_OFF) ||                                               ((HSE) == RST_CLK_HSE_ON)  ||                                               ((HSE) == RST_CLK_HSE_Bypass))
N
N/** @} */ /* End of group HSE_configuration */
N
N
N#if defined  (USE_MDR1986VE3) || defined (USE_MDR1986VE1T)
X#if 0L || 0L
S/** @defgroup HSE2_configuration HSE2 configuration
S *  @{
S */
S
S/**
S  * @brief RST_CLK HSE2 (High Speed External 2 ) clock mode and source selection constants
S  */
S
S#define RST_CLK_HSE2_OFF						((uint32_t)0x00000000)
S#define RST_CLK_HSE2_ON							((uint32_t)0x00000004)
S#define RST_CLK_HSE2_Bypass						((uint32_t)0x00000008)
S
S#define IS_RST_CLK_HSE2(HSE2)                  	(((HSE2) == RST_CLK_HSE2_OFF) || \
S                                              	 ((HSE2) == RST_CLK_HSE2_ON)  || \
S                                              	 ((HSE2) == RST_CLK_HSE2_Bypass))
X#define IS_RST_CLK_HSE2(HSE2)                  	(((HSE2) == RST_CLK_HSE2_OFF) ||                                               	 ((HSE2) == RST_CLK_HSE2_ON)  ||                                               	 ((HSE2) == RST_CLK_HSE2_Bypass))
S
S/** @} */ /* End of group HSE2_configuration */
S
N#endif /* #if defined  (USE_MDR1986VE3) || defined (USE_MDR1986VE1T) */
N
N/** @defgroup LSE_configuration LSE configuration
N  * @{
N  */
N
N/**
N  * @brief RST_CLK LSE (Low Speed External) clock mode and source selection constants
N  */
N
N#define RST_CLK_LSE_OFF                      ((uint32_t)0x00000000)
N#define RST_CLK_LSE_ON                       ((uint32_t)0x00000001)
N#define RST_CLK_LSE_Bypass                   ((uint32_t)0x00000002)
N
N#define IS_RST_CLK_LSE(LSE)                  (((LSE) == RST_CLK_LSE_OFF) || \
N                                              ((LSE) == RST_CLK_LSE_ON)  || \
N                                              ((LSE) == RST_CLK_LSE_Bypass))
X#define IS_RST_CLK_LSE(LSE)                  (((LSE) == RST_CLK_LSE_OFF) ||                                               ((LSE) == RST_CLK_LSE_ON)  ||                                               ((LSE) == RST_CLK_LSE_Bypass))
N
N/** @} */ /* End of group LSE_configuration */
N
N/** @defgroup CPU_PLL_entry_clock_source CPU PLL entry clock source
N  * @{
N  */
N
N/**
N  * @brief RST_CLK CPU_PLL clock mode and source selection constants
N  */
N
N#define RST_CLK_CPU_PLLsrcHSIdiv1           ((uint32_t)0x00000000)
N#define RST_CLK_CPU_PLLsrcHSIdiv2           ((uint32_t)0x00000001)
N#define RST_CLK_CPU_PLLsrcHSEdiv1           ((uint32_t)0x00000002)
N#define RST_CLK_CPU_PLLsrcHSEdiv2           ((uint32_t)0x00000003)
N
N#define IS_RST_CLK_CPU_PLL_SOURCE(SRC)      (((SRC) == RST_CLK_CPU_PLLsrcHSIdiv1) || \
N                                             ((SRC) == RST_CLK_CPU_PLLsrcHSIdiv2) || \
N                                             ((SRC) == RST_CLK_CPU_PLLsrcHSEdiv1) || \
N                                             ((SRC) == RST_CLK_CPU_PLLsrcHSEdiv2))
X#define IS_RST_CLK_CPU_PLL_SOURCE(SRC)      (((SRC) == RST_CLK_CPU_PLLsrcHSIdiv1) ||                                              ((SRC) == RST_CLK_CPU_PLLsrcHSIdiv2) ||                                              ((SRC) == RST_CLK_CPU_PLLsrcHSEdiv1) ||                                              ((SRC) == RST_CLK_CPU_PLLsrcHSEdiv2))
N
N/** @} */ /* End of group CPU_PLL_entry_clock_source */
N
N/** @defgroup CPU_PLL_clock_multiplier CPU_PLL clock multiplier
N  * @{
N  */
N
N/**
N  * @brief RST_CLK PLL_CPU_MUL multiplier of the CPU_C1 clock constants
N  */
N
N#define RST_CLK_CPU_PLLmul1                     ((uint32_t)0x00000000)
N#define RST_CLK_CPU_PLLmul2                     ((uint32_t)0x00000001)
N#define RST_CLK_CPU_PLLmul3                     ((uint32_t)0x00000002)
N#define RST_CLK_CPU_PLLmul4                     ((uint32_t)0x00000003)
N#define RST_CLK_CPU_PLLmul5                     ((uint32_t)0x00000004)
N#define RST_CLK_CPU_PLLmul6                     ((uint32_t)0x00000005)
N#define RST_CLK_CPU_PLLmul7                     ((uint32_t)0x00000006)
N#define RST_CLK_CPU_PLLmul8                     ((uint32_t)0x00000007)
N#define RST_CLK_CPU_PLLmul9                     ((uint32_t)0x00000008)
N#define RST_CLK_CPU_PLLmul10                    ((uint32_t)0x00000009)
N#define RST_CLK_CPU_PLLmul11                    ((uint32_t)0x0000000A)
N#define RST_CLK_CPU_PLLmul12                    ((uint32_t)0x0000000B)
N#define RST_CLK_CPU_PLLmul13                    ((uint32_t)0x0000000C)
N#define RST_CLK_CPU_PLLmul14                    ((uint32_t)0x0000000D)
N#define RST_CLK_CPU_PLLmul15                    ((uint32_t)0x0000000E)
N#define RST_CLK_CPU_PLLmul16                    ((uint32_t)0x0000000F)
N
N#define IS_RST_CLK_CPU_PLL_MUL(SRC)             (((SRC)>=0) && ((SRC)<16))
N
N/** @} */ /* End of group CPU_PLL_clock_multiplier */
N
N
N/** @defgroup USB_PLL_entry_clock_source USB PLL entry clock source
N  * @{
N  */
N
N/**
N  * @brief RST_CLK USB_PLL clock mode and source selection constants
N  */
N
N#define RST_CLK_USB_PLLsrcHSIdiv1           ((uint32_t)0x00000000)
N#define RST_CLK_USB_PLLsrcHSIdiv2           ((uint32_t)0x00000001)
N#define RST_CLK_USB_PLLsrcHSEdiv1           ((uint32_t)0x00000002)
N#define RST_CLK_USB_PLLsrcHSEdiv2           ((uint32_t)0x00000003)
N
N#define IS_RST_CLK_USB_PLL_SOURCE(SRC)      (((SRC) == RST_CLK_USB_PLLsrcHSIdiv1) ||\
N                                             ((SRC) == RST_CLK_USB_PLLsrcHSIdiv2) ||\
N                                             ((SRC) == RST_CLK_USB_PLLsrcHSEdiv1) ||\
N                                             ((SRC) == RST_CLK_USB_PLLsrcHSEdiv2))
X#define IS_RST_CLK_USB_PLL_SOURCE(SRC)      (((SRC) == RST_CLK_USB_PLLsrcHSIdiv1) ||                                             ((SRC) == RST_CLK_USB_PLLsrcHSIdiv2) ||                                             ((SRC) == RST_CLK_USB_PLLsrcHSEdiv1) ||                                             ((SRC) == RST_CLK_USB_PLLsrcHSEdiv2))
N
N/** @} */ /* End of group USB_PLL_entry_clock_source */
N
N/** @defgroup USB_PLL_clock_multiplier USB_PLL clock multiplier
N  * @{
N  */
N
N/**
N  * @brief RST_CLK USB_C1 clock PLL_USB_MUL multiplier constants
N  */
N
N#define RST_CLK_USB_PLLmul1                     ((uint32_t)0x00000000)
N#define RST_CLK_USB_PLLmul2                     ((uint32_t)0x00000001)
N#define RST_CLK_USB_PLLmul3                     ((uint32_t)0x00000002)
N#define RST_CLK_USB_PLLmul4                     ((uint32_t)0x00000003)
N#define RST_CLK_USB_PLLmul5                     ((uint32_t)0x00000004)
N#define RST_CLK_USB_PLLmul6                     ((uint32_t)0x00000005)
N#define RST_CLK_USB_PLLmul7                     ((uint32_t)0x00000006)
N#define RST_CLK_USB_PLLmul8                     ((uint32_t)0x00000007)
N#define RST_CLK_USB_PLLmul9                     ((uint32_t)0x00000008)
N#define RST_CLK_USB_PLLmul10                    ((uint32_t)0x00000009)
N#define RST_CLK_USB_PLLmul11                    ((uint32_t)0x0000000A)
N#define RST_CLK_USB_PLLmul12                    ((uint32_t)0x0000000B)
N#define RST_CLK_USB_PLLmul13                    ((uint32_t)0x0000000C)
N#define RST_CLK_USB_PLLmul14                    ((uint32_t)0x0000000D)
N#define RST_CLK_USB_PLLmul15                    ((uint32_t)0x0000000E)
N#define RST_CLK_USB_PLLmul16                    ((uint32_t)0x0000000F)
N
N#define IS_RST_CLK_USB_PLL_MUL(SRC)             (((SRC)>=0) && ((SRC)<16))
N
N/** @} */ /* End of group USB_PLL_clock_multiplier */
N
N/** @defgroup CPU_CLK_divider CPU CLK divider
N  * @{
N  */
N
N/**
N  * @brief RST_CLK CPU_PLL output clock CPU_CLK_DIV divider constants
N  */
N
N#define RST_CLK_CPUclkDIV1                    ((uint32_t)0x00000000)
N#define RST_CLK_CPUclkDIV2                    ((uint32_t)0x00000008)
N#define RST_CLK_CPUclkDIV4                    ((uint32_t)0x00000009)
N#define RST_CLK_CPUclkDIV8                    ((uint32_t)0x0000000A)
N#define RST_CLK_CPUclkDIV16                   ((uint32_t)0x0000000B)
N#define RST_CLK_CPUclkDIV32                   ((uint32_t)0x0000000C)
N#define RST_CLK_CPUclkDIV64                   ((uint32_t)0x0000000D)
N#define RST_CLK_CPUclkDIV128                  ((uint32_t)0x0000000E)
N#define RST_CLK_CPUclkDIV256                  ((uint32_t)0x0000000F)
N
N#define IS_RST_CLK_CPUclkDIV(DIV)             (((DIV) == RST_CLK_CPUclkDIV1)   || \
N                                               ((DIV) == RST_CLK_CPUclkDIV2)   || \
N                                               ((DIV) == RST_CLK_CPUclkDIV4)   || \
N                                               ((DIV) == RST_CLK_CPUclkDIV8)   || \
N                                               ((DIV) == RST_CLK_CPUclkDIV16)  || \
N                                               ((DIV) == RST_CLK_CPUclkDIV32)  || \
N                                               ((DIV) == RST_CLK_CPUclkDIV64)  || \
N                                               ((DIV) == RST_CLK_CPUclkDIV128) || \
N                                               ((DIV) == RST_CLK_CPUclkDIV256))
X#define IS_RST_CLK_CPUclkDIV(DIV)             (((DIV) == RST_CLK_CPUclkDIV1)   ||                                                ((DIV) == RST_CLK_CPUclkDIV2)   ||                                                ((DIV) == RST_CLK_CPUclkDIV4)   ||                                                ((DIV) == RST_CLK_CPUclkDIV8)   ||                                                ((DIV) == RST_CLK_CPUclkDIV16)  ||                                                ((DIV) == RST_CLK_CPUclkDIV32)  ||                                                ((DIV) == RST_CLK_CPUclkDIV64)  ||                                                ((DIV) == RST_CLK_CPUclkDIV128) ||                                                ((DIV) == RST_CLK_CPUclkDIV256))
N
N/** @} */ /* End of group CPU_CLK_divider */
N
N/** @defgroup CPU_CLK_selector CPU CLK selector
N  * @{
N  */
N
N/**
N  * @brief RST_CLK CPU_CLK source CPU_CLK selector constants
N  */
N
N#define RST_CLK_CPUclkHSI                     ((uint32_t)0x00000000)
N#define RST_CLK_CPUclkCPU_C3                  ((uint32_t)0x00000100)
N#define RST_CLK_CPUclkLSE                     ((uint32_t)0x00000200)
N#define RST_CLK_CPUclkLSI                     ((uint32_t)0x00000300)
N
N#define IS_RST_CPU_CLK(SRC)                   (((SRC) == RST_CLK_CPUclkHSI)    || \
N                                               ((SRC) == RST_CLK_CPUclkCPU_C3) || \
N                                               ((SRC) == RST_CLK_CPUclkLSE)    || \
N                                               ((SRC) == RST_CLK_CPUclkLSI))
X#define IS_RST_CPU_CLK(SRC)                   (((SRC) == RST_CLK_CPUclkHSI)    ||                                                ((SRC) == RST_CLK_CPUclkCPU_C3) ||                                                ((SRC) == RST_CLK_CPUclkLSE)    ||                                                ((SRC) == RST_CLK_CPUclkLSI))
N
N/** @} */ /* End of group CPU_CLK_selector */
N
N/** @defgroup ADC_MCO_CLOCK_source ADC clock source
N  * @{
N  */
N
N/**
N  * @brief RST_CLK ADC_CLK selector constants
N  */
N#define RST_CLK_ADCclkCPU_C1                  ((uint32_t)0x00000020)
N#define RST_CLK_ADCclkUSB_C1                  ((uint32_t)0x00000021)
N#define RST_CLK_ADCclkCPU_C2                  ((uint32_t)0x00000022)
N#define RST_CLK_ADCclkUSB_C2                  ((uint32_t)0x00000023)
N#define RST_CLK_ADCclkLSE                     ((uint32_t)0x00000000)
N#define RST_CLK_ADCclkLSI                     ((uint32_t)0x00000010)
N#define RST_CLK_ADCclkHSI_C1                  ((uint32_t)0x00000030)
N
N#define IS_RST_CLK_ADCclk(SRC)                (((SRC) == RST_CLK_ADCclkCPU_C1) || \
N                                               ((SRC) == RST_CLK_ADCclkUSB_C1) || \
N                                               ((SRC) == RST_CLK_ADCclkCPU_C2) || \
N                                               ((SRC) == RST_CLK_ADCclkUSB_C2) || \
N                                               ((SRC) == RST_CLK_ADCclkLSE)    || \
N                                               ((SRC) == RST_CLK_ADCclkLSI)    || \
N                                               ((SRC) == RST_CLK_ADCclkHSI_C1))
X#define IS_RST_CLK_ADCclk(SRC)                (((SRC) == RST_CLK_ADCclkCPU_C1) ||                                                ((SRC) == RST_CLK_ADCclkUSB_C1) ||                                                ((SRC) == RST_CLK_ADCclkCPU_C2) ||                                                ((SRC) == RST_CLK_ADCclkUSB_C2) ||                                                ((SRC) == RST_CLK_ADCclkLSE)    ||                                                ((SRC) == RST_CLK_ADCclkLSI)    ||                                                ((SRC) == RST_CLK_ADCclkHSI_C1))
N/** @} */ /* End of group ADC_MCO_CLOCK_source */
N
N/** @defgroup ADC_MCO_CS3_SEL ADC clock divider
N  * @{
N  */
N
N/**
N  * @brief RST_CLK ADC_CS2_SEL output clock ADC_CS3_SEL divider constants
N  */
N
N#define RST_CLK_ADCclkDIV1                    ((uint32_t)0x00000000)
N#define RST_CLK_ADCclkDIV2                    ((uint32_t)0x00000008)
N#define RST_CLK_ADCclkDIV4                    ((uint32_t)0x00000009)
N#define RST_CLK_ADCclkDIV8                    ((uint32_t)0x0000000A)
N#define RST_CLK_ADCclkDIV16                   ((uint32_t)0x0000000B)
N#define RST_CLK_ADCclkDIV32                   ((uint32_t)0x0000000C)
N#define RST_CLK_ADCclkDIV64                   ((uint32_t)0x0000000D)
N#define RST_CLK_ADCclkDIV128                  ((uint32_t)0x0000000E)
N#define RST_CLK_ADCclkDIV256                  ((uint32_t)0x0000000F)
N
N#define IS_RST_CLK_ADCclkDivValue(SRC)        (((SRC) == RST_CLK_ADCclkDIV1)    || \
N                                               ((SRC) == RST_CLK_ADCclkDIV2)    || \
N                                               ((SRC) == RST_CLK_ADCclkDIV4)    || \
N                                               ((SRC) == RST_CLK_ADCclkDIV8)    || \
N                                               ((SRC) == RST_CLK_ADCclkDIV16)   || \
N                                               ((SRC) == RST_CLK_ADCclkDIV32)   || \
N                                               ((SRC) == RST_CLK_ADCclkDIV64)   || \
N                                               ((SRC) == RST_CLK_ADCclkDIV128)  || \
N                                               ((SRC) == RST_CLK_ADCclkDIV256))
X#define IS_RST_CLK_ADCclkDivValue(SRC)        (((SRC) == RST_CLK_ADCclkDIV1)    ||                                                ((SRC) == RST_CLK_ADCclkDIV2)    ||                                                ((SRC) == RST_CLK_ADCclkDIV4)    ||                                                ((SRC) == RST_CLK_ADCclkDIV8)    ||                                                ((SRC) == RST_CLK_ADCclkDIV16)   ||                                                ((SRC) == RST_CLK_ADCclkDIV32)   ||                                                ((SRC) == RST_CLK_ADCclkDIV64)   ||                                                ((SRC) == RST_CLK_ADCclkDIV128)  ||                                                ((SRC) == RST_CLK_ADCclkDIV256))
N
N/** @} */ /* End of group ADC_MCO_CS3_SEL */
N
N/** @defgroup AUC_MCO_CLOCK_source AUC clock source
N *  @{
N */
N
N/**
N * @brief RST_CLK AUC_CLK selector constants
N */
N#define RST_CLK_AUCclkHSI_C1						((uint32_t)0x00000000)
N#define RST_CLK_AUCclkHSI_2_C1						((uint32_t)0x00010000)
N#define RST_CLK_AUCclkHSE_C1						((uint32_t)0x00020000)
N#define RST_CLK_AUCclkHSE_2_C1						((uint32_t)0x00030000)
N#define RST_CLK_AUCclkPLLCPU						((uint32_t)0x00100000)
N#define RST_CLK_AUCclkPLLUSB						((uint32_t)0x00200000)
N
N#define IS_RST_CLK_AUCclk(SRC)						(((SRC) == RST_CLK_AUCclkHSI_C1)   || \
N													 ((SRC) == RST_CLK_AUCclkHSI_2_C1) || \
N													 ((SRC) == RST_CLK_AUCclkHSE_C1)   || \
N													 ((SRC) == RST_CLK_AUCclkHSE_2_C1) || \
N													 ((SRC) == RST_CLK_AUCclkPLLCPU)   || \
N													 ((SRC) == RST_CLK_AUCclkPLLUSB))
X#define IS_RST_CLK_AUCclk(SRC)						(((SRC) == RST_CLK_AUCclkHSI_C1)   || 													 ((SRC) == RST_CLK_AUCclkHSI_2_C1) || 													 ((SRC) == RST_CLK_AUCclkHSE_C1)   || 													 ((SRC) == RST_CLK_AUCclkHSE_2_C1) || 													 ((SRC) == RST_CLK_AUCclkPLLCPU)   || 													 ((SRC) == RST_CLK_AUCclkPLLUSB))
N/** @} */ /* End of group AUC_MCO_CLOCK_source */
N
N/** @defgroup AUCclkDIV_divider AUC MCO divider
N *	@{
N */
N
N /**
N  * @brief AUC_MCO_CLK AUC_CLK output clock AUC_CLK_DIV divider
N  */
N#define RST_CLK_AUCclkDIV1							((uint32_t)0x00000000)
N#define RST_CLK_AUCclkDIV2							((uint32_t)0x08000000 | 0x00000000)
N#define RST_CLK_AUCclkDIV4							((uint32_t)0x08000000 | 0x01000000)
N#define RST_CLK_AUCclkDIV8							((uint32_t)0x08000000 | 0x02000000)
N#define RST_CLK_AUCclkDIV16							((uint32_t)0x08000000 | 0x03000000)
N#define RST_CLK_AUCclkDIV32							((uint32_t)0x08000000 | 0x04000000)
N#define RST_CLK_AUCclkDIV64							((uint32_t)0x08000000 | 0x05000000)
N#define RST_CLK_AUCclkDIV128						((uint32_t)0x08000000 | 0x06000000)
N#define RST_CLK_AUCclkDIV256						((uint32_t)0x08000000 | 0x07000000)
N
N#define IS_RST_CLK_AUCclkDIV(DIV)					(((DIV) == RST_CLK_AUCclkDIV1)   || \
N													 ((DIV) == RST_CLK_AUCclkDIV2)   || \
N													 ((DIV) == RST_CLK_AUCclkDIV4)   || \
N													 ((DIV) == RST_CLK_AUCclkDIV8)   || \
N													 ((DIV) == RST_CLK_AUCclkDIV16)  || \
N													 ((DIV) == RST_CLK_AUCclkDIV32)  || \
N													 ((DIV) == RST_CLK_AUCclkDIV64)  || \
N													 ((DIV) == RST_CLK_AUCclkDIV128) || \
N													 ((DIV) == RST_CLK_AUCclkDIV256))
X#define IS_RST_CLK_AUCclkDIV(DIV)					(((DIV) == RST_CLK_AUCclkDIV1)   || 													 ((DIV) == RST_CLK_AUCclkDIV2)   || 													 ((DIV) == RST_CLK_AUCclkDIV4)   || 													 ((DIV) == RST_CLK_AUCclkDIV8)   || 													 ((DIV) == RST_CLK_AUCclkDIV16)  || 													 ((DIV) == RST_CLK_AUCclkDIV32)  || 													 ((DIV) == RST_CLK_AUCclkDIV64)  || 													 ((DIV) == RST_CLK_AUCclkDIV128) || 													 ((DIV) == RST_CLK_AUCclkDIV256))
N/** @} */ /* End of group AUCclkDIV_divider */
N
N
N/** @defgroup CLK_peripheral CLK peripheral
N  * @{
N  */
N
N/**
N  * @brief RST_CLK peripheral modules clock constants
N  */
N
N#define PCLK_BIT(BASE)              ((uint32_t)(1U << ((((uint32_t)BASE) >> 15) & 0x1F)))
N#if defined USE_MDR1986VE3
X#if 0L
S	#define PCLK_BIT2(BASE)				((uint32_t)(1U << ((((uint32_t)BASE) >> 15) & 0x0F)))
N#endif
N
N#if defined ( USE_MDR1986VE9x )
X#if 1L
N
N	#define RST_CLK_PCLK_CAN1           PCLK_BIT(MDR_CAN1_BASE)
N	#define RST_CLK_PCLK_CAN2           PCLK_BIT(MDR_CAN2_BASE)
N	#define RST_CLK_PCLK_USB            PCLK_BIT(MDR_USB_BASE)
N	#define RST_CLK_PCLK_EEPROM         PCLK_BIT(MDR_EEPROM_BASE)
N	#define RST_CLK_PCLK_RST_CLK        PCLK_BIT(MDR_RST_CLK_BASE)
N	#define RST_CLK_PCLK_DMA            PCLK_BIT(MDR_DMA_BASE)
N	#define RST_CLK_PCLK_UART1          PCLK_BIT(MDR_UART1_BASE)
N	#define RST_CLK_PCLK_UART2          PCLK_BIT(MDR_UART2_BASE)
N	#define RST_CLK_PCLK_SSP1           PCLK_BIT(MDR_SSP1_BASE)
N	#define RST_CLK_PCLK_09             PCLK_BIT(0x40048000)
N	#define RST_CLK_PCLK_I2C            PCLK_BIT(MDR_I2C_BASE)
N	#define RST_CLK_PCLK_POWER          PCLK_BIT(MDR_POWER_BASE)
N	#define RST_CLK_PCLK_WWDG           PCLK_BIT(MDR_WWDG_BASE)
N	#define RST_CLK_PCLK_IWDG           PCLK_BIT(MDR_IWDG_BASE)
N	#define RST_CLK_PCLK_TIMER1         PCLK_BIT(MDR_TIMER1_BASE)
N	#define RST_CLK_PCLK_TIMER2         PCLK_BIT(MDR_TIMER2_BASE)
N	#define RST_CLK_PCLK_TIMER3         PCLK_BIT(MDR_TIMER3_BASE)
N	#define RST_CLK_PCLK_ADC            PCLK_BIT(MDR_ADC_BASE)
N	#define RST_CLK_PCLK_DAC            PCLK_BIT(MDR_DAC_BASE)
N	#define RST_CLK_PCLK_COMP           PCLK_BIT(MDR_COMP_BASE)
N	#define RST_CLK_PCLK_SSP2           PCLK_BIT(MDR_SSP2_BASE)
N	#define RST_CLK_PCLK_PORTA          PCLK_BIT(MDR_PORTA_BASE)
N	#define RST_CLK_PCLK_PORTB          PCLK_BIT(MDR_PORTB_BASE)
N	#define RST_CLK_PCLK_PORTC          PCLK_BIT(MDR_PORTC_BASE)
N	#define RST_CLK_PCLK_PORTD          PCLK_BIT(MDR_PORTD_BASE)
N	#define RST_CLK_PCLK_PORTE          PCLK_BIT(MDR_PORTE_BASE)
N	#define RST_CLK_PCLK_26             PCLK_BIT(0x400D0000)
N	#define RST_CLK_PCLK_BKP            PCLK_BIT(MDR_BKP_BASE)
N	#define RST_CLK_PCLK_28             PCLK_BIT(0x400E0000)
N	#define RST_CLK_PCLK_PORTF          PCLK_BIT(MDR_PORTF_BASE)
N	#define RST_CLK_PCLK_EBC            PCLK_BIT(MDR_EBC_BASE)
N	#define RST_CLK_PCLK_31             PCLK_BIT(0x400F8000)
N
N	#define IS_RST_CLK_PCLK(PCLK)       ((((PCLK) & RST_CLK_PCLK_09) == 0x00) && \
N										 (((PCLK) & RST_CLK_PCLK_26) == 0x00) && \
N										 (((PCLK) & RST_CLK_PCLK_28) == 0x00) && \
N										 (((PCLK) & RST_CLK_PCLK_31) == 0x00))
X	#define IS_RST_CLK_PCLK(PCLK)       ((((PCLK) & RST_CLK_PCLK_09) == 0x00) && 										 (((PCLK) & RST_CLK_PCLK_26) == 0x00) && 										 (((PCLK) & RST_CLK_PCLK_28) == 0x00) && 										 (((PCLK) & RST_CLK_PCLK_31) == 0x00))
N#endif // #ifdef USE_MDR1986VE9x /* For cortex M3 */
N
N#if  defined (USE_MDR1901VC1T) /* MDR1901VCT */
X#if  0L  
S
S	#define RST_CLK_PCLK_SSP3           PCLK_BIT(MDR_SSP3_BASE)
S	#define RST_CLK_PCLK_SSP4           PCLK_BIT(MDR_SSP4_BASE)
S	#define RST_CLK_PCLK_USB            PCLK_BIT(MDR_USB_BASE)
S	#define RST_CLK_PCLK_EEPROM         PCLK_BIT(MDR_EEPROM_BASE)
S	#define RST_CLK_PCLK_RST_CLK        PCLK_BIT(MDR_RST_CLK_BASE)
S	#define RST_CLK_PCLK_DMA            PCLK_BIT(MDR_DMA_BASE)
S	#define RST_CLK_PCLK_UART1          PCLK_BIT(MDR_UART1_BASE)
S	#define RST_CLK_PCLK_UART2          PCLK_BIT(MDR_UART2_BASE)
S	#define RST_CLK_PCLK_SSP1           PCLK_BIT(MDR_SSP1_BASE)
S	#define RST_CLK_PCLK_SDIO           PCLK_BIT(MDR_SDIO_BASE)
S	#define RST_CLK_PCLK_I2C            PCLK_BIT(MDR_I2C_BASE)
S	#define RST_CLK_PCLK_POWER          PCLK_BIT(MDR_POWER_BASE)
S	#define RST_CLK_PCLK_WWDG           PCLK_BIT(MDR_WWDG_BASE)
S	#define RST_CLK_PCLK_IWDG           PCLK_BIT(MDR_IWDG_BASE)
S	#define RST_CLK_PCLK_TIMER1         PCLK_BIT(MDR_TIMER1_BASE)
S	#define RST_CLK_PCLK_TIMER2         PCLK_BIT(MDR_TIMER2_BASE)
S	#define RST_CLK_PCLK_TIMER3         PCLK_BIT(MDR_TIMER3_BASE)
S	#define RST_CLK_PCLK_ADC            PCLK_BIT(MDR_ADC_BASE)
S	#define RST_CLK_PCLK_DAC            PCLK_BIT(MDR_DAC_BASE)
S	#define RST_CLK_PCLK_COMP           PCLK_BIT(MDR_COMP_BASE)
S	#define RST_CLK_PCLK_SSP2           PCLK_BIT(MDR_SSP2_BASE)
S	#define RST_CLK_PCLK_PORTA          PCLK_BIT(MDR_PORTA_BASE)
S	#define RST_CLK_PCLK_PORTB          PCLK_BIT(MDR_PORTB_BASE)
S	#define RST_CLK_PCLK_PORTC          PCLK_BIT(MDR_PORTC_BASE)
S	#define RST_CLK_PCLK_PORTD          PCLK_BIT(MDR_PORTD_BASE)
S	#define RST_CLK_PCLK_PORTE          PCLK_BIT(MDR_PORTE_BASE)
S	#define RST_CLK_PCLK_UART3          PCLK_BIT(MDR_UART3_BASE)
S	#define RST_CLK_PCLK_BKP            PCLK_BIT(MDR_BKP_BASE)
S	#define RST_CLK_PCLK_AUDIO_IP       ((uint32_t)0x10000000)
S	#define RST_CLK_PCLK_PORTF          PCLK_BIT(MDR_PORTF_BASE)
S	#define RST_CLK_PCLK_EBC            PCLK_BIT(MDR_EBC_BASE)
S	#define RST_CLK_PCLK_31             PCLK_BIT(0x400F8000)
S
S	#define IS_RST_CLK_PCLK(PCLK)       (((PCLK) & RST_CLK_PCLK_31) == 0x00)
N#endif // #ifdef USE_MDR1986VE9x /* For cortex MDR1901VC1T */
N
N
N#if defined (USE_MDR1986VE1T)
X#if 0L
S	#define RST_CLK_PCLK_CAN1           PCLK_BIT(MDR_CAN1_BASE)
S	#define RST_CLK_PCLK_CAN2           PCLK_BIT(MDR_CAN2_BASE)
S	#define RST_CLK_PCLK_USB            PCLK_BIT(MDR_USB_BASE)
S	#define RST_CLK_PCLK_EEPROM         PCLK_BIT(MDR_EEPROM_BASE)
S	#define RST_CLK_PCLK_RST_CLK        PCLK_BIT(MDR_RST_CLK_BASE)
S	#define RST_CLK_PCLK_DMA            PCLK_BIT(MDR_DMA_BASE)
S	#define RST_CLK_PCLK_UART1          PCLK_BIT(MDR_UART1_BASE)
S	#define RST_CLK_PCLK_UART2          PCLK_BIT(MDR_UART2_BASE)
S	#define RST_CLK_PCLK_SSP1           PCLK_BIT(MDR_SSP1_BASE)
S	#define RST_CLK_PCLK_MIL_STD_15531  PCLK_BIT(MDR_MIL_STD_15531_BASE)
S	#define RST_CLK_PCLK_MIL_STD_15532  PCLK_BIT(MDR_MIL_STD_15532_BASE)
S	#define RST_CLK_PCLK_POWER          PCLK_BIT(MDR_POWER_BASE)
S	#define RST_CLK_PCLK_WWDG           PCLK_BIT(MDR_WWDG_BASE)
S	#define RST_CLK_PCLK_IWDG           PCLK_BIT(MDR_IWDG_BASE)
S	#define RST_CLK_PCLK_TIMER1         PCLK_BIT(MDR_TIMER1_BASE)
S	#define RST_CLK_PCLK_TIMER2         PCLK_BIT(MDR_TIMER2_BASE)
S	#define RST_CLK_PCLK_TIMER3         PCLK_BIT(MDR_TIMER3_BASE)
S	#define RST_CLK_PCLK_ADC            PCLK_BIT(MDR_ADC_BASE)
S	#define RST_CLK_PCLK_DAC            PCLK_BIT(MDR_DAC_BASE)
S	#define RST_CLK_PCLK_TIMER4         PCLK_BIT(MDR_TIMER4_BASE)
S	#define RST_CLK_PCLK_SSP2           PCLK_BIT(MDR_SSP2_BASE)
S	#define RST_CLK_PCLK_PORTA          PCLK_BIT(MDR_PORTA_BASE)
S	#define RST_CLK_PCLK_PORTB          PCLK_BIT(MDR_PORTB_BASE)
S	#define RST_CLK_PCLK_PORTC          PCLK_BIT(MDR_PORTC_BASE)
S	#define RST_CLK_PCLK_PORTD          PCLK_BIT(MDR_PORTD_BASE)
S	#define RST_CLK_PCLK_PORTE          PCLK_BIT(MDR_PORTE_BASE)
S	#define RST_CLK_PCLK_ARINC429R      PCLK_BIT(MDR_ARINC429R_BASE)
S	#define RST_CLK_PCLK_BKP            PCLK_BIT(MDR_BKP_BASE)
S	#define RST_CLK_PCLK_ARINC429T      PCLK_BIT(MDR_ARINC429T_BASE)
S	#define RST_CLK_PCLK_PORTF          PCLK_BIT(MDR_PORTF_BASE)
S	#define RST_CLK_PCLK_EBC            PCLK_BIT(MDR_EBC_BASE)
S	#define RST_CLK_PCLK_SSP3           PCLK_BIT(MDR_SSP3_BASE)
S
S#define IS_RST_CLK_PCLK(PCLK)			(1)
N#endif /* #if defined (USE_MDR1986VE1T) */
N
N#ifdef USE_MDR1986VE3 /* For Coxtex M1 */
S	#define RST_CLK_PCLK_CAN1           PCLK_BIT(MDR_CAN1_BASE)
S	#define RST_CLK_PCLK_CAN2           PCLK_BIT(MDR_CAN2_BASE)
S	#define RST_CLK_PCLK_USB            PCLK_BIT(MDR_USB_BASE)
S	#define RST_CLK_PCLK_EEPROM         PCLK_BIT(MDR_EEPROM_BASE)
S	#define RST_CLK_PCLK_RST_CLK        PCLK_BIT(MDR_RST_CLK_BASE)
S	#define RST_CLK_PCLK_DMA            PCLK_BIT(MDR_DMA_BASE)
S	#define RST_CLK_PCLK_UART1          PCLK_BIT(MDR_UART1_BASE)
S	#define RST_CLK_PCLK_UART2          PCLK_BIT(MDR_UART2_BASE)
S	#define RST_CLK_PCLK_SSP1           PCLK_BIT(MDR_SSP1_BASE)
S	#define RST_CLK_PCLK_MIL_STD_15531  PCLK_BIT(MDR_MIL_STD_15531_BASE)
S	#define RST_CLK_PCLK_MIL_STD_15532  PCLK_BIT(MDR_MIL_STD_15532_BASE)
S	#define RST_CLK_PCLK_POWER          PCLK_BIT(MDR_POWER_BASE)
S	#define RST_CLK_PCLK_WWDG           PCLK_BIT(MDR_WWDG_BASE)
S	#define RST_CLK_PCLK_IWDG           PCLK_BIT(MDR_IWDG_BASE)
S	#define RST_CLK_PCLK_TIMER1         PCLK_BIT(MDR_TIMER1_BASE)
S	#define RST_CLK_PCLK_TIMER2         PCLK_BIT(MDR_TIMER2_BASE)
S	#define RST_CLK_PCLK_TIMER3         PCLK_BIT(MDR_TIMER3_BASE)
S	#define RST_CLK_PCLK_ADC            PCLK_BIT(MDR_ADC_BASE)
S	#define RST_CLK_PCLK_DAC            PCLK_BIT(MDR_DAC_BASE)
S	#define RST_CLK_PCLK_TIMER4         PCLK_BIT(MDR_TIMER4_BASE)
S	#define RST_CLK_PCLK_SSP2           PCLK_BIT(MDR_SSP2_BASE)
S	#define RST_CLK_PCLK_PORTA          PCLK_BIT(MDR_PORTA_BASE)
S	#define RST_CLK_PCLK_PORTB          PCLK_BIT(MDR_PORTB_BASE)
S	#define RST_CLK_PCLK_PORTC          PCLK_BIT(MDR_PORTC_BASE)
S	#define RST_CLK_PCLK_PORTD          PCLK_BIT(MDR_PORTD_BASE)
S	#define RST_CLK_PCLK_PORTE          PCLK_BIT(MDR_PORTE_BASE)
S	#define RST_CLK_PCLK_ARINC429R      PCLK_BIT(MDR_ARINC429R_BASE)
S	#define RST_CLK_PCLK_BKP            PCLK_BIT(MDR_BKP_BASE)
S	#define RST_CLK_PCLK_ARINC429T      PCLK_BIT(MDR_ARINC429T_BASE)
S	#define RST_CLK_PCLK_PORTF          PCLK_BIT(MDR_PORTF_BASE)
S	#define RST_CLK_PCLK_EBC            PCLK_BIT(MDR_EBC_BASE)
S	#define RST_CLK_PCLK_SSP3           PCLK_BIT(MDR_SSP3_BASE)
S
S	#define RST_CLK_PCLK2_AUDIO_IP		PCLK_BIT2(MDR_AUDIO_IP_BASE)
S	#define RST_CLK_PCLK2_LED			PCLK_BIT2(MDR_LED_BASE)
S	#define RST_CLK_PCLK2_KEYBOARD		PCLK_BIT2(MDR_KEYPAD_BASE)
S	#define RST_CLK_PCLK2_PORTG			PCLK_BIT2(MDR_PORTG_BASE)
S	#define RST_CLK_PCLK2_UART3			PCLK_BIT2(MDR_UART3_BASE)
S	#define RST_CLK_PCLK2_UART4			PCLK_BIT2(MDR_UART4_BASE)
S	#define RST_CLK_PCLK2_SSP4			PCLK_BIT2(MDR_SSP4_BASE)
S	#define RST_CLK_PCLK2_PORTH			PCLK_BIT2(MDR_PORTH_BASE)
S	#define RST_CLK_PCLK2_PORTI			PCLK_BIT2(MDR_PORTI_BASE)
S
S	#define RST_CLK_PCLK2_MASK			(RST_CLK_PCLK2_AUDIO_IP | RST_CLK_PCLK2_KEYBOARD |\
S										 RST_CLK_PCLK2_LED 		| RST_CLK_PCLK2_UART3 	 |\
S										 RST_CLK_PCLK2_UART4	| RST_CLK_PCLK2_SSP4 	 |\
S										 RST_CLK_PCLK2_PORTH 	| RST_CLK_PCLK2_PORTI | RST_CLK_PCLK2_PORTG)
X	#define RST_CLK_PCLK2_MASK			(RST_CLK_PCLK2_AUDIO_IP | RST_CLK_PCLK2_KEYBOARD |										 RST_CLK_PCLK2_LED 		| RST_CLK_PCLK2_UART3 	 |										 RST_CLK_PCLK2_UART4	| RST_CLK_PCLK2_SSP4 	 |										 RST_CLK_PCLK2_PORTH 	| RST_CLK_PCLK2_PORTI | RST_CLK_PCLK2_PORTG)
S
S	#define IS_RST_CLK_PCLK(PCLK)       (1)
S	#define IS_RST_CLK_PCLK2(PCLK2)		(PLCK2 & (~RST_CLK_PCLK2_MASK) == 0)
S
S
N#endif // #ifdef USE_MDR1986VE3 /* For Coxtex M1 */
N
N/** @} */ /* End of group CLK_peripheral */
N
N/** @defgroup RST_CLK_Flag RST_CLK Flag
N  * @{
N  */
N
N/**
N  * @brief RST_CLK flag identifiers
N  */
N
N#define RST_CLK_FLAG_HSIRDY                   ((uint32_t)(0x00 | 23))
N#define RST_CLK_FLAG_LSIRDY                   ((uint32_t)(0x00 | 21))
N#define RST_CLK_FLAG_HSERDY                   ((uint32_t)(0x20 |  2))
N#define RST_CLK_FLAG_HSE2RDY	           	  ((uint32_t)(0x20 |  3))
N#define RST_CLK_FLAG_LSERDY                   ((uint32_t)(0x00 | 13))
N#define RST_CLK_FLAG_PLLCPURDY                ((uint32_t)(0x20 |  1))
N#define RST_CLK_FLAG_PLLUSBRDY                ((uint32_t)(0x20 |  0))
N#define RST_CLK_FLAG_PLLDSPRDY                ((uint32_t)(0x20 |  3))
N
N#define IS_RST_CLK_FLAG(FLAG)                 (((FLAG) == RST_CLK_FLAG_HSIRDY)    || \
N                                               ((FLAG) == RST_CLK_FLAG_LSIRDY)    || \
N                                               ((FLAG) == RST_CLK_FLAG_HSERDY)    || \
N                                               ((FLAG) == RST_CLK_FLAG_HSE2RDY)	  || \
N                                               ((FLAG) == RST_CLK_FLAG_PLLDSPRDY) || \
N                                               ((FLAG) == RST_CLK_FLAG_LSERDY)    || \
N                                               ((FLAG) == RST_CLK_FLAG_PLLCPURDY) || \
N                                               ((FLAG) == RST_CLK_FLAG_PLLUSBRDY))
X#define IS_RST_CLK_FLAG(FLAG)                 (((FLAG) == RST_CLK_FLAG_HSIRDY)    ||                                                ((FLAG) == RST_CLK_FLAG_LSIRDY)    ||                                                ((FLAG) == RST_CLK_FLAG_HSERDY)    ||                                                ((FLAG) == RST_CLK_FLAG_HSE2RDY)	  ||                                                ((FLAG) == RST_CLK_FLAG_PLLDSPRDY) ||                                                ((FLAG) == RST_CLK_FLAG_LSERDY)    ||                                                ((FLAG) == RST_CLK_FLAG_PLLCPURDY) ||                                                ((FLAG) == RST_CLK_FLAG_PLLUSBRDY))
N
N/** @} */ /* End of group RST_CLK_Flag */
N
N#define IS_RCC_CLK_HSI_TRIM_VALUE(TRIM)       ((TRIM) <= 0x3F)
N#define IS_RCC_CLK_LSI_TRIM_VALUE(TRIM)       ((TRIM) <= 0x1F)
N
N/** @defgroup RST_CLK_HSI_C1_SEL HSI clock divider
N  * @{
N  */
N
N/**
N  * @brief RST_CLK HSI clock HSI_C1_SEL divider constants
N  */
N
N#define RST_CLK_HSIclkDIV1                    ((uint32_t)0x00000000)
N#define RST_CLK_HSIclkDIV2                    ((uint32_t)0x00000008)
N#define RST_CLK_HSIclkDIV4                    ((uint32_t)0x00000009)
N#define RST_CLK_HSIclkDIV8                    ((uint32_t)0x0000000A)
N#define RST_CLK_HSIclkDIV16                   ((uint32_t)0x0000000B)
N#define RST_CLK_HSIclkDIV32                   ((uint32_t)0x0000000C)
N#define RST_CLK_HSIclkDIV64                   ((uint32_t)0x0000000D)
N#define RST_CLK_HSIclkDIV128                  ((uint32_t)0x0000000E)
N#define RST_CLK_HSIclkDIV256                  ((uint32_t)0x0000000F)
N
N#define IS_RST_CLK_HSIclkDivValue(SRC)        (((SRC) == RST_CLK_HSIclkDIV1)    || \
N                                               ((SRC) == RST_CLK_HSIclkDIV2)    || \
N                                               ((SRC) == RST_CLK_HSIclkDIV4)    || \
N                                               ((SRC) == RST_CLK_HSIclkDIV8)    || \
N                                               ((SRC) == RST_CLK_HSIclkDIV16)   || \
N                                               ((SRC) == RST_CLK_HSIclkDIV32)   || \
N                                               ((SRC) == RST_CLK_HSIclkDIV64)   || \
N                                               ((SRC) == RST_CLK_HSIclkDIV128)  || \
N                                               ((SRC) == RST_CLK_HSIclkDIV256))
X#define IS_RST_CLK_HSIclkDivValue(SRC)        (((SRC) == RST_CLK_HSIclkDIV1)    ||                                                ((SRC) == RST_CLK_HSIclkDIV2)    ||                                                ((SRC) == RST_CLK_HSIclkDIV4)    ||                                                ((SRC) == RST_CLK_HSIclkDIV8)    ||                                                ((SRC) == RST_CLK_HSIclkDIV16)   ||                                                ((SRC) == RST_CLK_HSIclkDIV32)   ||                                                ((SRC) == RST_CLK_HSIclkDIV64)   ||                                                ((SRC) == RST_CLK_HSIclkDIV128)  ||                                                ((SRC) == RST_CLK_HSIclkDIV256))
N
N/** @} */ /* End of group RST_CLK_HSI_C1_SEL */
N
N/** @defgroup RST_CLK_HSE_C1_SEL HSE clock divider
N  * @{
N  */
N
N/**
N  * @brief RST_CLK HSE clock HSE_C1_SEL divider constants
N  */
N#define RST_CLK_HSEclkDIV1                    ((uint32_t)0x00000000)
N#define RST_CLK_HSEclkDIV2                    ((uint32_t)0x00000008)
N#define RST_CLK_HSEclkDIV4                    ((uint32_t)0x00000009)
N#define RST_CLK_HSEclkDIV8                    ((uint32_t)0x0000000A)
N#define RST_CLK_HSEclkDIV16                   ((uint32_t)0x0000000B)
N#define RST_CLK_HSEclkDIV32                   ((uint32_t)0x0000000C)
N#define RST_CLK_HSEclkDIV64                   ((uint32_t)0x0000000D)
N#define RST_CLK_HSEclkDIV128                  ((uint32_t)0x0000000E)
N#define RST_CLK_HSEclkDIV256                  ((uint32_t)0x0000000F)
N
N#define IS_RST_CLK_HSEclkDivValue(SRC)        (((SRC) == RST_CLK_HSEclkDIV1)    || \
N                                               ((SRC) == RST_CLK_HSEclkDIV2)    || \
N                                               ((SRC) == RST_CLK_HSEclkDIV4)    || \
N                                               ((SRC) == RST_CLK_HSEclkDIV8)    || \
N                                               ((SRC) == RST_CLK_HSEclkDIV16)   || \
N                                               ((SRC) == RST_CLK_HSEclkDIV32)   || \
N                                               ((SRC) == RST_CLK_HSEclkDIV64)   || \
N                                               ((SRC) == RST_CLK_HSEclkDIV128)  || \
N                                               ((SRC) == RST_CLK_HSEclkDIV256))
X#define IS_RST_CLK_HSEclkDivValue(SRC)        (((SRC) == RST_CLK_HSEclkDIV1)    ||                                                ((SRC) == RST_CLK_HSEclkDIV2)    ||                                                ((SRC) == RST_CLK_HSEclkDIV4)    ||                                                ((SRC) == RST_CLK_HSEclkDIV8)    ||                                                ((SRC) == RST_CLK_HSEclkDIV16)   ||                                                ((SRC) == RST_CLK_HSEclkDIV32)   ||                                                ((SRC) == RST_CLK_HSEclkDIV64)   ||                                                ((SRC) == RST_CLK_HSEclkDIV128)  ||                                                ((SRC) == RST_CLK_HSEclkDIV256))
N
N/** @} */ /* End of group RST_CLK_HSE_C1_SEL */
N
N/** @defgroup DSP_C1_CLOCK DSP_C1_CLOCK
N  * @{
N  */
N
N#define DSP_C1_CLOCK_HSI					(uint32_t)(0x0000000)
N#define DSP_C1_CLOCK_HSI2					(uint32_t)(0x0000001)
N#define DSP_C1_CLOCK_HSE					(uint32_t)(0x0000002)
N#define DSP_C1_CLOCK_HSE2					(uint32_t)(0x0000003)
N
N#define IS_DSP_C1_CLOCK(CLOCK)				(((CLOCK) == DSP_C1_CLOCK_HSI)  ||\
N											 ((CLOCK) == DSP_C1_CLOCK_HSI2) ||\
N											 ((CLOCK) == DSP_C1_CLOCK_HSE)  ||\
N											 ((CLOCK) == DSP_C1_CLOCK_HSE2))
X#define IS_DSP_C1_CLOCK(CLOCK)				(((CLOCK) == DSP_C1_CLOCK_HSI)  ||											 ((CLOCK) == DSP_C1_CLOCK_HSI2) ||											 ((CLOCK) == DSP_C1_CLOCK_HSE)  ||											 ((CLOCK) == DSP_C1_CLOCK_HSE2))
N
N/** @} */ /* End of group DSP_C1_CLOCK */
N
N/** @defgroup DSP_PLL_MUL DSP_PLL multiplier
N  * @{
N  */
N
N#define DSP_PLL_MUL1						(uint32_t)(0x00000000)
N#define DSP_PLL_MUL2						(uint32_t)(0x00000001)
N#define DSP_PLL_MUL3						(uint32_t)(0x00000002)
N#define DSP_PLL_MUL4						(uint32_t)(0x00000003)
N#define DSP_PLL_MUL5						(uint32_t)(0x00000004)
N#define DSP_PLL_MUL6						(uint32_t)(0x00000005)
N#define DSP_PLL_MUL7						(uint32_t)(0x00000006)
N#define DSP_PLL_MUL8						(uint32_t)(0x00000007)
N#define DSP_PLL_MUL9						(uint32_t)(0x00000008)
N#define DSP_PLL_MUL10 						(uint32_t)(0x00000009)
N#define DSP_PLL_MUL11						(uint32_t)(0x0000000A)
N#define DSP_PLL_MUL12						(uint32_t)(0x0000000B)
N#define DSP_PLL_MUL13						(uint32_t)(0x0000000C)
N#define DSP_PLL_MUL14						(uint32_t)(0x0000000D)
N#define DSP_PLL_MUL15						(uint32_t)(0x0000000E)
N#define DSP_PLL_MUL16						(uint32_t)(0x0000000F)
N
N#define	IS_DSP_PLL_MULL(PLL_MUL)			(((PLL_MUL) >= DSP_PLL_MUL1) &&\
N										    ((PLL_MUL) <= DSP_PLL_MUL15))
X#define	IS_DSP_PLL_MULL(PLL_MUL)			(((PLL_MUL) >= DSP_PLL_MUL1) &&										    ((PLL_MUL) <= DSP_PLL_MUL15))
N
N/** @} */ /* End of group DSP_PLL_MUL */
N
N/** @defgroup DSP_Prescalere DSP_Prescalere
N  * @{
N  */
N
N#define DSP_PRESCALER1						(uint32_t)(0x00000000)
N#define DSP_PRESCALER2						(uint32_t)(0x00000001)
N
N#define IS_DSP_PRESCALER(PRESCALER)			(((PRESCALER) == DSP_PRESCALER1) ||\
N											 ((PRESCALER) == DSP_PRESCALER2))
X#define IS_DSP_PRESCALER(PRESCALER)			(((PRESCALER) == DSP_PRESCALER1) ||											 ((PRESCALER) == DSP_PRESCALER2))
N
N/** @} */ /* End of group DSP_Prescalere */
N
N/** @} */ /* End of group RST_CLK_Exported_Constants */
N
N/** @defgroup RST_CLK_Exported_Macros RST_CLK Exported Macros
N  * @{
N  */
N
N/** @} */ /* End of group RST_CLK_Exported_Macros */
N
N/** @defgroup RST_CLK_Exported_Functions RST_CLK Exported Functions
N  * @{
N  */
N
Nvoid RST_CLK_DeInit(void);
Nvoid RST_CLK_WarmDeInit(void);
N
N
Nvoid RST_CLK_HSEconfig(uint32_t RST_CLK_HSE);
NErrorStatus RST_CLK_HSEstatus(void);
N
Nvoid RST_CLK_LSEconfig(uint32_t RST_CLK_LSE);
NErrorStatus RST_CLK_LSEstatus(void);
N
Nvoid RST_CLK_HSIcmd(FunctionalState NewState);
Nvoid RST_CLK_HSIadjust(uint32_t HSItrimValue);
NErrorStatus RST_CLK_HSIstatus(void);
N
Nvoid RST_CLK_LSIcmd(FunctionalState NewState);
Nvoid RST_CLK_LSIadjust(uint32_t LSItrimValue);
NErrorStatus RST_CLK_LSIstatus(void);
N
Nvoid RST_CLK_CPU_PLLconfig(uint32_t RST_CLK_CPU_PLLsource, uint32_t RST_CLK_CPU_PLLmul);
Nvoid RST_CLK_CPU_PLLuse(FunctionalState UsePLL);
Nvoid RST_CLK_CPU_PLLcmd(FunctionalState NewState);
NErrorStatus RST_CLK_CPU_PLLstatus(void);
N
Nvoid RST_CLK_CPUclkPrescaler(uint32_t CPUclkDivValue);
Nvoid RST_CLK_CPUclkSelection(uint32_t CPU_CLK);
N
Nvoid RST_CLK_USB_PLLconfig(uint32_t RST_CLK_USB_PLLsource, uint32_t RST_CLK_USB_PLLmul);
Nvoid RST_CLK_USB_PLLuse(FunctionalState UsePLL);
Nvoid RST_CLK_USB_PLLcmd(FunctionalState NewState);
NErrorStatus RST_CLK_USB_PLLstatus(void);
N
Nvoid RST_CLK_USBclkPrescaler(FunctionalState NewState);
Nvoid RST_CLK_USBclkEnable(FunctionalState NewState);
N
Nvoid RST_CLK_ADCclkSelection(uint32_t ADC_CLK);
Nvoid RST_CLK_ADCclkPrescaler(uint32_t ADCclkDivValue);
Nvoid RST_CLK_ADCclkEnable(FunctionalState NewState);
N
Nvoid RST_CLK_HSIclkPrescaler(uint32_t HSIclkDivValue);
Nvoid RST_CLK_RTC_HSIclkEnable(FunctionalState NewState);
N
Nvoid RST_CLK_HSEclkPrescaler(uint32_t HSEclkDivValue);
Nvoid RST_CLK_RTC_HSEclkEnable(FunctionalState NewState);
N
Nvoid RST_CLK_PCLKcmd(uint32_t RST_CLK_PCLK, FunctionalState NewState);
N#if defined (USE_MDR1986VE3)
X#if 0L
S	void RST_CLK_PCLK2cmd ( uint32_t RST_CLK_PCLK2, FunctionalState NewState);
N#endif
N#if defined (USE_MDR1986VE3) || defined (USE_MDR1901VC1T)
X#if 0L || 0L
S	void RST_CLK_AUCclkDeInit(void);
S	void RST_CLK_AUCclkSelection(uint32_t AUC_CLK);
S	void RST_CLK_AUCclkPrescaler(uint32_t AUCclkDIVValue);
S	void RST_CLK_AUCclkCMD(FunctionalState NewState);
N#endif
Nvoid RST_CLK_GetClocksFreq(RST_CLK_FreqTypeDef* RST_CLK_Clocks);
N
NFlagStatus RST_CLK_GetFlagStatus(uint32_t RST_CLK_FLAG);
N
N#if defined (USE_MDR1986VE3) || defined (USE_MDR1986VE1T)
X#if 0L || 0L
S	void RST_CLK_HSE2config(uint32_t RST_CLK_HSE2);
S	ErrorStatus RST_CLK_HSE2status(void);
N#endif
N
N#if defined (USE_MDR1901VC1T)
X#if 0L
S	void RST_CLK_DSP_Selection(uint32_t DSP_CLOCK);
S	void RST_CLK_DSPPLLConfig(uint32_t PLLMul);
S	void RST_CLK_DSPPLL_CMD(FunctionalState NewState);
S	ErrorStatus RST_CLK_DSP_PLLStatus(void);
S	void RST_CLK_DSP_PLLUse(FunctionalState UsePLL);
S	void RST_CLK_DSPPrescaler(uint32_t DSP_Prescaler);
S	void RST_CLK_DSPCmd(FunctionalState NewState);
N#endif
N
N/** @} */ /* End of group RST_CLK_Exported_Functions */
N
N/** @} */ /* End of group RST_CLK */
N
N/** @} */ /* End of group __MDR32F9Qx_StdPeriph_Driver */
N
N#ifdef __cplusplus
S} // extern "C" block end
N#endif
N
N#endif /* __MDR32F9Qx_RST_CLK_H */
N
N/*
N*
N* END OF FILE MDR32F9Qx_rst_clk.h */
L 19 "adc.c" 2
N/* Подключение функций управления АЦП */
N#include <MDR32F9Qx_adc.h>
L 1 "C:\Keil_v5\ARM\PACK\Keil\MDR1986BExx\1.5.3\Libraries\MDR32F9Qx_StdPeriph_Driver\inc\MDR32F9Qx_adc.h" 1
N/**
N  * FILE MDR32F9Qx_adc.h
N  */
N
N/* Define to prevent recursive inclusion -------------------------------------*/
N#ifndef __MDR32F9QX_ADC_H
N#define __MDR32F9QX_ADC_H
N
N#ifdef __cplusplus
Sextern "C" {
N#endif
N
N/* Includes ------------------------------------------------------------------*/
N#include "MDR32F9Qx_config.h"
N#include "MDR32F9Qx_lib.h"
N
N/** @addtogroup __MDR32F9Qx_StdPeriph_Driver MDR32F9Qx Standard Peripherial Driver
N  * @{
N  */
N
N/** @addtogroup  ADC ADC
N  * @{
N  */
N
N/** @defgroup ADC_Exported_Types ADC Exported Types
N  * @{
N  */
N
N/**
N  * @brief  ADC Init structure definition
N  */
N
Ntypedef struct {
N#if defined (USE_MDR1986VE9x) || defined (USE_MDR1901VC1T)
X#if 1L || 0L
N	uint32_t ADC_SynchronousMode; 		/*!< Enables or disables the ADC1, ADC2 synchronous mode operation.
N	 	 	 	 	 	 	 	 	 	 	 This parameter can be a value of @ref ADC_Synchronous_Mode */
N#endif
N
N	uint32_t ADC_StartDelay; 			/*!< Specifies the ADC1 and ADC2 conversion start delay.
N	 	 	 	 	 	 	 	 	 	 	 This parameter can be a number between 0 and 15. */
N
N	uint32_t ADC_TempSensor; 			/*!< Enables or disables the temperature sensor and internal voltage reference.
N	 	 	 	 	 	 	 	 	 	 	 This parameter can be a value of @ref ADC_Temp_Sensor */
N
N	uint32_t ADC_TempSensorAmplifier; 	/*!< Enables or disables the temperature sensor and internal voltage
N	 	 	 	 	 	 	 	 	 	 	 reference amplifier.
N	 	 	 	 	 	 	 	 	 	 	 This parameter can be a value of @ref ADC_Temp_Sensor_Amplifier */
N
N	uint32_t ADC_TempSensorConversion; 	/*!< Enables or disables the temperature sensor conversion.
N	 	 	 	 	 	 	 	 	 	 	 This parameter can be a value of @ref ADC_Temp_Sensor_Conversion */
N
N	uint32_t ADC_IntVRefConversion; 	/*!< Enables or disables the internal voltage reference conversion.
N	 	 	 	 	 	 	 	 	 	 	 This parameter can be a value of @ref ADC_Int_VRef_Conversion */
N
N	uint32_t ADC_IntVRefTrimming; 		/*!< Configures the internal voltage reference trimming.
N	 	 	 	 	 	 	 	 	 	 	 This parameter can be a number between 0 and 7. */
N#if defined (USE_MDR1986VE1T) || defined (USE_MDR1986VE3)
X#if 0L || 0L
S	uint32_t ADC_IntVRefAmplifier;		/*!< Enable or disable the internal voltage reference amplifier.
S											 This parameter can be a value of @ref ADC_Int_VRef_Amlifier */
N#endif
N
N} ADC_InitTypeDef;
N
N/**
N  * @brief  ADC1, ADC2 Init structure definition
N  */
N
Ntypedef struct
N{
N  uint32_t ADC_ClockSource;             /*!< Specifies the ADCx clock source.
N                                             This parameter can be a value of @ref ADCx_Clock_Source */
N
N  uint32_t ADC_SamplingMode;            /*!< Specifies the ADCx sampling mode.
N                                             This parameter can be a value of @ref ADCx_Sampling_Mode */
N
N  uint32_t ADC_ChannelSwitching;        /*!< Enables or disables the ADCx channel switching.
N                                             This parameter can be a value of @ref ADCx_Channel_Switching */
N
N  uint32_t ADC_ChannelNumber;           /*!< Specifies the ADCx channel number.
N                                             This parameter can be a value of @ref ADCx_Channel_Number */
N
N  uint32_t ADC_Channels;                /*!< Specifies the ADCx channels mask.
N                                             This parameter can be a value of @ref ADCx_Channels */
N
N  uint32_t ADC_LevelControl;            /*!< Enables or disables the ADCx level control.
N                                             This parameter can be a value of @ref ADCx_Level_Control */
N
N  uint16_t ADC_LowLevel;                /*!< Specifies the ADCx value low level.
N                                             This parameter can be a number between 0x0000 and 0x0FFF. */
N
N  uint16_t ADC_HighLevel;                /*!< Specifies the ADCx value high level.
N                                             This parameter can be a number between 0x0000 and 0x0FFF. */
N
N  uint32_t ADC_VRefSource;              /*!< Specifies the ADCx voltage reference source (internal or external).
N                                             This parameter can be a value of @ref ADCx_VRef_Source */
N
N  uint32_t ADC_IntVRefSource;           /*!< Specifies the ADCx internal voltage reference source (inexact or exact).
N                                             This parameter can be a value of @ref ADCx_Int_VRef_Source */
N
N  uint32_t ADC_Prescaler;               /*!< Specifies the ADCx Prescaler configuration.
N                                             This parameter can be a value of @ref ADCx_Prescaler */
N
N  uint32_t ADC_DelayGo;                 /*!< Specifies the ADCx start conversion delay at sequential conversion mode.
N                                             This parameter can be a number between 0 and 7. */
N}ADCx_InitTypeDef;
N
N/** @} */ /* End of group ADC_Exported_Types */
N
N/** @defgroup ADC_Exported_Constants ADC Exported Constants
N  * @{
N  */
N
N#if defined (USE_MDR1986VE9x) || defined (USE_MDR1901VC1T)
X#if 1L || 0L
N
N/** @defgroup ADC_Synchronous_Mode ADC Synchronous Mode
N  * @{
N  */
N
N#define ADC_SyncMode_Independent              (((uint32_t)0x0) << ADC1_CFG_SYNC_CONVER_Pos) /*!< The independent ADC1, ADC2 operation mode. */
N#define ADC_SyncMode_Synchronous              (((uint32_t)0x1) << ADC1_CFG_SYNC_CONVER_Pos) /*!< The synchronous ADC1, ADC2 operation mode. */
N
N#define IS_ADC_SYNC_MODE(MODE) (((MODE) == ADC_SyncMode_Independent) || \
N                                ((MODE) == ADC_SyncMode_Synchronous))
X#define IS_ADC_SYNC_MODE(MODE) (((MODE) == ADC_SyncMode_Independent) ||                                 ((MODE) == ADC_SyncMode_Synchronous))
N
N/** @} */ /* End of group ADC_Synchronous_Mode */
N
N#endif
N
N/** @defgroup ADC_Start_Delay ADC Start Delay
N  * @{
N  */
N
N#define IS_ADC_START_DELAY_VALUE(VALUE) (((VALUE) >= 0) && ((VALUE) <= 15))
N
N/** @} */ /* End of group ADC_Start_Delay */
N
N/** @defgroup ADC_Temp_Sensor ADC Temperature Sensor configuration
N  * @{
N  */
N
N#define ADC_TEMP_SENSOR_Disable               (((uint32_t)0x0) << ADC1_CFG_TS_EN_Pos)       /*!< Disables Temperature Sensor. */
N#define ADC_TEMP_SENSOR_Enable                (((uint32_t)0x1) << ADC1_CFG_TS_EN_Pos)       /*!< Enables Temperature Sensor. */
N
N#define IS_ADC_TEMP_SENSOR_CONFIG(CONFIG) (((CONFIG) == ADC_TEMP_SENSOR_Disable) || \
N                                           ((CONFIG) == ADC_TEMP_SENSOR_Enable ))
X#define IS_ADC_TEMP_SENSOR_CONFIG(CONFIG) (((CONFIG) == ADC_TEMP_SENSOR_Disable) ||                                            ((CONFIG) == ADC_TEMP_SENSOR_Enable ))
N
N/** @} */ /* End of group ADC_Temp_Sensor */
N
N/** @defgroup ADC_Temp_Sensor_Amplifier ADC Temperature Sensor Amplifier configuration
N  * @{
N  */
N
N#define ADC_TEMP_SENSOR_AMPLIFIER_Disable     (((uint32_t)0x0) << ADC1_CFG_TS_BUF_EN_Pos)   /*!< Disables Temperature Sensor Amplifier. */
N#define ADC_TEMP_SENSOR_AMPLIFIER_Enable      (((uint32_t)0x1) << ADC1_CFG_TS_BUF_EN_Pos)   /*!< Enables Temperature Sensor Amplifier. */
N
N#define IS_ADC_TEMP_SENSOR_AMP_CONFIG(CONFIG) (((CONFIG) == ADC_TEMP_SENSOR_AMPLIFIER_Disable) || \
N                                               ((CONFIG) == ADC_TEMP_SENSOR_AMPLIFIER_Enable ))
X#define IS_ADC_TEMP_SENSOR_AMP_CONFIG(CONFIG) (((CONFIG) == ADC_TEMP_SENSOR_AMPLIFIER_Disable) ||                                                ((CONFIG) == ADC_TEMP_SENSOR_AMPLIFIER_Enable ))
N
N/** @} */ /* End of group ADC_Temp_Sensor_Amplifier */
N
N/** @defgroup ADC_Temp_Sensor_Conversion ADC Temperature Sensor Conversion configuration
N  * @{
N  */
N
N#define ADC_TEMP_SENSOR_CONVERSION_Disable    (((uint32_t)0x0) << ADC1_CFG_SEL_TS_Pos)      /*!< Disables Temperature Sensor Conversion. */
N#define ADC_TEMP_SENSOR_CONVERSION_Enable     (((uint32_t)0x1) << ADC1_CFG_SEL_TS_Pos)      /*!< Enables Temperature Sensor Conversion. */
N
N#define IS_ADC_TEMP_SENSOR_CONVERSION_CONFIG(CONFIG) (((CONFIG) == ADC_TEMP_SENSOR_CONVERSION_Disable) || \
N                                                      ((CONFIG) == ADC_TEMP_SENSOR_CONVERSION_Enable ))
X#define IS_ADC_TEMP_SENSOR_CONVERSION_CONFIG(CONFIG) (((CONFIG) == ADC_TEMP_SENSOR_CONVERSION_Disable) ||                                                       ((CONFIG) == ADC_TEMP_SENSOR_CONVERSION_Enable ))
N
N/** @} */ /* End of group ADC_Temp_Sensor_Conversion */
N
N/** @defgroup ADC_Int_VRef_Conversion ADC Internal Voltage Reference Conversion configuration
N  * @{
N  */
N
N#define ADC_VREF_CONVERSION_Disable           (((uint32_t)0x0) << ADC1_CFG_SEL_VREF_Pos)    /*!< Disables Internal Voltage Reference Conversion. */
N#define ADC_VREF_CONVERSION_Enable            (((uint32_t)0x1) << ADC1_CFG_SEL_VREF_Pos)    /*!< Enables Internal Voltage Reference Conversion. */
N
N#define IS_ADC_VREF_CONVERSION_CONFIG(CONFIG) (((CONFIG) == ADC_VREF_CONVERSION_Disable) || \
N                                               ((CONFIG) == ADC_VREF_CONVERSION_Enable ))
X#define IS_ADC_VREF_CONVERSION_CONFIG(CONFIG) (((CONFIG) == ADC_VREF_CONVERSION_Disable) ||                                                ((CONFIG) == ADC_VREF_CONVERSION_Enable ))
N
N/** @} */ /* End of group ADC_Int_VRef_Conversion */
N
N/** @defgroup ADC_Int_VRef_Trimming ADC Internal Voltage Reference Trimming
N  * @{
N  */
N
N#if defined (USE_MDR1986VE9x) || defined (USE_MDR1901VC1T)
X#if 1L || 0L
N	#define IS_ADC_VREF_TRIMMING_VALUE(VALUE) (((VALUE) >= 0) && ((VALUE) <= 0x0F))
N#elif defined (USE_MDR1986VE3) || defined (USE_MDR1986VE1T)
S	#define IS_ADC_VREF_TRIMMING_VALUE(VALUE) (((VALUE) >= 0) && ((VALUE) <= 0x1F))
N#endif
N
N/** @} */ /* End of group ADC_Int_VRef_Trimming */
N
N/** @defgroup ADCx_Clock_Source ADCx Clock Source configuration
N  * @{
N  */
N
N#define ADC_CLOCK_SOURCE_CPU                  (((uint32_t)0x0) << ADC1_CFG_REG_CLKS_Pos)    /*!< Selects CPU_CLK as ADC clock. */
N#define ADC_CLOCK_SOURCE_ADC                  (((uint32_t)0x1) << ADC1_CFG_REG_CLKS_Pos)    /*!< Selects ADC_CLK as ADC clock. */
N
N#define IS_ADC_CLOCK_SOURCE_CONFIG(CONFIG) (((CONFIG) == ADC_CLOCK_SOURCE_ADC) || \
N                                            ((CONFIG) == ADC_CLOCK_SOURCE_CPU))
X#define IS_ADC_CLOCK_SOURCE_CONFIG(CONFIG) (((CONFIG) == ADC_CLOCK_SOURCE_ADC) ||                                             ((CONFIG) == ADC_CLOCK_SOURCE_CPU))
N
N/** @} */ /* End of group ADCx_Clock_Source */
N
N/** @defgroup ADCx_Sampling_Mode ADC Sampling Mode configuration
N  * @{
N  */
N
N#define ADC_SAMPLING_MODE_SINGLE_CONV         (((uint32_t)0x0) << ADC1_CFG_REG_SAMPLE_Pos)  /*!< Selects ADC single mode operation. */
N#define ADC_SAMPLING_MODE_CICLIC_CONV         (((uint32_t)0x1) << ADC1_CFG_REG_SAMPLE_Pos)  /*!< Selects ADC ciclic mode operation. */
N
N#define IS_ADC_SAMPLING_MODE_CONFIG(CONFIG) (((CONFIG) == ADC_SAMPLING_MODE_SINGLE_CONV) || \
N                                             ((CONFIG) == ADC_SAMPLING_MODE_CICLIC_CONV))
X#define IS_ADC_SAMPLING_MODE_CONFIG(CONFIG) (((CONFIG) == ADC_SAMPLING_MODE_SINGLE_CONV) ||                                              ((CONFIG) == ADC_SAMPLING_MODE_CICLIC_CONV))
N
N/** @} */ /* End of group ADCx_Sampling_Mode */
N
N/** @defgroup ADCx_Channel_Switching ADC Channel Swithing configuration
N  * @{
N  */
N
N#define ADC_CH_SWITCHING_Disable              (((uint32_t)0x0) << ADC1_CFG_REG_CHCH_Pos)    /*!< Disables Channel Swithing. */
N#define ADC_CH_SWITCHING_Enable               (((uint32_t)0x1) << ADC1_CFG_REG_CHCH_Pos)    /*!< Enables Channel Swithing. */
N
N#define IS_ADC_CH_SWITCHING_CONFIG(CONFIG) (((CONFIG) == ADC_CH_SWITCHING_Disable) || \
N                                            ((CONFIG) == ADC_CH_SWITCHING_Enable ))
X#define IS_ADC_CH_SWITCHING_CONFIG(CONFIG) (((CONFIG) == ADC_CH_SWITCHING_Disable) ||                                             ((CONFIG) == ADC_CH_SWITCHING_Enable ))
N
N/** @} */ /* End of group ADCx_Channel_Switching */
N
N
N/** @defgroup ADCx_Channel_Number ADC Channel Number
N  * @{
N  */
N
N#define ADC_CH_ADC0                           ((uint32_t)0x00) /*!< Specifies the ADC channel 0.  */
N#define ADC_CH_ADC1                           ((uint32_t)0x01) /*!< Specifies the ADC channel 1.  */
N#define ADC_CH_ADC2                           ((uint32_t)0x02) /*!< Specifies the ADC channel 2.  */
N#define ADC_CH_ADC3                           ((uint32_t)0x03) /*!< Specifies the ADC channel 3.  */
N#define ADC_CH_ADC4                           ((uint32_t)0x04) /*!< Specifies the ADC channel 4.  */
N#define ADC_CH_ADC5                           ((uint32_t)0x05) /*!< Specifies the ADC channel 5.  */
N#define ADC_CH_ADC6                           ((uint32_t)0x06) /*!< Specifies the ADC channel 6.  */
N#define ADC_CH_ADC7                           ((uint32_t)0x07) /*!< Specifies the ADC channel 7.  */
N#define ADC_CH_ADC8                           ((uint32_t)0x08) /*!< Specifies the ADC channel 8.  */
N#define ADC_CH_ADC9                           ((uint32_t)0x09) /*!< Specifies the ADC channel 9.  */
N#define ADC_CH_ADC10                          ((uint32_t)0x0A) /*!< Specifies the ADC channel 10. */
N#define ADC_CH_ADC11                          ((uint32_t)0x0B) /*!< Specifies the ADC channel 11. */
N#define ADC_CH_ADC12                          ((uint32_t)0x0C) /*!< Specifies the ADC channel 12. */
N#define ADC_CH_ADC13                          ((uint32_t)0x0D) /*!< Specifies the ADC channel 13. */
N#define ADC_CH_ADC14                          ((uint32_t)0x0E) /*!< Specifies the ADC channel 14. */
N#define ADC_CH_ADC15                          ((uint32_t)0x0F) /*!< Specifies the ADC channel 15. */
N#define ADC_CH_INT_VREF                       ((uint32_t)0x1E) /*!< Specifies the ADC channel 30 (Internal VRef). */
N#define ADC_CH_TEMP_SENSOR                    ((uint32_t)0x1F) /*!< Specifies the ADC channel 31 (Temperature Sensor). */
N
N#define IS_ADC2_CH_NUM(NUM) (((NUM) == ADC_CH_ADC0       ) || \
N                             ((NUM) == ADC_CH_ADC1       ) || \
N                             ((NUM) == ADC_CH_ADC2       ) || \
N                             ((NUM) == ADC_CH_ADC3       ) || \
N                             ((NUM) == ADC_CH_ADC4       ) || \
N                             ((NUM) == ADC_CH_ADC5       ) || \
N                             ((NUM) == ADC_CH_ADC6       ) || \
N                             ((NUM) == ADC_CH_ADC7       ) || \
N                             ((NUM) == ADC_CH_ADC8       ) || \
N                             ((NUM) == ADC_CH_ADC9       ) || \
N                             ((NUM) == ADC_CH_ADC10      ) || \
N                             ((NUM) == ADC_CH_ADC11      ) || \
N                             ((NUM) == ADC_CH_ADC12      ) || \
N                             ((NUM) == ADC_CH_ADC13      ) || \
N                             ((NUM) == ADC_CH_ADC14      ) || \
N                             ((NUM) == ADC_CH_ADC15      ))
X#define IS_ADC2_CH_NUM(NUM) (((NUM) == ADC_CH_ADC0       ) ||                              ((NUM) == ADC_CH_ADC1       ) ||                              ((NUM) == ADC_CH_ADC2       ) ||                              ((NUM) == ADC_CH_ADC3       ) ||                              ((NUM) == ADC_CH_ADC4       ) ||                              ((NUM) == ADC_CH_ADC5       ) ||                              ((NUM) == ADC_CH_ADC6       ) ||                              ((NUM) == ADC_CH_ADC7       ) ||                              ((NUM) == ADC_CH_ADC8       ) ||                              ((NUM) == ADC_CH_ADC9       ) ||                              ((NUM) == ADC_CH_ADC10      ) ||                              ((NUM) == ADC_CH_ADC11      ) ||                              ((NUM) == ADC_CH_ADC12      ) ||                              ((NUM) == ADC_CH_ADC13      ) ||                              ((NUM) == ADC_CH_ADC14      ) ||                              ((NUM) == ADC_CH_ADC15      ))
N
N#define IS_ADC1_CH_NUM(NUM)  ((IS_ADC2_CH_NUM(NUM))        || \
N                             ((NUM) == ADC_CH_INT_VREF   ) || \
N                             ((NUM) == ADC_CH_TEMP_SENSOR))
X#define IS_ADC1_CH_NUM(NUM)  ((IS_ADC2_CH_NUM(NUM))        ||                              ((NUM) == ADC_CH_INT_VREF   ) ||                              ((NUM) == ADC_CH_TEMP_SENSOR))
N
N/** @} */ /* End of group ADCx_Channel_Number */
N
N/** @defgroup ADCx_Channels ADC Channels
N  * @{
N  */
N
N#define ADC_CH_ADC0_MSK                       (((uint32_t)0x1) << ADC_CH_ADC0       ) /*!< Selects the ADC channel 0.  */
N#define ADC_CH_ADC1_MSK                       (((uint32_t)0x1) << ADC_CH_ADC1       ) /*!< Selects the ADC channel 1.  */
N#define ADC_CH_ADC2_MSK                       (((uint32_t)0x1) << ADC_CH_ADC2       ) /*!< Selects the ADC channel 2.  */
N#define ADC_CH_ADC3_MSK                       (((uint32_t)0x1) << ADC_CH_ADC3       ) /*!< Selects the ADC channel 3.  */
N#define ADC_CH_ADC4_MSK                       (((uint32_t)0x1) << ADC_CH_ADC4       ) /*!< Selects the ADC channel 4.  */
N#define ADC_CH_ADC5_MSK                       (((uint32_t)0x1) << ADC_CH_ADC5       ) /*!< Selects the ADC channel 5.  */
N#define ADC_CH_ADC6_MSK                       (((uint32_t)0x1) << ADC_CH_ADC6       ) /*!< Selects the ADC channel 6.  */
N#define ADC_CH_ADC7_MSK                       (((uint32_t)0x1) << ADC_CH_ADC7       ) /*!< Selects the ADC channel 7.  */
N#define ADC_CH_ADC8_MSK                       (((uint32_t)0x1) << ADC_CH_ADC8       ) /*!< Selects the ADC channel 8.  */
N#define ADC_CH_ADC9_MSK                       (((uint32_t)0x1) << ADC_CH_ADC9       ) /*!< Selects the ADC channel 9.  */
N#define ADC_CH_ADC10_MSK                      (((uint32_t)0x1) << ADC_CH_ADC10      ) /*!< Selects the ADC channel 10. */
N#define ADC_CH_ADC11_MSK                      (((uint32_t)0x1) << ADC_CH_ADC11      ) /*!< Selects the ADC channel 11. */
N#define ADC_CH_ADC12_MSK                      (((uint32_t)0x1) << ADC_CH_ADC12      ) /*!< Selects the ADC channel 12. */
N#define ADC_CH_ADC13_MSK                      (((uint32_t)0x1) << ADC_CH_ADC13      ) /*!< Selects the ADC channel 13. */
N#define ADC_CH_ADC14_MSK                      (((uint32_t)0x1) << ADC_CH_ADC14      ) /*!< Selects the ADC channel 14. */
N#define ADC_CH_ADC15_MSK                      (((uint32_t)0x1) << ADC_CH_ADC15      ) /*!< Selects the ADC channel 15. */
N#define ADC_CH_INT_VREF_MSK                   (((uint32_t)0x1) << ADC_CH_INT_VREF   ) /*!< Selects the ADC channel 30 (Internal VRef). */
N#define ADC_CH_TEMP_SENSOR_MSK                (((uint32_t)0x1) << ADC_CH_TEMP_SENSOR) /*!< Selects the ADC channel 31 (Temperature Sensor). */
N
N#define ADC2_ALL_CH_MSK         (ADC_CH_ADC0_MSK  | \
N                                 ADC_CH_ADC1_MSK  | \
N                                 ADC_CH_ADC2_MSK  | \
N                                 ADC_CH_ADC3_MSK  | \
N                                 ADC_CH_ADC4_MSK  | \
N                                 ADC_CH_ADC5_MSK  | \
N                                 ADC_CH_ADC6_MSK  | \
N                                 ADC_CH_ADC7_MSK  | \
N                                 ADC_CH_ADC8_MSK  | \
N                                 ADC_CH_ADC9_MSK  | \
N                                 ADC_CH_ADC10_MSK | \
N                                 ADC_CH_ADC11_MSK | \
N                                 ADC_CH_ADC12_MSK | \
N                                 ADC_CH_ADC13_MSK | \
N                                 ADC_CH_ADC14_MSK | \
N                                 ADC_CH_ADC15_MSK)
X#define ADC2_ALL_CH_MSK         (ADC_CH_ADC0_MSK  |                                  ADC_CH_ADC1_MSK  |                                  ADC_CH_ADC2_MSK  |                                  ADC_CH_ADC3_MSK  |                                  ADC_CH_ADC4_MSK  |                                  ADC_CH_ADC5_MSK  |                                  ADC_CH_ADC6_MSK  |                                  ADC_CH_ADC7_MSK  |                                  ADC_CH_ADC8_MSK  |                                  ADC_CH_ADC9_MSK  |                                  ADC_CH_ADC10_MSK |                                  ADC_CH_ADC11_MSK |                                  ADC_CH_ADC12_MSK |                                  ADC_CH_ADC13_MSK |                                  ADC_CH_ADC14_MSK |                                  ADC_CH_ADC15_MSK)
N
N#define IS_ADC2_CH_MASK(MASK) (((MASK) & ~ADC2_ALL_CH_MSK) == 0)
N
N#define ADC1_ALL_CH_MSK          (ADC2_ALL_CH_MSK    | \
N                                 ADC_CH_INT_VREF_MSK | \
N                                 ADC_CH_TEMP_SENSOR_MSK)
X#define ADC1_ALL_CH_MSK          (ADC2_ALL_CH_MSK    |                                  ADC_CH_INT_VREF_MSK |                                  ADC_CH_TEMP_SENSOR_MSK)
N
N#define IS_ADC1_CH_MASK(MASK) ((((MASK) & ~ADC2_ALL_CH_MSK) == 0) || \
N                               ((MASK) == ADC_CH_INT_VREF_MSK)    || \
N                               ((MASK) == ADC_CH_TEMP_SENSOR_MSK))
X#define IS_ADC1_CH_MASK(MASK) ((((MASK) & ~ADC2_ALL_CH_MSK) == 0) ||                                ((MASK) == ADC_CH_INT_VREF_MSK)    ||                                ((MASK) == ADC_CH_TEMP_SENSOR_MSK))
N
N/** @} */ /* End of group ADCx_Channels */
N
N/** @defgroup ADCx_Level_Control ADC Level Control configuration
N  * @{
N  */
N
N#define ADC_LEVEL_CONTROL_Disable             (((uint32_t)0x0) << ADC1_CFG_REG_RNGC_Pos)    /*!< Disables Level Control. */
N#define ADC_LEVEL_CONTROL_Enable              (((uint32_t)0x1) << ADC1_CFG_REG_RNGC_Pos)    /*!< Enables Level Control. */
N
N#define IS_ADC_LEVEL_CONTROL_CONFIG(CONFIG) (((CONFIG) == ADC_LEVEL_CONTROL_Disable) || \
N                                             ((CONFIG) == ADC_LEVEL_CONTROL_Enable ))
X#define IS_ADC_LEVEL_CONTROL_CONFIG(CONFIG) (((CONFIG) == ADC_LEVEL_CONTROL_Disable) ||                                              ((CONFIG) == ADC_LEVEL_CONTROL_Enable ))
N
N#define ADC_VALUE_MAX                        (0x0FFF)
N#define IS_ADC_VALUE(VALUE) (((VALUE) >= 0) && ((VALUE) <= ADC_VALUE_MAX))
N
N/** @} */ /* End of group ADCx_Level_Control */
N
N/** @defgroup ADCx_VRef_Source ADC Voltage Reference Source configuration
N  * @{
N  */
N
N#define ADC_VREF_SOURCE_INTERNAL              (((uint32_t)0x0) << ADC1_CFG_M_REF_Pos)       /*!< Selects Internal Voltage Reference. */
N#define ADC_VREF_SOURCE_EXTERNAL              (((uint32_t)0x1) << ADC1_CFG_M_REF_Pos)       /*!< Selects External Voltage Reference. */
N
N#define IS_ADC_VREF_SOURCE_CONFIG(CONFIG) (((CONFIG) == ADC_VREF_SOURCE_INTERNAL) || \
N                                           ((CONFIG) == ADC_VREF_SOURCE_EXTERNAL))
X#define IS_ADC_VREF_SOURCE_CONFIG(CONFIG) (((CONFIG) == ADC_VREF_SOURCE_INTERNAL) ||                                            ((CONFIG) == ADC_VREF_SOURCE_EXTERNAL))
N
N/** @} */ /* End of group ADCx_VRef_Source */
N
N/** @defgroup ADCx_Int_VRef_Source ADC Internal Voltage Reference Source configuration
N  * @{
N  */
N
N#define ADC_INT_VREF_SOURCE_INEXACT           ((uint32_t)0x0)   /*!< Selects inexact Internal Voltage Reference. */
N#define ADC_INT_VREF_SOURCE_EXACT             ((uint32_t)0x1)   /*!< Selects exact Internal Voltage Reference (from Temperature Sensor). */
N
N#define IS_ADC_INT_VREF_SOURCE_CONFIG(CONFIG) (((CONFIG) == ADC_INT_VREF_SOURCE_INEXACT) || \
N                                               ((CONFIG) == ADC_INT_VREF_SOURCE_EXACT  ))
X#define IS_ADC_INT_VREF_SOURCE_CONFIG(CONFIG) (((CONFIG) == ADC_INT_VREF_SOURCE_INEXACT) ||                                                ((CONFIG) == ADC_INT_VREF_SOURCE_EXACT  ))
N
N/** @} */ /* End of group ADCx_VRef_Source */
N
N/** @defgroup ADCx_Prescaler ADC Clock Prescaler
N  * @{
N  */
N
N#define ADC_CLK_div_None                      (((uint32_t)0x0) << ADC1_CFG_REG_DIVCLK_Pos) /*!< The input ADC clock devides by 1.     */
N#define ADC_CLK_div_2                         (((uint32_t)0x1) << ADC1_CFG_REG_DIVCLK_Pos) /*!< The input ADC clock devides by 2.     */
N#define ADC_CLK_div_4                         (((uint32_t)0x2) << ADC1_CFG_REG_DIVCLK_Pos) /*!< The input ADC clock devides by 4.     */
N#define ADC_CLK_div_8                         (((uint32_t)0x3) << ADC1_CFG_REG_DIVCLK_Pos) /*!< The input ADC clock devides by 8.     */
N#define ADC_CLK_div_16                        (((uint32_t)0x4) << ADC1_CFG_REG_DIVCLK_Pos) /*!< The input ADC clock devides by 16.    */
N#define ADC_CLK_div_32                        (((uint32_t)0x5) << ADC1_CFG_REG_DIVCLK_Pos) /*!< The input ADC clock devides by 32.    */
N#define ADC_CLK_div_64                        (((uint32_t)0x6) << ADC1_CFG_REG_DIVCLK_Pos) /*!< The input ADC clock devides by 64.    */
N#define ADC_CLK_div_128                       (((uint32_t)0x7) << ADC1_CFG_REG_DIVCLK_Pos) /*!< The input ADC clock devides by 128.   */
N#define ADC_CLK_div_256                       (((uint32_t)0x8) << ADC1_CFG_REG_DIVCLK_Pos) /*!< The input ADC clock devides by 256.   */
N#define ADC_CLK_div_512                       (((uint32_t)0x9) << ADC1_CFG_REG_DIVCLK_Pos) /*!< The input ADC clock devides by 512.   */
N#define ADC_CLK_div_1024                      (((uint32_t)0xA) << ADC1_CFG_REG_DIVCLK_Pos) /*!< The input ADC clock devides by 1024.  */
N#define ADC_CLK_div_2048                      (((uint32_t)0xB) << ADC1_CFG_REG_DIVCLK_Pos) /*!< The input ADC clock devides by 2048.  */
N#define ADC_CLK_div_4096                      (((uint32_t)0xC) << ADC1_CFG_REG_DIVCLK_Pos) /*!< The input ADC clock devides by 4096.  */
N#define ADC_CLK_div_8192                      (((uint32_t)0xD) << ADC1_CFG_REG_DIVCLK_Pos) /*!< The input ADC clock devides by 8192.  */
N#define ADC_CLK_div_16384                     (((uint32_t)0xE) << ADC1_CFG_REG_DIVCLK_Pos) /*!< The input ADC clock devides by 16384. */
N#define ADC_CLK_div_32768                     (((uint32_t)0xF) << ADC1_CFG_REG_DIVCLK_Pos) /*!< The input ADC clock devides by 32768. */
N
N#define IS_ADC_CLK_div_VALUE(VALUE) (((VALUE) == ADC_CLK_div_None ) || \
N                                     ((VALUE) == ADC_CLK_div_2    ) || \
N                                     ((VALUE) == ADC_CLK_div_4    ) || \
N                                     ((VALUE) == ADC_CLK_div_8    ) || \
N                                     ((VALUE) == ADC_CLK_div_16   ) || \
N                                     ((VALUE) == ADC_CLK_div_32   ) || \
N                                     ((VALUE) == ADC_CLK_div_64   ) || \
N                                     ((VALUE) == ADC_CLK_div_128  ) || \
N                                     ((VALUE) == ADC_CLK_div_256  ) || \
N                                     ((VALUE) == ADC_CLK_div_512  ) || \
N                                     ((VALUE) == ADC_CLK_div_1024 ) || \
N                                     ((VALUE) == ADC_CLK_div_2048 ) || \
N                                     ((VALUE) == ADC_CLK_div_4096 ) || \
N                                     ((VALUE) == ADC_CLK_div_8192 ) || \
N                                     ((VALUE) == ADC_CLK_div_16384) || \
N                                     ((VALUE) == ADC_CLK_div_32768))
X#define IS_ADC_CLK_div_VALUE(VALUE) (((VALUE) == ADC_CLK_div_None ) ||                                      ((VALUE) == ADC_CLK_div_2    ) ||                                      ((VALUE) == ADC_CLK_div_4    ) ||                                      ((VALUE) == ADC_CLK_div_8    ) ||                                      ((VALUE) == ADC_CLK_div_16   ) ||                                      ((VALUE) == ADC_CLK_div_32   ) ||                                      ((VALUE) == ADC_CLK_div_64   ) ||                                      ((VALUE) == ADC_CLK_div_128  ) ||                                      ((VALUE) == ADC_CLK_div_256  ) ||                                      ((VALUE) == ADC_CLK_div_512  ) ||                                      ((VALUE) == ADC_CLK_div_1024 ) ||                                      ((VALUE) == ADC_CLK_div_2048 ) ||                                      ((VALUE) == ADC_CLK_div_4096 ) ||                                      ((VALUE) == ADC_CLK_div_8192 ) ||                                      ((VALUE) == ADC_CLK_div_16384) ||                                      ((VALUE) == ADC_CLK_div_32768))
N
N/** @} */ /* End of group ADCx_Prescaler */
N
N/** @defgroup ADCx_Delay_Go ADCx start conversion delay
N  * @{
N  */
N
N#define IS_ADC_DELAY_GO_VALUE(VALUE) (((VALUE) >= 0) && ((VALUE) <= 7))
N
N/** @} */ /* End of group ADCx_Level_Control */
N
N/** @defgroup ADC_Flags ADC Flags
N  * @{
N  */
N
N#if defined ADC_STATUS_FLG_REG_OVERWRITE_Pos
X#if 1L
N	#define ADCx_FLAG_OVERWRITE                   (((uint32_t)0x1) << ADC_STATUS_FLG_REG_OVERWRITE_Pos)
N#endif
N
N#if defined ADC1_STATUS_FLG_REG_OVERWRITE_Pos
X#if 0L
S	#define ADCx_FLAG_OVERWRITE                   (((uint32_t)0x1) << ADC1_STATUS_FLG_REG_OVERWRITE_Pos)
N#endif
N
N#if defined (ADC_STATUS_FLG_REG_AWOIFEN_Pos)
X#if 1L
N	#define ADCx_FLAG_OUT_OF_RANGE                (((uint32_t)0x1) << ADC_STATUS_FLG_REG_AWOIFEN_Pos)
N#endif
N
N#if defined (ADC1_STATUS_FLG_REG_AWOIFEN_Pos)
X#if 0L
S	#define ADCx_FLAG_OUT_OF_RANGE                (((uint32_t)0x1) << ADC1_STATUS_FLG_REG_AWOIFEN_Pos)
N#endif
N
N#if defined (ADC_STATUS_FLG_REG_EOCIF_Pos)
X#if 1L
N	#define ADCx_FLAG_END_OF_CONVERSION           (((uint32_t)0x1) << ADC_STATUS_FLG_REG_EOCIF_Pos)
N#endif
N
N#if defined (ADC1_STATUS_FLG_REG_EOCIF_Pos)
X#if 0L
S	#define ADCx_FLAG_END_OF_CONVERSION           (((uint32_t)0x1) << ADC1_STATUS_FLG_REG_EOCIF_Pos)
N#endif
N
N
N
N#define IS_ADCx_STATUS_FLAG(FLAG) (((FLAG) == ADCx_FLAG_OVERWRITE        ) || \
N                                   ((FLAG) == ADCx_FLAG_OUT_OF_RANGE     ) || \
N                                   ((FLAG) == ADCx_FLAG_END_OF_CONVERSION))
X#define IS_ADCx_STATUS_FLAG(FLAG) (((FLAG) == ADCx_FLAG_OVERWRITE        ) ||                                    ((FLAG) == ADCx_FLAG_OUT_OF_RANGE     ) ||                                    ((FLAG) == ADCx_FLAG_END_OF_CONVERSION))
N
N#define ADC1_FLAG_OVERWRITE                   (ADCx_FLAG_OVERWRITE         <<  0)
N#define ADC1_FLAG_OUT_OF_RANGE                (ADCx_FLAG_OUT_OF_RANGE      <<  0)
N#define ADC1_FLAG_END_OF_CONVERSION           (ADCx_FLAG_END_OF_CONVERSION <<  0)
N#define ADC2_FLAG_OVERWRITE                   (ADCx_FLAG_OVERWRITE         << 16)
N#define ADC2_FLAG_OUT_OF_RANGE                (ADCx_FLAG_OUT_OF_RANGE      << 16)
N#define ADC2_FLAG_END_OF_CONVERSION           (ADCx_FLAG_END_OF_CONVERSION << 16)
N
N#if defined  (USE_MDR1986VE9x) || defined (USE_MDR1901VC1T)
X#if 1L || 0L
N#define IS_ADC_STATUS_FLAG(FLAG) (((FLAG) == ADC1_FLAG_OVERWRITE        ) || \
N                                  ((FLAG) == ADC1_FLAG_OUT_OF_RANGE     ) || \
N                                  ((FLAG) == ADC1_FLAG_END_OF_CONVERSION) || \
N                                  ((FLAG) == ADC2_FLAG_OVERWRITE        ) || \
N                                  ((FLAG) == ADC2_FLAG_OUT_OF_RANGE     ) || \
N                                  ((FLAG) == ADC2_FLAG_END_OF_CONVERSION))
X#define IS_ADC_STATUS_FLAG(FLAG) (((FLAG) == ADC1_FLAG_OVERWRITE        ) ||                                   ((FLAG) == ADC1_FLAG_OUT_OF_RANGE     ) ||                                   ((FLAG) == ADC1_FLAG_END_OF_CONVERSION) ||                                   ((FLAG) == ADC2_FLAG_OVERWRITE        ) ||                                   ((FLAG) == ADC2_FLAG_OUT_OF_RANGE     ) ||                                   ((FLAG) == ADC2_FLAG_END_OF_CONVERSION))
N#endif
N
N#if defined (USE_MDR1986VE1T) || defined (USE_MDR1986VE3)
X#if 0L || 0L
S#define IS_ADC_STATUS_FLAG(FLAG) (((FLAG) == ADC1_FLAG_OVERWRITE        ) || \
S                                  ((FLAG) == ADC1_FLAG_OUT_OF_RANGE     ) || \
S                                  ((FLAG) == ADC1_FLAG_END_OF_CONVERSION))
X#define IS_ADC_STATUS_FLAG(FLAG) (((FLAG) == ADC1_FLAG_OVERWRITE        ) ||                                   ((FLAG) == ADC1_FLAG_OUT_OF_RANGE     ) ||                                   ((FLAG) == ADC1_FLAG_END_OF_CONVERSION))
N#endif
N
N/** @} */ /* End of group ADC_Flags */
N
N/** @defgroup ADC_Interrupt_definition ADC Interrupt definition
N  * @{
N  */
N
N#define ADCx_IT_OUT_OF_RANGE               (((uint32_t)0x1) << ADC_STATUS_FLG_REG_AWOIFEN_Pos)
N#define ADCx_IT_END_OF_CONVERSION          (((uint32_t)0x1) << ADC_STATUS_FLG_REG_EOCIF_Pos)
N
N#define IS_ADCx_CONFIG_IT(IT)              (((IT) == ADCx_IT_OUT_OF_RANGE     ) || \
N                                            ((IT) == ADCx_IT_END_OF_CONVERSION))
X#define IS_ADCx_CONFIG_IT(IT)              (((IT) == ADCx_IT_OUT_OF_RANGE     ) ||                                             ((IT) == ADCx_IT_END_OF_CONVERSION))
N
N#define ADC1_IT_OUT_OF_RANGE               (ADCx_IT_OUT_OF_RANGE      <<  0)
N#define ADC1_IT_END_OF_CONVERSION          (ADCx_IT_END_OF_CONVERSION <<  0)
N#define ADC2_IT_OUT_OF_RANGE               (ADCx_IT_OUT_OF_RANGE      << 16)
N#define ADC2_IT_END_OF_CONVERSION          (ADCx_IT_END_OF_CONVERSION << 16)
N
N#if defined  (USE_MDR1986VE9x) || defined (USE_MDR1901VC1T)
X#if 1L || 0L
N#define IS_ADC_CONFIG_IT(IT)              (((IT) == ADC1_IT_OUT_OF_RANGE     ) || \
N                                           ((IT) == ADC1_IT_END_OF_CONVERSION) || \
N                                           ((IT) == ADC2_IT_OUT_OF_RANGE     ) || \
N                                           ((IT) == ADC2_IT_END_OF_CONVERSION))
X#define IS_ADC_CONFIG_IT(IT)              (((IT) == ADC1_IT_OUT_OF_RANGE     ) ||                                            ((IT) == ADC1_IT_END_OF_CONVERSION) ||                                            ((IT) == ADC2_IT_OUT_OF_RANGE     ) ||                                            ((IT) == ADC2_IT_END_OF_CONVERSION))
N#endif
N
N#if defined (USE_MDR1986VE1T) || defined (USE_MDR1986VE3)
X#if 0L || 0L
S#define IS_ADC_CONFIG_IT(IT)              (((IT) == ADC1_IT_OUT_OF_RANGE     ) || \
S                                           ((IT) == ADC1_IT_END_OF_CONVERSION))
X#define IS_ADC_CONFIG_IT(IT)              (((IT) == ADC1_IT_OUT_OF_RANGE     ) ||                                            ((IT) == ADC1_IT_END_OF_CONVERSION))
N#endif
N
N/** @} */ /* End of group ADC_Interrupt_definition */
N
N#if defined (USE_MDR1986VE1T) || defined (USE_MDR1986VE3)
X#if 0L || 0L
S
S/** @defgroup ADC_Int_VRef_Amplifier ADC Int_VRef Amplifier
S  * @{
S  */
S
S#define ADC_INT_VREF_AMPLIFIER_Enable			((uint32_t)(1 << ADC1_TRIM_SEL_VREF_BUF_Pos))
S#define ADC_INT_VREF_AMPLIFIER_Disable			((uint32_t)(0 << ADC1_TRIM_SEL_VREF_BUF_Pos))
S
S#define IS_ADC_INT_VREF_AMPLIFIER(AMPLIFIER)	(((AMPLIFIER) == ADC_INT_VREF_AMPLIFIER_Enable) ||\
S												 ((AMPLIFIER) == ADC_INT_VREF_AMPLIFIER_Disable))
X#define IS_ADC_INT_VREF_AMPLIFIER(AMPLIFIER)	(((AMPLIFIER) == ADC_INT_VREF_AMPLIFIER_Enable) ||												 ((AMPLIFIER) == ADC_INT_VREF_AMPLIFIER_Disable))
S/** @} */ /* End of group ADC_Int_VRef_Amplifier */
S
N#endif
N
N
N/** @} */ /* End of group ADC_Exported_Constants */
N
N/** @defgroup ADC_Exported_Macros ADC Exported Macros
N  * @{
N  */
N
N/** @} */ /* End of group ADC_Exported_Macros */
N
N/** @defgroup ADC_Exported_Functions ADC Exported Functions
N  * @{
N  */
N
Nvoid ADC_DeInit(void);
N
Nvoid ADC_Init(const ADC_InitTypeDef* ADC_InitStruct);
Nvoid ADC_StructInit(ADC_InitTypeDef* ADC_InitStruct);
N
Nvoid ADC_SetTrim(uint32_t Trim);
N
Nvoid ADC1_Init(const ADCx_InitTypeDef* ADCx_InitStruct);
Nvoid ADC2_Init(const ADCx_InitTypeDef* ADCx_InitStruct);
Nvoid ADCx_StructInit(ADCx_InitTypeDef* ADCx_InitStruct);
N
Nvoid ADC1_Cmd(FunctionalState NewState);
Nvoid ADC2_Cmd(FunctionalState NewState);
N
Nvoid ADC1_SetChannel(uint32_t Channel);
Nvoid ADC2_SetChannel(uint32_t Channel);
Nvoid ADC1_SetChannels(uint32_t ChannelMask);
Nvoid ADC2_SetChannels(uint32_t ChannelMask);
N
Nvoid ADC1_OperationModeConfig(uint32_t SamplingMode, uint32_t SwitchingMode);
Nvoid ADC2_OperationModeConfig(uint32_t SamplingMode, uint32_t SwitchingMode);
Nvoid ADC1_SamplingModeConfig(uint32_t SamplingMode);
Nvoid ADC2_SamplingModeConfig(uint32_t SamplingMode);
Nvoid ADC1_ChannelSwithingConfig(uint32_t SwitchingMode);
Nvoid ADC2_ChannelSwithingConfig(uint32_t SwitchingMode);
N
Nvoid ADC1_LevelsConfig(uint32_t LowLevel, uint32_t HighLevel, uint32_t NewState);
Nvoid ADC2_LevelsConfig(uint32_t LowLevel, uint32_t HighLevel, uint32_t NewState);
Nvoid ADC1_SetLowLevel(uint32_t LowLevel);
Nvoid ADC2_SetLowLevel(uint32_t LowLevel);
Nvoid ADC1_SetHighLevel(uint32_t HighLevel);
Nvoid ADC2_SetHighLevel(uint32_t HighLevel);
N
Nvoid ADC1_Start(void);
Nvoid ADC2_Start(void);
N
Nuint32_t ADC1_GetResult(void);
Nuint32_t ADC2_GetResult(void);
N
Nuint32_t ADC_GetStatus(void);
Nuint32_t ADC1_GetStatus(void);
Nuint32_t ADC2_GetStatus(void);
NFlagStatus ADC_GetFlagStatus(uint32_t Flag);
NFlagStatus ADC1_GetFlagStatus(uint32_t Flag);
NFlagStatus ADC2_GetFlagStatus(uint32_t Flag);
Nvoid ADC1_ClearOverwriteFlag(void);
Nvoid ADC2_ClearOverwriteFlag(void);
Nvoid ADC1_ClearOutOfRangeFlag(void);
Nvoid ADC2_ClearOutOfRangeFlag(void);
N
Nvoid ADC_ITConfig(uint32_t ADC_IT, FunctionalState NewState);
Nvoid ADC1_ITConfig(uint32_t ADC_IT, FunctionalState NewState);
Nvoid ADC2_ITConfig(uint32_t ADC_IT, FunctionalState NewState);
NITStatus ADC_GetITStatus(uint32_t ADC_IT);
NITStatus ADC1_GetITStatus(uint32_t ADC_IT);
NITStatus ADC2_GetITStatus(uint32_t ADC_IT);
N
N/** @} */ /* End of group ADC_Exported_Functions */
N
N/** @} */ /* End of group ADC */
N
N/** @} */ /* End of group __MDR32F9Qx_StdPeriph_Driver */
N
N#ifdef __cplusplus
S} // extern "C" block end
N#endif
N
N#endif /* __MDR32F9QX_ADC_H */
N
N/*
N*
N* END OF FILE MDR32F9Qx_adc.h */
N
L 21 "adc.c" 2
N
N/* Подключение заголовочного файла, содержащего платформо-зависимые 
N   макроопределения */
N#include "adc.h"
L 1 "adc.h" 1
N/************************************************************************************
N
N  Устройство: Evaluation Board For MCU MDR32F2Q
N  Файл: adc.h 
N  Назначение: Управление АЦП 
N  Компилятор:  Armcc 5.06.0 из комплекта Keil uVision 5.20.0
N************************************************************************************/
N
N#include "common.h"
L 1 "common.h" 1
N/************************************************************************************
N
N  Микроконтроллер: K1986ВЕ92QI
N  Устройство: Evaluation Board For MCU MDR32F2Q
N  Файл: common.h
N  Назначение: Подключение необходимых библиотек
N  Компилятор:  Armcc 5.06.0 из комплекта Keil uVision 5.20.0
N************************************************************************************/
N
N#include "MDR32Fx.h"
N#include "MDR32F9Qx_config.h"
N#include "MDR32F9Qx_rst_clk.h"
N#include "MDR32F9Qx_port.h"
N#include "MDR32F9Qx_it.h"
L 1 "MDR32F9Qx_it.h" 1
N/**
N  ******************************************************************************
N  * @file    Examples/MDR32F9Q2_EVAL/CAN/LoopBack_RTR/MDR32F9Qx_it.h
N  * @author  Milandr Application Team
N  * @version V1.2.0
N  * @date    12/09/2011
N  * @brief   This file contains all the functions prototypes for the interrupt.
N  *
N  ******************************************************************************
N  * <br><br>
N  *
N  * THE PRESENT FIRMWARE WHICH IS FOR GUIDANCE ONLY AIMS AT PROVIDING CUSTOMERS
N  * WITH CODING INFORMATION REGARDING THEIR PRODUCTS IN ORDER FOR THEM TO SAVE
N  * TIME. AS A RESULT, MILANDR SHALL NOT BE HELD LIABLE FOR ANY DIRECT, INDIRECT
N  * OR CONSEQUENTIAL DAMAGES WITH RESPECT TO ANY CLAIMS ARISING
N  * FROM THE CONTENT OF SUCH FIRMWARE AND/OR THE USE MADE BY CUSTOMERS OF THE
N  * CODING INFORMATION CONTAINED HEREIN IN CONNECTION WITH THEIR PRODUCTS.
N  *
N  * <h2><center>&copy; COPYRIGHT 2011 Milandr</center></h2>
N  */
N
N/* Define to prevent recursive inclusion -------------------------------------*/
N#ifndef __MDR32F9QX_IT_H
N#define __MDR32F9QX_IT_H
N
N
Nvoid NMI_Handler(void);
Nvoid HardFault_Handler(void);
Nvoid MemManage_Handler(void);
Nvoid BusFault_Handler(void);
Nvoid UsageFault_Handler(void);
Nvoid SVC_Handler(void);
Nvoid DebugMon_Handler(void);
Nvoid PendSV_Handler(void);
Nvoid SysTick_Handler(void);
Nvoid CAN1_IRQHandler(void);
Nvoid CAN2_IRQHandler(void);
Nvoid DMA_IRQHandler(void);
Nvoid UART1_IRQHandler(void);
Nvoid UART2_IRQHandler(void);
Nvoid SSP1_IRQHandler(void);
Nvoid I2C_IRQHandler(void);
Nvoid POWER_IRQHandler(void);
Nvoid WWDG_IRQHandler(void);
Nvoid Timer1_IRQHandler(void);
Nvoid Timer2_IRQHandler(void);
Nvoid Timer3_IRQHandler(void);
Nvoid ADC_IRQHandler(void);
Nvoid COMPARATOR_IRQHandler(void);
Nvoid SSP2_IRQHandler(void);
Nvoid BACKUP_IRQHandler(void);
Nvoid EXT_INT1_IRQHandler(void);
Nvoid EXT_INT2_IRQHandler(void);
Nvoid EXT_INT3_IRQHandler(void);
Nvoid EXT_INT4_IRQHandler(void);
N
N#endif /* __MDR32F9QX_IT_H */
N
N/******************* (C) COPYRIGHT 2011 Milandr *********/
N
N/* END OF FILE MDR32F9Qx_it.h */
L 15 "common.h" 2
N/* Подключение функций управления UART */
N#include <MDR32F9Qx_uart.h>
L 1 "C:\Keil_v5\ARM\PACK\Keil\MDR1986BExx\1.5.3\Libraries\MDR32F9Qx_StdPeriph_Driver\inc\MDR32F9Qx_uart.h" 1
N/**
N  * FILE MDR32F9Qx_uart.h
N  */
N
N/* Define to prevent recursive inclusion -------------------------------------*/
N#ifndef __MDR32F9Qx_UART_H
N#define __MDR32F9Qx_UART_H
N
N#ifdef __cplusplus
Sextern "C" {
N#endif
N
N/* Includes ------------------------------------------------------------------*/
N#include "MDR32F9Qx_config.h"
N#include "MDR32F9Qx_lib.h"
N
N/** @addtogroup __MDR32F9Qx_StdPeriph_Driver MDR32F9Qx Standard Peripherial Driver
N  * @{
N  */
N
N/** @addtogroup UART
N  * @{
N  */
N
N/** @defgroup UART_Exported_Types UART Exported Types
N  * @{
N  */
N
Ntypedef enum {BaudRateInvalid = 0, BaudRateValid = !BaudRateInvalid} BaudRateStatus;
N
N/**
N  * @brief  UART Init Structure definition
N  */
N
Ntypedef struct
N{
N  uint32_t UART_BaudRate;            /*!< This member configures the UART communication baud rate.
N                                          The baud rate is computed using the following formula:
N                                           - IntegerDivider = ((UARTCLK) / (16 * (UART_InitStruct->UART_BaudRate)))
N                                           - FractionalDivider = ((IntegerDivider - ((u32) IntegerDivider)) * 64) + 0.5 */
N  uint16_t UART_WordLength;          /*!< Specifies the number of data bits transmitted or received in a frame.
N                                          This parameter is one of @ref UART_Word_Length values. */
N  uint16_t UART_StopBits;            /*!< Specifies the number of stop bits transmitted.
N                                          This parameter is one of @ref UART_Stop_Bits values. */
N  uint16_t UART_Parity;              /*!< Specifies the parity mode.
N                                          This parameter is one of @ref UART_Parity values. */
N  uint16_t UART_FIFOMode;            /*!< Specifies the FIFO mode.
N                                          This parameter is one of @ref UART_FIFO_Mode values. */
N  uint16_t UART_HardwareFlowControl; /*!< Specifies whether the hardware flow control mode is enabled or disabled.
N                                          This parameter is one of @ref UART_Hardware_Flow_Control values. */
N}UART_InitTypeDef;
N
N/** @} */ /* End of group UART_Exported_Types */
N
N
N/** @defgroup UART_Exported_Constants UART Exported Constants
N  * @{
N  */
N
N#if defined (USE_MDR1986VE9x) || defined(USE_MDR1986VE1T)
X#if 1L || 0L
N
N#define IS_UART_ALL_PERIPH(PERIPH)          (((PERIPH) == MDR_UART1) || \
N                                             ((PERIPH) == MDR_UART2))
X#define IS_UART_ALL_PERIPH(PERIPH)          (((PERIPH) == MDR_UART1) ||                                              ((PERIPH) == MDR_UART2))
N#elif defined (USE_MDR1986VE3)
S
S#define IS_UART_ALL_PERIPH(PERIPH)          (((PERIPH) == MDR_UART1) || \
S                                            ((PERIPH) == MDR_UART2) || \
S                                            ((PERIPH) == MDR_UART3) || \
S                                            ((PERIPH) == MDR_UART4))
X#define IS_UART_ALL_PERIPH(PERIPH)          (((PERIPH) == MDR_UART1) ||                                             ((PERIPH) == MDR_UART2) ||                                             ((PERIPH) == MDR_UART3) ||                                             ((PERIPH) == MDR_UART4))
S
S#elif defined (USE_MDR1901VC1T)
S
S#define IS_UART_ALL_PERIPH(PERIPH)          (((PERIPH) == MDR_UART1) || \
S											 ((PERIPH) == MDR_UART2) || \
S											 ((PERIPH) == MDR_UART3))
X#define IS_UART_ALL_PERIPH(PERIPH)          (((PERIPH) == MDR_UART1) || 											 ((PERIPH) == MDR_UART2) || 											 ((PERIPH) == MDR_UART3))
N#endif
N
N/** @defgroup UART_Word_Length UART Word Length
N  * @{
N  */
N
N#define UART_WordLength5b                   ((uint16_t)0x0000)
N#define UART_WordLength6b                   ((uint16_t)0x0020)
N#define UART_WordLength7b                   ((uint16_t)0x0040)
N#define UART_WordLength8b                   ((uint16_t)0x0060)
N
N#define IS_UART_WORD_LENGTH(LENGTH)         (((LENGTH) == UART_WordLength5b) || \
N                                             ((LENGTH) == UART_WordLength6b) || \
N                                             ((LENGTH) == UART_WordLength7b) || \
N                                             ((LENGTH) == UART_WordLength8b))
X#define IS_UART_WORD_LENGTH(LENGTH)         (((LENGTH) == UART_WordLength5b) ||                                              ((LENGTH) == UART_WordLength6b) ||                                              ((LENGTH) == UART_WordLength7b) ||                                              ((LENGTH) == UART_WordLength8b))
N
N/** @} */ /* End of group UART_Word_Length */
N
N/** @defgroup UART_Stop_Bits UART Stop Bits
N  * @{
N  */
N
N#define UART_StopBits1                      ((uint16_t)0x0000)
N#define UART_StopBits2                      ((uint16_t)0x0008)
N
N#define IS_UART_STOPBITS(STOPBITS)          (((STOPBITS) == UART_StopBits1) || \
N                                             ((STOPBITS) == UART_StopBits2))
X#define IS_UART_STOPBITS(STOPBITS)          (((STOPBITS) == UART_StopBits1) ||                                              ((STOPBITS) == UART_StopBits2))
N
N/** @} */ /* End of group UART_Stop_Bits */
N
N/** @defgroup UART_Parity UART Parity
N  * @{
N  */
N
N#define UART_Parity_No                      ((uint16_t)0x0000)
N#define UART_Parity_Even                    ((uint16_t)0x0006)
N#define UART_Parity_Odd                     ((uint16_t)0x0002)
N#define UART_Parity_1                       ((uint16_t)0x0082)
N#define UART_Parity_0                       ((uint16_t)0x0086)
N
N#define IS_UART_PARITY(PARITY)              (((PARITY) == UART_Parity_No)   || \
N                                             ((PARITY) == UART_Parity_Even) || \
N                                             ((PARITY) == UART_Parity_Odd)  || \
N                                             ((PARITY) == UART_Parity_1)    || \
N                                             ((PARITY) == UART_Parity_0))
X#define IS_UART_PARITY(PARITY)              (((PARITY) == UART_Parity_No)   ||                                              ((PARITY) == UART_Parity_Even) ||                                              ((PARITY) == UART_Parity_Odd)  ||                                              ((PARITY) == UART_Parity_1)    ||                                              ((PARITY) == UART_Parity_0))
N
N/** @} */ /* End of group UART_Parity */
N
N/** @defgroup UART_FIFO_Mode UART FIFO Mode
N  * @{
N  */
N
N#define UART_FIFO_OFF                       ((uint16_t)0x0000)
N#define UART_FIFO_ON                        ((uint16_t)0x0010)
N
N#define IS_UART_FIFOMODE(FIFOMODE)          (((FIFOMODE) == UART_FIFO_ON) || \
N                                             ((FIFOMODE) == UART_FIFO_OFF))
X#define IS_UART_FIFOMODE(FIFOMODE)          (((FIFOMODE) == UART_FIFO_ON) ||                                              ((FIFOMODE) == UART_FIFO_OFF))
N
N/** @} */ /* End of group UART_FIFO_Mode */
N
N/** @defgroup UART_Hardware_Flow_Control UART Hardware Flow Control
N  * @{
N  */
N#define UART_HardwareFlowControl_None       ((uint16_t)0x0000)
N#define UART_HardwareFlowControl_CTSEn      ((uint16_t)0x8000)
N#define UART_HardwareFlowControl_RTSEn      ((uint16_t)0x4000)
N#define UART_HardwareFlowControl_Out2       ((uint16_t)0x2000)
N#define UART_HardwareFlowControl_Out1       ((uint16_t)0x1000)
N#define UART_HardwareFlowControl_RTS        ((uint16_t)0x0800)
N#define UART_HardwareFlowControl_DTR        ((uint16_t)0x0400)
N#define UART_HardwareFlowControl_RXE        ((uint16_t)0x0200)
N#define UART_HardwareFlowControl_TXE        ((uint16_t)0x0100)
N#define UART_HardwareFlowControl_LBE        ((uint16_t)0x0080)
N
N#define UART_HARDWARE_FLOW_CONTROL_MASK		((uint16_t)0xFF80)
N
N#define IS_UART_HARDWARE_FLOW_CONTROL(CONTROL) 		((CONTROL&(~(UART_HARDWARE_FLOW_CONTROL_MASK))) == 0)
N
N/** @} */ /* End of group UART_Hardware_Flow_Control */
N
N/** @defgroup UART_Interrupt_definition UART Interrupt definition
N  * @{
N  */
N
N#define UART_IT_OE                          ((uint32_t)0x00000400)
N#define UART_IT_BE                          ((uint32_t)0x00000200)
N#define UART_IT_PE                          ((uint32_t)0x00000100)
N#define UART_IT_FE                          ((uint32_t)0x00000080)
N#define UART_IT_RT                          ((uint32_t)0x00000040)
N#define UART_IT_TX                          ((uint32_t)0x00000020)
N#define UART_IT_RX                          ((uint32_t)0x00000010)
N#define UART_IT_DSR                         ((uint32_t)0x00000008)
N#define UART_IT_DCD                         ((uint32_t)0x00000004)
N#define UART_IT_CTS                         ((uint32_t)0x00000002)
N#define UART_IT_RI                          ((uint32_t)0x00000001)
N
N#define IS_UART_CONFIG_IT(IT)               (((IT) == UART_IT_OE)  || ((IT) == UART_IT_BE)  || \
N                                             ((IT) == UART_IT_PE)  || ((IT) == UART_IT_FE)  || \
N                                             ((IT) == UART_IT_RT)  || ((IT) == UART_IT_TX)  || \
N                                             ((IT) == UART_IT_RX)  || ((IT) == UART_IT_DSR) || \
N                                             ((IT) == UART_IT_DCD) || ((IT) == UART_IT_CTS) || \
N                                             ((IT) == UART_IT_RI))
X#define IS_UART_CONFIG_IT(IT)               (((IT) == UART_IT_OE)  || ((IT) == UART_IT_BE)  ||                                              ((IT) == UART_IT_PE)  || ((IT) == UART_IT_FE)  ||                                              ((IT) == UART_IT_RT)  || ((IT) == UART_IT_TX)  ||                                              ((IT) == UART_IT_RX)  || ((IT) == UART_IT_DSR) ||                                              ((IT) == UART_IT_DCD) || ((IT) == UART_IT_CTS) ||                                              ((IT) == UART_IT_RI))
N
N/** @} */ /* End of group UART_Interrupt_definition */
N
N/** @defgroup UART_DMA_interrupt_definition UART DMA interrupt definition
N  * @{
N  */
N
N#define UART_IT_FIFO_LVL_2words             ((uint32_t)0x00000000)
N#define UART_IT_FIFO_LVL_4words             ((uint32_t)0x00000001)
N#define UART_IT_FIFO_LVL_8words             ((uint32_t)0x00000002)
N#define UART_IT_FIFO_LVL_12words            ((uint32_t)0x00000003)
N#define UART_IT_FIFO_LVL_14words            ((uint32_t)0x00000004)
N
N#define IS_UART_IT_FIFO_LVL(IT_FIFO_LVL)    (((IT_FIFO_LVL) == UART_IT_FIFO_LVL_2words) || \
N                                             ((IT_FIFO_LVL) == UART_IT_FIFO_LVL_4words) || \
N                                             ((IT_FIFO_LVL) == UART_IT_FIFO_LVL_8words) || \
N                                             ((IT_FIFO_LVL) == UART_IT_FIFO_LVL_12words) || \
N                                             ((IT_FIFO_LVL) == UART_IT_FIFO_LVL_14words))
X#define IS_UART_IT_FIFO_LVL(IT_FIFO_LVL)    (((IT_FIFO_LVL) == UART_IT_FIFO_LVL_2words) ||                                              ((IT_FIFO_LVL) == UART_IT_FIFO_LVL_4words) ||                                              ((IT_FIFO_LVL) == UART_IT_FIFO_LVL_8words) ||                                              ((IT_FIFO_LVL) == UART_IT_FIFO_LVL_12words) ||                                              ((IT_FIFO_LVL) == UART_IT_FIFO_LVL_14words))
N
N/** @} */ /* End of group UART_DMA_interrupt_definition */
N
N/** @defgroup UART_DMA_request UART DMA request
N  * @{
N  */
N
N#define UART_DMA_RXE                        ((uint32_t)0x00000001)
N#define UART_DMA_TXE                        ((uint32_t)0x00000002)
N#define UART_DMA_ONERR                      ((uint32_t)0x00000004)
N
N#define IS_UART_DMAREQ(DMAREQ)              (((DMAREQ) == UART_DMA_RXE) || \
N                                             ((DMAREQ) == UART_DMA_TXE) || \
N                                             ((DMAREQ) == UART_DMA_ONERR))
X#define IS_UART_DMAREQ(DMAREQ)              (((DMAREQ) == UART_DMA_RXE) ||                                              ((DMAREQ) == UART_DMA_TXE) ||                                              ((DMAREQ) == UART_DMA_ONERR))
N
N/** @} */ /* End of group UART_DMA_request */
N
N/** @defgroup UART_IrDA_Low_Power UART IrDA Low Power
N  * @{
N  */
N
N#define UART_IrDAMode_LowPower              ((uint32_t)0x00000004)
N#define UART_IrDAMode_Normal                ((uint32_t)0x00000000)
N
N#define IS_UART_IRDA_MODE(MODE)             (((MODE) == UART_IrDAMode_LowPower) || \
N                                             ((MODE) == UART_IrDAMode_Normal))
X#define IS_UART_IRDA_MODE(MODE)             (((MODE) == UART_IrDAMode_LowPower) ||                                              ((MODE) == UART_IrDAMode_Normal))
N
N/** @} */ /* End of group UART_IrDA_Low_Power */
N
N/** @defgroup UART_Flags UART Flags
N  * @{
N  */
N
N#define UART_FLAG_RI                        ((uint32_t)0x00000100)
N#define UART_FLAG_TXFE                      ((uint32_t)0x00000080)
N#define UART_FLAG_RXFF                      ((uint32_t)0x00000040)
N#define UART_FLAG_TXFF                      ((uint32_t)0x00000020)
N#define UART_FLAG_RXFE                      ((uint32_t)0x00000010)
N#define UART_FLAG_BUSY                      ((uint32_t)0x00000008)
N#define UART_FLAG_DCD                       ((uint32_t)0x00000004)
N#define UART_FLAG_DSR                       ((uint32_t)0x00000002)
N#define UART_FLAG_CTS                       ((uint32_t)0x00000001)
N
N#define IS_UART_FLAG(FLAG)                  (((FLAG) == UART_FLAG_RI)   || ((FLAG) == UART_FLAG_TXFE) || \
N                                             ((FLAG) == UART_FLAG_RXFF) || ((FLAG) == UART_FLAG_TXFF) || \
N                                             ((FLAG) == UART_FLAG_RXFE) || ((FLAG) == UART_FLAG_BUSY) || \
N                                             ((FLAG) == UART_FLAG_DCD)  || ((FLAG) == UART_FLAG_DSR)  || \
N                                             ((FLAG) == UART_FLAG_CTS))
X#define IS_UART_FLAG(FLAG)                  (((FLAG) == UART_FLAG_RI)   || ((FLAG) == UART_FLAG_TXFE) ||                                              ((FLAG) == UART_FLAG_RXFF) || ((FLAG) == UART_FLAG_TXFF) ||                                              ((FLAG) == UART_FLAG_RXFE) || ((FLAG) == UART_FLAG_BUSY) ||                                              ((FLAG) == UART_FLAG_DCD)  || ((FLAG) == UART_FLAG_DSR)  ||                                              ((FLAG) == UART_FLAG_CTS))
N
N#define IS_UART_BAUDRATE(BAUDRATE) (((BAUDRATE) > 0) && ((BAUDRATE) <= 921600))
N
N/** @} */ /* End of group UART_Flags */
N
N/** @defgroup UART_Data_Status UART Data Status
N  * @{
N  */
N
N#define UART_Data_OE                        0x0B
N#define UART_Data_BE                        0x0A
N#define UART_Data_PE                        0x09
N#define UART_Data_FE                        0x08
N
N#define UART_Data_OE_Msk                    ((uint32_t)(1 << UART_Data_OE))
N#define UART_Data_BE_Msk                    ((uint32_t)(1 << UART_Data_BE))
N#define UART_Data_PE_Msk                    ((uint32_t)(1 << UART_Data_FE))
N#define UART_Data_FE_Msk                    ((uint32_t)(1 << UART_Data_PE))
N
N#define UART_Data(DATA)                     ((uint8_t)(DATA))
N#define UART_Flags(DATA)                    ((uint8_t)((DATA) >> 8))
N#define UART_CheckDataStatus(DATA, BIT)     ((((uint32_t)(DATA)) << (31 - (BIT))) >> 31)
N
N#define IS_UART_DATA(DATA)                  ((DATA) <= 0xFF)
N
N/** @} */ /* End of group UART_Data_Status */
N
N/** @defgroup UART_Clock_BRG UART Clock BRG
N  * @{
N  */
N
N#define UART_HCLKdiv1                       ((uint32_t)0x00000000)
N#define UART_HCLKdiv2                       ((uint32_t)0x00000001)
N#define UART_HCLKdiv4                       ((uint32_t)0x00000002)
N#define UART_HCLKdiv8                       ((uint32_t)0x00000003)
N#define UART_HCLKdiv16                      ((uint32_t)0x00000004)
N#define UART_HCLKdiv32                      ((uint32_t)0x00000005)
N#define UART_HCLKdiv64                      ((uint32_t)0x00000006)
N#define UART_HCLKdiv128                     ((uint32_t)0x00000007)
N
N#define IS_UART_CLOCK_BRG(BRG)              (((BRG) >= 0) && ((BRG) <= 7))
N
N/** @} */ /* End of group UART_Clock_BRG */
N
N/** @} */ /* End of group UART_Exported_Constants */
N
N/** @defgroup UART_Exported_Macros UART Exported Macros
N  * @{
N  */
N
N/** @} */ /* End of group UART_Exported_Macros */
N
N/** @defgroup UART_Exported_Functions UART Exported Functions
N  * @{
N  */
N
Nvoid UART_DeInit(MDR_UART_TypeDef* UARTx);
NBaudRateStatus UART_Init(MDR_UART_TypeDef* UARTx, UART_InitTypeDef* UART_InitStruct);
Nvoid UART_StructInit(UART_InitTypeDef* UART_InitStruct);
N
Nvoid UART_Cmd(MDR_UART_TypeDef* UARTx, FunctionalState NewState);
N
Nvoid UART_ITConfig(MDR_UART_TypeDef* UARTx, uint32_t UART_IT, FunctionalState NewState);
NITStatus UART_GetITStatus(MDR_UART_TypeDef* UARTx, uint32_t UART_IT);
NITStatus UART_GetITStatusMasked(MDR_UART_TypeDef* UARTx, uint32_t UART_IT);
Nvoid UART_ClearITPendingBit(MDR_UART_TypeDef* UARTx, uint32_t UART_IT);
N
Nvoid UART_DMAConfig(MDR_UART_TypeDef* UARTx, uint32_t UART_IT_RB_LVL, uint32_t UART_IT_TB_LVL);
Nvoid UART_DMACmd(MDR_UART_TypeDef* UARTx, uint32_t UART_DMAReq, FunctionalState NewState);
N
Nvoid UART_SendData(MDR_UART_TypeDef* UARTx, uint16_t Data);
Nuint16_t UART_ReceiveData(MDR_UART_TypeDef* UARTx);
Nvoid UART_BreakLine(MDR_UART_TypeDef* UARTx, FunctionalState NewState);
N
Nvoid UART_IrDAConfig(MDR_UART_TypeDef* UARTx, uint32_t UART_IrDAMode);
Nvoid UART_IrDACmd(MDR_UART_TypeDef* UARTx, FunctionalState NewState);
N
NFlagStatus UART_GetFlagStatus(MDR_UART_TypeDef* UARTx, uint32_t UART_FLAG);
Nvoid UART_BRGInit(MDR_UART_TypeDef* UARTx, uint32_t UART_BRG);
N
N/** @} */ /* End of group UART_Exported_Functions */
N
N/** @} */ /* End of group UART */
N
N/** @} */ /* End of group MDR32F9Qx_StdPeriph_Driver */
N
N#ifdef __cplusplus
S} // extern "C" block end
N#endif
N
N#endif /* __MDR32F9Qx_UART_H */
N
N/*
N*
N* END OF FILE MDR32F9Qx_uart.h */
L 17 "common.h" 2
N/* Подключение функций управления АЦП */
N#include <MDR32F9Qx_adc.h>
N/* Подключение функций управления таймерами */
N#include <MDR32F9Qx_timer.h>
L 1 "C:\Keil_v5\ARM\PACK\Keil\MDR1986BExx\1.5.3\Libraries\MDR32F9Qx_StdPeriph_Driver\inc\MDR32F9Qx_timer.h" 1
N/**
N  * FILE MDR32F9Qx_timer.h
N  */
N
N/* Define to prevent recursive inclusion -------------------------------------*/
N#ifndef __MDR32F9QX_TIMER_H
N#define __MDR32F9QX_TIMER_H
N
N#ifdef __cplusplus
Sextern "C" {
N#endif
N
N/* Includes ------------------------------------------------------------------*/
N#include "MDR32F9Qx_config.h"
N#include "MDR32F9Qx_lib.h"
N
N/** @addtogroup __MDR32F9Qx_StdPeriph_Driver MDR32F9Qx Standard Peripherial Driver
N  * @{
N  */
N
N/** @addtogroup TIMER
N  * @{
N  */
N
N/** @defgroup TIMER_Exported_Types TIMER Exported Types
N  * @{
N  */
N
N/**
N  * @brief  TIMER Counter Init structure definition
N  */
N
Ntypedef struct {
N
N#if defined(USE_MDR1986VE9x) || defined (USE_MDR1901VC1T) /* For Cortex M3 */
X#if 1L || 0L  
N	uint16_t TIMER_IniCounter; 		 /*!< Specifies the initial counter value.
N	 	 	 	 	 	 	 	     	  This parameter can be a number between 0x0000 and 0xFFFF. */
N#elif ((defined (USE_MDR1986VE3)) || (defined (USE_MDR1986VE1T)))
S	uint32_t TIMER_IniCounter;		/*!< Specifies the initial counter value.
S									 	 This parameter can be a number between 0x0000 and 0xFFFFFFFF. */
N#endif // #elif ((defined (USE_MDR1986VE3)) || (defined (USE_MDR1986VE1T)))
N
N	uint16_t TIMER_Prescaler; 		 /*!< Specifies the prescaler value used to divide the TIMER clock.
N	 	 	 	 	 	 	 	   	 	  This parameter can be a number between 0x0000 and 0xFFFF.
N	 	 	 	 	 	 	 	   	 	  CLK = TIMER_CLK/(TIMER_Prescaler + 1) */
N
N#if defined(USE_MDR1986VE9x) || defined (USE_MDR1901VC1T) /* For Cortex M3 */
X#if 1L || 0L  
N	uint16_t TIMER_Period; 			 /*!< Specifies the period value to be loaded into the
N	 	 	 	 	 	 	 	 	 	  Auto-Reload Register (ARR) at the next update event.
N	 	 	 	 	 	 	 	 	 	  This parameter must be a number between 0x0000 and 0xFFFF.  */
N#elif ((defined (USE_MDR1986VE3)) || (defined (USE_MDR1986VE1T))) /* For Cortex M1 */
S	uint32_t TIMER_Period;			/*!< Specifies the period value to be loaded into the
S										 Auto-Reload Register (ARR) at the next update event.
S										 This parameter must be a number between 0x0000 and 0xFFFFFFFF.  */
N#endif // #elif ((defined (USE_MDR1986VE3)) || (defined (USE_MDR1986VE1T))) /* For Cortex M1 */
N
N	uint16_t TIMER_CounterMode;		 /*!< Specifies the counter mode.
N	 	 	 	 	 	 	 	 	 	  This parameter can be a value of @ref TIMER_Counter_Mode */
N
N	uint16_t TIMER_CounterDirection; /*!< Specifies the counter direction.
N	 	 	 	 	 	 	 	 	 	  This parameter can be a value of @ref TIMER_Counter_Direction */
N
N	uint16_t TIMER_EventSource; 	/*!< Specifies the Counter Event source.
N	 	 	 	 	 	 	 	 	 	 This parameter can be a value of @ref TIMER_Event_Source */
N
N	uint16_t TIMER_FilterSampling;  /*!< Specifies the filter sampling clock (FDTS).
N	 	 	 	 	 	 	 	 	 	 This parameter can be a value of @ref TIMER_Filter_Sampling */
N
N	uint16_t TIMER_ARR_UpdateMode; 	/*!< Specifies the Auto-Reload Register (ARR) updating mode.
N	 	 	 	 	 	 	 	 	 	 This parameter can be a value of @ref TIMER_ARR_Update_Mode */
N
N	uint16_t TIMER_ETR_FilterConf; 	/*!< Specifies the ETR Filter configuration.
N	 	 	 	 	 	 	 	 	 	 This parameter can be a value of @ref TIMER_FilterConfiguration */
N
N	uint16_t TIMER_ETR_Prescaler; 	/*!< Specifies the ETR Prescaler configuration.
N	 	 	 	 	 	 	 	 	 	 This parameter can be a value of @ref TIMER_ETR_Prescaler */
N
N	uint16_t TIMER_ETR_Polarity; 	/*!< Specifies the ETR Polarity configuration.
N	 	 	 	 	 	 	 	 	 	 This parameter can be a value of @ref TIMER_ETR_Polarity */
N
N	uint16_t TIMER_BRK_Polarity; 	/*!< Specifies the BRK Polarity configuration.
N	 	 	 	 	 	 	 	 	 	 This parameter can be a value of @ref TIMER_BRK_Polarity */
N} TIMER_CntInitTypeDef;
N
N/**
N  * @brief  TIMER Channel Init structure definition
N  */
N
Ntypedef struct
N{
N  uint16_t TIMER_CH_Number;             /*!< Specifies the TIMER Channel number to be configured.
N                                             This parameter can be a value of @ref TIMER_CH_Number */
N
N  uint16_t TIMER_CH_Mode;               /*!< Specifies the TIMER Channel mode.
N                                             This parameter can be a value of @ref TIMER_CH_Mode */
N
N  uint16_t TIMER_CH_ETR_Ena;            /*!< Enables or disables ETR.
N                                             This parameter can be a value of FunctionalState */
N
N  uint16_t TIMER_CH_ETR_Reset;          /*!< Enables or disables ETR Reset.
N                                             This parameter can be a value of @ref TIMER_CH_ETR_Reset */
N
N  uint16_t TIMER_CH_BRK_Reset;          /*!< Enables or disables BRK Reset.
N                                             This parameter can be a value of @ref TIMER_CH_BRK_Reset */
N
N  uint16_t TIMER_CH_REF_Format;         /*!< Specifies the REF signal format.
N                                             This parameter can be a value of @ref TIMER_CH_REF_Format */
N
N  uint16_t TIMER_CH_Prescaler;          /*!< Specifies the TIMER Channel Prescaler configuration.
N                                             This parameter can be a value of @ref TIMER_CH_Prescaler */
N
N  uint16_t TIMER_CH_EventSource;        /*!< Specifies the Channel Event source.
N                                             This parameter can be a value of @ref TIMER_CH_EventSource */
N
N  uint16_t TIMER_CH_FilterConf;         /*!< Specifies the TIMER Channel Filter configuration.
N                                             This parameter can be a value of @ref TIMER_FilterConfiguration */
N
N  uint16_t TIMER_CH_CCR_UpdateMode;     /*!< Specifies the TIMER CCR, CCR1 update mode.
N                                             This parameter can be a value of @ref TIMER_CH_CCR_Update_Mode */
N
N  uint16_t TIMER_CH_CCR1_Ena;           /*!< Enables or disables the CCR1 register.
N                                             This parameter can be a value of FunctionalState */
N
N  uint16_t TIMER_CH_CCR1_EventSource;   /*!< Specifies the Channel CCR1 Event source.
N                                             This parameter can be a value of @ref TIMER_CH_CCR1_EventSource */
N}TIMER_ChnInitTypeDef;
N
N/**
N  * @brief  TIMER Channel Output Init structure definition
N  */
N
Ntypedef struct
N{
N  uint16_t TIMER_CH_Number;             /*!< Specifies the TIMER Channel number to be configured.
N                                             This parameter can be a value of @ref TIMER_CH_Number */
N
N  uint16_t TIMER_CH_DirOut_Polarity;    /*!< Specifies the TIMER CHx output polarity.
N                                             This parameter can be a value of @ref TIMER_CH_OUT_Polarity */
N
N  uint16_t TIMER_CH_DirOut_Source;      /*!< Specifies the TIMER CHx output source.
N                                             This parameter can be a value of @ref TIMER_CH_OUT_Source */
N
N  uint16_t TIMER_CH_DirOut_Mode;        /*!< Specifies the TIMER CHx output enable source.
N                                             This parameter can be a value of @ref TIMER_CH_OUT_Mode */
N
N  uint16_t TIMER_CH_NegOut_Polarity;    /*!< Enables or disables the TIMER CHxN output inversion.
N                                             This parameter can be a value of @ref TIMER_CH_OUT_Polarity */
N
N  uint16_t TIMER_CH_NegOut_Source;      /*!< Specifies the TIMER CHxN output source.
N                                             This parameter can be a value of @ref TIMER_CH_OUT_Source */
N
N  uint16_t TIMER_CH_NegOut_Mode;        /*!< Specifies the TIMER CHxN output enable source.
N                                             This parameter can be a value of @ref TIMER_CH_OUT_Mode */
N
N  uint16_t TIMER_CH_DTG_MainPrescaler;  /*!< Specifies the main prescaler of TIMER DTG.
N                                             This parameter can be a number between 0x0000 and 0x00FF.
N                                             Delay DTGdel = TIMER_CH_DTG_MainPrescaler*(TIMER_CH_DTG_AuxPrescaler + 1) clocks. */
N
N  uint16_t TIMER_CH_DTG_AuxPrescaler;   /*!< Specifies the auxiliary prescaler of TIMER DTG.
N                                             This parameter can be a number between 0x0000 and 0x000F.
N                                             Delay DTGdel = TIMER_CH_DTG_MainPrescaler*(TIMER_CH_DTG_AuxPrescaler + 1) clocks. */
N
N  uint16_t TIMER_CH_DTG_ClockSource;    /*!< Specifies the TIMER DTG clock source.
N                                             This parameter can be a value of @ref TIMER_CH_DTG_Clock_Source */
N}TIMER_ChnOutInitTypeDef;
N
N/** @} */ /* End of group TIMER_Exported_Types */
N
N/** @defgroup TIMER_Exported_Constants TIMER Exported Constants
N  * @{
N  */
N
N#if ((defined (USE_MDR1986VE9x)) || (defined (USE_MDR1901VC1T)))
X#if ((1L) || (0L))
N
N#define IS_TIMER_ALL_PERIPH(PERIPH) (((PERIPH) == MDR_TIMER1) || \
N                                     ((PERIPH) == MDR_TIMER2) || \
N                                     ((PERIPH) == MDR_TIMER3))
X#define IS_TIMER_ALL_PERIPH(PERIPH) (((PERIPH) == MDR_TIMER1) ||                                      ((PERIPH) == MDR_TIMER2) ||                                      ((PERIPH) == MDR_TIMER3))
N#elif ((defined (USE_MDR1986VE3)) || (defined (USE_MDR1986VE1T)))
S#define IS_TIMER_ALL_PERIPH(PERIPH) (((PERIPH) == MDR_TIMER1) || \
S                                     ((PERIPH) == MDR_TIMER2) || \
S                                     ((PERIPH) == MDR_TIMER3) || \
S                                     ((PERIPH) == MDR_TIMER4))
X#define IS_TIMER_ALL_PERIPH(PERIPH) (((PERIPH) == MDR_TIMER1) ||                                      ((PERIPH) == MDR_TIMER2) ||                                      ((PERIPH) == MDR_TIMER3) ||                                      ((PERIPH) == MDR_TIMER4))
N#endif
N
N/** @defgroup TIMER_Counter_Mode TIMER Counter Mode
N  * @{
N  */
N
N#define TIMER_CntMode_ClkFixedDir             (((uint32_t)0x0) << TIMER_CNTRL_CNT_MODE_Pos) /*!< The Timer clock changes the TIMERx_CNT value. The count direction is not changed. */
N#define TIMER_CntMode_ClkChangeDir            (((uint32_t)0x1) << TIMER_CNTRL_CNT_MODE_Pos) /*!< The Timer clock changes the TIMERx_CNT value. The count direction changes. */
N#define TIMER_CntMode_EvtFixedDir             (((uint32_t)0x2) << TIMER_CNTRL_CNT_MODE_Pos) /*!< The event changes the TIMERx_CNT value. The count direction is not changed. */
N#define TIMER_CntMode_EvtChangeDir            (((uint32_t)0x3) << TIMER_CNTRL_CNT_MODE_Pos) /*!< The event changes the TIMERx_CNT value. The count direction changes. */
N
N#define IS_TIMER_COUNTER_MODE(MODE) (((MODE) == TIMER_CntMode_ClkFixedDir ) || \
N                                     ((MODE) == TIMER_CntMode_ClkChangeDir) || \
N                                     ((MODE) == TIMER_CntMode_EvtFixedDir ) || \
N                                     ((MODE) == TIMER_CntMode_EvtChangeDir))
X#define IS_TIMER_COUNTER_MODE(MODE) (((MODE) == TIMER_CntMode_ClkFixedDir ) ||                                      ((MODE) == TIMER_CntMode_ClkChangeDir) ||                                      ((MODE) == TIMER_CntMode_EvtFixedDir ) ||                                      ((MODE) == TIMER_CntMode_EvtChangeDir))
N
N/** @} */ /* End of group TIMER_Counter_Mode */
N
N/** @defgroup TIMER_Counter_Direction TIMER Counter Direction
N  * @{
N  */
N
N#define TIMER_CntDir_Up                       (((uint32_t)0x0) << TIMER_CNTRL_DIR_Pos)  /*!< Increments the Timer TIMERx_CNT counter value. */
N#define TIMER_CntDir_Dn                       (((uint32_t)0x1) << TIMER_CNTRL_DIR_Pos)  /*!< Decrements the Timer TIMERx_CNT counter value. */
N
N#define IS_TIMER_COUNTER_DIR(DIR) (((DIR) == TIMER_CntDir_Up) || \
N                                   ((DIR) == TIMER_CntDir_Dn))
X#define IS_TIMER_COUNTER_DIR(DIR) (((DIR) == TIMER_CntDir_Up) ||                                    ((DIR) == TIMER_CntDir_Dn))
N
N/** @} */ /* End of group TIMER_Counter_Direction */
N
N/** @defgroup TIMER_Event_Source TIMER Event Source
N  * @{
N  */
N
N#define TIMER_EvSrc_None                      (((uint32_t)0x0) << TIMER_CNTRL_EVENT_SEL_Pos)  /*!< No events. */
N#define TIMER_EvSrc_TM1                       (((uint32_t)0x1) << TIMER_CNTRL_EVENT_SEL_Pos)  /*!< Selects TIMER1 (CNT == ARR) event. */
N#define TIMER_EvSrc_TM2                       (((uint32_t)0x2) << TIMER_CNTRL_EVENT_SEL_Pos)  /*!< Selects TIMER2 (CNT == ARR) event. */
N#define TIMER_EvSrc_TM3                       (((uint32_t)0x3) << TIMER_CNTRL_EVENT_SEL_Pos)  /*!< Selects TIMER3 (CNT == ARR) event. */
N#define TIMER_EvSrc_CH1                       (((uint32_t)0x4) << TIMER_CNTRL_EVENT_SEL_Pos)  /*!< Selects Channel 1 event. */
N#define TIMER_EvSrc_CH2                       (((uint32_t)0x5) << TIMER_CNTRL_EVENT_SEL_Pos)  /*!< Selects Channel 2 event. */
N#define TIMER_EvSrc_CH3                       (((uint32_t)0x6) << TIMER_CNTRL_EVENT_SEL_Pos)  /*!< Selects Channel 3 event. */
N#define TIMER_EvSrc_CH4                       (((uint32_t)0x7) << TIMER_CNTRL_EVENT_SEL_Pos)  /*!< Selects Channel 4 event. */
N#define TIMER_EvSrc_ETR                       (((uint32_t)0x8) << TIMER_CNTRL_EVENT_SEL_Pos)  /*!< Selects ETR event. */
N
N#define IS_TIMER_EVENT_SOURCE(SOURCE) (((SOURCE) == TIMER_EvSrc_None) || \
N                                       ((SOURCE) == TIMER_EvSrc_TM1 ) || \
N                                       ((SOURCE) == TIMER_EvSrc_TM2 ) || \
N                                       ((SOURCE) == TIMER_EvSrc_TM3 ) || \
N                                       ((SOURCE) == TIMER_EvSrc_CH1 ) || \
N                                       ((SOURCE) == TIMER_EvSrc_CH2 ) || \
N                                       ((SOURCE) == TIMER_EvSrc_CH3 ) || \
N                                       ((SOURCE) == TIMER_EvSrc_CH4 ) || \
N                                       ((SOURCE) == TIMER_EvSrc_ETR ))
X#define IS_TIMER_EVENT_SOURCE(SOURCE) (((SOURCE) == TIMER_EvSrc_None) ||                                        ((SOURCE) == TIMER_EvSrc_TM1 ) ||                                        ((SOURCE) == TIMER_EvSrc_TM2 ) ||                                        ((SOURCE) == TIMER_EvSrc_TM3 ) ||                                        ((SOURCE) == TIMER_EvSrc_CH1 ) ||                                        ((SOURCE) == TIMER_EvSrc_CH2 ) ||                                        ((SOURCE) == TIMER_EvSrc_CH3 ) ||                                        ((SOURCE) == TIMER_EvSrc_CH4 ) ||                                        ((SOURCE) == TIMER_EvSrc_ETR ))
N
N/** @} */ /* End of group TIMER_Event_Source */
N
N/** @defgroup TIMER_Filter_Sampling TIMER Filter Sampling Clock
N  * @{
N  */
N
N#define TIMER_FDTS_TIMER_CLK_div_1              (((uint32_t)0x0) << TIMER_CNTRL_FDTS_Pos) /*!< The FDTS clock occures each TIMER_CLK clock. */
N#define TIMER_FDTS_TIMER_CLK_div_2              (((uint32_t)0x1) << TIMER_CNTRL_FDTS_Pos) /*!< The FDTS clock occures each 2-nd TIMER_CLK clock. */
N#define TIMER_FDTS_TIMER_CLK_div_3              (((uint32_t)0x2) << TIMER_CNTRL_FDTS_Pos) /*!< The FDTS clock occures each 3-rd TIMER_CLK clock. */
N#define TIMER_FDTS_TIMER_CLK_div_4              (((uint32_t)0x3) << TIMER_CNTRL_FDTS_Pos) /*!< The FDTS clock occures each 4-th TIMER_CLK clock. */
N
N#define IS_TIMER_FILTER_SAMPLING(CONFIG) (((CONFIG) == TIMER_FDTS_TIMER_CLK_div_1) || \
N                                          ((CONFIG) == TIMER_FDTS_TIMER_CLK_div_2) || \
N                                          ((CONFIG) == TIMER_FDTS_TIMER_CLK_div_3) || \
N                                          ((CONFIG) == TIMER_FDTS_TIMER_CLK_div_4))
X#define IS_TIMER_FILTER_SAMPLING(CONFIG) (((CONFIG) == TIMER_FDTS_TIMER_CLK_div_1) ||                                           ((CONFIG) == TIMER_FDTS_TIMER_CLK_div_2) ||                                           ((CONFIG) == TIMER_FDTS_TIMER_CLK_div_3) ||                                           ((CONFIG) == TIMER_FDTS_TIMER_CLK_div_4))
N
N/** @} */ /* End of group TIMER_Filter_Sampling */
N
N/** @defgroup TIMER_ARR_Update_Mode TIMER ARR Update Mode
N  * @{
N  */
N
N#define TIMER_ARR_Update_Immediately          (((uint32_t)0x0) << TIMER_CNTRL_ARRB_EN_Pos)  /*!< The ARR register is updated immediately. */
N#define TIMER_ARR_Update_On_CNT_Overflow      (((uint32_t)0x1) << TIMER_CNTRL_ARRB_EN_Pos)  /*!< The ARR register is updated at CNT count end. */
N
N#define IS_TIMER_ARR_UPDATE_MODE(MODE) (((MODE) == TIMER_ARR_Update_Immediately    ) || \
N                                        ((MODE) == TIMER_ARR_Update_On_CNT_Overflow))
X#define IS_TIMER_ARR_UPDATE_MODE(MODE) (((MODE) == TIMER_ARR_Update_Immediately    ) ||                                         ((MODE) == TIMER_ARR_Update_On_CNT_Overflow))
N
N/** @} */ /* End of group TIMER_ARR_UpdateMode */
N
N/** @defgroup TIMER_FilterConfiguration TIMER Filter configuration
N  * @{
N  */
N
N#define TIMER_Filter_1FF_at_TIMER_CLK         ((uint32_t)0x0)  /*!< Signal is latched by 1 trigger  at TIMER_CLK clock frequency. */
N#define TIMER_Filter_2FF_at_TIMER_CLK         ((uint32_t)0x1)  /*!< Signal is latched by 2 triggers at TIMER_CLK clock frequency. */
N#define TIMER_Filter_4FF_at_TIMER_CLK         ((uint32_t)0x2)  /*!< Signal is latched by 4 triggers at TIMER_CLK clock frequency. */
N#define TIMER_Filter_8FF_at_TIMER_CLK         ((uint32_t)0x3)  /*!< Signal is latched by 8 triggers at TIMER_CLK clock frequency. */
N#define TIMER_Filter_6FF_at_FTDS_div_2        ((uint32_t)0x4)  /*!< Signal is latched by 6 triggers at FDTS/2  clock frequency. */
N#define TIMER_Filter_8FF_at_FTDS_div_2        ((uint32_t)0x5)  /*!< Signal is latched by 8 triggers at FDTS/2  clock frequency. */
N#define TIMER_Filter_6FF_at_FTDS_div_4        ((uint32_t)0x6)  /*!< Signal is latched by 6 triggers at FDTS/4  clock frequency. */
N#define TIMER_Filter_8FF_at_FTDS_div_4        ((uint32_t)0x7)  /*!< Signal is latched by 8 triggers at FDTS/4  clock frequency. */
N#define TIMER_Filter_6FF_at_FTDS_div_8        ((uint32_t)0x8)  /*!< Signal is latched by 6 triggers at FDTS/8  clock frequency. */
N#define TIMER_Filter_8FF_at_FTDS_div_8        ((uint32_t)0x9)  /*!< Signal is latched by 8 triggers at FDTS/8  clock frequency. */
N#define TIMER_Filter_5FF_at_FTDS_div_16       ((uint32_t)0xA)  /*!< Signal is latched by 5 triggers at FDTS/16 clock frequency. */
N#define TIMER_Filter_6FF_at_FTDS_div_16       ((uint32_t)0xB)  /*!< Signal is latched by 6 triggers at FDTS/16 clock frequency. */
N#define TIMER_Filter_8FF_at_FTDS_div_16       ((uint32_t)0xC)  /*!< Signal is latched by 8 triggers at FDTS/16 clock frequency. */
N#define TIMER_Filter_5FF_at_FTDS_div_32       ((uint32_t)0xD)  /*!< Signal is latched by 5 triggers at FDTS/32 clock frequency. */
N#define TIMER_Filter_6FF_at_FTDS_div_32       ((uint32_t)0xE)  /*!< Signal is latched by 6 triggers at FDTS/32 clock frequency. */
N#define TIMER_Filter_8FF_at_FTDS_div_32       ((uint32_t)0xF)  /*!< Signal is latched by 8 triggers at FDTS/32 clock frequency. */
N
N#define IS_TIMER_FILTER_CONF(CONF) (((CONF) == TIMER_Filter_1FF_at_TIMER_CLK  ) || \
N                                    ((CONF) == TIMER_Filter_2FF_at_TIMER_CLK  ) || \
N                                    ((CONF) == TIMER_Filter_4FF_at_TIMER_CLK  ) || \
N                                    ((CONF) == TIMER_Filter_8FF_at_TIMER_CLK  ) || \
N                                    ((CONF) == TIMER_Filter_6FF_at_FTDS_div_2 ) || \
N                                    ((CONF) == TIMER_Filter_8FF_at_FTDS_div_2 ) || \
N                                    ((CONF) == TIMER_Filter_6FF_at_FTDS_div_4 ) || \
N                                    ((CONF) == TIMER_Filter_8FF_at_FTDS_div_4 ) || \
N                                    ((CONF) == TIMER_Filter_6FF_at_FTDS_div_8 ) || \
N                                    ((CONF) == TIMER_Filter_8FF_at_FTDS_div_8 ) || \
N                                    ((CONF) == TIMER_Filter_5FF_at_FTDS_div_16) || \
N                                    ((CONF) == TIMER_Filter_6FF_at_FTDS_div_16) || \
N                                    ((CONF) == TIMER_Filter_8FF_at_FTDS_div_16) || \
N                                    ((CONF) == TIMER_Filter_5FF_at_FTDS_div_32) || \
N                                    ((CONF) == TIMER_Filter_6FF_at_FTDS_div_32) || \
N                                    ((CONF) == TIMER_Filter_8FF_at_FTDS_div_32))
X#define IS_TIMER_FILTER_CONF(CONF) (((CONF) == TIMER_Filter_1FF_at_TIMER_CLK  ) ||                                     ((CONF) == TIMER_Filter_2FF_at_TIMER_CLK  ) ||                                     ((CONF) == TIMER_Filter_4FF_at_TIMER_CLK  ) ||                                     ((CONF) == TIMER_Filter_8FF_at_TIMER_CLK  ) ||                                     ((CONF) == TIMER_Filter_6FF_at_FTDS_div_2 ) ||                                     ((CONF) == TIMER_Filter_8FF_at_FTDS_div_2 ) ||                                     ((CONF) == TIMER_Filter_6FF_at_FTDS_div_4 ) ||                                     ((CONF) == TIMER_Filter_8FF_at_FTDS_div_4 ) ||                                     ((CONF) == TIMER_Filter_6FF_at_FTDS_div_8 ) ||                                     ((CONF) == TIMER_Filter_8FF_at_FTDS_div_8 ) ||                                     ((CONF) == TIMER_Filter_5FF_at_FTDS_div_16) ||                                     ((CONF) == TIMER_Filter_6FF_at_FTDS_div_16) ||                                     ((CONF) == TIMER_Filter_8FF_at_FTDS_div_16) ||                                     ((CONF) == TIMER_Filter_5FF_at_FTDS_div_32) ||                                     ((CONF) == TIMER_Filter_6FF_at_FTDS_div_32) ||                                     ((CONF) == TIMER_Filter_8FF_at_FTDS_div_32))
N
N/** @} */ /* End of group TIMER_FilterConfiguration */
N
N/** @defgroup TIMER_ETR_Prescaler TIMER ETR Prescaler
N  * @{
N  */
N
N#define TIMER_ETR_Prescaler_None              (((uint32_t)0x0) << TIMER_BRKETR_CNTRL_ETR_PSC_Pos)  /*!< No division of input frequency. */
N#define TIMER_ETR_Prescaler_div_2             (((uint32_t)0x1) << TIMER_BRKETR_CNTRL_ETR_PSC_Pos)  /*!< Selects input frequency divider by 2. */
N#define TIMER_ETR_Prescaler_div_4             (((uint32_t)0x2) << TIMER_BRKETR_CNTRL_ETR_PSC_Pos)  /*!< Selects input frequency divider by 4. */
N#define TIMER_ETR_Prescaler_div_8             (((uint32_t)0x3) << TIMER_BRKETR_CNTRL_ETR_PSC_Pos)  /*!< Selects input frequency divider by 8. */
N
N#define IS_TIMER_ETR_PRESCALER(VALUE) (((VALUE) == TIMER_ETR_Prescaler_None ) || \
N                                       ((VALUE) == TIMER_ETR_Prescaler_div_2) || \
N                                       ((VALUE) == TIMER_ETR_Prescaler_div_4) || \
N                                       ((VALUE) == TIMER_ETR_Prescaler_div_8))
X#define IS_TIMER_ETR_PRESCALER(VALUE) (((VALUE) == TIMER_ETR_Prescaler_None ) ||                                        ((VALUE) == TIMER_ETR_Prescaler_div_2) ||                                        ((VALUE) == TIMER_ETR_Prescaler_div_4) ||                                        ((VALUE) == TIMER_ETR_Prescaler_div_8))
N
N/** @} */ /* End of group TIMER_ETR_Prescaler */
N
N/** @defgroup TIMER_ETR_Polarity TIMER ETR Polarity
N  * @{
N  */
N
N#define TIMER_ETRPolarity_NonInverted         (((uint32_t)0x0) << TIMER_BRKETR_CNTRL_ETR_INV_Pos)  /*!< No inversion of the ETR input. */
N#define TIMER_ETRPolarity_Inverted            (((uint32_t)0x1) << TIMER_BRKETR_CNTRL_ETR_INV_Pos)  /*!< The ETR input is inverted. */
N
N#define IS_TIMER_ETR_POLARITY(STATE) (((STATE) == TIMER_ETRPolarity_NonInverted) || \
N                                      ((STATE) == TIMER_ETRPolarity_Inverted   ))
X#define IS_TIMER_ETR_POLARITY(STATE) (((STATE) == TIMER_ETRPolarity_NonInverted) ||                                       ((STATE) == TIMER_ETRPolarity_Inverted   ))
N
N/** @} */ /* End of group TIMER_ETR_Polarity */
N
N/** @defgroup TIMER_BRK_Polarity TIMER BRK Polarity
N  * @{
N  */
N
N#define TIMER_BRKPolarity_NonInverted         (((uint32_t)0x0) << TIMER_BRKETR_CNTRL_BRK_INV_Pos)  /*!< No inversion of the BRK input. */
N#define TIMER_BRKPolarity_Inverted            (((uint32_t)0x1) << TIMER_BRKETR_CNTRL_BRK_INV_Pos)  /*!< The BRK input is inverted. */
N
N#define IS_TIMER_BRK_POLARITY(STATE) (((STATE) == TIMER_BRKPolarity_NonInverted) || \
N                                      ((STATE) == TIMER_BRKPolarity_Inverted   ))
X#define IS_TIMER_BRK_POLARITY(STATE) (((STATE) == TIMER_BRKPolarity_NonInverted) ||                                       ((STATE) == TIMER_BRKPolarity_Inverted   ))
N
N/** @} */ /* End of group TIMER_BRK_Polarity */
N
N/** @defgroup TIMER_CH_Number TIMER Channel Number
N  * @{
N  */
N
N#define TIMER_CHANNEL1                        ((uint32_t)0x0)  /*!< Specifies the TIMER channel 1. */
N#define TIMER_CHANNEL2                        ((uint32_t)0x1)  /*!< Specifies the TIMER channel 2. */
N#define TIMER_CHANNEL3                        ((uint32_t)0x2)  /*!< Specifies the TIMER channel 3. */
N#define TIMER_CHANNEL4                        ((uint32_t)0x3)  /*!< Specifies the TIMER channel 4. */
N
N#define IS_TIMER_CHANNEL_NUMBER(NUMBER) (((NUMBER) == TIMER_CHANNEL1) || \
N                                         ((NUMBER) == TIMER_CHANNEL2) || \
N                                         ((NUMBER) == TIMER_CHANNEL3) || \
N                                         ((NUMBER) == TIMER_CHANNEL4))
X#define IS_TIMER_CHANNEL_NUMBER(NUMBER) (((NUMBER) == TIMER_CHANNEL1) ||                                          ((NUMBER) == TIMER_CHANNEL2) ||                                          ((NUMBER) == TIMER_CHANNEL3) ||                                          ((NUMBER) == TIMER_CHANNEL4))
N
N/** @} */ /* End of group TIMER_CH_Number */
N
N/** @defgroup TIMER_CH_ETR_Reset TIMER Channel ETR Reset configuration
N  * @{
N  */
N
N#define TIMER_CH_ETR_RESET_Disable            (((uint32_t)0x0) << TIMER_CH_CNTRL_ETREN_Pos)   /*!< Disables ETR Reset. */
N#define TIMER_CH_ETR_RESET_Enable             (((uint32_t)0x1) << TIMER_CH_CNTRL_ETREN_Pos)   /*!< Enables ETR Reset. */
N
N#define IS_TIMER_CHANNEL_ETR_RESET_CONFIG(CONFIG) (((CONFIG) == TIMER_CH_ETR_RESET_Disable) || \
N                                                   ((CONFIG) == TIMER_CH_ETR_RESET_Enable ))
X#define IS_TIMER_CHANNEL_ETR_RESET_CONFIG(CONFIG) (((CONFIG) == TIMER_CH_ETR_RESET_Disable) ||                                                    ((CONFIG) == TIMER_CH_ETR_RESET_Enable ))
N
N/** @} */ /* End of group TIMER_CH_ETR_Reset */
N
N/** @defgroup TIMER_CH_BRK_Reset TIMER Channel BRK Reset configuration
N  * @{
N  */
N
N#define TIMER_CH_BRK_RESET_Disable            (((uint32_t)0x0) << TIMER_CH_CNTRL_BRKEN_Pos)   /*!< Disables BRK Reset. */
N#define TIMER_CH_BRK_RESET_Enable             (((uint32_t)0x1) << TIMER_CH_CNTRL_BRKEN_Pos)   /*!< Enables BRK Reset. */
N
N#define IS_TIMER_CHANNEL_BRK_RESET_CONFIG(CONFIG) (((CONFIG) == TIMER_CH_BRK_RESET_Disable) || \
N                                                   ((CONFIG) == TIMER_CH_BRK_RESET_Enable ))
X#define IS_TIMER_CHANNEL_BRK_RESET_CONFIG(CONFIG) (((CONFIG) == TIMER_CH_BRK_RESET_Disable) ||                                                    ((CONFIG) == TIMER_CH_BRK_RESET_Enable ))
N
N/** @} */ /* End of group TIMER_CH_BRK_Reset */
N
N/** @defgroup TIMER_CH_Mode TIMER Channel Mode
N  * @{
N  */
N
N#define TIMER_CH_MODE_PWM                     (((uint32_t)0x0) << TIMER_CH_CNTRL_CAP_NPWM_Pos)  /*!< Specifies the PWM channel mode. */
N#define TIMER_CH_MODE_CAPTURE                 (((uint32_t)0x1) << TIMER_CH_CNTRL_CAP_NPWM_Pos)  /*!< Specifies the Capture channel mode. */
N
N#define IS_TIMER_CHANNEL_MODE(MODE) (((MODE) == TIMER_CH_MODE_PWM    ) || \
N                                     ((MODE) == TIMER_CH_MODE_CAPTURE))
X#define IS_TIMER_CHANNEL_MODE(MODE) (((MODE) == TIMER_CH_MODE_PWM    ) ||                                      ((MODE) == TIMER_CH_MODE_CAPTURE))
N
N/** @} */ /* End of group TIMER_CH_Mode */
N
N/** @defgroup TIMER_CH_REF_Format TIMER Channel REF Format
N  * @{
N  */
N
N#define TIMER_CH_REF_Format0                  (((uint32_t)0x0) << TIMER_CH_CNTRL_OCCM_Pos)  /*!< REF is equal to 0 */
N#define TIMER_CH_REF_Format1                  (((uint32_t)0x1) << TIMER_CH_CNTRL_OCCM_Pos)  /*!< REF is equal to 1 if:
N                                                                                                   (CNT == CCR) or
N                                                                                                   ((CNT == CCR1) and CCR1 enabled),
N                                                                                                 else REF is equal to 0. */
N#define TIMER_CH_REF_Format2                  (((uint32_t)0x2) << TIMER_CH_CNTRL_OCCM_Pos)  /*!< REF is equal to 0 if:
N                                                                                                   (CNT == CCR) or
N                                                                                                   ((CNT == CCR1) and CCR1 enabled),
N                                                                                                 else REF is equal to 1. */
N#define TIMER_CH_REF_Format3                  (((uint32_t)0x3) << TIMER_CH_CNTRL_OCCM_Pos)  /*!< Toggle REF state if:
N                                                                                                   (CNT == CCR) or
N                                                                                                   ((CNT == CCR1) and CCR1 enabled). */
N#define TIMER_CH_REF_Format4                  (((uint32_t)0x4) << TIMER_CH_CNTRL_OCCM_Pos)  /*!< REF is equal to 0. */
N#define TIMER_CH_REF_Format5                  (((uint32_t)0x5) << TIMER_CH_CNTRL_OCCM_Pos)  /*!< REF is equal to 1. */
N#define TIMER_CH_REF_Format6                  (((uint32_t)0x6) << TIMER_CH_CNTRL_OCCM_Pos)  /*!< REF is equal to inverted DIR state if:
N                                                                                                   (CCR1 disabled and (CNT < CCR)) or
N                                                                                                   (CCR1 enabled  and (CCR1 < CNT < CCR)),
N                                                                                                 else REF is equal to DIR state. */
N#define TIMER_CH_REF_Format7                  (((uint32_t)0x7) << TIMER_CH_CNTRL_OCCM_Pos)  /*!< REF is equal to DIR state if:
N                                                                                                   (CCR1 disabled and (CNT < CCR)) or
N                                                                                                   (CCR1 enabled  and (CCR1 < CNT < CCR)),
N                                                                                                 else REF is equal to inverted DIR state. */
N
N#define IS_TIMER_CHANNEL_REF_FORMAT(FORMAT) (((FORMAT) == TIMER_CH_REF_Format0) || \
N                                             ((FORMAT) == TIMER_CH_REF_Format1) || \
N                                             ((FORMAT) == TIMER_CH_REF_Format2) || \
N                                             ((FORMAT) == TIMER_CH_REF_Format3) || \
N                                             ((FORMAT) == TIMER_CH_REF_Format4) || \
N                                             ((FORMAT) == TIMER_CH_REF_Format5) || \
N                                             ((FORMAT) == TIMER_CH_REF_Format6) || \
N                                             ((FORMAT) == TIMER_CH_REF_Format7))
X#define IS_TIMER_CHANNEL_REF_FORMAT(FORMAT) (((FORMAT) == TIMER_CH_REF_Format0) ||                                              ((FORMAT) == TIMER_CH_REF_Format1) ||                                              ((FORMAT) == TIMER_CH_REF_Format2) ||                                              ((FORMAT) == TIMER_CH_REF_Format3) ||                                              ((FORMAT) == TIMER_CH_REF_Format4) ||                                              ((FORMAT) == TIMER_CH_REF_Format5) ||                                              ((FORMAT) == TIMER_CH_REF_Format6) ||                                              ((FORMAT) == TIMER_CH_REF_Format7))
N
N/** @} */ /* End of group TIMER_CH_REF_Format */
N
N/** @defgroup TIMER_CH_Prescaler TIMER Channel Prescaler
N  * @{
N  */
N
N#define TIMER_CH_Prescaler_None               ((uint32_t)0x0)  /*!< No division of input frequency. */
N#define TIMER_CH_Prescaler_div_2              ((uint32_t)0x1)  /*!< Selects input frequency divider by 2. */
N#define TIMER_CH_Prescaler_div_4              ((uint32_t)0x2)  /*!< Selects input frequency divider by 4. */
N#define TIMER_CH_Prescaler_div_8              ((uint32_t)0x3)  /*!< Selects input frequency divider by 8. */
N
N#define IS_TIMER_CHANNEL_PRESCALER(VALUE) (((VALUE) == TIMER_CH_Prescaler_None ) || \
N                                           ((VALUE) == TIMER_CH_Prescaler_div_2) || \
N                                           ((VALUE) == TIMER_CH_Prescaler_div_4) || \
N                                           ((VALUE) == TIMER_CH_Prescaler_div_8))
X#define IS_TIMER_CHANNEL_PRESCALER(VALUE) (((VALUE) == TIMER_CH_Prescaler_None ) ||                                            ((VALUE) == TIMER_CH_Prescaler_div_2) ||                                            ((VALUE) == TIMER_CH_Prescaler_div_4) ||                                            ((VALUE) == TIMER_CH_Prescaler_div_8))
N
N/** @} */ /* End of group TIMER_CH_Prescaler */
N
N/** @defgroup TIMER_CH_EventSource TIMER Channel Event Source
N  * @{
N  */
N
N#define TIMER_CH_EvSrc_PE                     (((uint32_t)0x0) << TIMER_CH_CNTRL_CHSEL_Pos)  /*!< Selects positive edge from current TIMER channel. */
N#define TIMER_CH_EvSrc_NE                     (((uint32_t)0x1) << TIMER_CH_CNTRL_CHSEL_Pos)  /*!< Selects negative edge from current TIMER channel. */
N#define TIMER_CH_EvSrc_PE_OC1                 (((uint32_t)0x2) << TIMER_CH_CNTRL_CHSEL_Pos)  /*!< Selects positive edge from other TIMER channel (variant 1). */
N#define TIMER_CH_EvSrc_PE_OC2                 (((uint32_t)0x3) << TIMER_CH_CNTRL_CHSEL_Pos)  /*!< Selects positive edge from other TIMER channel (variant 2). */
N
N#define IS_TIMER_CHANNEL_EVENT_SOURCE(SOURCE) (((SOURCE) == TIMER_CH_EvSrc_PE    ) || \
N                                               ((SOURCE) == TIMER_CH_EvSrc_NE    ) || \
N                                               ((SOURCE) == TIMER_CH_EvSrc_PE_OC1) || \
N                                               ((SOURCE) == TIMER_CH_EvSrc_PE_OC2))
X#define IS_TIMER_CHANNEL_EVENT_SOURCE(SOURCE) (((SOURCE) == TIMER_CH_EvSrc_PE    ) ||                                                ((SOURCE) == TIMER_CH_EvSrc_NE    ) ||                                                ((SOURCE) == TIMER_CH_EvSrc_PE_OC1) ||                                                ((SOURCE) == TIMER_CH_EvSrc_PE_OC2))
N
N/** @} */ /* End of group TIMER_CH_EventSource */
N
N/** @defgroup TIMER_CH_CCR1_EventSource TIMER Channel CCR1 Event Source
N  * @{
N  */
N
N#define TIMER_CH_CCR1EvSrc_PE                 (((uint32_t)0x0) << TIMER_CH_CNTRL2_CHSEL1_Pos)  /*!< Selects positive edge from current TIMER channel. */
N#define TIMER_CH_CCR1EvSrc_NE                 (((uint32_t)0x1) << TIMER_CH_CNTRL2_CHSEL1_Pos)  /*!< Selects negative edge from current TIMER channel. */
N#define TIMER_CH_CCR1EvSrc_NE_OC1             (((uint32_t)0x2) << TIMER_CH_CNTRL2_CHSEL1_Pos)  /*!< Selects negative edge from other TIMER channel (variant 1). */
N#define TIMER_CH_CCR1EvSrc_NE_OC2             (((uint32_t)0x3) << TIMER_CH_CNTRL2_CHSEL1_Pos)  /*!< Selects negative edge from other TIMER channel (variant 2). */
N
N#define IS_TIMER_CHANNEL_CCR1_EVENT_SOURCE(SOURCE) (((SOURCE) == TIMER_CH_CCR1EvSrc_PE    ) || \
N                                                    ((SOURCE) == TIMER_CH_CCR1EvSrc_NE    ) || \
N                                                    ((SOURCE) == TIMER_CH_CCR1EvSrc_NE_OC1) || \
N                                                    ((SOURCE) == TIMER_CH_CCR1EvSrc_NE_OC2))
X#define IS_TIMER_CHANNEL_CCR1_EVENT_SOURCE(SOURCE) (((SOURCE) == TIMER_CH_CCR1EvSrc_PE    ) ||                                                     ((SOURCE) == TIMER_CH_CCR1EvSrc_NE    ) ||                                                     ((SOURCE) == TIMER_CH_CCR1EvSrc_NE_OC1) ||                                                     ((SOURCE) == TIMER_CH_CCR1EvSrc_NE_OC2))
N
N/** @} */ /* End of group TIMER_CH_CCR1_EventSource */
N
N/** @defgroup TIMER_CH_CCR_Update_Mode TIMER CCR, CCR1 Update mode
N  * @{
N  */
N
N#define TIMER_CH_CCR_Update_Immediately       (((uint32_t)0x0) << TIMER_CH_CNTRL2_CCRRLD_Pos)  /*!< The CCR, CCR1 registers is updated immediately. */
N#define TIMER_CH_CCR_Update_On_CNT_eq_0       (((uint32_t)0x1) << TIMER_CH_CNTRL2_CCRRLD_Pos)  /*!< The CCR, CCR1 registers is updated at (CNT == 0) condition. */
N
N#define IS_TIMER_CHANNEL_CCR_UPDATE_MODE(MODE) (((MODE) == TIMER_CH_CCR_Update_Immediately) || \
N                                                ((MODE) == TIMER_CH_CCR_Update_On_CNT_eq_0))
X#define IS_TIMER_CHANNEL_CCR_UPDATE_MODE(MODE) (((MODE) == TIMER_CH_CCR_Update_Immediately) ||                                                 ((MODE) == TIMER_CH_CCR_Update_On_CNT_eq_0))
N
N/** @} */ /* End of group TIMER_CH_CCR_UpdateMode */
N
N/** @defgroup TIMER_CH_OUT_Polarity TIMER Channel Output Polarity
N  * @{
N  */
N
N#define TIMER_CHOPolarity_NonInverted         ((uint32_t)0x0)   /*!< No inversion on the Channel output. */
N#define TIMER_CHOPolarity_Inverted            ((uint32_t)0x1)   /*!< The Channel output is inverted. */
N
N#define IS_TIMER_CHO_POLARITY(STATE) (((STATE) == TIMER_CHOPolarity_NonInverted) || \
N                                      ((STATE) == TIMER_CHOPolarity_Inverted   ))
X#define IS_TIMER_CHO_POLARITY(STATE) (((STATE) == TIMER_CHOPolarity_NonInverted) ||                                       ((STATE) == TIMER_CHOPolarity_Inverted   ))
N
N/** @} */ /* End of group TIMER_CH_OUT_Polarity */
N
N/** @defgroup TIMER_CH_OUT_Source TIMER Channel Output Source
N  * @{
N  */
N
N#define TIMER_CH_OutSrc_Only_0                ((uint32_t)0x0)   /*!< Selects the '0' state on the CHx (or CHxN) line. */
N#define TIMER_CH_OutSrc_Only_1                ((uint32_t)0x1)   /*!< Selects the '1' state on the CHx (or CHxN) line. */
N#define TIMER_CH_OutSrc_REF                   ((uint32_t)0x2)   /*!< Selects the REF state on the CHx (or CHxN) line. */
N#define TIMER_CH_OutSrc_DTG                   ((uint32_t)0x3)   /*!< Selects the DTG output state on the CHx (or CHxN) line. */
N
N#define IS_TIMER_CHO_SOURCE(SOURCE) (((SOURCE) == TIMER_CH_OutSrc_Only_0) || \
N                                     ((SOURCE) == TIMER_CH_OutSrc_Only_1) || \
N                                     ((SOURCE) == TIMER_CH_OutSrc_REF   ) || \
N                                     ((SOURCE) == TIMER_CH_OutSrc_DTG   ))
X#define IS_TIMER_CHO_SOURCE(SOURCE) (((SOURCE) == TIMER_CH_OutSrc_Only_0) ||                                      ((SOURCE) == TIMER_CH_OutSrc_Only_1) ||                                      ((SOURCE) == TIMER_CH_OutSrc_REF   ) ||                                      ((SOURCE) == TIMER_CH_OutSrc_DTG   ))
N
N/** @} */ /* End of group TIMER_CH_OUT_Source */
N
N/** @defgroup TIMER_CH_OUT_Mode TIMER Channel Output Enable Source
N  * @{
N  */
N
N#define TIMER_CH_OutMode_Input                ((uint32_t)0x0)   /*!< Selects the Input mode on the CHx (or CHxN) line. */
N#define TIMER_CH_OutMode_Output               ((uint32_t)0x1)   /*!< Selects the Output mode on the CHx (or CHxN) line. */
N#define TIMER_CH_OutMode_REF_as_OE            ((uint32_t)0x2)   /*!< The REF signal specifies the CHx (or CHxN) line mode. */
N#define TIMER_CH_OutMode_DTG_as_OE            ((uint32_t)0x3)   /*!< The DTG output specifies the CHx (or CHxN) line mode. */
N
N#define IS_TIMER_CHO_MODE(MODE) (((MODE) == TIMER_CH_OutMode_Input    ) || \
N                                 ((MODE) == TIMER_CH_OutMode_Output   ) || \
N                                 ((MODE) == TIMER_CH_OutMode_REF_as_OE) || \
N                                 ((MODE) == TIMER_CH_OutMode_DTG_as_OE))
X#define IS_TIMER_CHO_MODE(MODE) (((MODE) == TIMER_CH_OutMode_Input    ) ||                                  ((MODE) == TIMER_CH_OutMode_Output   ) ||                                  ((MODE) == TIMER_CH_OutMode_REF_as_OE) ||                                  ((MODE) == TIMER_CH_OutMode_DTG_as_OE))
N
N/** @} */ /* End of group TIMER_CH_OUT_Mode */
N
N/** @defgroup TIMER_CH_DTG_Prescaler TIMER Channel DTG Prescaler
N  * @{
N  */
N
N#define IS_TIMER_CHANNEL_DTG_MAIN_PRESCALER(VALUE) (((VALUE) >> 8) == 0)
N
N#define IS_TIMER_CHANNEL_DTG_AUX_PRESCALER(VALUE) (((VALUE) >> 4) == 0)
N
N/** @} */ /* End of group TIMER_CH_DTG_Prescaler */
N
N/** @defgroup TIMER_CH_DTG_Clock_Source TIMER Channel DTG Clock Source
N  * @{
N  */
N
N#define TIMER_CH_DTG_ClkSrc_TIMER_CLK         (((uint32_t)0x0) << TIMER_CH_DTG_EDTS_Pos)  /*!< Specifies the TIMER_CLK signal as DTG clock source. */
N#define TIMER_CH_DTG_ClkSrc_FDTS              (((uint32_t)0x1) << TIMER_CH_DTG_EDTS_Pos)  /*!< Specifies the FDTS signal as DTG clock source. */
N
N#define IS_TIMER_CHANNEL_DTG_CLK_SOURCE(SOURCE) (((SOURCE) == TIMER_CH_DTG_ClkSrc_TIMER_CLK) || \
N                                                 ((SOURCE) == TIMER_CH_DTG_ClkSrc_FDTS     ))
X#define IS_TIMER_CHANNEL_DTG_CLK_SOURCE(SOURCE) (((SOURCE) == TIMER_CH_DTG_ClkSrc_TIMER_CLK) ||                                                  ((SOURCE) == TIMER_CH_DTG_ClkSrc_FDTS     ))
N
N/** @} */ /* End of group TIMER_CH_DTG_Clock_Source */
N
N/** @defgroup TIMER_StatusFlags TIMER Status flags
N  * @{
N  */
N
N#define TIMER_STATUS_CNT_ZERO                 (((uint32_t)0x1) <<  0) /*!< The (CNT == 0) condition occured. */
N#define TIMER_STATUS_CNT_ARR                  (((uint32_t)0x1) <<  1) /*!< The (CNT == ARR) condition occured. */
N#define TIMER_STATUS_ETR_RISING_EDGE          (((uint32_t)0x1) <<  2) /*!< The ETR rising edge occured. */
N#define TIMER_STATUS_ETR_FALLING_EDGE         (((uint32_t)0x1) <<  3) /*!< The ETR falling edge occured. */
N#define TIMER_STATUS_BRK                      (((uint32_t)0x1) <<  4) /*!< The (BRK == 1) condition occured. */
N#define TIMER_STATUS_CCR_CAP_CH1              (((uint32_t)0x1) <<  5) /*!< The Channel 1 CCR capture condition occured. */
N#define TIMER_STATUS_CCR_CAP_CH2              (((uint32_t)0x1) <<  6) /*!< The Channel 2 CCR capture condition occured. */
N#define TIMER_STATUS_CCR_CAP_CH3              (((uint32_t)0x1) <<  7) /*!< The Channel 3 CCR capture condition occured. */
N#define TIMER_STATUS_CCR_CAP_CH4              (((uint32_t)0x1) <<  8) /*!< The Channel 4 CCR capture condition occured. */
N#define TIMER_STATUS_CCR_REF_CH1              (((uint32_t)0x1) <<  9) /*!< The Channel 1 (REF == 1) condition occured. */
N#define TIMER_STATUS_CCR_REF_CH2              (((uint32_t)0x1) << 10) /*!< The Channel 2 (REF == 1) condition occured. */
N#define TIMER_STATUS_CCR_REF_CH3              (((uint32_t)0x1) << 11) /*!< The Channel 3 (REF == 1) condition occured. */
N#define TIMER_STATUS_CCR_REF_CH4              (((uint32_t)0x1) << 12) /*!< The Channel 4 (REF == 1) condition occured. */
N#define TIMER_STATUS_CCR_CAP1_CH1             (((uint32_t)0x1) << 13) /*!< The Channel 1 CCR1 capture condition occured. */
N#define TIMER_STATUS_CCR_CAP1_CH2             (((uint32_t)0x1) << 14) /*!< The Channel 2 CCR1 capture condition occured. */
N#define TIMER_STATUS_CCR_CAP1_CH3             (((uint32_t)0x1) << 15) /*!< The Channel 3 CCR1 capture condition occured. */
N#define TIMER_STATUS_CCR_CAP1_CH4             (((uint32_t)0x1) << 16) /*!< The Channel 4 CCR1 capture condition occured. */
N
N#define TIMER_STATUS_Msk                      (TIMER_STATUS_CNT_ZERO         | \
N                                               TIMER_STATUS_CNT_ARR          | \
N                                               TIMER_STATUS_ETR_RISING_EDGE  | \
N                                               TIMER_STATUS_ETR_FALLING_EDGE | \
N                                               TIMER_STATUS_BRK              | \
N                                               TIMER_STATUS_CCR_CAP_CH1      | \
N                                               TIMER_STATUS_CCR_CAP_CH2      | \
N                                               TIMER_STATUS_CCR_CAP_CH3      | \
N                                               TIMER_STATUS_CCR_CAP_CH4      | \
N                                               TIMER_STATUS_CCR_REF_CH1      | \
N                                               TIMER_STATUS_CCR_REF_CH2      | \
N                                               TIMER_STATUS_CCR_REF_CH3      | \
N                                               TIMER_STATUS_CCR_REF_CH4      | \
N                                               TIMER_STATUS_CCR_CAP1_CH1     | \
N                                               TIMER_STATUS_CCR_CAP1_CH2     | \
N                                               TIMER_STATUS_CCR_CAP1_CH3     | \
N                                               TIMER_STATUS_CCR_CAP1_CH4)
X#define TIMER_STATUS_Msk                      (TIMER_STATUS_CNT_ZERO         |                                                TIMER_STATUS_CNT_ARR          |                                                TIMER_STATUS_ETR_RISING_EDGE  |                                                TIMER_STATUS_ETR_FALLING_EDGE |                                                TIMER_STATUS_BRK              |                                                TIMER_STATUS_CCR_CAP_CH1      |                                                TIMER_STATUS_CCR_CAP_CH2      |                                                TIMER_STATUS_CCR_CAP_CH3      |                                                TIMER_STATUS_CCR_CAP_CH4      |                                                TIMER_STATUS_CCR_REF_CH1      |                                                TIMER_STATUS_CCR_REF_CH2      |                                                TIMER_STATUS_CCR_REF_CH3      |                                                TIMER_STATUS_CCR_REF_CH4      |                                                TIMER_STATUS_CCR_CAP1_CH1     |                                                TIMER_STATUS_CCR_CAP1_CH2     |                                                TIMER_STATUS_CCR_CAP1_CH3     |                                                TIMER_STATUS_CCR_CAP1_CH4)
N
N#define IS_TIMER_STATUS_FLAG(FLAG) (((FLAG) == TIMER_STATUS_CNT_ZERO        ) || \
N                                    ((FLAG) == TIMER_STATUS_CNT_ARR         ) || \
N                                    ((FLAG) == TIMER_STATUS_ETR_RISING_EDGE ) || \
N                                    ((FLAG) == TIMER_STATUS_ETR_FALLING_EDGE) || \
N                                    ((FLAG) == TIMER_STATUS_BRK             ) || \
N                                    ((FLAG) == TIMER_STATUS_CCR_CAP_CH1     ) || \
N                                    ((FLAG) == TIMER_STATUS_CCR_CAP_CH2     ) || \
N                                    ((FLAG) == TIMER_STATUS_CCR_CAP_CH3     ) || \
N                                    ((FLAG) == TIMER_STATUS_CCR_CAP_CH4     ) || \
N                                    ((FLAG) == TIMER_STATUS_CCR_REF_CH1     ) || \
N                                    ((FLAG) == TIMER_STATUS_CCR_REF_CH2     ) || \
N                                    ((FLAG) == TIMER_STATUS_CCR_REF_CH3     ) || \
N                                    ((FLAG) == TIMER_STATUS_CCR_REF_CH4     ) || \
N                                    ((FLAG) == TIMER_STATUS_CCR_CAP1_CH1    ) || \
N                                    ((FLAG) == TIMER_STATUS_CCR_CAP1_CH2    ) || \
N                                    ((FLAG) == TIMER_STATUS_CCR_CAP1_CH3    ) || \
N                                    ((FLAG) == TIMER_STATUS_CCR_CAP1_CH4    ))
X#define IS_TIMER_STATUS_FLAG(FLAG) (((FLAG) == TIMER_STATUS_CNT_ZERO        ) ||                                     ((FLAG) == TIMER_STATUS_CNT_ARR         ) ||                                     ((FLAG) == TIMER_STATUS_ETR_RISING_EDGE ) ||                                     ((FLAG) == TIMER_STATUS_ETR_FALLING_EDGE) ||                                     ((FLAG) == TIMER_STATUS_BRK             ) ||                                     ((FLAG) == TIMER_STATUS_CCR_CAP_CH1     ) ||                                     ((FLAG) == TIMER_STATUS_CCR_CAP_CH2     ) ||                                     ((FLAG) == TIMER_STATUS_CCR_CAP_CH3     ) ||                                     ((FLAG) == TIMER_STATUS_CCR_CAP_CH4     ) ||                                     ((FLAG) == TIMER_STATUS_CCR_REF_CH1     ) ||                                     ((FLAG) == TIMER_STATUS_CCR_REF_CH2     ) ||                                     ((FLAG) == TIMER_STATUS_CCR_REF_CH3     ) ||                                     ((FLAG) == TIMER_STATUS_CCR_REF_CH4     ) ||                                     ((FLAG) == TIMER_STATUS_CCR_CAP1_CH1    ) ||                                     ((FLAG) == TIMER_STATUS_CCR_CAP1_CH2    ) ||                                     ((FLAG) == TIMER_STATUS_CCR_CAP1_CH3    ) ||                                     ((FLAG) == TIMER_STATUS_CCR_CAP1_CH4    ))
N
N#define IS_TIMER_STATUS(STATUS) (((STATUS) & TIMER_STATUS_Msk) == (STATUS))
N
N/** @} */ /* End of group TIMER_StatusFlags */
N
N/** @defgroup TIMER_DMAChannels TIMER DMAChannels
N  * @{
N  */
N/** @note Available only for MC MDR1986VE1T and MC MDR1986BE3 */
N
N#define TIMER_DMA_Channel0					((uint32_t)0x00000004)
N#define TIMER_DMA_Channel1					((uint32_t)0x00000000)
N#define TIMER_DMA_Channel2					((uint32_t)0x00000001)
N#define TIMER_DMA_Channel3					((uint32_t)0x00000002)
N#define TIMER_DMA_Channel4					((uint32_t)0x00000003)
N
N#define IS_TIMER_DMA_Channel(DMA_Channel)	((DMA_Channel == TIMER_DMA_Channel0) ||\
N											 (DMA_CHannel == TIMER_DMA_Channel1) ||\
N											 (DMA_CHannel == TIMER_DMA_Channel2) ||\
N											 (DMA_CHannel == TIMER_DMA_Channel3) ||\
N											 (DMA_CHannel == TIMER_DMA_Channel4))
X#define IS_TIMER_DMA_Channel(DMA_Channel)	((DMA_Channel == TIMER_DMA_Channel0) ||											 (DMA_CHannel == TIMER_DMA_Channel1) ||											 (DMA_CHannel == TIMER_DMA_Channel2) ||											 (DMA_CHannel == TIMER_DMA_Channel3) ||											 (DMA_CHannel == TIMER_DMA_Channel4))
N
N/** @} */ /* End of group TIMER_DMAChannels */
N
N/** @defgroup TIMER_Clock_BRG TIMER Clock BRG
N  * @{
N  */
N
N#define TIMER_HCLKdiv1                        ((uint32_t)0x0)
N#define TIMER_HCLKdiv2                        ((uint32_t)0x1)
N#define TIMER_HCLKdiv4                        ((uint32_t)0x2)
N#define TIMER_HCLKdiv8                        ((uint32_t)0x3)
N#define TIMER_HCLKdiv16                       ((uint32_t)0x4)
N#define TIMER_HCLKdiv32                       ((uint32_t)0x5)
N#define TIMER_HCLKdiv64                       ((uint32_t)0x6)
N#define TIMER_HCLKdiv128                      ((uint32_t)0x7)
N
N#define IS_TIMER_CLOCK_BRG(BRG) (((BRG) == TIMER_HCLKdiv1  ) || \
N                                 ((BRG) == TIMER_HCLKdiv2  ) || \
N                                 ((BRG) == TIMER_HCLKdiv4  ) || \
N                                 ((BRG) == TIMER_HCLKdiv8  ) || \
N                                 ((BRG) == TIMER_HCLKdiv16 ) || \
N                                 ((BRG) == TIMER_HCLKdiv32 ) || \
N                                 ((BRG) == TIMER_HCLKdiv64 ) || \
N                                 ((BRG) == TIMER_HCLKdiv128))
X#define IS_TIMER_CLOCK_BRG(BRG) (((BRG) == TIMER_HCLKdiv1  ) ||                                  ((BRG) == TIMER_HCLKdiv2  ) ||                                  ((BRG) == TIMER_HCLKdiv4  ) ||                                  ((BRG) == TIMER_HCLKdiv8  ) ||                                  ((BRG) == TIMER_HCLKdiv16 ) ||                                  ((BRG) == TIMER_HCLKdiv32 ) ||                                  ((BRG) == TIMER_HCLKdiv64 ) ||                                  ((BRG) == TIMER_HCLKdiv128))
N
N/** @} */ /* End of group TIMER_Clock_BRG */
N
N/** @} */ /* End of group TIMER_Exported_Constants */
N
N/** @defgroup TIMER_Exported_Macros TIMER Exported Macros
N  * @{
N  */
N
N/**
N  * @brief  Clears the TIMERx's interrupt pending (TIMERx's Status) bits.
N  * @param  TIMERx: where x can be 1 to 3 to select the TIMER peripheral.
N  * @param  TIMER_IT: specifies the pending bit to clear.
N  *         This parameter can be any combination of the TIMER_StatusFlags:
N  *           @arg TIMER_STATUS_CNT_ZERO:         the (CNT == 0) condition occured;
N  *           @arg TIMER_STATUS_CNT_ARR:          the (CNT == ARR) condition occured;
N  *           @arg TIMER_STATUS_ETR_RISING_EDGE:  the ETR rising edge occured;
N  *           @arg TIMER_STATUS_ETR_FALLING_EDGE: the ETR falling edge occured;
N  *           @arg TIMER_STATUS_BRK:              the (BRK == 1) condition occured;
N  *           @arg TIMER_STATUS_CCR_CAP_CH1:      the Channel 1 CCR capture condition occured;
N  *           @arg TIMER_STATUS_CCR_CAP_CH2:      the Channel 2 CCR capture condition occured;
N  *           @arg TIMER_STATUS_CCR_CAP_CH3:      the Channel 3 CCR capture condition occured;
N  *           @arg TIMER_STATUS_CCR_CAP_CH4:      the Channel 4 CCR capture condition occured;
N  *           @arg TIMER_STATUS_CCR_REF_CH1:      the Channel 1 (REF == 1) condition occured;
N  *           @arg TIMER_STATUS_CCR_REF_CH2:      the Channel 2 (REF == 1) condition occured;
N  *           @arg TIMER_STATUS_CCR_REF_CH3:      the Channel 3 (REF == 1) condition occured;
N  *           @arg TIMER_STATUS_CCR_REF_CH4:      the Channel 4 (REF == 1) condition occured;
N  *           @arg TIMER_STATUS_CCR_CAP1_CH1:     the Channel 1 CCR1 capture condition occured;
N  *           @arg TIMER_STATUS_CCR_CAP1_CH2:     the Channel 2 CCR1 capture condition occured;
N  *           @arg TIMER_STATUS_CCR_CAP1_CH3:     the Channel 3 CCR1 capture condition occured;
N  *           @arg TIMER_STATUS_CCR_CAP1_CH4:     the Channel 4 CCR1 capture condition occured.
N  * @retval None
N  */
N#define TIMER_ClearITPendingBit(TIMERx, TIMER_IT) TIMER_ClearFlag(TIMERx, TIMER_IT)
N
N/** @} */ /* End of group TIMER_Exported_Macros */
N
N/** @defgroup TIMER_Exported_Functions TIMER Exported Functions
N  * @{
N  */
N
Nvoid TIMER_DeInit(MDR_TIMER_TypeDef* TIMERx);
N
Nvoid TIMER_CntInit(MDR_TIMER_TypeDef* TIMERx, const TIMER_CntInitTypeDef* TIMER_CntInitStruct);
Nvoid TIMER_CntStructInit(TIMER_CntInitTypeDef* TIMER_CntInitStruct);
N
Nvoid TIMER_Cmd(MDR_TIMER_TypeDef* TIMERx, FunctionalState NewState);
N
N#if defined (USE_MDR1986VE1T) || defined (USE_MDR1986VE3)
X#if 0L || 0L
S	void TIMER_SetCounter(MDR_TIMER_TypeDef* TIMERx, uint32_t Counter);
N#elif defined (USE_MDR1986VE9x) || defined (USE_MDR1901VC1T)
X#elif 1L || 0L
N	void TIMER_SetCounter(MDR_TIMER_TypeDef* TIMERx, uint16_t Counter);
N#endif
N
Nvoid TIMER_SetCntPrescaler(MDR_TIMER_TypeDef* TIMERx, uint16_t Prescaler);
N#if defined (USE_MDR1986VE1T) || defined (USE_MDR1986VE3)
X#if 0L || 0L
S	void TIMER_SetCntAutoreload(MDR_TIMER_TypeDef* TIMERx, uint32_t Autoreload);
N#elif defined (USE_MDR1986VE9x) || defined (USE_MDR1901VC1T)
X#elif 1L || 0L
N	void TIMER_SetCntAutoreload(MDR_TIMER_TypeDef* TIMERx, uint16_t Autoreload);
N#endif
N#if defined (USE_MDR1986VE1T) || defined (USE_MDR1986VE3)
X#if 0L || 0L
S	void TIMER_CntAutoreloadConfig(MDR_TIMER_TypeDef* TIMERx, uint32_t Autoreload, uint32_t UpdateMode);
N#elif defined (USE_MDR1986VE9x) || defined (USE_MDR1901VC1T)
X#elif 1L || 0L
N	void TIMER_CntAutoreloadConfig(MDR_TIMER_TypeDef* TIMERx, uint16_t Autoreload, uint32_t UpdateMode);
N#endif
N
N#if defined (USE_MDR1986VE1T) || defined (USE_MDR1986VE3)
X#if 0L || 0L
S	uint32_t TIMER_GetCounter(MDR_TIMER_TypeDef* TIMERx);
N#elif defined (USE_MDR1986VE9x) || defined (USE_MDR1901VC1T)
X#elif 1L || 0L
N	uint16_t TIMER_GetCounter(MDR_TIMER_TypeDef* TIMERx);
N#endif
N
Nvoid TIMER_CntEventSourceConfig(MDR_TIMER_TypeDef* TIMERx, uint32_t EventSource);
Nvoid TIMER_FilterSamplingConfig(MDR_TIMER_TypeDef* TIMERx, uint32_t Prescaler);
Nvoid TIMER_CounterModeConfig(MDR_TIMER_TypeDef* TIMERx, uint32_t Mode);
Nvoid TIMER_SetCounterDirection(MDR_TIMER_TypeDef* TIMERx, uint32_t Direction);
Nvoid TIMER_ETRInputConfig(MDR_TIMER_TypeDef* TIMERx, uint32_t Prescaler, uint32_t Polarity, uint32_t Filter);
Nvoid TIMER_ETRFilterConfig(MDR_TIMER_TypeDef* TIMERx, uint32_t Filter);
Nvoid TIMER_ETRPrescalerConfig(MDR_TIMER_TypeDef* TIMERx, uint32_t Prescaler);
Nvoid TIMER_ETRPolarityConfig(MDR_TIMER_TypeDef* TIMERx, uint32_t Polarity);
Nvoid TIMER_BRKPolarityConfig(MDR_TIMER_TypeDef* TIMERx, uint32_t Polarity);
Nuint32_t TIMER_GetCounterDirection(MDR_TIMER_TypeDef* TIMERx);
NFlagStatus TIMER_GetCntWriteComplete(MDR_TIMER_TypeDef* TIMERx);
N
Nvoid TIMER_ChnInit(MDR_TIMER_TypeDef* TIMERx, const TIMER_ChnInitTypeDef* TIMER_ChnInitStruct);
Nvoid TIMER_ChnStructInit(TIMER_ChnInitTypeDef* TIMER_ChnInitStruct);
N
N#if defined (USE_MDR1986VE1T) || defined (USE_MDR1986VE3)
X#if 0L || 0L
S	void TIMER_SetChnCompare(MDR_TIMER_TypeDef* TIMERx, uint32_t Channel, uint32_t Compare);
N#elif defined (USE_MDR1986VE9x) || defined (USE_MDR1901VC1T)
X#elif 1L || 0L
N	void TIMER_SetChnCompare(MDR_TIMER_TypeDef* TIMERx, uint32_t Channel, uint16_t Compare);
N#endif
N
N#if defined (USE_MDR1986VE1T) || defined (USE_MDR1986VE3)
X#if 0L || 0L
S	void TIMER_SetChnCompare1(MDR_TIMER_TypeDef* TIMERx, uint32_t Channel, uint32_t Compare);
N#elif defined (USE_MDR1986VE9x) || defined (USE_MDR1901VC1T)
X#elif 1L || 0L
N	void TIMER_SetChnCompare1(MDR_TIMER_TypeDef* TIMERx, uint32_t Channel, uint16_t Compare);
N#endif
N
N#if defined (USE_MDR1986VE1T) || defined (USE_MDR1986VE3)
X#if 0L || 0L
S	void TIMER_ChnCompareConfig(MDR_TIMER_TypeDef* TIMERx, uint32_t Channel, uint32_t Compare, uint32_t UpdateMode);
N#elif defined (USE_MDR1986VE9x) || defined (USE_MDR1901VC1T)
X#elif 1L || 0L
N	void TIMER_ChnCompareConfig(MDR_TIMER_TypeDef* TIMERx, uint32_t Channel, uint16_t Compare, uint32_t UpdateMode);
N#endif
N
N#if defined (USE_MDR1986VE1T) || defined (USE_MDR1986VE3)
X#if 0L || 0L
S	void TIMER_ChnCompare1Config(MDR_TIMER_TypeDef* TIMERx, uint32_t Channel, uint32_t Compare, uint32_t UpdateMode);
N#elif defined (USE_MDR1986VE9x) || defined (USE_MDR1901VC1T)
X#elif 1L || 0L
N	void TIMER_ChnCompare1Config(MDR_TIMER_TypeDef* TIMERx, uint32_t Channel, uint16_t Compare, uint32_t UpdateMode);
N#endif
N
N#if defined (USE_MDR1986VE1T) || defined (USE_MDR1986VE3)
X#if 0L || 0L
S	uint32_t TIMER_GetChnCapture(MDR_TIMER_TypeDef* TIMERx, uint32_t Channel);
N#elif defined (USE_MDR1986VE9x) || defined (USE_MDR1901VC1T)
X#elif 1L || 0L
N	uint16_t TIMER_GetChnCapture(MDR_TIMER_TypeDef* TIMERx, uint32_t Channel);
N#endif
N
N#if defined (USE_MDR1986VE1T) || defined (USE_MDR1986VE3)
X#if 0L || 0L
S	uint32_t TIMER_GetChnCapture1(MDR_TIMER_TypeDef* TIMERx, uint32_t Channel);
N#elif defined (USE_MDR1986VE9x) || defined (USE_MDR1901VC1T)
X#elif 1L || 0L
N	uint16_t TIMER_GetChnCapture1(MDR_TIMER_TypeDef* TIMERx, uint32_t Channel);
N#endif
N
N
Nvoid TIMER_ChnETR_Cmd(MDR_TIMER_TypeDef* TIMERx, uint32_t Channel, FunctionalState NewState);
Nvoid TIMER_ChnETRResetConfig(MDR_TIMER_TypeDef* TIMERx, uint32_t Channel, uint32_t NewState);
Nvoid TIMER_ChnBRKResetConfig(MDR_TIMER_TypeDef* TIMERx, uint32_t Channel, uint32_t NewState);
Nvoid TIMER_ChnREFFormatConfig(MDR_TIMER_TypeDef* TIMERx, uint32_t Channel, uint32_t Format);
Nvoid TIMER_ChnCapturePrescalerConfig(MDR_TIMER_TypeDef* TIMERx, uint32_t Channel, uint32_t Prescaler);
Nvoid TIMER_ChnEventSourceConfig(MDR_TIMER_TypeDef* TIMERx, uint32_t Channel, uint32_t EventSource);
Nvoid TIMER_ChnFilterConfig(MDR_TIMER_TypeDef* TIMERx, uint32_t Channel, uint32_t Filter);
NFlagStatus TIMER_GetChnWriteComplete(MDR_TIMER_TypeDef* TIMERx, uint32_t Channel);
Nvoid TIMER_ChnCCR1_EventSourceConfig(MDR_TIMER_TypeDef* TIMERx, uint32_t Channel, uint32_t EventSource);
Nvoid TIMER_ChnCCR1_Cmd(MDR_TIMER_TypeDef* TIMERx, uint32_t Channel, FunctionalState NewState);
N
Nvoid TIMER_ChnOutInit(MDR_TIMER_TypeDef* TIMERx, const TIMER_ChnOutInitTypeDef* TIMER_ChnOutInitStruct);
Nvoid TIMER_ChnOutStructInit(TIMER_ChnOutInitTypeDef* TIMER_ChnOutInitStruct);
Nvoid TIMER_ChnOutConfig(MDR_TIMER_TypeDef* TIMERx, uint32_t Channel, uint32_t OutSource, uint32_t Mode, uint32_t Polarity);
Nvoid TIMER_ChnOutSourceConfig(MDR_TIMER_TypeDef* TIMERx, uint32_t Channel, uint32_t OutSource);
Nvoid TIMER_ChnOutModeConfig(MDR_TIMER_TypeDef* TIMERx, uint32_t Channel, uint32_t Mode);
Nvoid TIMER_ChnOutPolarityConfig(MDR_TIMER_TypeDef* TIMERx, uint32_t Channel, uint32_t Polarity);
Nvoid TIMER_ChnNOutConfig(MDR_TIMER_TypeDef* TIMERx, uint32_t Channel, uint32_t OutSource, uint32_t Mode, uint32_t Polarity);
Nvoid TIMER_ChnNOutSourceConfig(MDR_TIMER_TypeDef* TIMERx, uint32_t Channel, uint32_t OutSource);
Nvoid TIMER_ChnNOutModeConfig(MDR_TIMER_TypeDef* TIMERx, uint32_t Channel, uint32_t Mode);
Nvoid TIMER_ChnNOutPolarityConfig(MDR_TIMER_TypeDef* TIMERx, uint32_t Channel, uint32_t Polarity);
Nvoid TIMER_ChnOutDTGConfig(MDR_TIMER_TypeDef* TIMERx, uint32_t Channel,
N                         uint32_t MainPrescaler, uint32_t AuxPrescaler, uint32_t ClockSource);
N
Nuint32_t TIMER_GetStatus(MDR_TIMER_TypeDef* TIMERx);
NFlagStatus TIMER_GetFlagStatus(MDR_TIMER_TypeDef* TIMERx, uint32_t Flag);
Nvoid TIMER_ClearFlag(MDR_TIMER_TypeDef* TIMERx, uint32_t Flags);
N#if defined (USE_MDR1986VE1T) || defined (USE_MDR1986VE3)
X#if 0L || 0L
S	void TIMER_DMACmd(MDR_TIMER_TypeDef* TIMERx, uint32_t TIMER_DMASource, uint32_t TIMER_DMAChannel, FunctionalState NewState);
N#endif
N#if defined (USE_MDR1986VE9x) || defined (USE_MDR1901VC1T)
X#if 1L || 0L
N	void TIMER_DMACmd(MDR_TIMER_TypeDef* TIMERx, uint32_t TIMER_DMASource, FunctionalState NewState);
N#endif
N
Nvoid TIMER_ITConfig(MDR_TIMER_TypeDef* TIMERx, uint32_t TIMER_IT, FunctionalState NewState);
NITStatus TIMER_GetITStatus(MDR_TIMER_TypeDef* TIMERx, uint32_t TIMER_IT);
Nvoid TIMER_BRGInit(MDR_TIMER_TypeDef* TIMERx, uint32_t TIMER_BRG);
N
N/** @} */ /* End of group TIMER_Exported_Functions */
N
N/** @} */ /* End of group TIMER */
N
N/** @} */ /* End of group __MDR32F9Qx_StdPeriph_Driver */
N
N#ifdef __cplusplus
S} // extern "C" block end
N#endif
N
N#endif /* __MDR32F9QX_TIMER_H */
N
N/*
N*
N* END OF FILE MDR32F9Qx_timer.h */
L 21 "common.h" 2
N/* Подключение функций управления контроллером ПДП */
N#include <MDR32F9Qx_dma.h>
L 1 "C:\Keil_v5\ARM\PACK\Keil\MDR1986BExx\1.5.3\Libraries\MDR32F9Qx_StdPeriph_Driver\inc\MDR32F9Qx_dma.h" 1
N/**
N  * FILE MDR32F9Qx_dma.h
N  */
N
N/* Define to prevent recursive inclusion -------------------------------------*/
N#ifndef __MDR32F9Qx_DMA_H
N#define __MDR32F9Qx_DMA_H
N
N#ifdef __cplusplus
Sextern "C" {
N#endif
N
N/* Includes ------------------------------------------------------------------*/
N#include "MDR32F9Qx_config.h"
N#include "MDR32F9Qx_lib.h"
N
N/** @addtogroup __MDR32F9Qx_StdPeriph_Driver MDR32F9Qx Standard Peripherial Driver
N  * @{
N  */
N
N/** @addtogroup DMA
N  * @{
N  */
N
N/** @defgroup DMA_Exported_Types DMA Exported Types
N  * @{
N  */
N
N/**
N  * @brief  DMA Channel Primary / Alternate Control Data initialization structure definition
N  */
N
Ntypedef struct
N{
N  uint32_t DMA_SourceBaseAddr;                 /*!< Specifies the source base address for DMA Channelx. */
N
N  uint32_t DMA_DestBaseAddr;                  /*!< Specifies the destination base address for DMA Channelx. */
N
N  uint32_t DMA_SourceIncSize;                 /*!< Specifies the source address register increment value.
N                                                 This parameter can be a value of @ref DMA_source_incremented_mode */
N
N  uint32_t DMA_DestIncSize;                   /*!< Specifies the destination address register increment value.
N                                                 This parameter can be a value of @ref DMA_dest_incremented_mode */
N
N  uint32_t DMA_MemoryDataSize;                /*!< Specifies the Memory data width.
N                                                 This parameter can be a value of @ref DMA_memory_data_size */
N
N  uint32_t DMA_Mode;                          /*!< Specifies the operation mode of the DMA Channelx.
N                                                 This parameter can be a value of @ref DMA_operating_mode. */
N
N  uint32_t DMA_CycleSize;                     /*!< Specifies the  total number of DMA transfers that the DMA cycle contains.
N                                                 This parameter can be a value of @ref DMA_cycle_size. */
N
N  uint32_t DMA_NumContinuous;                 /*!< Specifies how many DMA transfers can occur before the DMA controller rearbitrates.
N                                                 This parameter can be a value of @ref DMA_number_continuous_transfers. */
N
N  uint32_t DMA_SourceProtCtrl;                /*!< Specifies the DMA Source protection control.
N                                                 This parameter can be a value of @ref DMA_source_protection_control. */
N
N  uint32_t DMA_DestProtCtrl;                  /*!< Specifies the DMA Destination protection control.
N                                                 This parameter can be a value of @ref DMA_dest_protection_control. */
N} DMA_CtrlDataInitTypeDef;
N
N/**
N  * @brief  DMA Channel Control Data structure definition
N  */
N
Ntypedef struct
N{
N  uint32_t DMA_SourceEndAddr;                 /*!< Specifies the DMA channel source end address */
N
N  uint32_t DMA_DestEndAddr;                   /*!< Specifies the DMA channel destination end address. */
N
N  uint32_t DMA_Control;                       /*!< Specifies the DMA channel control data configuration. */
N
N  uint32_t DMA_Unused;                        /*!< Specifies the DMA channel unused memory. */
N
N}DMA_CtrlDataTypeDef;
N
N/**
N  * @brief  DMA Channel Init structure definition
N  */
N
Ntypedef struct
N{
N  DMA_CtrlDataInitTypeDef *DMA_PriCtrlData;   /*!< Specifies the pointer to the primary control data structure.
N                                                 This parameter should be NULL if primary data structure is not used */
N
N  DMA_CtrlDataInitTypeDef *DMA_AltCtrlData;   /*!< Specifies the pointer to the alternate control data structure.
N                                                 This parameter should be NULL if alternate data structure is not used */
N
N  uint32_t DMA_ProtCtrl;                      /*!< Specifies the AHB-Lite protection control.
N                                                 This parameter can be a value of @ref DMA_AHB_protection_control. */
N
N  uint8_t DMA_Priority;                       /*!< Specifies the software priority for the DMA Channelx.
N                                                 This parameter can be a value of @ref DMA_priority_level */
N
N  uint8_t DMA_UseBurst;                       /*!< Disables single request to generate DMA requests for the DMA Channelx.
N                                                 This parameter can be a value of @ref DMA_burst_mode */
N
N  uint8_t DMA_SelectDataStructure;            /*!< Specifies the primary /alternate data structure to use by the DMA channel.
N                                                 This parameter can be a value of @ref DMA_data_structure_selection. */
N
N} DMA_ChannelInitTypeDef;
N
N/**
N  * @brief  DMA Channel Scatter-Gather Init structure definition
N  */
N
Ntypedef struct
N{
N  DMA_CtrlDataTypeDef *DMA_SG_TaskArray;      /*!< Specifies the pointer to the Scatter-Gather task structures array. The size
N                                                 of the array should be equal to DMA_SG_TaskNumber.
N                                                 Every structure of the array should contain the copy of the alternate control
N                                                 data for the related task. It will be used by DMA to configure
N                                                 the alternate control data while operating in the
N                                                 scatter-gather mode */
N
N  uint32_t DMA_SG_TaskNumber;                 /*!< Specifies the number of scatter-gather tasks to be executed by DMA */
N
N
N  uint32_t DMA_SourceProtCtrl;                /*!< Specifies the Primary Control Data DMA Source protection control.
N                                                 This parameter can be a value of @ref DMA_source_protection_control. */
N
N  uint32_t DMA_DestProtCtrl;                  /*!< Specifies the Primary Control Data DMA Destination protection control.
N                                                 This parameter can be a value of @ref DMA_dest_protection_control. */
N
N  uint32_t DMA_ProtCtrl;                      /*!< Specifies the AHB-Lite protection control.
N                                                 This parameter can be a value of @ref DMA_AHB_protection_control. */
N
N  uint8_t DMA_Priority;                       /*!< Specifies the software priority for the DMA Channelx.
N                                                 This parameter can be a value of @ref DMA_priority_level */
N
N  uint8_t DMA_UseBurst;                       /*!< Disables single request to generate DMA requests for the DMA Channelx.
N                                                 This parameter can be a value of @ref DMA_burst_mode */
N
N} DMA_Channel_SG_InitTypeDef;
N
N
N/** @} */ /* End of group DMA_Exported_Types */
N
N/** @defgroup DMA_Exported_Constants DMA Exported Constants
N  * @{
N  */
N
N/** @defgroup DMA_channels_number DMA channels number
N  * @{
N  */
N
N#define IS_DMA_CHANNELS(NUMBER) (((NUMBER) >= 1) && ((NUMBER) <= 32))
N
N/** @} */ /* End of group DMA_channels_number */
N
N/** @defgroup DMA_alternate_data_usage DMA alternate data usage
N  * @{
N  */
N
N#define DMA_ALternateDataDisabled           ((uint16_t)(0x00))
N#define DMA_ALternateDataEnabled            ((uint16_t)(0x01))
N
N#define IS_DMA_ALTERNATE_DATA(STATE)        (((STATE) == DMA_ALternateDataDisabled) || \
N                                            ((STATE)  == DMA_ALternateDataEnabled))
X#define IS_DMA_ALTERNATE_DATA(STATE)        (((STATE) == DMA_ALternateDataDisabled) ||                                             ((STATE)  == DMA_ALternateDataEnabled))
N
N/** @} */ /* End of group DMA_alternate_data_usage */
N
N/** @defgroup DMA_valid_channels DMA valid channels
N  * @{
N  */
N#if defined (USE_MDR1986VE9x)
X#if 1L
N
N#define DMA_Channel_UART1_TX    ((uint8_t)(0))
N#define DMA_Channel_UART1_RX    ((uint8_t)(1))
N#define DMA_Channel_UART2_TX    ((uint8_t)(2))
N#define DMA_Channel_UART2_RX    ((uint8_t)(3))
N#define DMA_Channel_SSP1_TX     ((uint8_t)(4))
N#define DMA_Channel_SSP1_RX     ((uint8_t)(5))
N#define DMA_Channel_SSP2_TX     ((uint8_t)(6))
N#define DMA_Channel_SSP2_RX     ((uint8_t)(7))
N#define DMA_Channel_ADC1        ((uint8_t)(8))
N#define DMA_Channel_ADC2        ((uint8_t)(9))
N#define DMA_Channel_TIM1        ((uint8_t)(10))
N#define DMA_Channel_TIM2        ((uint8_t)(11))
N#define DMA_Channel_TIM3        ((uint8_t)(12))
N#define DMA_Channel_SW1         ((uint8_t)(13))
N#define DMA_Channel_SW2         ((uint8_t)(14))
N#define DMA_Channel_SW3         ((uint8_t)(15))
N#define DMA_Channel_SW4         ((uint8_t)(16))
N#define DMA_Channel_SW5         ((uint8_t)(17))
N#define DMA_Channel_SW6         ((uint8_t)(18))
N#define DMA_Channel_SW7         ((uint8_t)(19))
N#define DMA_Channel_SW8         ((uint8_t)(20))
N#define DMA_Channel_SW9         ((uint8_t)(21))
N#define DMA_Channel_SW10        ((uint8_t)(22))
N#define DMA_Channel_SW11        ((uint8_t)(23))
N#define DMA_Channel_SW12        ((uint8_t)(24))
N#define DMA_Channel_SW13        ((uint8_t)(25))
N#define DMA_Channel_SW14        ((uint8_t)(26))
N#define DMA_Channel_SW15        ((uint8_t)(27))
N#define DMA_Channel_SW16        ((uint8_t)(28))
N#define DMA_Channel_SW17        ((uint8_t)(29))
N#define DMA_Channel_SW18        ((uint8_t)(30))
N#define DMA_Channel_SW19        ((uint8_t)(31))
N
N#elif defined (USE_MDR1986VE1T)
S
S/*-- req DMA request ---------------------------------------------------------*/
S#define DMA_Channel_REQ_UART1_TX    ((uint8_t)(0))
S#define DMA_Channel_REQ_UART1_RX    ((uint8_t)(1))
S#define DMA_Channel_REQ_UART2_TX    ((uint8_t)(2))
S#define DMA_Channel_REQ_UART2_RX    ((uint8_t)(3))
S#define DMA_Channel_REQ_SSP1_TX     ((uint8_t)(4))
S#define DMA_Channel_REQ_SSP1_RX     ((uint8_t)(5))
S#define DMA_Channel_REQ_SSP2_TX     ((uint8_t)(6))
S#define DMA_Channel_REQ_SSP2_RX     ((uint8_t)(7))
S#define DMA_Channel_REQ_SSP3_TX     ((uint8_t)(8))
S#define DMA_Channel_REQ_SSP3_RX     ((uint8_t)(9))
S#define DMA_Channel_REQ_TIM1        ((uint8_t)(10))
S#define DMA_Channel_REQ_TIM2        ((uint8_t)(11))
S#define DMA_Channel_REQ_TIM3        ((uint8_t)(12))
S#define DMA_Channel_REQ_TIM4        ((uint8_t)(13))
S#define DMA_Channel_SW1           ((uint8_t)(14))
S#define DMA_Channel_SW2           ((uint8_t)(15))
S#define DMA_Channel_SW3             ((uint8_t)(16))
S#define DMA_Channel_SW4           ((uint8_t)(17))
S#define DMA_Channel_SW5           ((uint8_t)(18))
S#define DMA_Channel_SW6           ((uint8_t)(19))
S#define DMA_Channel_SW7           ((uint8_t)(20))
S#define DMA_Channel_SW8           ((uint8_t)(21))
S#define DMA_Channel_SW9           ((uint8_t)(22))
S#define DMA_Channel_SW10      ((uint8_t)(23))
S#define DMA_Channel_SW11      ((uint8_t)(24))
S#define DMA_Channel_SW12      ((uint8_t)(25))
S#define DMA_Channel_SW13      ((uint8_t)(26))
S#define DMA_Channel_SW14      ((uint8_t)(27))
S#define DMA_Channel_SW15      ((uint8_t)(28))
S#define DMA_Channel_SW16      ((uint8_t)(29))
S#define DMA_Channel_SW17      ((uint8_t)(30))
S#define DMA_Channel_SW18      ((uint8_t)(31))
S
S/*-- sreq DMA request --------------------------------------------------------*/
S#define DMA_Channel_SREQ_UART1_TX    ((uint8_t)(0))
S#define DMA_Channel_SREQ_UART1_RX    ((uint8_t)(1))
S#define DMA_Channel_SREQ_UART2_TX    ((uint8_t)(2))
S#define DMA_Channel_SREQ_UART2_RX    ((uint8_t)(3))
S#define DMA_Channel_SREQ_SSP1_TX     ((uint8_t)(4))
S#define DMA_Channel_SREQ_SSP1_RX     ((uint8_t)(5))
S#define DMA_Channel_SREQ_SSP2_TX     ((uint8_t)(6))
S#define DMA_Channel_SREQ_SSP2_RX     ((uint8_t)(7))
S#define DMA_Channel_SREQ_SSP3_TX     ((uint8_t)(8))
S#define DMA_Channel_SREQ_SSP3_RX     ((uint8_t)(9))
S#define DMA_Channel_SREQ_TIM1        ((uint8_t)(10))
S#define DMA_Channel_SREQ_TIM2        ((uint8_t)(11))
S#define DMA_Channel_SREQ_TIM3        ((uint8_t)(12))
S#define DMA_Channel_SREQ_TIM4        ((uint8_t)(13))
S#define DMA_Channel_SREQ_TIM1_REQ1   ((uint8_t)(14))
S#define DMA_Channel_SREQ_TIM1_REQ2   ((uint8_t)(15))
S#define DMA_Channel_SREQ_TIM1_REQ3   ((uint8_t)(16))
S#define DMA_Channel_SREQ_TIM1_REQ4   ((uint8_t)(17))
S#define DMA_Channel_SREQ_TIM2_REQ1   ((uint8_t)(18))
S#define DMA_Channel_SREQ_TIM2_REQ2   ((uint8_t)(19))
S#define DMA_Channel_SREQ_TIM2_REQ3   ((uint8_t)(20))
S#define DMA_Channel_SREQ_TIM2_REQ4   ((uint8_t)(21))
S#define DMA_Channel_SREQ_TIM3_REQ1   ((uint8_t)(22))
S#define DMA_Channel_SREQ_TIM3_REQ2   ((uint8_t)(23))
S#define DMA_Channel_SREQ_TIM3_REQ3   ((uint8_t)(24))
S#define DMA_Channel_SREQ_TIM3_REQ4   ((uint8_t)(25))
S#define DMA_Channel_SREQ_TIM4_REQ1   ((uint8_t)(26))
S#define DMA_Channel_SREQ_TIM4_REQ2   ((uint8_t)(27))
S#define DMA_Channel_SREQ_TIM4_REQ3   ((uint8_t)(28))
S#define DMA_Channel_SREQ_TIM4_REQ4   ((uint8_t)(29))
S#define DMA_Channel_SREQ_ADCDMA    ((uint8_t)(30))
S#define DMA_Channel_SREQ_SW1         ((uint8_t)(31))
S
S#elif defined (USE_MDR1986VE3)
S
S/*-- req DMA request ---------------------------------------------------------*/
S#define DMA_Channel_REQ_UART1_TX    ((uint8_t)(0))
S#define DMA_Channel_REQ_UART1_RX    ((uint8_t)(1))
S#define DMA_Channel_REQ_UART2_TX    ((uint8_t)(2))
S#define DMA_Channel_REQ_UART2_RX    ((uint8_t)(3))
S#define DMA_Channel_REQ_SSP1_TX     ((uint8_t)(4))
S#define DMA_Channel_REQ_SSP1_RX     ((uint8_t)(5))
S#define DMA_Channel_REQ_SSP2_TX     ((uint8_t)(6))
S#define DMA_Channel_REQ_SSP2_RX     ((uint8_t)(7))
S#define DMA_Channel_REQ_SSP3_TX     ((uint8_t)(8))
S#define DMA_Channel_REQ_SSP3_RX     ((uint8_t)(9))
S#define DMA_Channel_REQ_TIM1        ((uint8_t)(10))
S#define DMA_Channel_REQ_TIM2        ((uint8_t)(11))
S#define DMA_Channel_REQ_TIM3        ((uint8_t)(12))
S#define DMA_Channel_REQ_TIM4        ((uint8_t)(13))
S#define DMA_Channel_SW1           ((uint8_t)(14))
S#define DMA_Channel_SW2           ((uint8_t)(15))
S#define DMA_Channel_SW3             ((uint8_t)(16))
S#define DMA_Channel_SW4           ((uint8_t)(17))
S#define DMA_Channel_SW5           ((uint8_t)(18))
S#define DMA_Channel_SW6           ((uint8_t)(19))
S#define DMA_Channel_SW7           ((uint8_t)(20))
S#define DMA_Channel_SW8           ((uint8_t)(21))
S#define DMA_Channel_SW9           ((uint8_t)(22))
S#define DMA_Channel_REQ_SSP4_RX     ((uint8_t)(23))
S#define DMA_Channel_REQ_UART3_TX    ((uint8_t)(24))
S#define DMA_Channel_REQ_UART3_RX    ((uint8_t)(25))
S#define DMA_Channel_REQ_UART4_TX    ((uint8_t)(26))
S#define DMA_Channel_REQ_UART4_RX    ((uint8_t)(27))
S#define DMA_Channel_REQ_SSP4_TX     ((uint8_t)(28))
S#define DMA_Channel_REQ_AUDIO_TX  ((uint8_t)(29))
S#define DMA_Channel_SW10          ((uint8_t)(30))
S#define DMA_Channel_REQ_AUDIO_RX    ((uint8_t)(31))
S
S/*-- sreq DMA request --------------------------------------------------------*/
S#define DMA_Channel_SREQ_UART1_TX    ((uint8_t)(0))
S#define DMA_Channel_SREQ_UART1_RX    ((uint8_t)(1))
S#define DMA_Channel_SREQ_UART2_TX    ((uint8_t)(2))
S#define DMA_Channel_SREQ_UART2_RX    ((uint8_t)(3))
S#define DMA_Channel_SREQ_SSP1_TX     ((uint8_t)(4))
S#define DMA_Channel_SREQ_SSP1_RX     ((uint8_t)(5))
S#define DMA_Channel_SREQ_SSP2_TX     ((uint8_t)(6))
S#define DMA_Channel_SREQ_SSP2_RX     ((uint8_t)(7))
S#define DMA_Channel_SREQ_SSP3_TX     ((uint8_t)(8))
S#define DMA_Channel_SREQ_SSP3_RX     ((uint8_t)(9))
S#define DMA_Channel_SREQ_TIM1        ((uint8_t)(10))
S#define DMA_Channel_SREQ_TIM2        ((uint8_t)(11))
S#define DMA_Channel_SREQ_TIM3        ((uint8_t)(12))
S#define DMA_Channel_SREQ_TIM4        ((uint8_t)(13))
S#define DMA_Channel_SREQ_TIM1_REQ1   ((uint8_t)(14))
S#define DMA_Channel_SREQ_TIM1_REQ2   ((uint8_t)(15))
S#define DMA_Channel_SREQ_TIM1_REQ3   ((uint8_t)(16))
S#define DMA_Channel_SREQ_TIM1_REQ4   ((uint8_t)(17))
S#define DMA_Channel_SREQ_TIM2_REQ1   ((uint8_t)(18))
S#define DMA_Channel_SREQ_TIM2_REQ2   ((uint8_t)(19))
S#define DMA_Channel_SREQ_TIM2_REQ3   ((uint8_t)(20))
S#define DMA_Channel_SREQ_TIM2_REQ4   ((uint8_t)(21))
S#define DMA_Channel_SREQ_TIM3_REQ1   ((uint8_t)(22))
S#define DMA_Channel_SREQ_TIM3_REQ2   ((uint8_t)(23))
S#define DMA_Channel_SREQ_TIM3_REQ3   ((uint8_t)(24))
S#define DMA_Channel_SREQ_TIM3_REQ4   ((uint8_t)(25))
S#define DMA_Channel_SREQ_TIM4_REQ1   ((uint8_t)(26))
S#define DMA_Channel_SREQ_TIM4_REQ2   ((uint8_t)(27))
S#define DMA_Channel_SREQ_TIM4_REQ3   ((uint8_t)(28))
S#define DMA_Channel_SREQ_TIM4_REQ4   ((uint8_t)(29))
S#define DMA_Channel_SREQ_ADCDMA    ((uint8_t)(30))
S#define DMA_Channel_SREQ_SW1         ((uint8_t)(31))
S
S#elif defined (USE_MDR1901VC1T)
S
S/*-- req DMA request ---------------------------------------------------------*/
S#define DMA_Channel_REQ_UART1_TX    ((uint8_t)(0))
S#define DMA_Channel_REQ_UART1_RX    ((uint8_t)(1))
S#define DMA_Channel_REQ_UART2_TX    ((uint8_t)(2))
S#define DMA_Channel_REQ_UART2_RX    ((uint8_t)(3))
S#define DMA_Channel_REQ_SSP1_TX     ((uint8_t)(4))
S#define DMA_Channel_REQ_SSP1_RX     ((uint8_t)(5))
S#define DMA_Channel_REQ_SSP2_TX     ((uint8_t)(6))
S#define DMA_Channel_REQ_SSP2_RX     ((uint8_t)(7))
S
S#define DMA_Channel_REQ_DSP0        ((uint8_t)(9))
S#define DMA_Channel_REQ_DSP1        ((uint8_t)(10))
S
S#define DMA_Channel_REQ_DSP2        ((uint8_t)(14))
S#define DMA_Channel_REQ_DSP3        ((uint8_t)(15))
S#define DMA_Channel_REQ_SSP3_TX     ((uint8_t)(16))
S#define DMA_Channel_REQ_SSP3_RX     ((uint8_t)(17))
S#define DMA_Channel_REQ_SSP4_TX     ((uint8_t)(18))
S#define DMA_Channel_REQ_SSP4_RX     ((uint8_t)(19))
S#define DMA_Channel_REQ_UART3_TX    ((uint8_t)(20))
S#define DMA_Channel_REQ_UART3_RX    ((uint8_t)(21)
S#define DMA_Channel_REQ_AUC_ADC     ((uint8_t)(22))
S#define DMA_Channel_REQ_AUC_DAC     ((uint8_t)(23))
S#define DMA_Channel_REQ_CRYPTO      ((uint8_t)(24))
S#define DMA_Channel_REQ_DSP_TIM     ((uint8_t)(25))
S#define DMA_Channel_REQ_MCBSP1_TX   ((uint8_t)(26))
S#define DMA_Channel_REQ_MCBSP1_RX   ((uint8_t)(27))
S#define DMA_Channel_REQ_MCBSP2_TX   ((uint8_t)(28))
S#define DMA_Channel_REQ_MCBSP2_RX   ((uint8_t)(29))
S#define DMA_Channel_REQ_MCBSP3_TX   ((uint8_t)(30))
S#define DMA_Channel_REQ_MCBSP3_RX   ((uint8_t)(31))
S
S/*-- sreq DMA request --------------------------------------------------------*/
S#define DMA_Channel_SREQ_UART1_TX    ((uint8_t)(0))
S#define DMA_Channel_SREQ_UART1_RX    ((uint8_t)(1))
S#define DMA_Channel_SREQ_UART2_TX    ((uint8_t)(2))
S#define DMA_Channel_SREQ_UART2_RX    ((uint8_t)(3))
S#define DMA_Channel_SREQ_SSP1_TX     ((uint8_t)(4))
S#define DMA_Channel_SREQ_SSP1_RX     ((uint8_t)(5))
S#define DMA_Channel_SREQ_SSP2_TX     ((uint8_t)(6))
S#define DMA_Channel_SREQ_SSP2_RX     ((uint8_t)(7))
S#define DMA_Channel_SREQ_ADC1        ((uint8_t)(8))
S#define DMA_Channel_SREQ_ADC2        ((uint8_t)(9))
S#define DMA_Channel_SREQ_TIM1        ((uint8_t)(10))
S#define DMA_Channel_SREQ_TIM2        ((uint8_t)(11))
S#define DMA_Channel_SREQ_TIM3        ((uint8_t)(12))
S#define DMA_Channel_SREQ_SDIO        ((uint8_t)(13))
S#define DMA_Channel_SREQ_DSP0        ((uint8_t)(14))
S#define DMA_Channel_SREQ_DSP1        ((uint8_t)(15))
S#define DMA_Channel_SREQ_SSP3_TX     ((uint8_t)(16))
S#define DMA_Channel_SREQ_SSP3_RX     ((uint8_t)(17))
S#define DMA_Channel_SREQ_SSP4_TX     ((uint8_t)(18))
S#define DMA_Channel_SREQ_SSP4_RX     ((uint8_t)(19))
S#define DMA_Channel_SREQ_UART3_TX    ((uint8_t)(20))
S#define DMA_Channel_SREQ_UART3_RX    ((uint8_t)(21))
S
S#define DMA_Channel_SREQ_DSP_TIM     ((uint8_t)(25))
S#define DMA_Channel_SREQ_MCBSP1_TX   ((uint8_t)(26))
S#define DMA_Channel_SREQ_MCBSP1_RX   ((uint8_t)(27))
S#define DMA_Channel_SREQ_MCBSP2_TX   ((uint8_t)(28))
S#define DMA_Channel_SREQ_MCBSP2_RX   ((uint8_t)(29))
S#define DMA_Channel_SREQ_MCBSP3_TX   ((uint8_t)(30))
S#define DMA_Channel_SREQ_MCBSP3_RX   ((uint8_t)(31))
S
N#endif
N
N#define IS_DMA_CHANNEL(CHANNEL) ((CHANNEL) <= (DMA_Channels_Number - 1))
N
N/** @} */ /* End of group DMA_valid_channels */
N
N/** @defgroup DMA_source_incremented_mode DMA source incremented mode
N  * @{
N  */
N
N#define DMA_SourceIncByte                   ((uint32_t)(0 << 26))
N#define DMA_SourceIncHalfword               ((uint32_t)(1 << 26))
N#define DMA_SourceIncWord                   ((uint32_t)(2 << 26))
N#define DMA_SourceIncNo                     ((uint32_t)(3 << 26))
N#define IS_DMA_SOURCE_INC_STATE(STATE)      (((STATE) == DMA_SourceIncByte)     || \
N                                            ((STATE)  == DMA_SourceIncHalfword) || \
N                                            ((STATE)  == DMA_SourceIncWord)     || \
N                                            ((STATE)  == DMA_SourceIncNo))
X#define IS_DMA_SOURCE_INC_STATE(STATE)      (((STATE) == DMA_SourceIncByte)     ||                                             ((STATE)  == DMA_SourceIncHalfword) ||                                             ((STATE)  == DMA_SourceIncWord)     ||                                             ((STATE)  == DMA_SourceIncNo))
N
N/** @} */ /* End of group DMA_source_incremented_mode */
N
N/** @defgroup DMA_dest_incremented_mode DMA dest incremented mode
N  * @{
N  */
N
N#define DMA_DestIncByte                 ((uint32_t)(0x0UL << 30))
N#define DMA_DestIncHalfword             ((uint32_t)(0x1UL << 30))
N#define DMA_DestIncWord                 ((uint32_t)(0x2UL << 30))
N#define DMA_DestIncNo                   ((uint32_t)(0x3UL << 30))
N#define IS_DMA_DEST_INC_STATE(STATE)    (((STATE) == DMA_DestIncByte)       || \
N                                        ((STATE)  == DMA_DestIncHalfword)   || \
N                                        ((STATE)  == DMA_DestIncWord)       || \
N                                        ((STATE)  == DMA_DestIncNo))
X#define IS_DMA_DEST_INC_STATE(STATE)    (((STATE) == DMA_DestIncByte)       ||                                         ((STATE)  == DMA_DestIncHalfword)   ||                                         ((STATE)  == DMA_DestIncWord)       ||                                         ((STATE)  == DMA_DestIncNo))
N
N/** @} */ /* End of group DMA_dest_incremented_mode */
N
N/** @defgroup DMA_memory_data_size DMA memory data size
N  * @{
N  */
N
N#define DMA_MemoryDataSize_Byte        ((uint32_t)(0x00 << 24))
N#define DMA_MemoryDataSize_HalfWord    ((uint32_t)(0x11 << 24))
N#define DMA_MemoryDataSize_Word        ((uint32_t)(0x22 << 24))
N#define IS_DMA_MEMORY_DATA_SIZE(SIZE) (((SIZE) == DMA_MemoryDataSize_Byte)      || \
N                                       ((SIZE) == DMA_MemoryDataSize_HalfWord)  || \
N                                       ((SIZE) == DMA_MemoryDataSize_Word))
X#define IS_DMA_MEMORY_DATA_SIZE(SIZE) (((SIZE) == DMA_MemoryDataSize_Byte)      ||                                        ((SIZE) == DMA_MemoryDataSize_HalfWord)  ||                                        ((SIZE) == DMA_MemoryDataSize_Word))
N
N/** @} */ /* End of group DMA_memory_data_size */
N
N/** @defgroup DMA_operating_mode DMA operating mode
N  * @{
N  */
N
N#define DMA_Mode_Stop                       ((uint32_t)0x0)
N#define DMA_Mode_Basic                      ((uint32_t)0x1)
N#define DMA_Mode_AutoRequest                ((uint32_t)0x2)
N#define DMA_Mode_PingPong                   ((uint32_t)0x3)
N#define DMA_Mode_MemScatterPri              ((uint32_t)0x4)
N#define DMA_Mode_MemScatterAlt              ((uint32_t)0x5)
N#define DMA_Mode_PerScatterPri              ((uint32_t)0x6)
N#define DMA_Mode_PerScatterAlt              ((uint32_t)0x7)
N#define DMA_Mode_PerScatterAltBurst         ((uint32_t)0xF)
N
N#define IS_DMA_MODE(MODE)          (((MODE) == DMA_Mode_Stop)           || \
N                                    ((MODE) == DMA_Mode_Basic)          || \
N                                    ((MODE) == DMA_Mode_AutoRequest)    || \
N                                    ((MODE) == DMA_Mode_PingPong)       || \
N                                    ((MODE) == DMA_Mode_MemScatterPri)  || \
N                                    ((MODE) == DMA_Mode_MemScatterAlt)  || \
N                                    ((MODE) == DMA_Mode_PerScatterPri)  || \
N                                    ((MODE) == DMA_Mode_PerScatterAlt)  || \
N                                    ((MODE) == DMA_Mode_PerScatterAltBurst))
X#define IS_DMA_MODE(MODE)          (((MODE) == DMA_Mode_Stop)           ||                                     ((MODE) == DMA_Mode_Basic)          ||                                     ((MODE) == DMA_Mode_AutoRequest)    ||                                     ((MODE) == DMA_Mode_PingPong)       ||                                     ((MODE) == DMA_Mode_MemScatterPri)  ||                                     ((MODE) == DMA_Mode_MemScatterAlt)  ||                                     ((MODE) == DMA_Mode_PerScatterPri)  ||                                     ((MODE) == DMA_Mode_PerScatterAlt)  ||                                     ((MODE) == DMA_Mode_PerScatterAltBurst))
N
N/** @} */ /* End of group DMA_operating_mode */
N
N/** @defgroup DMA_cycle_size DMA cycle size
N  * @{
N  */
N
N#define IS_DMA_CYCLE_SIZE(SIZE)   (((SIZE) >= 1) && ((SIZE) <= 1024))
N
N/** @} */ /* End of group DMA_cycle_size */
N
N/** @defgroup DMA_priority_level DMA priority level
N  * @{
N  */
N
N#define DMA_Priority_Default                ((uint8_t)0x00)
N#define DMA_Priority_High                   ((uint8_t)0x01)
N#define IS_DMA_PRIORITY(PRIORITY)           (((PRIORITY) == DMA_Priority_Default) || \
N                                            ((PRIORITY)  == DMA_Priority_High))
X#define IS_DMA_PRIORITY(PRIORITY)           (((PRIORITY) == DMA_Priority_Default) ||                                             ((PRIORITY)  == DMA_Priority_High))
N
N/** @} */ /* End of group DMA_priority_level */
N
N/** @defgroup DMA_burst_mode DMA burst mode
N  * @{
N  */
N
N#define DMA_BurstClear                      ((uint8_t)0x00)
N#define DMA_BurstSet                        ((uint8_t)0x01)
N#define IS_DMA_BURST(STATE)                 (((STATE) == DMA_BurstClear) || \
N                                            ((STATE)  == DMA_BurstSet))
X#define IS_DMA_BURST(STATE)                 (((STATE) == DMA_BurstClear) ||                                             ((STATE)  == DMA_BurstSet))
N
N/** @} */ /* End of group DMA_burst_mode */
N
N
N/** @defgroup DMA_source_protection_control DMA source protection control
N  * @{
N  */
N
N#define DMA_SourceCacheable                 ((uint32_t)(0x01 << 20))
N#define DMA_SourceBufferable                ((uint32_t)(0x01 << 19))
N#define DMA_SourcePrivileged                ((uint32_t)(0x01 << 18))
N
N#define IS_DMA_SOURCE_PROT(STATE)           (((STATE) & (~(0x7 << 18))) == 0)
N
N/** @} */ /* End of group DMA_source_protection_control */
N
N/** @defgroup DMA_dest_protection_control DMA dest protection control
N  * @{
N  */
N
N#define DMA_DestCacheable                   ((uint32_t)(0x01 << 23))
N#define DMA_DestBufferable                  ((uint32_t)(0x01 << 22))
N#define DMA_DestPrivileged                  ((uint32_t)(0x01 << 21))
N
N#define IS_DMA_DEST_PROT(STATE)             (((STATE) & (~(0x7 << 21))) == 0)
N
N/** @} */ /* End of group DMA_dest_protection_control */
N
N/** @defgroup DMA_AHB_protection_control DMA AHB-Lite protection control
N  * @{
N  */
N
N#define DMA_AHB_Cacheable                 ((uint32_t)(0x01 << 7))
N#define DMA_AHB_Bufferable                ((uint32_t)(0x01 << 6))
N#define DMA_AHB_Privileged                ((uint32_t)(0x01 << 5))
N
N#define IS_DMA_AHB_PROT(STATE)            (((STATE) & (~(0x7 << 5))) == 0)
N
N/** @} */ /* End of group DMA_source_protection_control */
N
N/** @defgroup DMA_number_continuous_transfers DMA number continuous transfers
N  * @{
N  */
N
N#define DMA_Transfers_1                     ((uint32_t)(0x00 << 14))
N#define DMA_Transfers_2                     ((uint32_t)(0x01 << 14))
N#define DMA_Transfers_4                     ((uint32_t)(0x02 << 14))
N#define DMA_Transfers_8                     ((uint32_t)(0x03 << 14))
N#define DMA_Transfers_16                    ((uint32_t)(0x04 << 14))
N#define DMA_Transfers_32                    ((uint32_t)(0x05 << 14))
N#define DMA_Transfers_64                    ((uint32_t)(0x06 << 14))
N#define DMA_Transfers_128                   ((uint32_t)(0x07 << 14))
N#define DMA_Transfers_256                   ((uint32_t)(0x08 << 14))
N#define DMA_Transfers_512                   ((uint32_t)(0x09 << 14))
N#define DMA_Transfers_1024                  ((uint32_t)(0x0A << 14))
N
N#define IS_DMA_CONTINUOUS_NUMBER(NUMBER)   (((NUMBER)  == DMA_Transfers_1)      || \
N                                            ((NUMBER)  == DMA_Transfers_2)      || \
N                                            ((NUMBER)  == DMA_Transfers_4)      || \
N                                            ((NUMBER)  == DMA_Transfers_8)      || \
N                                            ((NUMBER)  == DMA_Transfers_16)     || \
N                                            ((NUMBER)  == DMA_Transfers_32)     || \
N                                            ((NUMBER)  == DMA_Transfers_64)     || \
N                                            ((NUMBER)  == DMA_Transfers_128)    || \
N                                            ((NUMBER)  == DMA_Transfers_256)    || \
N                                            ((NUMBER)  == DMA_Transfers_512)    || \
N                                            ((NUMBER)  == DMA_Transfers_1024))
X#define IS_DMA_CONTINUOUS_NUMBER(NUMBER)   (((NUMBER)  == DMA_Transfers_1)      ||                                             ((NUMBER)  == DMA_Transfers_2)      ||                                             ((NUMBER)  == DMA_Transfers_4)      ||                                             ((NUMBER)  == DMA_Transfers_8)      ||                                             ((NUMBER)  == DMA_Transfers_16)     ||                                             ((NUMBER)  == DMA_Transfers_32)     ||                                             ((NUMBER)  == DMA_Transfers_64)     ||                                             ((NUMBER)  == DMA_Transfers_128)    ||                                             ((NUMBER)  == DMA_Transfers_256)    ||                                             ((NUMBER)  == DMA_Transfers_512)    ||                                             ((NUMBER)  == DMA_Transfers_1024))
N
N/** @} */ /* End of group DMA_number_continuous_transfers */
N
N/** @defgroup DMA_data_structure_selection DMA data structure selection
N  * @{
N  */
N
N#define DMA_CTRL_DATA_PRIMARY   ((uint8_t)0x00)
N
N#if (DMA_AlternateData == 1)
X#if (1 == 1)
N
N  #define DMA_CTRL_DATA_ALTERNATE ((uint8_t)0x01)
N
N  #define IS_DMA_SELECT_DATA_STRUCTURE(TYPE) (((TYPE)  == DMA_CTRL_DATA_PRIMARY)      || \
N                                              ((TYPE)  == DMA_CTRL_DATA_ALTERNATE))
X  #define IS_DMA_SELECT_DATA_STRUCTURE(TYPE) (((TYPE)  == DMA_CTRL_DATA_PRIMARY)      ||                                               ((TYPE)  == DMA_CTRL_DATA_ALTERNATE))
N#else
S  #define IS_DMA_SELECT_DATA_STRUCTURE(TYPE) (((TYPE)  == DMA_CTRL_DATA_PRIMARY))
N#endif
N
N/** @} */ /* End of group DMA_data_structure_selection */
N
N/** @defgroup DMA_flags_definition DMA flags definition
N  * @{
N  */
N
N#define DMA_FLAG_DMA_ENA        ((uint8_t)0x01)
N#define DMA_FLAG_DMA_ERR        ((uint8_t)0x02)
N#define DMA_FLAG_CHNL_ENA       ((uint8_t)0x03)
N#define DMA_FLAG_CHNL_MASK      ((uint8_t)0x04)
N#define DMA_FLAG_CHNL_WAIT      ((uint8_t)0x05)
N#define DMA_FLAG_CHNL_BURST     ((uint8_t)0x06)
N#define DMA_FLAG_CHNL_ALT       ((uint8_t)0x07)
N#define DMA_FLAG_CHNL_PRIORITY  ((uint8_t)0x08)
N
N#define IS_DMA_FLAG(FLAG)       (((FLAG)  == DMA_FLAG_DMA_ENA)      || \
N                                 ((FLAG)  == DMA_FLAG_DMA_ERR)      || \
N                                 ((FLAG)  == DMA_FLAG_CHNL_ENA)     || \
N                                 ((FLAG)  == DMA_FLAG_CHNL_MASK)    || \
N                                 ((FLAG)  == DMA_FLAG_CHNL_WAIT)    || \
N                                 ((FLAG)  == DMA_FLAG_CHNL_BURST)   || \
N                                 ((FLAG)  == DMA_FLAG_CHNL_ALT)     || \
N                                 ((FLAG)  == DMA_FLAG_CHNL_PRIORITY))
X#define IS_DMA_FLAG(FLAG)       (((FLAG)  == DMA_FLAG_DMA_ENA)      ||                                  ((FLAG)  == DMA_FLAG_DMA_ERR)      ||                                  ((FLAG)  == DMA_FLAG_CHNL_ENA)     ||                                  ((FLAG)  == DMA_FLAG_CHNL_MASK)    ||                                  ((FLAG)  == DMA_FLAG_CHNL_WAIT)    ||                                  ((FLAG)  == DMA_FLAG_CHNL_BURST)   ||                                  ((FLAG)  == DMA_FLAG_CHNL_ALT)     ||                                  ((FLAG)  == DMA_FLAG_CHNL_PRIORITY))
N
N/** @} */ /* End of group DMA_flags_definition */
N
N/** @} */ /* End of group DMA_Exported_Constants */
N
N/** @defgroup DMA_Exported_Macros DMA Exported Macros
N  * @{
N  */
N
N/** @} */ /* End of group DMA_Exported_Macros */
N
N/** @defgroup DMA_Exported_Functions DMA Exported Functions
N  * @{
N  */
N
Nvoid DMA_DeInit(void);
Nvoid DMA_Init(uint8_t DMA_Channel, DMA_ChannelInitTypeDef* DMA_InitStruct);
Nvoid DMA_SG_Init( uint8_t DMA_Channel, DMA_Channel_SG_InitTypeDef *DMA_SG_InitStruct);
Nvoid DMA_StructInit(DMA_ChannelInitTypeDef* DMA_InitStruct);
Nvoid DMA_SG_StructInit(DMA_Channel_SG_InitTypeDef* DMA_InitStruct);
Nvoid DMA_CtrlInit(uint8_t DMA_Channel, uint8_t DMA_CtrlDataType,  DMA_CtrlDataInitTypeDef* DMA_CtrlStruct);
Nvoid DMA_SG_CtrlInit(uint32_t DMA_Task, DMA_CtrlDataTypeDef *DMA_SG_TaskArray,  DMA_CtrlDataInitTypeDef* DMA_CtrlStruct);
Nvoid DMA_Cmd(uint8_t DMA_Channel, FunctionalState NewState);
Nvoid DMA_Request(uint8_t DMA_Channel);
Nvoid DMA_ClearError(void);
Nuint32_t DMA_GetCurrTransferCounter(uint8_t DMA_Channel, uint8_t DMA_CtrlData);
NFlagStatus DMA_GetFlagStatus(uint8_t DMA_Channel, uint8_t DMA_Flag);
Nvoid DMA_CtrlDataInit(DMA_CtrlDataInitTypeDef *DMA_ctrl_data_ptr, DMA_CtrlDataTypeDef *DMA_ctrl_table_ptr);
N
N/** @} */ /* End of group DMA_Exported_Functions */
N
N/** @} */ /* End of group DMA */
N
N/** @} */ /* End of group __MDR32F9Qx_StdPeriph_Driver */
N
N#ifdef __cplusplus
S} // extern "C" block end
N#endif
N
N#endif /* __MDR32F9Qx_DMA_H */
N
N/*
N*
N* END OF FILE MDR32F9Qx_dma.h */
N
L 23 "common.h" 2
L 10 "adc.h" 2
N // Канал для измерения напряжения
N
N #define U_ADC_U_PIN     PORT_Pin_7
N// Размер буффера результатов измерений
N #define ADC_BUFFER_SIZE 200
N #define PING 0
N #define PONG 1
N // Калибровка вольтметра путем указания полученного значения
N// АЦП U_ADC_D для известного напряжения U_ADC_U на входе АЦП
N#define U_ADC_U 3.3F
N#define U_ADC_D 0x1000
N// Прототип функции инициализации АЦП
Nvoid ADC_init (void);
N
N
L 25 "adc.c" 2
N#include "FreeRTOS.h"
L 1 ".\rtos\include\FreeRTOS.h" 1
N/*
N    FreeRTOS V9.0.0 - Copyright (C) 2016 Real Time Engineers Ltd.
N    All rights reserved
N
N    VISIT http://www.FreeRTOS.org TO ENSURE YOU ARE USING THE LATEST VERSION.
N
N    This file is part of the FreeRTOS distribution.
N
N    FreeRTOS is free software; you can redistribute it and/or modify it under
N    the terms of the GNU General Public License (version 2) as published by the
N    Free Software Foundation >>>> AND MODIFIED BY <<<< the FreeRTOS exception.
N
N    ***************************************************************************
N    >>!   NOTE: The modification to the GPL is included to allow you to     !<<
N    >>!   distribute a combined work that includes FreeRTOS without being   !<<
N    >>!   obliged to provide the source code for proprietary components     !<<
N    >>!   outside of the FreeRTOS kernel.                                   !<<
N    ***************************************************************************
N
N    FreeRTOS is distributed in the hope that it will be useful, but WITHOUT ANY
N    WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
N    FOR A PARTICULAR PURPOSE.  Full license text is available on the following
N    link: http://www.freertos.org/a00114.html
N
N    ***************************************************************************
N     *                                                                       *
N     *    FreeRTOS provides completely free yet professionally developed,    *
N     *    robust, strictly quality controlled, supported, and cross          *
N     *    platform software that is more than just the market leader, it     *
N     *    is the industry's de facto standard.                               *
N     *                                                                       *
N     *    Help yourself get started quickly while simultaneously helping     *
N     *    to support the FreeRTOS project by purchasing a FreeRTOS           *
N     *    tutorial book, reference manual, or both:                          *
N     *    http://www.FreeRTOS.org/Documentation                              *
N     *                                                                       *
N    ***************************************************************************
N
N    http://www.FreeRTOS.org/FAQHelp.html - Having a problem?  Start by reading
N    the FAQ page "My application does not run, what could be wrong?".  Have you
N    defined configASSERT()?
N
N    http://www.FreeRTOS.org/support - In return for receiving this top quality
N    embedded software for free we request you assist our global community by
N    participating in the support forum.
N
N    http://www.FreeRTOS.org/training - Investing in training allows your team to
N    be as productive as possible as early as possible.  Now you can receive
N    FreeRTOS training directly from Richard Barry, CEO of Real Time Engineers
N    Ltd, and the world's leading authority on the world's leading RTOS.
N
N    http://www.FreeRTOS.org/plus - A selection of FreeRTOS ecosystem products,
N    including FreeRTOS+Trace - an indispensable productivity tool, a DOS
N    compatible FAT file system, and our tiny thread aware UDP/IP stack.
N
N    http://www.FreeRTOS.org/labs - Where new FreeRTOS products go to incubate.
N    Come and try FreeRTOS+TCP, our new open source TCP/IP stack for FreeRTOS.
N
N    http://www.OpenRTOS.com - Real Time Engineers ltd. license FreeRTOS to High
N    Integrity Systems ltd. to sell under the OpenRTOS brand.  Low cost OpenRTOS
N    licenses offer ticketed support, indemnification and commercial middleware.
N
N    http://www.SafeRTOS.com - High Integrity Systems also provide a safety
N    engineered and independently SIL3 certified version for use in safety and
N    mission critical applications that require provable dependability.
N
N    1 tab == 4 spaces!
N*/
N
N#ifndef INC_FREERTOS_H
N#define INC_FREERTOS_H
N
N/*
N * Include the generic headers required for the FreeRTOS port being used.
N */
N#include <stddef.h>
L 1 "C:\Keil_v5\ARM\ARMCC\Bin\..\include\stddef.h" 1
N/* stddef.h: ANSI 'C' (X3J11 Oct 88) library header, section 4.1.4 */
N
N/* Copyright (C) ARM Ltd., 1999
N * All rights reserved
N * RCS $Revision$
N * Checkin $Date$
N * Revising $Author: agrant $
N */
N
N/* Copyright (C) Codemist Ltd., 1988                            */
N/* Copyright 1991 ARM Limited. All rights reserved.             */
N/* version 0.05 */
N
N/*
N * The following types and macros are defined in several headers referred to in
N * the descriptions of the functions declared in that header. They are also
N * defined in this header file.
N */
N
N#ifndef __stddef_h
N#define __stddef_h
N#define __ARMCLIB_VERSION 5060034
N
N  #ifndef __STDDEF_DECLS
N  #define __STDDEF_DECLS
N    #undef __CLIBNS
N    #ifdef __cplusplus
S        namespace std {
S        #define __CLIBNS ::std::
S        extern "C" {
N    #else
N      #define __CLIBNS
N    #endif  /* __cplusplus */
N
N#if __sizeof_ptr == 8
X#if 4 == 8
S  typedef signed long ptrdiff_t;
N#else
N  typedef signed int ptrdiff_t;
N#endif
N
N#if defined(__cplusplus) || !defined(__STRICT_ANSI__)
X#if 0L || !0L
N /* unconditional in C++ and non-strict C for consistency of debug info */
N  #if __sizeof_ptr == 8
X  #if 4 == 8
S    typedef unsigned long size_t;   /* see <stddef.h> */
N  #else
N    typedef unsigned int size_t;   /* see <stddef.h> */
N  #endif
N#elif !defined(__size_t)
S  #define __size_t 1
S  #if __sizeof_ptr == 8
S    typedef unsigned long size_t;   /* see <stddef.h> */
S  #else
S    typedef unsigned int size_t;   /* see <stddef.h> */
S  #endif
S   /* the unsigned integral type of the result of the sizeof operator. */
N#endif
N
N#ifndef __cplusplus  /* wchar_t is a builtin type for C++ */
N  #if !defined(__STRICT_ANSI__)
X  #if !0L
N  /* unconditional in non-strict C for consistency of debug info */
N    #if defined(__WCHAR32) || (defined(__ARM_SIZEOF_WCHAR_T) && __ARM_SIZEOF_WCHAR_T == 4)
X    #if 0L || (0L && __ARM_SIZEOF_WCHAR_T == 4)
S      typedef unsigned int wchar_t; /* also in <stdlib.h> and <inttypes.h> */
N    #else
N      typedef unsigned short wchar_t; /* also in <stdlib.h> and <inttypes.h> */
N    #endif
N  #elif !defined(__wchar_t)
S    #define __wchar_t 1
S    #if defined(__WCHAR32) || (defined(__ARM_SIZEOF_WCHAR_T) && __ARM_SIZEOF_WCHAR_T == 4)
S      typedef unsigned int wchar_t; /* also in <stdlib.h> and <inttypes.h> */
S    #else
S      typedef unsigned short wchar_t; /* also in <stdlib.h> and <inttypes.h> */
S    #endif
S   /*
S    * An integral type whose range of values can represent distinct codes for
S    * all members of the largest extended character set specified among the
S    * supported locales; the null character shall have the code value zero and
S    * each member of the basic character set shall have a code value when used
S    * as the lone character in an integer character constant.
S    */
N  #endif
N#endif
N
N#undef NULL  /* others (e.g. <stdio.h>) also define */
N#define NULL 0
N   /* null pointer constant. */
N
N#ifdef __clang__
S  #define offsetof(t, d) __builtin_offsetof(t, d)
N#else
N  /* EDG uses __INTADDR__ to avoid errors when strict */
N  #define offsetof(t, memb) ((__CLIBNS size_t)__INTADDR__(&(((t *)0)->memb)))
N#endif
N
N#if !defined(__STRICT_ANSI__) || (defined(__STDC_VERSION__) && 201112L <= __STDC_VERSION__) || (defined(__cplusplus) && 201103L <= __cplusplus)
X#if !0L || (1L && 201112L <= 199409L) || (0L && 201103L <= __cplusplus)
N  typedef long double max_align_t;
N#endif
N
N    #ifdef __cplusplus
S         }  /* extern "C" */
S      }  /* namespace std */
N    #endif /* __cplusplus */
N  #endif /* __STDDEF_DECLS */
N
N
N  #ifdef __cplusplus
S    #ifndef __STDDEF_NO_EXPORTS
S      using ::std::size_t;
S      using ::std::ptrdiff_t;
S      #if !defined(__STRICT_ANSI__) || (defined(__cplusplus) && 201103L <= __cplusplus)
S        using ::std::max_align_t;
S      #endif
S    #endif 
N  #endif /* __cplusplus */
N
N#endif
N
N/* end of stddef.h */
N
L 77 ".\rtos\include\FreeRTOS.h" 2
N
N/*
N * If stdint.h cannot be located then:
N *   + If using GCC ensure the -nostdint options is *not* being used.
N *   + Ensure the project's include path includes the directory in which your
N *     compiler stores stdint.h.
N *   + Set any compiler options necessary for it to support C99, as technically
N *     stdint.h is only mandatory with C99 (FreeRTOS does not require C99 in any
N *     other way).
N *   + The FreeRTOS download includes a simple stdint.h definition that can be
N *     used in cases where none is provided by the compiler.  The files only
N *     contains the typedefs required to build FreeRTOS.  Read the instructions
N *     in FreeRTOS/source/stdint.readme for more information.
N */
N#include <stdint.h> /* READ COMMENT ABOVE. */
N
N#ifdef __cplusplus
Sextern "C" {
N#endif
N
N/* Application specific configuration options. */
N#include "FreeRTOSConfig.h"
L 1 ".\rtos\include\FreeRTOSConfig.h" 1
N#ifndef FREERTOS_CONFIG_H
N#define FREERTOS_CONFIG_H
N
N/* Here is a good place to include header files that are required across
Nyour application. */
N
N#define configUSE_PREEMPTION                    1
N#define configUSE_PORT_OPTIMISED_TASK_SELECTION 0
N#define configUSE_TICKLESS_IDLE                 0
N#define configCPU_CLOCK_HZ                      ( ( unsigned long ) 80000000 )
N#define configTICK_RATE_HZ                      1000
N#define configMAX_PRIORITIES                    5
N#define configMINIMAL_STACK_SIZE                128
N#define configMAX_TASK_NAME_LEN                 16
N#define configUSE_16_BIT_TICKS                  0
N#define configIDLE_SHOULD_YIELD                 1
N#define configUSE_TASK_NOTIFICATIONS            1
N#define configUSE_MUTEXES                       1
N#define configUSE_RECURSIVE_MUTEXES             1
N#define configUSE_COUNTING_SEMAPHORES           1
N#define configUSE_ALTERNATIVE_API               0 /* Deprecated! */
N#define configQUEUE_REGISTRY_SIZE               10
N#define configUSE_QUEUE_SETS                    0
N#define configUSE_TIME_SLICING                  0
N#define configUSE_NEWLIB_REENTRANT              0
N#define configENABLE_BACKWARD_COMPATIBILITY     0
N#define configNUM_THREAD_LOCAL_STORAGE_POINTERS 5
N/* Memory allocation related definitions. */
N#define configTOTAL_HEAP_SIZE                   ( ( size_t ) ( 20 * 1024 ) )
N#define configAPPLICATION_ALLOCATED_HEAP        0
N
N/* Hook function related definitions. */
N#define configUSE_IDLE_HOOK                     1
N#define configUSE_TICK_HOOK                     0
N#define configCHECK_FOR_STACK_OVERFLOW          0
N#define configUSE_MALLOC_FAILED_HOOK            0
N#define configUSE_DAEMON_TASK_STARTUP_HOOK      0
N
N/* Run time and task stats gathering related definitions. */
N#define configGENERATE_RUN_TIME_STATS           0
N#define configUSE_TRACE_FACILITY                0
N#define configUSE_STATS_FORMATTING_FUNCTIONS    0
N
N/* Co-routine related definitions. */
N#define configUSE_CO_ROUTINES                   0
N#define configMAX_CO_ROUTINE_PRIORITIES         2
N
N/* Software timer related definitions. */
N#define configUSE_TIMERS                        1
N#define configTIMER_TASK_PRIORITY               3
N#define configTIMER_QUEUE_LENGTH                10
N#define configTIMER_TASK_STACK_DEPTH            configMINIMAL_STACK_SIZE
N
N/* Interrupt nesting behaviour configuration. */
N#define configKERNEL_INTERRUPT_PRIORITY         255
N#define configMAX_SYSCALL_INTERRUPT_PRIORITY    191
N#define configMAX_API_CALL_INTERRUPT_PRIORITY   15
N
N/* FreeRTOS MPU specific definitions. */
N#define configINCLUDE_APPLICATION_DEFINED_PRIVILEGED_FUNCTIONS 0
N
N/* Optional functions - most linkers will remove unused functions anyway. */
N#define INCLUDE_vTaskPrioritySet                1
N#define INCLUDE_uxTaskPriorityGet               1
N#define INCLUDE_vTaskDelete                     1
N#define INCLUDE_vTaskSuspend                    1
N#define INCLUDE_xResumeFromISR                  1
N#define INCLUDE_vTaskDelayUntil                 1
N#define INCLUDE_vTaskDelay                      1
N#define INCLUDE_xTaskGetSchedulerState          1
N#define INCLUDE_xTaskGetCurrentTaskHandle       1
N#define INCLUDE_uxTaskGetStackHighWaterMark     0
N#define INCLUDE_xTaskGetIdleTaskHandle          0
N#define INCLUDE_eTaskGetState                   0
N#define INCLUDE_xEventGroupSetBitFromISR        1
N#define INCLUDE_xTimerPendFunctionCall          0
N#define INCLUDE_xTaskAbortDelay                 0
N#define INCLUDE_xTaskGetHandle                  0
N#define INCLUDE_xTaskResumeFromISR              1
N
N#define xPortSysTickHandler 					SysTick_Handler
N#define xPortPendSVHandler 						PendSV_Handler
N#define vPortSVCHandler 						SVC_Handler
N
N/* A header file that defines trace macro can be included here. */
N
N#endif /* FREERTOS_CONFIG_H */
L 99 ".\rtos\include\FreeRTOS.h" 2
N
N/* Basic FreeRTOS definitions. */
N#include "projdefs.h"
L 1 ".\rtos\include\projdefs.h" 1
N/*
N    FreeRTOS V9.0.0 - Copyright (C) 2016 Real Time Engineers Ltd.
N    All rights reserved
N
N    VISIT http://www.FreeRTOS.org TO ENSURE YOU ARE USING THE LATEST VERSION.
N
N    This file is part of the FreeRTOS distribution.
N
N    FreeRTOS is free software; you can redistribute it and/or modify it under
N    the terms of the GNU General Public License (version 2) as published by the
N    Free Software Foundation >>>> AND MODIFIED BY <<<< the FreeRTOS exception.
N
N    ***************************************************************************
N    >>!   NOTE: The modification to the GPL is included to allow you to     !<<
N    >>!   distribute a combined work that includes FreeRTOS without being   !<<
N    >>!   obliged to provide the source code for proprietary components     !<<
N    >>!   outside of the FreeRTOS kernel.                                   !<<
N    ***************************************************************************
N
N    FreeRTOS is distributed in the hope that it will be useful, but WITHOUT ANY
N    WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
N    FOR A PARTICULAR PURPOSE.  Full license text is available on the following
N    link: http://www.freertos.org/a00114.html
N
N    ***************************************************************************
N     *                                                                       *
N     *    FreeRTOS provides completely free yet professionally developed,    *
N     *    robust, strictly quality controlled, supported, and cross          *
N     *    platform software that is more than just the market leader, it     *
N     *    is the industry's de facto standard.                               *
N     *                                                                       *
N     *    Help yourself get started quickly while simultaneously helping     *
N     *    to support the FreeRTOS project by purchasing a FreeRTOS           *
N     *    tutorial book, reference manual, or both:                          *
N     *    http://www.FreeRTOS.org/Documentation                              *
N     *                                                                       *
N    ***************************************************************************
N
N    http://www.FreeRTOS.org/FAQHelp.html - Having a problem?  Start by reading
N    the FAQ page "My application does not run, what could be wrong?".  Have you
N    defined configASSERT()?
N
N    http://www.FreeRTOS.org/support - In return for receiving this top quality
N    embedded software for free we request you assist our global community by
N    participating in the support forum.
N
N    http://www.FreeRTOS.org/training - Investing in training allows your team to
N    be as productive as possible as early as possible.  Now you can receive
N    FreeRTOS training directly from Richard Barry, CEO of Real Time Engineers
N    Ltd, and the world's leading authority on the world's leading RTOS.
N
N    http://www.FreeRTOS.org/plus - A selection of FreeRTOS ecosystem products,
N    including FreeRTOS+Trace - an indispensable productivity tool, a DOS
N    compatible FAT file system, and our tiny thread aware UDP/IP stack.
N
N    http://www.FreeRTOS.org/labs - Where new FreeRTOS products go to incubate.
N    Come and try FreeRTOS+TCP, our new open source TCP/IP stack for FreeRTOS.
N
N    http://www.OpenRTOS.com - Real Time Engineers ltd. license FreeRTOS to High
N    Integrity Systems ltd. to sell under the OpenRTOS brand.  Low cost OpenRTOS
N    licenses offer ticketed support, indemnification and commercial middleware.
N
N    http://www.SafeRTOS.com - High Integrity Systems also provide a safety
N    engineered and independently SIL3 certified version for use in safety and
N    mission critical applications that require provable dependability.
N
N    1 tab == 4 spaces!
N*/
N
N#ifndef PROJDEFS_H
N#define PROJDEFS_H
N
N/*
N * Defines the prototype to which task functions must conform.  Defined in this
N * file to ensure the type is known before portable.h is included.
N */
Ntypedef void (*TaskFunction_t)( void * );
N
N/* Converts a time in milliseconds to a time in ticks.  This macro can be
Noverridden by a macro of the same name defined in FreeRTOSConfig.h in case the
Ndefinition here is not suitable for your application. */
N#ifndef pdMS_TO_TICKS
N	#define pdMS_TO_TICKS( xTimeInMs ) ( ( TickType_t ) ( ( ( TickType_t ) ( xTimeInMs ) * ( TickType_t ) configTICK_RATE_HZ ) / ( TickType_t ) 1000 ) )
N#endif
N
N#define pdFALSE			( ( BaseType_t ) 0 )
N#define pdTRUE			( ( BaseType_t ) 1 )
N
N#define pdPASS			( pdTRUE )
N#define pdFAIL			( pdFALSE )
N#define errQUEUE_EMPTY	( ( BaseType_t ) 0 )
N#define errQUEUE_FULL	( ( BaseType_t ) 0 )
N
N/* FreeRTOS error definitions. */
N#define errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY	( -1 )
N#define errQUEUE_BLOCKED						( -4 )
N#define errQUEUE_YIELD							( -5 )
N
N/* Macros used for basic data corruption checks. */
N#ifndef configUSE_LIST_DATA_INTEGRITY_CHECK_BYTES
N	#define configUSE_LIST_DATA_INTEGRITY_CHECK_BYTES 0
N#endif
N
N#if( configUSE_16_BIT_TICKS == 1 )
X#if( 0 == 1 )
S	#define pdINTEGRITY_CHECK_VALUE 0x5a5a
N#else
N	#define pdINTEGRITY_CHECK_VALUE 0x5a5a5a5aUL
N#endif
N
N/* The following errno values are used by FreeRTOS+ components, not FreeRTOS
Nitself. */
N#define pdFREERTOS_ERRNO_NONE			0	/* No errors */
N#define	pdFREERTOS_ERRNO_ENOENT			2	/* No such file or directory */
N#define	pdFREERTOS_ERRNO_EINTR			4	/* Interrupted system call */
N#define	pdFREERTOS_ERRNO_EIO			5	/* I/O error */
N#define	pdFREERTOS_ERRNO_ENXIO			6	/* No such device or address */
N#define	pdFREERTOS_ERRNO_EBADF			9	/* Bad file number */
N#define	pdFREERTOS_ERRNO_EAGAIN			11	/* No more processes */
N#define	pdFREERTOS_ERRNO_EWOULDBLOCK	11	/* Operation would block */
N#define	pdFREERTOS_ERRNO_ENOMEM			12	/* Not enough memory */
N#define	pdFREERTOS_ERRNO_EACCES			13	/* Permission denied */
N#define	pdFREERTOS_ERRNO_EFAULT			14	/* Bad address */
N#define	pdFREERTOS_ERRNO_EBUSY			16	/* Mount device busy */
N#define	pdFREERTOS_ERRNO_EEXIST			17	/* File exists */
N#define	pdFREERTOS_ERRNO_EXDEV			18	/* Cross-device link */
N#define	pdFREERTOS_ERRNO_ENODEV			19	/* No such device */
N#define	pdFREERTOS_ERRNO_ENOTDIR		20	/* Not a directory */
N#define	pdFREERTOS_ERRNO_EISDIR			21	/* Is a directory */
N#define	pdFREERTOS_ERRNO_EINVAL			22	/* Invalid argument */
N#define	pdFREERTOS_ERRNO_ENOSPC			28	/* No space left on device */
N#define	pdFREERTOS_ERRNO_ESPIPE			29	/* Illegal seek */
N#define	pdFREERTOS_ERRNO_EROFS			30	/* Read only file system */
N#define	pdFREERTOS_ERRNO_EUNATCH		42	/* Protocol driver not attached */
N#define	pdFREERTOS_ERRNO_EBADE			50	/* Invalid exchange */
N#define	pdFREERTOS_ERRNO_EFTYPE			79	/* Inappropriate file type or format */
N#define	pdFREERTOS_ERRNO_ENMFILE		89	/* No more files */
N#define	pdFREERTOS_ERRNO_ENOTEMPTY		90	/* Directory not empty */
N#define	pdFREERTOS_ERRNO_ENAMETOOLONG 	91	/* File or path name too long */
N#define	pdFREERTOS_ERRNO_EOPNOTSUPP		95	/* Operation not supported on transport endpoint */
N#define	pdFREERTOS_ERRNO_ENOBUFS		105	/* No buffer space available */
N#define	pdFREERTOS_ERRNO_ENOPROTOOPT	109	/* Protocol not available */
N#define	pdFREERTOS_ERRNO_EADDRINUSE		112	/* Address already in use */
N#define	pdFREERTOS_ERRNO_ETIMEDOUT		116	/* Connection timed out */
N#define	pdFREERTOS_ERRNO_EINPROGRESS	119	/* Connection already in progress */
N#define	pdFREERTOS_ERRNO_EALREADY		120	/* Socket already connected */
N#define	pdFREERTOS_ERRNO_EADDRNOTAVAIL 	125	/* Address not available */
N#define	pdFREERTOS_ERRNO_EISCONN		127	/* Socket is already connected */
N#define	pdFREERTOS_ERRNO_ENOTCONN		128	/* Socket is not connected */
N#define	pdFREERTOS_ERRNO_ENOMEDIUM		135	/* No medium inserted */
N#define	pdFREERTOS_ERRNO_EILSEQ			138	/* An invalid UTF-16 sequence was encountered. */
N#define	pdFREERTOS_ERRNO_ECANCELED		140	/* Operation canceled. */
N
N/* The following endian values are used by FreeRTOS+ components, not FreeRTOS
Nitself. */
N#define pdFREERTOS_LITTLE_ENDIAN	0
N#define pdFREERTOS_BIG_ENDIAN		1
N
N#endif /* PROJDEFS_H */
N
N
N
L 102 ".\rtos\include\FreeRTOS.h" 2
N
N/* Definitions specific to the port being used. */
N#include "portable.h"
L 1 ".\rtos\include\portable.h" 1
N/*
N    FreeRTOS V9.0.0 - Copyright (C) 2016 Real Time Engineers Ltd.
N    All rights reserved
N
N    VISIT http://www.FreeRTOS.org TO ENSURE YOU ARE USING THE LATEST VERSION.
N
N    This file is part of the FreeRTOS distribution.
N
N    FreeRTOS is free software; you can redistribute it and/or modify it under
N    the terms of the GNU General Public License (version 2) as published by the
N    Free Software Foundation >>>> AND MODIFIED BY <<<< the FreeRTOS exception.
N
N    ***************************************************************************
N    >>!   NOTE: The modification to the GPL is included to allow you to     !<<
N    >>!   distribute a combined work that includes FreeRTOS without being   !<<
N    >>!   obliged to provide the source code for proprietary components     !<<
N    >>!   outside of the FreeRTOS kernel.                                   !<<
N    ***************************************************************************
N
N    FreeRTOS is distributed in the hope that it will be useful, but WITHOUT ANY
N    WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
N    FOR A PARTICULAR PURPOSE.  Full license text is available on the following
N    link: http://www.freertos.org/a00114.html
N
N    ***************************************************************************
N     *                                                                       *
N     *    FreeRTOS provides completely free yet professionally developed,    *
N     *    robust, strictly quality controlled, supported, and cross          *
N     *    platform software that is more than just the market leader, it     *
N     *    is the industry's de facto standard.                               *
N     *                                                                       *
N     *    Help yourself get started quickly while simultaneously helping     *
N     *    to support the FreeRTOS project by purchasing a FreeRTOS           *
N     *    tutorial book, reference manual, or both:                          *
N     *    http://www.FreeRTOS.org/Documentation                              *
N     *                                                                       *
N    ***************************************************************************
N
N    http://www.FreeRTOS.org/FAQHelp.html - Having a problem?  Start by reading
N    the FAQ page "My application does not run, what could be wrong?".  Have you
N    defined configASSERT()?
N
N    http://www.FreeRTOS.org/support - In return for receiving this top quality
N    embedded software for free we request you assist our global community by
N    participating in the support forum.
N
N    http://www.FreeRTOS.org/training - Investing in training allows your team to
N    be as productive as possible as early as possible.  Now you can receive
N    FreeRTOS training directly from Richard Barry, CEO of Real Time Engineers
N    Ltd, and the world's leading authority on the world's leading RTOS.
N
N    http://www.FreeRTOS.org/plus - A selection of FreeRTOS ecosystem products,
N    including FreeRTOS+Trace - an indispensable productivity tool, a DOS
N    compatible FAT file system, and our tiny thread aware UDP/IP stack.
N
N    http://www.FreeRTOS.org/labs - Where new FreeRTOS products go to incubate.
N    Come and try FreeRTOS+TCP, our new open source TCP/IP stack for FreeRTOS.
N
N    http://www.OpenRTOS.com - Real Time Engineers ltd. license FreeRTOS to High
N    Integrity Systems ltd. to sell under the OpenRTOS brand.  Low cost OpenRTOS
N    licenses offer ticketed support, indemnification and commercial middleware.
N
N    http://www.SafeRTOS.com - High Integrity Systems also provide a safety
N    engineered and independently SIL3 certified version for use in safety and
N    mission critical applications that require provable dependability.
N
N    1 tab == 4 spaces!
N*/
N
N/*-----------------------------------------------------------
N * Portable layer API.  Each function must be defined for each port.
N *----------------------------------------------------------*/
N
N#ifndef PORTABLE_H
N#define PORTABLE_H
N
N/* Each FreeRTOS port has a unique portmacro.h header file.  Originally a
Npre-processor definition was used to ensure the pre-processor found the correct
Nportmacro.h file for the port being used.  That scheme was deprecated in favour
Nof setting the compiler's include path such that it found the correct
Nportmacro.h file - removing the need for the constant and allowing the
Nportmacro.h file to be located anywhere in relation to the port being used.
NPurely for reasons of backward compatibility the old method is still valid, but
Nto make it clear that new projects should not use it, support for the port
Nspecific constants has been moved into the deprecated_definitions.h header
Nfile. */
N#include "deprecated_definitions.h"
L 1 ".\rtos\include\deprecated_definitions.h" 1
N/*
N    FreeRTOS V9.0.0 - Copyright (C) 2016 Real Time Engineers Ltd.
N    All rights reserved
N
N    VISIT http://www.FreeRTOS.org TO ENSURE YOU ARE USING THE LATEST VERSION.
N
N    This file is part of the FreeRTOS distribution.
N
N    FreeRTOS is free software; you can redistribute it and/or modify it under
N    the terms of the GNU General Public License (version 2) as published by the
N    Free Software Foundation >>>> AND MODIFIED BY <<<< the FreeRTOS exception.
N
N    ***************************************************************************
N    >>!   NOTE: The modification to the GPL is included to allow you to     !<<
N    >>!   distribute a combined work that includes FreeRTOS without being   !<<
N    >>!   obliged to provide the source code for proprietary components     !<<
N    >>!   outside of the FreeRTOS kernel.                                   !<<
N    ***************************************************************************
N
N    FreeRTOS is distributed in the hope that it will be useful, but WITHOUT ANY
N    WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
N    FOR A PARTICULAR PURPOSE.  Full license text is available on the following
N    link: http://www.freertos.org/a00114.html
N
N    ***************************************************************************
N     *                                                                       *
N     *    FreeRTOS provides completely free yet professionally developed,    *
N     *    robust, strictly quality controlled, supported, and cross          *
N     *    platform software that is more than just the market leader, it     *
N     *    is the industry's de facto standard.                               *
N     *                                                                       *
N     *    Help yourself get started quickly while simultaneously helping     *
N     *    to support the FreeRTOS project by purchasing a FreeRTOS           *
N     *    tutorial book, reference manual, or both:                          *
N     *    http://www.FreeRTOS.org/Documentation                              *
N     *                                                                       *
N    ***************************************************************************
N
N    http://www.FreeRTOS.org/FAQHelp.html - Having a problem?  Start by reading
N    the FAQ page "My application does not run, what could be wrong?".  Have you
N    defined configASSERT()?
N
N    http://www.FreeRTOS.org/support - In return for receiving this top quality
N    embedded software for free we request you assist our global community by
N    participating in the support forum.
N
N    http://www.FreeRTOS.org/training - Investing in training allows your team to
N    be as productive as possible as early as possible.  Now you can receive
N    FreeRTOS training directly from Richard Barry, CEO of Real Time Engineers
N    Ltd, and the world's leading authority on the world's leading RTOS.
N
N    http://www.FreeRTOS.org/plus - A selection of FreeRTOS ecosystem products,
N    including FreeRTOS+Trace - an indispensable productivity tool, a DOS
N    compatible FAT file system, and our tiny thread aware UDP/IP stack.
N
N    http://www.FreeRTOS.org/labs - Where new FreeRTOS products go to incubate.
N    Come and try FreeRTOS+TCP, our new open source TCP/IP stack for FreeRTOS.
N
N    http://www.OpenRTOS.com - Real Time Engineers ltd. license FreeRTOS to High
N    Integrity Systems ltd. to sell under the OpenRTOS brand.  Low cost OpenRTOS
N    licenses offer ticketed support, indemnification and commercial middleware.
N
N    http://www.SafeRTOS.com - High Integrity Systems also provide a safety
N    engineered and independently SIL3 certified version for use in safety and
N    mission critical applications that require provable dependability.
N
N    1 tab == 4 spaces!
N*/
N
N#ifndef DEPRECATED_DEFINITIONS_H
N#define DEPRECATED_DEFINITIONS_H
N
N
N/* Each FreeRTOS port has a unique portmacro.h header file.  Originally a
Npre-processor definition was used to ensure the pre-processor found the correct
Nportmacro.h file for the port being used.  That scheme was deprecated in favour
Nof setting the compiler's include path such that it found the correct
Nportmacro.h file - removing the need for the constant and allowing the
Nportmacro.h file to be located anywhere in relation to the port being used.  The
Ndefinitions below remain in the code for backward compatibility only.  New
Nprojects should not use them. */
N
N#ifdef OPEN_WATCOM_INDUSTRIAL_PC_PORT
S	#include "..\..\Source\portable\owatcom\16bitdos\pc\portmacro.h"
S	typedef void ( __interrupt __far *pxISR )();
N#endif
N
N#ifdef OPEN_WATCOM_FLASH_LITE_186_PORT
S	#include "..\..\Source\portable\owatcom\16bitdos\flsh186\portmacro.h"
S	typedef void ( __interrupt __far *pxISR )();
N#endif
N
N#ifdef GCC_MEGA_AVR
S	#include "../portable/GCC/ATMega323/portmacro.h"
N#endif
N
N#ifdef IAR_MEGA_AVR
S	#include "../portable/IAR/ATMega323/portmacro.h"
N#endif
N
N#ifdef MPLAB_PIC24_PORT
S	#include "../../Source/portable/MPLAB/PIC24_dsPIC/portmacro.h"
N#endif
N
N#ifdef MPLAB_DSPIC_PORT
S	#include "../../Source/portable/MPLAB/PIC24_dsPIC/portmacro.h"
N#endif
N
N#ifdef MPLAB_PIC18F_PORT
S	#include "../../Source/portable/MPLAB/PIC18F/portmacro.h"
N#endif
N
N#ifdef MPLAB_PIC32MX_PORT
S	#include "../../Source/portable/MPLAB/PIC32MX/portmacro.h"
N#endif
N
N#ifdef _FEDPICC
S	#include "libFreeRTOS/Include/portmacro.h"
N#endif
N
N#ifdef SDCC_CYGNAL
S	#include "../../Source/portable/SDCC/Cygnal/portmacro.h"
N#endif
N
N#ifdef GCC_ARM7
S	#include "../../Source/portable/GCC/ARM7_LPC2000/portmacro.h"
N#endif
N
N#ifdef GCC_ARM7_ECLIPSE
S	#include "portmacro.h"
N#endif
N
N#ifdef ROWLEY_LPC23xx
S	#include "../../Source/portable/GCC/ARM7_LPC23xx/portmacro.h"
N#endif
N
N#ifdef IAR_MSP430
S	#include "..\..\Source\portable\IAR\MSP430\portmacro.h"
N#endif
N
N#ifdef GCC_MSP430
S	#include "../../Source/portable/GCC/MSP430F449/portmacro.h"
N#endif
N
N#ifdef ROWLEY_MSP430
S	#include "../../Source/portable/Rowley/MSP430F449/portmacro.h"
N#endif
N
N#ifdef ARM7_LPC21xx_KEIL_RVDS
S	#include "..\..\Source\portable\RVDS\ARM7_LPC21xx\portmacro.h"
N#endif
N
N#ifdef SAM7_GCC
S	#include "../../Source/portable/GCC/ARM7_AT91SAM7S/portmacro.h"
N#endif
N
N#ifdef SAM7_IAR
S	#include "..\..\Source\portable\IAR\AtmelSAM7S64\portmacro.h"
N#endif
N
N#ifdef SAM9XE_IAR
S	#include "..\..\Source\portable\IAR\AtmelSAM9XE\portmacro.h"
N#endif
N
N#ifdef LPC2000_IAR
S	#include "..\..\Source\portable\IAR\LPC2000\portmacro.h"
N#endif
N
N#ifdef STR71X_IAR
S	#include "..\..\Source\portable\IAR\STR71x\portmacro.h"
N#endif
N
N#ifdef STR75X_IAR
S	#include "..\..\Source\portable\IAR\STR75x\portmacro.h"
N#endif
N
N#ifdef STR75X_GCC
S	#include "..\..\Source\portable\GCC\STR75x\portmacro.h"
N#endif
N
N#ifdef STR91X_IAR
S	#include "..\..\Source\portable\IAR\STR91x\portmacro.h"
N#endif
N
N#ifdef GCC_H8S
S	#include "../../Source/portable/GCC/H8S2329/portmacro.h"
N#endif
N
N#ifdef GCC_AT91FR40008
S	#include "../../Source/portable/GCC/ARM7_AT91FR40008/portmacro.h"
N#endif
N
N#ifdef RVDS_ARMCM3_LM3S102
S	#include "../../Source/portable/RVDS/ARM_CM3/portmacro.h"
N#endif
N
N#ifdef GCC_ARMCM3_LM3S102
S	#include "../../Source/portable/GCC/ARM_CM3/portmacro.h"
N#endif
N
N#ifdef GCC_ARMCM3
S	#include "../../Source/portable/GCC/ARM_CM3/portmacro.h"
N#endif
N
N#ifdef IAR_ARM_CM3
S	#include "../../Source/portable/IAR/ARM_CM3/portmacro.h"
N#endif
N
N#ifdef IAR_ARMCM3_LM
S	#include "../../Source/portable/IAR/ARM_CM3/portmacro.h"
N#endif
N
N#ifdef HCS12_CODE_WARRIOR
S	#include "../../Source/portable/CodeWarrior/HCS12/portmacro.h"
N#endif
N
N#ifdef MICROBLAZE_GCC
S	#include "../../Source/portable/GCC/MicroBlaze/portmacro.h"
N#endif
N
N#ifdef TERN_EE
S	#include "..\..\Source\portable\Paradigm\Tern_EE\small\portmacro.h"
N#endif
N
N#ifdef GCC_HCS12
S	#include "../../Source/portable/GCC/HCS12/portmacro.h"
N#endif
N
N#ifdef GCC_MCF5235
S    #include "../../Source/portable/GCC/MCF5235/portmacro.h"
N#endif
N
N#ifdef COLDFIRE_V2_GCC
S	#include "../../../Source/portable/GCC/ColdFire_V2/portmacro.h"
N#endif
N
N#ifdef COLDFIRE_V2_CODEWARRIOR
S	#include "../../Source/portable/CodeWarrior/ColdFire_V2/portmacro.h"
N#endif
N
N#ifdef GCC_PPC405
S	#include "../../Source/portable/GCC/PPC405_Xilinx/portmacro.h"
N#endif
N
N#ifdef GCC_PPC440
S	#include "../../Source/portable/GCC/PPC440_Xilinx/portmacro.h"
N#endif
N
N#ifdef _16FX_SOFTUNE
S	#include "..\..\Source\portable\Softune\MB96340\portmacro.h"
N#endif
N
N#ifdef BCC_INDUSTRIAL_PC_PORT
S	/* A short file name has to be used in place of the normal
S	FreeRTOSConfig.h when using the Borland compiler. */
S	#include "frconfig.h"
S	#include "..\portable\BCC\16BitDOS\PC\prtmacro.h"
S    typedef void ( __interrupt __far *pxISR )();
N#endif
N
N#ifdef BCC_FLASH_LITE_186_PORT
S	/* A short file name has to be used in place of the normal
S	FreeRTOSConfig.h when using the Borland compiler. */
S	#include "frconfig.h"
S	#include "..\portable\BCC\16BitDOS\flsh186\prtmacro.h"
S    typedef void ( __interrupt __far *pxISR )();
N#endif
N
N#ifdef __GNUC__
S   #ifdef __AVR32_AVR32A__
S	   #include "portmacro.h"
S   #endif
N#endif
N
N#ifdef __ICCAVR32__
S   #ifdef __CORE__
S      #if __CORE__ == __AVR32A__
S	      #include "portmacro.h"
S      #endif
S   #endif
N#endif
N
N#ifdef __91467D
S	#include "portmacro.h"
N#endif
N
N#ifdef __96340
S	#include "portmacro.h"
N#endif
N
N
N#ifdef __IAR_V850ES_Fx3__
S	#include "../../Source/portable/IAR/V850ES/portmacro.h"
N#endif
N
N#ifdef __IAR_V850ES_Jx3__
S	#include "../../Source/portable/IAR/V850ES/portmacro.h"
N#endif
N
N#ifdef __IAR_V850ES_Jx3_L__
S	#include "../../Source/portable/IAR/V850ES/portmacro.h"
N#endif
N
N#ifdef __IAR_V850ES_Jx2__
S	#include "../../Source/portable/IAR/V850ES/portmacro.h"
N#endif
N
N#ifdef __IAR_V850ES_Hx2__
S	#include "../../Source/portable/IAR/V850ES/portmacro.h"
N#endif
N
N#ifdef __IAR_78K0R_Kx3__
S	#include "../../Source/portable/IAR/78K0R/portmacro.h"
N#endif
N
N#ifdef __IAR_78K0R_Kx3L__
S	#include "../../Source/portable/IAR/78K0R/portmacro.h"
N#endif
N
N#endif /* DEPRECATED_DEFINITIONS_H */
N
L 88 ".\rtos\include\portable.h" 2
N
N/* If portENTER_CRITICAL is not defined then including deprecated_definitions.h
Ndid not result in a portmacro.h header file being included - and it should be
Nincluded here.  In this case the path to the correct portmacro.h header file
Nmust be set in the compiler's include path. */
N#ifndef portENTER_CRITICAL
N	#include "portmacro.h"
L 1 ".\rtos\include\portmacro.h" 1
N/*
N    FreeRTOS V9.0.0 - Copyright (C) 2016 Real Time Engineers Ltd.
N    All rights reserved
N
N    VISIT http://www.FreeRTOS.org TO ENSURE YOU ARE USING THE LATEST VERSION.
N
N    This file is part of the FreeRTOS distribution.
N
N    FreeRTOS is free software; you can redistribute it and/or modify it under
N    the terms of the GNU General Public License (version 2) as published by the
N    Free Software Foundation >>>> AND MODIFIED BY <<<< the FreeRTOS exception.
N
N    ***************************************************************************
N    >>!   NOTE: The modification to the GPL is included to allow you to     !<<
N    >>!   distribute a combined work that includes FreeRTOS without being   !<<
N    >>!   obliged to provide the source code for proprietary components     !<<
N    >>!   outside of the FreeRTOS kernel.                                   !<<
N    ***************************************************************************
N
N    FreeRTOS is distributed in the hope that it will be useful, but WITHOUT ANY
N    WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
N    FOR A PARTICULAR PURPOSE.  Full license text is available on the following
N    link: http://www.freertos.org/a00114.html
N
N    ***************************************************************************
N     *                                                                       *
N     *    FreeRTOS provides completely free yet professionally developed,    *
N     *    robust, strictly quality controlled, supported, and cross          *
N     *    platform software that is more than just the market leader, it     *
N     *    is the industry's de facto standard.                               *
N     *                                                                       *
N     *    Help yourself get started quickly while simultaneously helping     *
N     *    to support the FreeRTOS project by purchasing a FreeRTOS           *
N     *    tutorial book, reference manual, or both:                          *
N     *    http://www.FreeRTOS.org/Documentation                              *
N     *                                                                       *
N    ***************************************************************************
N
N    http://www.FreeRTOS.org/FAQHelp.html - Having a problem?  Start by reading
N    the FAQ page "My application does not run, what could be wrong?".  Have you
N    defined configASSERT()?
N
N    http://www.FreeRTOS.org/support - In return for receiving this top quality
N    embedded software for free we request you assist our global community by
N    participating in the support forum.
N
N    http://www.FreeRTOS.org/training - Investing in training allows your team to
N    be as productive as possible as early as possible.  Now you can receive
N    FreeRTOS training directly from Richard Barry, CEO of Real Time Engineers
N    Ltd, and the world's leading authority on the world's leading RTOS.
N
N    http://www.FreeRTOS.org/plus - A selection of FreeRTOS ecosystem products,
N    including FreeRTOS+Trace - an indispensable productivity tool, a DOS
N    compatible FAT file system, and our tiny thread aware UDP/IP stack.
N
N    http://www.FreeRTOS.org/labs - Where new FreeRTOS products go to incubate.
N    Come and try FreeRTOS+TCP, our new open source TCP/IP stack for FreeRTOS.
N
N    http://www.OpenRTOS.com - Real Time Engineers ltd. license FreeRTOS to High
N    Integrity Systems ltd. to sell under the OpenRTOS brand.  Low cost OpenRTOS
N    licenses offer ticketed support, indemnification and commercial middleware.
N
N    http://www.SafeRTOS.com - High Integrity Systems also provide a safety
N    engineered and independently SIL3 certified version for use in safety and
N    mission critical applications that require provable dependability.
N
N    1 tab == 4 spaces!
N*/
N
N
N#ifndef PORTMACRO_H
N#define PORTMACRO_H
N
N#include "FreeRTOSConfig.h"
N#include "projdefs.h"
N#ifdef __cplusplus
Sextern "C" {
N#endif
N
N/*-----------------------------------------------------------
N * Port specific definitions.
N *
N * The settings in this file configure FreeRTOS correctly for the
N * given hardware and compiler.
N *
N * These settings should not be altered.
N *-----------------------------------------------------------
N */
N
N/* Type definitions. */
N#define portCHAR		char
N#define portFLOAT		float
N#define portDOUBLE		double
N#define portLONG		long
N#define portSHORT		short
N#define portSTACK_TYPE	uint32_t
N#define portBASE_TYPE	long
N
Ntypedef portSTACK_TYPE StackType_t;
Xtypedef uint32_t StackType_t;
Ntypedef long BaseType_t;
Ntypedef unsigned long UBaseType_t;
N
N#if( configUSE_16_BIT_TICKS == 1 )
X#if( 0 == 1 )
S	typedef uint16_t TickType_t;
S	#define portMAX_DELAY ( TickType_t ) 0xffff
N#else
N	typedef uint32_t TickType_t;
N	#define portMAX_DELAY ( TickType_t ) 0xffffffffUL
N
N	/* 32-bit tick type on a 32-bit architecture, so reads of the tick count do
N	not need to be guarded with a critical section. */
N	#define portTICK_TYPE_IS_ATOMIC 1
N	
N#endif
N#define portTickType TickType_t
N/*-----------------------------------------------------------*/
N
N/* Architecture specifics. */
N#define portSTACK_GROWTH			( -1 )
N#define portTICK_PERIOD_MS			( ( TickType_t ) 1000 / configTICK_RATE_HZ )
N#define portBYTE_ALIGNMENT			8
N
N/* Constants used with memory barrier intrinsics. */
N#define portSY_FULL_READ_WRITE		( 15 )
N
N/*-----------------------------------------------------------*/
N
N/* Scheduler utilities. */
N#define portYIELD()																\
N{																				\
N	/* Set a PendSV to request a context switch. */								\
N	portNVIC_INT_CTRL_REG = portNVIC_PENDSVSET_BIT;								\
N																				\
N	/* Barriers are normally not required but do ensure the code is completely	\
N	within the specified behaviour for the architecture. */						\
N	__dsb( portSY_FULL_READ_WRITE );											\
N	__isb( portSY_FULL_READ_WRITE );											\
N}
X#define portYIELD()																{																					 									portNVIC_INT_CTRL_REG = portNVIC_PENDSVSET_BIT;																													 							__dsb( portSY_FULL_READ_WRITE );												__isb( portSY_FULL_READ_WRITE );											}
N/*-----------------------------------------------------------*/
N
N#define portNVIC_INT_CTRL_REG		( * ( ( volatile uint32_t * ) 0xe000ed04 ) )
N#define portNVIC_PENDSVSET_BIT		( 1UL << 28UL )
N#define portEND_SWITCHING_ISR( xSwitchRequired ) if( xSwitchRequired != pdFALSE ) portYIELD()
N#define portYIELD_FROM_ISR( x ) portEND_SWITCHING_ISR( x )
N/*-----------------------------------------------------------*/
N
N/* Critical section management. */
Nextern void vPortEnterCritical( void );
Nextern void vPortExitCritical( void );
N
N#define portDISABLE_INTERRUPTS()				vPortRaiseBASEPRI()
N#define portENABLE_INTERRUPTS()					vPortSetBASEPRI( 0 )
N#define portENTER_CRITICAL()					vPortEnterCritical()
N#define portEXIT_CRITICAL()						vPortExitCritical()
N#define portSET_INTERRUPT_MASK_FROM_ISR()		ulPortRaiseBASEPRI()
N#define portCLEAR_INTERRUPT_MASK_FROM_ISR(x)	vPortSetBASEPRI(x)
N
N/*-----------------------------------------------------------*/
N
N/* Tickless idle/low power functionality. */
N#ifndef portSUPPRESS_TICKS_AND_SLEEP
N	extern void vPortSuppressTicksAndSleep( TickType_t xExpectedIdleTime );
N	#define portSUPPRESS_TICKS_AND_SLEEP( xExpectedIdleTime ) vPortSuppressTicksAndSleep( xExpectedIdleTime )
N#endif
N/*-----------------------------------------------------------*/
N
N/* Port specific optimisations. */
N#ifndef configUSE_PORT_OPTIMISED_TASK_SELECTION
S	#define configUSE_PORT_OPTIMISED_TASK_SELECTION 1
N#endif
N
N#if configUSE_PORT_OPTIMISED_TASK_SELECTION == 1
X#if 0 == 1
S
S	/* Check the configuration. */
S	#if( configMAX_PRIORITIES > 32 )
S		#error configUSE_PORT_OPTIMISED_TASK_SELECTION can only be set to 1 when configMAX_PRIORITIES is less than or equal to 32.  It is very rare that a system requires more than 10 to 15 difference priorities as tasks that share a priority will time slice.
S	#endif
S
S	/* Store/clear the ready priorities in a bit map. */
S	#define portRECORD_READY_PRIORITY( uxPriority, uxReadyPriorities ) ( uxReadyPriorities ) |= ( 1UL << ( uxPriority ) )
S	#define portRESET_READY_PRIORITY( uxPriority, uxReadyPriorities ) ( uxReadyPriorities ) &= ~( 1UL << ( uxPriority ) )
S
S	/*-----------------------------------------------------------*/
S
S	#define portGET_HIGHEST_PRIORITY( uxTopPriority, uxReadyPriorities ) uxTopPriority = ( 31UL - ( uint32_t ) __clz( ( uxReadyPriorities ) ) )
S
N#endif /* taskRECORD_READY_PRIORITY */
N/*-----------------------------------------------------------*/
N
N/* Task function macros as described on the FreeRTOS.org WEB site.  These are
Nnot necessary for to use this port.  They are defined so the common demo files
N(which build with all the ports) will build. */
N#define portTASK_FUNCTION_PROTO( vFunction, pvParameters ) void vFunction( void *pvParameters )
N#define portTASK_FUNCTION( vFunction, pvParameters ) void vFunction( void *pvParameters )
N/*-----------------------------------------------------------*/
N
N#ifdef configASSERT
S	void vPortValidateInterruptPriority( void );
S	#define portASSERT_IF_INTERRUPT_PRIORITY_INVALID() 	vPortValidateInterruptPriority()
N#endif
N
N/* portNOP() is not required by this port. */
N#define portNOP()
N
N#define portINLINE __inline
N
N#ifndef portFORCE_INLINE
N	#define portFORCE_INLINE __forceinline
N#endif
N
N/*-----------------------------------------------------------*/
N
Nstatic portFORCE_INLINE void vPortSetBASEPRI( uint32_t ulBASEPRI )
Xstatic __forceinline void vPortSetBASEPRI( uint32_t ulBASEPRI )
N{
N	__asm
N	{
N		/* Barrier instructions are not used as this function is only used to
N		lower the BASEPRI value. */
N		msr basepri, ulBASEPRI
N	}
N}
N/*-----------------------------------------------------------*/
N
Nstatic portFORCE_INLINE void vPortRaiseBASEPRI( void )
Xstatic __forceinline void vPortRaiseBASEPRI( void )
N{
Nuint32_t ulNewBASEPRI = configMAX_SYSCALL_INTERRUPT_PRIORITY;
Xuint32_t ulNewBASEPRI = 191;
N
N	__asm
N	{
N		/* Set BASEPRI to the max syscall priority to effect a critical
N		section. */
N		msr basepri, ulNewBASEPRI
N		dsb
N		isb
N	}
N}
N/*-----------------------------------------------------------*/
N
Nstatic portFORCE_INLINE void vPortClearBASEPRIFromISR( void )
Xstatic __forceinline void vPortClearBASEPRIFromISR( void )
N{
N	__asm
N	{
N		/* Set BASEPRI to 0 so no interrupts are masked.  This function is only
N		used to lower the mask in an interrupt, so memory barriers are not 
N		used. */
N		msr basepri, #0
N	}
N}
N/*-----------------------------------------------------------*/
N
Nstatic portFORCE_INLINE uint32_t ulPortRaiseBASEPRI( void )
Xstatic __forceinline uint32_t ulPortRaiseBASEPRI( void )
N{
Nuint32_t ulReturn, ulNewBASEPRI = configMAX_SYSCALL_INTERRUPT_PRIORITY;
Xuint32_t ulReturn, ulNewBASEPRI = 191;
N
N	__asm
N	{
N		/* Set BASEPRI to the max syscall priority to effect a critical
N		section. */
N		mrs ulReturn, basepri
N		msr basepri, ulNewBASEPRI
N		dsb
N		isb
N	}
N
N	return ulReturn;
N}
N/*-----------------------------------------------------------*/
N
Nstatic portFORCE_INLINE BaseType_t xPortIsInsideInterrupt( void )
Xstatic __forceinline BaseType_t xPortIsInsideInterrupt( void )
N{
Nuint32_t ulCurrentInterrupt;
NBaseType_t xReturn;
N
N	/* Obtain the number of the currently executing interrupt. */
N	__asm
N	{
N		mrs ulCurrentInterrupt, ipsr
N	}
N
N	if( ulCurrentInterrupt == 0 )
N	{
N		xReturn = pdFALSE;
X		xReturn = ( ( BaseType_t ) 0 );
N	}
N	else
N	{
N		xReturn = pdTRUE;
X		xReturn = ( ( BaseType_t ) 1 );
N	}
N
N	return xReturn;
N}
N
N
N#ifdef __cplusplus
S}
N#endif
N
N#endif /* PORTMACRO_H */
N
L 95 ".\rtos\include\portable.h" 2
N#endif
N
N#if portBYTE_ALIGNMENT == 32
X#if 8 == 32
S	#define portBYTE_ALIGNMENT_MASK ( 0x001f )
N#endif
N
N#if portBYTE_ALIGNMENT == 16
X#if 8 == 16
S	#define portBYTE_ALIGNMENT_MASK ( 0x000f )
N#endif
N
N#if portBYTE_ALIGNMENT == 8
X#if 8 == 8
N	#define portBYTE_ALIGNMENT_MASK ( 0x0007 )
N#endif
N
N#if portBYTE_ALIGNMENT == 4
X#if 8 == 4
S	#define portBYTE_ALIGNMENT_MASK	( 0x0003 )
N#endif
N
N#if portBYTE_ALIGNMENT == 2
X#if 8 == 2
S	#define portBYTE_ALIGNMENT_MASK	( 0x0001 )
N#endif
N
N#if portBYTE_ALIGNMENT == 1
X#if 8 == 1
S	#define portBYTE_ALIGNMENT_MASK	( 0x0000 )
N#endif
N
N#ifndef portBYTE_ALIGNMENT_MASK
S	#error "Invalid portBYTE_ALIGNMENT definition"
N#endif
N
N#ifndef portNUM_CONFIGURABLE_REGIONS
N	#define portNUM_CONFIGURABLE_REGIONS 1
N#endif
N
N#ifdef __cplusplus
Sextern "C" {
N#endif
N
N#include "mpu_wrappers.h"
L 1 ".\rtos\include\mpu_wrappers.h" 1
N/*
N    FreeRTOS V9.0.0 - Copyright (C) 2016 Real Time Engineers Ltd.
N    All rights reserved
N
N    VISIT http://www.FreeRTOS.org TO ENSURE YOU ARE USING THE LATEST VERSION.
N
N    This file is part of the FreeRTOS distribution.
N
N    FreeRTOS is free software; you can redistribute it and/or modify it under
N    the terms of the GNU General Public License (version 2) as published by the
N    Free Software Foundation >>>> AND MODIFIED BY <<<< the FreeRTOS exception.
N
N    ***************************************************************************
N    >>!   NOTE: The modification to the GPL is included to allow you to     !<<
N    >>!   distribute a combined work that includes FreeRTOS without being   !<<
N    >>!   obliged to provide the source code for proprietary components     !<<
N    >>!   outside of the FreeRTOS kernel.                                   !<<
N    ***************************************************************************
N
N    FreeRTOS is distributed in the hope that it will be useful, but WITHOUT ANY
N    WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
N    FOR A PARTICULAR PURPOSE.  Full license text is available on the following
N    link: http://www.freertos.org/a00114.html
N
N    ***************************************************************************
N     *                                                                       *
N     *    FreeRTOS provides completely free yet professionally developed,    *
N     *    robust, strictly quality controlled, supported, and cross          *
N     *    platform software that is more than just the market leader, it     *
N     *    is the industry's de facto standard.                               *
N     *                                                                       *
N     *    Help yourself get started quickly while simultaneously helping     *
N     *    to support the FreeRTOS project by purchasing a FreeRTOS           *
N     *    tutorial book, reference manual, or both:                          *
N     *    http://www.FreeRTOS.org/Documentation                              *
N     *                                                                       *
N    ***************************************************************************
N
N    http://www.FreeRTOS.org/FAQHelp.html - Having a problem?  Start by reading
N    the FAQ page "My application does not run, what could be wrong?".  Have you
N    defined configASSERT()?
N
N    http://www.FreeRTOS.org/support - In return for receiving this top quality
N    embedded software for free we request you assist our global community by
N    participating in the support forum.
N
N    http://www.FreeRTOS.org/training - Investing in training allows your team to
N    be as productive as possible as early as possible.  Now you can receive
N    FreeRTOS training directly from Richard Barry, CEO of Real Time Engineers
N    Ltd, and the world's leading authority on the world's leading RTOS.
N
N    http://www.FreeRTOS.org/plus - A selection of FreeRTOS ecosystem products,
N    including FreeRTOS+Trace - an indispensable productivity tool, a DOS
N    compatible FAT file system, and our tiny thread aware UDP/IP stack.
N
N    http://www.FreeRTOS.org/labs - Where new FreeRTOS products go to incubate.
N    Come and try FreeRTOS+TCP, our new open source TCP/IP stack for FreeRTOS.
N
N    http://www.OpenRTOS.com - Real Time Engineers ltd. license FreeRTOS to High
N    Integrity Systems ltd. to sell under the OpenRTOS brand.  Low cost OpenRTOS
N    licenses offer ticketed support, indemnification and commercial middleware.
N
N    http://www.SafeRTOS.com - High Integrity Systems also provide a safety
N    engineered and independently SIL3 certified version for use in safety and
N    mission critical applications that require provable dependability.
N
N    1 tab == 4 spaces!
N*/
N
N#ifndef MPU_WRAPPERS_H
N#define MPU_WRAPPERS_H
N
N/* This file redefines API functions to be called through a wrapper macro, but
Nonly for ports that are using the MPU. */
N#ifdef portUSING_MPU_WRAPPERS
S
S	/* MPU_WRAPPERS_INCLUDED_FROM_API_FILE will be defined when this file is
S	included from queue.c or task.c to prevent it from having an effect within
S	those files. */
S	#ifndef MPU_WRAPPERS_INCLUDED_FROM_API_FILE
S
S		/*
S		 * Map standard (non MPU) API functions to equivalents that start
S		 * "MPU_".  This will cause the application code to call the MPU_
S		 * version, which wraps the non-MPU version with privilege promoting
S		 * then demoting code, so the kernel code always runs will full
S		 * privileges.
S		 */
S
S		/* Map standard tasks.h API functions to the MPU equivalents. */
S		#define xTaskCreate								MPU_xTaskCreate
S		#define xTaskCreateStatic						MPU_xTaskCreateStatic
S		#define xTaskCreateRestricted					MPU_xTaskCreateRestricted
S		#define vTaskAllocateMPURegions					MPU_vTaskAllocateMPURegions
S		#define vTaskDelete								MPU_vTaskDelete
S		#define vTaskDelay								MPU_vTaskDelay
S		#define vTaskDelayUntil							MPU_vTaskDelayUntil
S		#define xTaskAbortDelay							MPU_xTaskAbortDelay
S		#define uxTaskPriorityGet						MPU_uxTaskPriorityGet
S		#define eTaskGetState							MPU_eTaskGetState
S		#define vTaskGetInfo							MPU_vTaskGetInfo
S		#define vTaskPrioritySet						MPU_vTaskPrioritySet
S		#define vTaskSuspend							MPU_vTaskSuspend
S		#define vTaskResume								MPU_vTaskResume
S		#define vTaskSuspendAll							MPU_vTaskSuspendAll
S		#define xTaskResumeAll							MPU_xTaskResumeAll
S		#define xTaskGetTickCount						MPU_xTaskGetTickCount
S		#define uxTaskGetNumberOfTasks					MPU_uxTaskGetNumberOfTasks
S		#define pcTaskGetName							MPU_pcTaskGetName
S		#define xTaskGetHandle							MPU_xTaskGetHandle
S		#define uxTaskGetStackHighWaterMark				MPU_uxTaskGetStackHighWaterMark
S		#define vTaskSetApplicationTaskTag				MPU_vTaskSetApplicationTaskTag
S		#define xTaskGetApplicationTaskTag				MPU_xTaskGetApplicationTaskTag
S		#define vTaskSetThreadLocalStoragePointer		MPU_vTaskSetThreadLocalStoragePointer
S		#define pvTaskGetThreadLocalStoragePointer		MPU_pvTaskGetThreadLocalStoragePointer
S		#define xTaskCallApplicationTaskHook			MPU_xTaskCallApplicationTaskHook
S		#define xTaskGetIdleTaskHandle					MPU_xTaskGetIdleTaskHandle
S		#define uxTaskGetSystemState					MPU_uxTaskGetSystemState
S		#define vTaskList								MPU_vTaskList
S		#define vTaskGetRunTimeStats					MPU_vTaskGetRunTimeStats
S		#define xTaskGenericNotify						MPU_xTaskGenericNotify
S		#define xTaskNotifyWait							MPU_xTaskNotifyWait
S		#define ulTaskNotifyTake						MPU_ulTaskNotifyTake
S		#define xTaskNotifyStateClear					MPU_xTaskNotifyStateClear
S
S		#define xTaskGetCurrentTaskHandle				MPU_xTaskGetCurrentTaskHandle
S		#define vTaskSetTimeOutState					MPU_vTaskSetTimeOutState
S		#define xTaskCheckForTimeOut					MPU_xTaskCheckForTimeOut
S		#define xTaskGetSchedulerState					MPU_xTaskGetSchedulerState
S
S		/* Map standard queue.h API functions to the MPU equivalents. */
S		#define xQueueGenericSend						MPU_xQueueGenericSend
S		#define xQueueGenericReceive					MPU_xQueueGenericReceive
S		#define uxQueueMessagesWaiting					MPU_uxQueueMessagesWaiting
S		#define uxQueueSpacesAvailable					MPU_uxQueueSpacesAvailable
S		#define vQueueDelete							MPU_vQueueDelete
S		#define xQueueCreateMutex						MPU_xQueueCreateMutex
S		#define xQueueCreateMutexStatic					MPU_xQueueCreateMutexStatic
S		#define xQueueCreateCountingSemaphore			MPU_xQueueCreateCountingSemaphore
S		#define xQueueCreateCountingSemaphoreStatic		MPU_xQueueCreateCountingSemaphoreStatic
S		#define xQueueGetMutexHolder					MPU_xQueueGetMutexHolder
S		#define xQueueTakeMutexRecursive				MPU_xQueueTakeMutexRecursive
S		#define xQueueGiveMutexRecursive				MPU_xQueueGiveMutexRecursive
S		#define xQueueGenericCreate						MPU_xQueueGenericCreate
S		#define xQueueGenericCreateStatic				MPU_xQueueGenericCreateStatic
S		#define xQueueCreateSet							MPU_xQueueCreateSet
S		#define xQueueAddToSet							MPU_xQueueAddToSet
S		#define xQueueRemoveFromSet						MPU_xQueueRemoveFromSet
S		#define xQueueSelectFromSet						MPU_xQueueSelectFromSet
S		#define xQueueGenericReset						MPU_xQueueGenericReset
S
S		#if( configQUEUE_REGISTRY_SIZE > 0 )
S			#define vQueueAddToRegistry						MPU_vQueueAddToRegistry
S			#define vQueueUnregisterQueue					MPU_vQueueUnregisterQueue
S			#define pcQueueGetName							MPU_pcQueueGetName
S		#endif
S
S		/* Map standard timer.h API functions to the MPU equivalents. */
S		#define xTimerCreate							MPU_xTimerCreate
S		#define xTimerCreateStatic						MPU_xTimerCreateStatic
S		#define pvTimerGetTimerID						MPU_pvTimerGetTimerID
S		#define vTimerSetTimerID						MPU_vTimerSetTimerID
S		#define xTimerIsTimerActive						MPU_xTimerIsTimerActive
S		#define xTimerGetTimerDaemonTaskHandle			MPU_xTimerGetTimerDaemonTaskHandle
S		#define xTimerPendFunctionCall					MPU_xTimerPendFunctionCall
S		#define pcTimerGetName							MPU_pcTimerGetName
S		#define xTimerGetPeriod							MPU_xTimerGetPeriod
S		#define xTimerGetExpiryTime						MPU_xTimerGetExpiryTime
S		#define xTimerGenericCommand					MPU_xTimerGenericCommand
S
S		/* Map standard event_group.h API functions to the MPU equivalents. */
S		#define xEventGroupCreate						MPU_xEventGroupCreate
S		#define xEventGroupCreateStatic					MPU_xEventGroupCreateStatic
S		#define xEventGroupWaitBits						MPU_xEventGroupWaitBits
S		#define xEventGroupClearBits					MPU_xEventGroupClearBits
S		#define xEventGroupSetBits						MPU_xEventGroupSetBits
S		#define xEventGroupSync							MPU_xEventGroupSync
S		#define vEventGroupDelete						MPU_vEventGroupDelete
S
S		/* Remove the privileged function macro. */
S		#define PRIVILEGED_FUNCTION
S
S	#else /* MPU_WRAPPERS_INCLUDED_FROM_API_FILE */
S
S		/* Ensure API functions go in the privileged execution section. */
S		#define PRIVILEGED_FUNCTION __attribute__((section("privileged_functions")))
S		#define PRIVILEGED_DATA __attribute__((section("privileged_data")))
S
S	#endif /* MPU_WRAPPERS_INCLUDED_FROM_API_FILE */
S
N#else /* portUSING_MPU_WRAPPERS */
N
N	#define PRIVILEGED_FUNCTION
N	#define PRIVILEGED_DATA
N	#define portUSING_MPU_WRAPPERS 0
N
N#endif /* portUSING_MPU_WRAPPERS */
N
N
N#endif /* MPU_WRAPPERS_H */
N
L 134 ".\rtos\include\portable.h" 2
N
N/*
N * Setup the stack of a new task so it is ready to be placed under the
N * scheduler control.  The registers have to be placed on the stack in
N * the order that the port expects to find them.
N *
N */
N#if( portUSING_MPU_WRAPPERS == 1 )
X#if( 0 == 1 )
S	StackType_t *pxPortInitialiseStack( StackType_t *pxTopOfStack, TaskFunction_t pxCode, void *pvParameters, BaseType_t xRunPrivileged ) PRIVILEGED_FUNCTION;
N#else
N	StackType_t *pxPortInitialiseStack( StackType_t *pxTopOfStack, TaskFunction_t pxCode, void *pvParameters ) PRIVILEGED_FUNCTION;
X	StackType_t *pxPortInitialiseStack( StackType_t *pxTopOfStack, TaskFunction_t pxCode, void *pvParameters ) ;
N#endif
N
N/* Used by heap_5.c. */
Ntypedef struct HeapRegion
N{
N	uint8_t *pucStartAddress;
N	size_t xSizeInBytes;
N} HeapRegion_t;
N
N/*
N * Used to define multiple heap regions for use by heap_5.c.  This function
N * must be called before any calls to pvPortMalloc() - not creating a task,
N * queue, semaphore, mutex, software timer, event group, etc. will result in
N * pvPortMalloc being called.
N *
N * pxHeapRegions passes in an array of HeapRegion_t structures - each of which
N * defines a region of memory that can be used as the heap.  The array is
N * terminated by a HeapRegions_t structure that has a size of 0.  The region
N * with the lowest start address must appear first in the array.
N */
Nvoid vPortDefineHeapRegions( const HeapRegion_t * const pxHeapRegions ) PRIVILEGED_FUNCTION;
Xvoid vPortDefineHeapRegions( const HeapRegion_t * const pxHeapRegions ) ;
N
N
N/*
N * Map to the memory management routines required for the port.
N */
Nvoid *pvPortMalloc( size_t xSize ) PRIVILEGED_FUNCTION;
Xvoid *pvPortMalloc( size_t xSize ) ;
Nvoid vPortFree( void *pv ) PRIVILEGED_FUNCTION;
Xvoid vPortFree( void *pv ) ;
Nvoid vPortInitialiseBlocks( void ) PRIVILEGED_FUNCTION;
Xvoid vPortInitialiseBlocks( void ) ;
Nsize_t xPortGetFreeHeapSize( void ) PRIVILEGED_FUNCTION;
Xsize_t xPortGetFreeHeapSize( void ) ;
Nsize_t xPortGetMinimumEverFreeHeapSize( void ) PRIVILEGED_FUNCTION;
Xsize_t xPortGetMinimumEverFreeHeapSize( void ) ;
N
N/*
N * Setup the hardware ready for the scheduler to take control.  This generally
N * sets up a tick interrupt and sets timers for the correct tick frequency.
N */
NBaseType_t xPortStartScheduler( void ) PRIVILEGED_FUNCTION;
XBaseType_t xPortStartScheduler( void ) ;
N
N/*
N * Undo any hardware/ISR setup that was performed by xPortStartScheduler() so
N * the hardware is left in its original condition after the scheduler stops
N * executing.
N */
Nvoid vPortEndScheduler( void ) PRIVILEGED_FUNCTION;
Xvoid vPortEndScheduler( void ) ;
N
N/*
N * The structures and methods of manipulating the MPU are contained within the
N * port layer.
N *
N * Fills the xMPUSettings structure with the memory region information
N * contained in xRegions.
N */
N#if( portUSING_MPU_WRAPPERS == 1 )
X#if( 0 == 1 )
S	struct xMEMORY_REGION;
S	void vPortStoreTaskMPUSettings( xMPU_SETTINGS *xMPUSettings, const struct xMEMORY_REGION * const xRegions, StackType_t *pxBottomOfStack, uint32_t ulStackDepth ) PRIVILEGED_FUNCTION;
N#endif
N
N#ifdef __cplusplus
S}
N#endif
N
N#endif /* PORTABLE_H */
N
L 105 ".\rtos\include\FreeRTOS.h" 2
N
N/* Must be defaulted before configUSE_NEWLIB_REENTRANT is used below. */
N#ifndef configUSE_NEWLIB_REENTRANT
S	#define configUSE_NEWLIB_REENTRANT 0
N#endif
N
N/* Required if struct _reent is used. */
N#if ( configUSE_NEWLIB_REENTRANT == 1 )
X#if ( 0 == 1 )
S	#include <reent.h>
N#endif
N/*
N * Check all the required application specific macros have been defined.
N * These macros are application specific and (as downloaded) are defined
N * within FreeRTOSConfig.h.
N */
N
N#ifndef configMINIMAL_STACK_SIZE
S	#error Missing definition:  configMINIMAL_STACK_SIZE must be defined in FreeRTOSConfig.h.  configMINIMAL_STACK_SIZE defines the size (in words) of the stack allocated to the idle task.  Refer to the demo project provided for your port for a suitable value.
N#endif
N
N#ifndef configMAX_PRIORITIES
S	#error Missing definition:  configMAX_PRIORITIES must be defined in FreeRTOSConfig.h.  See the Configuration section of the FreeRTOS API documentation for details.
N#endif
N
N#ifndef configUSE_PREEMPTION
S	#error Missing definition:  configUSE_PREEMPTION must be defined in FreeRTOSConfig.h as either 1 or 0.  See the Configuration section of the FreeRTOS API documentation for details.
N#endif
N
N#ifndef configUSE_IDLE_HOOK
S	#error Missing definition:  configUSE_IDLE_HOOK must be defined in FreeRTOSConfig.h as either 1 or 0.  See the Configuration section of the FreeRTOS API documentation for details.
N#endif
N
N#ifndef configUSE_TICK_HOOK
S	#error Missing definition:  configUSE_TICK_HOOK must be defined in FreeRTOSConfig.h as either 1 or 0.  See the Configuration section of the FreeRTOS API documentation for details.
N#endif
N
N#ifndef configUSE_16_BIT_TICKS
S	#error Missing definition:  configUSE_16_BIT_TICKS must be defined in FreeRTOSConfig.h as either 1 or 0.  See the Configuration section of the FreeRTOS API documentation for details.
N#endif
N
N#ifndef configMAX_PRIORITIES
S	#error configMAX_PRIORITIES must be defined to be greater than or equal to 1.
N#endif
N
N#ifndef configUSE_CO_ROUTINES
S	#define configUSE_CO_ROUTINES 0
N#endif
N
N#ifndef INCLUDE_vTaskPrioritySet
S	#define INCLUDE_vTaskPrioritySet 0
N#endif
N
N#ifndef INCLUDE_uxTaskPriorityGet
S	#define INCLUDE_uxTaskPriorityGet 0
N#endif
N
N#ifndef INCLUDE_vTaskDelete
S	#define INCLUDE_vTaskDelete 0
N#endif
N
N#ifndef INCLUDE_vTaskSuspend
S	#define INCLUDE_vTaskSuspend 0
N#endif
N
N#ifndef INCLUDE_vTaskDelayUntil
S	#define INCLUDE_vTaskDelayUntil 0
N#endif
N
N#ifndef INCLUDE_vTaskDelay
S	#define INCLUDE_vTaskDelay 0
N#endif
N
N#ifndef INCLUDE_xTaskGetIdleTaskHandle
S	#define INCLUDE_xTaskGetIdleTaskHandle 0
N#endif
N
N#ifndef INCLUDE_xTaskAbortDelay
S	#define INCLUDE_xTaskAbortDelay 0
N#endif
N
N#ifndef INCLUDE_xQueueGetMutexHolder
N	#define INCLUDE_xQueueGetMutexHolder 0
N#endif
N
N#ifndef INCLUDE_xSemaphoreGetMutexHolder
N	#define INCLUDE_xSemaphoreGetMutexHolder INCLUDE_xQueueGetMutexHolder
N#endif
N
N#ifndef INCLUDE_xTaskGetHandle
S	#define INCLUDE_xTaskGetHandle 0
N#endif
N
N#ifndef INCLUDE_uxTaskGetStackHighWaterMark
S	#define INCLUDE_uxTaskGetStackHighWaterMark 0
N#endif
N
N#ifndef INCLUDE_eTaskGetState
S	#define INCLUDE_eTaskGetState 0
N#endif
N
N#ifndef INCLUDE_xTaskResumeFromISR
S	#define INCLUDE_xTaskResumeFromISR 1
N#endif
N
N#ifndef INCLUDE_xTimerPendFunctionCall
S	#define INCLUDE_xTimerPendFunctionCall 0
N#endif
N
N#ifndef INCLUDE_xTaskGetSchedulerState
S	#define INCLUDE_xTaskGetSchedulerState 0
N#endif
N
N#ifndef INCLUDE_xTaskGetCurrentTaskHandle
S	#define INCLUDE_xTaskGetCurrentTaskHandle 0
N#endif
N
N#if configUSE_CO_ROUTINES != 0
X#if 0 != 0
S	#ifndef configMAX_CO_ROUTINE_PRIORITIES
S		#error configMAX_CO_ROUTINE_PRIORITIES must be greater than or equal to 1.
S	#endif
N#endif
N
N#ifndef configUSE_DAEMON_TASK_STARTUP_HOOK
S	#define configUSE_DAEMON_TASK_STARTUP_HOOK 0
N#endif
N
N#ifndef configUSE_APPLICATION_TASK_TAG
N	#define configUSE_APPLICATION_TASK_TAG 0
N#endif
N
N#ifndef configNUM_THREAD_LOCAL_STORAGE_POINTERS
S	#define configNUM_THREAD_LOCAL_STORAGE_POINTERS 0
N#endif
N
N#ifndef configUSE_RECURSIVE_MUTEXES
S	#define configUSE_RECURSIVE_MUTEXES 0
N#endif
N
N#ifndef configUSE_MUTEXES
S	#define configUSE_MUTEXES 0
N#endif
N
N#ifndef configUSE_TIMERS
S	#define configUSE_TIMERS 0
N#endif
N
N#ifndef configUSE_COUNTING_SEMAPHORES
S	#define configUSE_COUNTING_SEMAPHORES 0
N#endif
N
N#ifndef configUSE_ALTERNATIVE_API
S	#define configUSE_ALTERNATIVE_API 0
N#endif
N
N#ifndef portCRITICAL_NESTING_IN_TCB
N	#define portCRITICAL_NESTING_IN_TCB 0
N#endif
N
N#ifndef configMAX_TASK_NAME_LEN
S	#define configMAX_TASK_NAME_LEN 16
N#endif
N
N#ifndef configIDLE_SHOULD_YIELD
S	#define configIDLE_SHOULD_YIELD		1
N#endif
N
N#if configMAX_TASK_NAME_LEN < 1
X#if 16 < 1
S	#error configMAX_TASK_NAME_LEN must be set to a minimum of 1 in FreeRTOSConfig.h
N#endif
N
N#ifndef configASSERT
N	#define configASSERT( x )
N	#define configASSERT_DEFINED 0
N#else
S	#define configASSERT_DEFINED 1
N#endif
N
N/* The timers module relies on xTaskGetSchedulerState(). */
N#if configUSE_TIMERS == 1
X#if 1 == 1
N
N	#ifndef configTIMER_TASK_PRIORITY
S		#error If configUSE_TIMERS is set to 1 then configTIMER_TASK_PRIORITY must also be defined.
N	#endif /* configTIMER_TASK_PRIORITY */
N
N	#ifndef configTIMER_QUEUE_LENGTH
S		#error If configUSE_TIMERS is set to 1 then configTIMER_QUEUE_LENGTH must also be defined.
N	#endif /* configTIMER_QUEUE_LENGTH */
N
N	#ifndef configTIMER_TASK_STACK_DEPTH
S		#error If configUSE_TIMERS is set to 1 then configTIMER_TASK_STACK_DEPTH must also be defined.
N	#endif /* configTIMER_TASK_STACK_DEPTH */
N
N#endif /* configUSE_TIMERS */
N
N#ifndef portSET_INTERRUPT_MASK_FROM_ISR
S	#define portSET_INTERRUPT_MASK_FROM_ISR() 0
N#endif
N
N#ifndef portCLEAR_INTERRUPT_MASK_FROM_ISR
S	#define portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedStatusValue ) ( void ) uxSavedStatusValue
N#endif
N
N#ifndef portCLEAN_UP_TCB
N	#define portCLEAN_UP_TCB( pxTCB ) ( void ) pxTCB
N#endif
N
N#ifndef portPRE_TASK_DELETE_HOOK
N	#define portPRE_TASK_DELETE_HOOK( pvTaskToDelete, pxYieldPending )
N#endif
N
N#ifndef portSETUP_TCB
N	#define portSETUP_TCB( pxTCB ) ( void ) pxTCB
N#endif
N
N#ifndef configQUEUE_REGISTRY_SIZE
S	#define configQUEUE_REGISTRY_SIZE 0U
N#endif
N
N#if ( configQUEUE_REGISTRY_SIZE < 1 )
X#if ( 10 < 1 )
S	#define vQueueAddToRegistry( xQueue, pcName )
S	#define vQueueUnregisterQueue( xQueue )
S	#define pcQueueGetName( xQueue )
N#endif
N
N#ifndef portPOINTER_SIZE_TYPE
N	#define portPOINTER_SIZE_TYPE uint32_t
N#endif
N
N/* Remove any unused trace macros. */
N#ifndef traceSTART
N	/* Used to perform any necessary initialisation - for example, open a file
N	into which trace is to be written. */
N	#define traceSTART()
N#endif
N
N#ifndef traceEND
N	/* Use to close a trace, for example close a file into which trace has been
N	written. */
N	#define traceEND()
N#endif
N
N#ifndef traceTASK_SWITCHED_IN
N	/* Called after a task has been selected to run.  pxCurrentTCB holds a pointer
N	to the task control block of the selected task. */
N	#define traceTASK_SWITCHED_IN()
N#endif
N
N#ifndef traceINCREASE_TICK_COUNT
N	/* Called before stepping the tick count after waking from tickless idle
N	sleep. */
N	#define traceINCREASE_TICK_COUNT( x )
N#endif
N
N#ifndef traceLOW_POWER_IDLE_BEGIN
N	/* Called immediately before entering tickless idle. */
N	#define traceLOW_POWER_IDLE_BEGIN()
N#endif
N
N#ifndef	traceLOW_POWER_IDLE_END
N	/* Called when returning to the Idle task after a tickless idle. */
N	#define traceLOW_POWER_IDLE_END()
N#endif
N
N#ifndef traceTASK_SWITCHED_OUT
N	/* Called before a task has been selected to run.  pxCurrentTCB holds a pointer
N	to the task control block of the task being switched out. */
N	#define traceTASK_SWITCHED_OUT()
N#endif
N
N#ifndef traceTASK_PRIORITY_INHERIT
N	/* Called when a task attempts to take a mutex that is already held by a
N	lower priority task.  pxTCBOfMutexHolder is a pointer to the TCB of the task
N	that holds the mutex.  uxInheritedPriority is the priority the mutex holder
N	will inherit (the priority of the task that is attempting to obtain the
N	muted. */
N	#define traceTASK_PRIORITY_INHERIT( pxTCBOfMutexHolder, uxInheritedPriority )
N#endif
N
N#ifndef traceTASK_PRIORITY_DISINHERIT
N	/* Called when a task releases a mutex, the holding of which had resulted in
N	the task inheriting the priority of a higher priority task.
N	pxTCBOfMutexHolder is a pointer to the TCB of the task that is releasing the
N	mutex.  uxOriginalPriority is the task's configured (base) priority. */
N	#define traceTASK_PRIORITY_DISINHERIT( pxTCBOfMutexHolder, uxOriginalPriority )
N#endif
N
N#ifndef traceBLOCKING_ON_QUEUE_RECEIVE
N	/* Task is about to block because it cannot read from a
N	queue/mutex/semaphore.  pxQueue is a pointer to the queue/mutex/semaphore
N	upon which the read was attempted.  pxCurrentTCB points to the TCB of the
N	task that attempted the read. */
N	#define traceBLOCKING_ON_QUEUE_RECEIVE( pxQueue )
N#endif
N
N#ifndef traceBLOCKING_ON_QUEUE_SEND
N	/* Task is about to block because it cannot write to a
N	queue/mutex/semaphore.  pxQueue is a pointer to the queue/mutex/semaphore
N	upon which the write was attempted.  pxCurrentTCB points to the TCB of the
N	task that attempted the write. */
N	#define traceBLOCKING_ON_QUEUE_SEND( pxQueue )
N#endif
N
N#ifndef configCHECK_FOR_STACK_OVERFLOW
S	#define configCHECK_FOR_STACK_OVERFLOW 0
N#endif
N
N/* The following event macros are embedded in the kernel API calls. */
N
N#ifndef traceMOVED_TASK_TO_READY_STATE
N	#define traceMOVED_TASK_TO_READY_STATE( pxTCB )
N#endif
N
N#ifndef tracePOST_MOVED_TASK_TO_READY_STATE
N	#define tracePOST_MOVED_TASK_TO_READY_STATE( pxTCB )
N#endif
N
N#ifndef traceQUEUE_CREATE
N	#define traceQUEUE_CREATE( pxNewQueue )
N#endif
N
N#ifndef traceQUEUE_CREATE_FAILED
N	#define traceQUEUE_CREATE_FAILED( ucQueueType )
N#endif
N
N#ifndef traceCREATE_MUTEX
N	#define traceCREATE_MUTEX( pxNewQueue )
N#endif
N
N#ifndef traceCREATE_MUTEX_FAILED
N	#define traceCREATE_MUTEX_FAILED()
N#endif
N
N#ifndef traceGIVE_MUTEX_RECURSIVE
N	#define traceGIVE_MUTEX_RECURSIVE( pxMutex )
N#endif
N
N#ifndef traceGIVE_MUTEX_RECURSIVE_FAILED
N	#define traceGIVE_MUTEX_RECURSIVE_FAILED( pxMutex )
N#endif
N
N#ifndef traceTAKE_MUTEX_RECURSIVE
N	#define traceTAKE_MUTEX_RECURSIVE( pxMutex )
N#endif
N
N#ifndef traceTAKE_MUTEX_RECURSIVE_FAILED
N	#define traceTAKE_MUTEX_RECURSIVE_FAILED( pxMutex )
N#endif
N
N#ifndef traceCREATE_COUNTING_SEMAPHORE
N	#define traceCREATE_COUNTING_SEMAPHORE()
N#endif
N
N#ifndef traceCREATE_COUNTING_SEMAPHORE_FAILED
N	#define traceCREATE_COUNTING_SEMAPHORE_FAILED()
N#endif
N
N#ifndef traceQUEUE_SEND
N	#define traceQUEUE_SEND( pxQueue )
N#endif
N
N#ifndef traceQUEUE_SEND_FAILED
N	#define traceQUEUE_SEND_FAILED( pxQueue )
N#endif
N
N#ifndef traceQUEUE_RECEIVE
N	#define traceQUEUE_RECEIVE( pxQueue )
N#endif
N
N#ifndef traceQUEUE_PEEK
N	#define traceQUEUE_PEEK( pxQueue )
N#endif
N
N#ifndef traceQUEUE_PEEK_FROM_ISR
N	#define traceQUEUE_PEEK_FROM_ISR( pxQueue )
N#endif
N
N#ifndef traceQUEUE_RECEIVE_FAILED
N	#define traceQUEUE_RECEIVE_FAILED( pxQueue )
N#endif
N
N#ifndef traceQUEUE_SEND_FROM_ISR
N	#define traceQUEUE_SEND_FROM_ISR( pxQueue )
N#endif
N
N#ifndef traceQUEUE_SEND_FROM_ISR_FAILED
N	#define traceQUEUE_SEND_FROM_ISR_FAILED( pxQueue )
N#endif
N
N#ifndef traceQUEUE_RECEIVE_FROM_ISR
N	#define traceQUEUE_RECEIVE_FROM_ISR( pxQueue )
N#endif
N
N#ifndef traceQUEUE_RECEIVE_FROM_ISR_FAILED
N	#define traceQUEUE_RECEIVE_FROM_ISR_FAILED( pxQueue )
N#endif
N
N#ifndef traceQUEUE_PEEK_FROM_ISR_FAILED
N	#define traceQUEUE_PEEK_FROM_ISR_FAILED( pxQueue )
N#endif
N
N#ifndef traceQUEUE_DELETE
N	#define traceQUEUE_DELETE( pxQueue )
N#endif
N
N#ifndef traceTASK_CREATE
N	#define traceTASK_CREATE( pxNewTCB )
N#endif
N
N#ifndef traceTASK_CREATE_FAILED
N	#define traceTASK_CREATE_FAILED()
N#endif
N
N#ifndef traceTASK_DELETE
N	#define traceTASK_DELETE( pxTaskToDelete )
N#endif
N
N#ifndef traceTASK_DELAY_UNTIL
N	#define traceTASK_DELAY_UNTIL( x )
N#endif
N
N#ifndef traceTASK_DELAY
N	#define traceTASK_DELAY()
N#endif
N
N#ifndef traceTASK_PRIORITY_SET
N	#define traceTASK_PRIORITY_SET( pxTask, uxNewPriority )
N#endif
N
N#ifndef traceTASK_SUSPEND
N	#define traceTASK_SUSPEND( pxTaskToSuspend )
N#endif
N
N#ifndef traceTASK_RESUME
N	#define traceTASK_RESUME( pxTaskToResume )
N#endif
N
N#ifndef traceTASK_RESUME_FROM_ISR
N	#define traceTASK_RESUME_FROM_ISR( pxTaskToResume )
N#endif
N
N#ifndef traceTASK_INCREMENT_TICK
N	#define traceTASK_INCREMENT_TICK( xTickCount )
N#endif
N
N#ifndef traceTIMER_CREATE
N	#define traceTIMER_CREATE( pxNewTimer )
N#endif
N
N#ifndef traceTIMER_CREATE_FAILED
N	#define traceTIMER_CREATE_FAILED()
N#endif
N
N#ifndef traceTIMER_COMMAND_SEND
N	#define traceTIMER_COMMAND_SEND( xTimer, xMessageID, xMessageValueValue, xReturn )
N#endif
N
N#ifndef traceTIMER_EXPIRED
N	#define traceTIMER_EXPIRED( pxTimer )
N#endif
N
N#ifndef traceTIMER_COMMAND_RECEIVED
N	#define traceTIMER_COMMAND_RECEIVED( pxTimer, xMessageID, xMessageValue )
N#endif
N
N#ifndef traceMALLOC
N    #define traceMALLOC( pvAddress, uiSize )
N#endif
N
N#ifndef traceFREE
N    #define traceFREE( pvAddress, uiSize )
N#endif
N
N#ifndef traceEVENT_GROUP_CREATE
N	#define traceEVENT_GROUP_CREATE( xEventGroup )
N#endif
N
N#ifndef traceEVENT_GROUP_CREATE_FAILED
N	#define traceEVENT_GROUP_CREATE_FAILED()
N#endif
N
N#ifndef traceEVENT_GROUP_SYNC_BLOCK
N	#define traceEVENT_GROUP_SYNC_BLOCK( xEventGroup, uxBitsToSet, uxBitsToWaitFor )
N#endif
N
N#ifndef traceEVENT_GROUP_SYNC_END
N	#define traceEVENT_GROUP_SYNC_END( xEventGroup, uxBitsToSet, uxBitsToWaitFor, xTimeoutOccurred ) ( void ) xTimeoutOccurred
N#endif
N
N#ifndef traceEVENT_GROUP_WAIT_BITS_BLOCK
N	#define traceEVENT_GROUP_WAIT_BITS_BLOCK( xEventGroup, uxBitsToWaitFor )
N#endif
N
N#ifndef traceEVENT_GROUP_WAIT_BITS_END
N	#define traceEVENT_GROUP_WAIT_BITS_END( xEventGroup, uxBitsToWaitFor, xTimeoutOccurred ) ( void ) xTimeoutOccurred
N#endif
N
N#ifndef traceEVENT_GROUP_CLEAR_BITS
N	#define traceEVENT_GROUP_CLEAR_BITS( xEventGroup, uxBitsToClear )
N#endif
N
N#ifndef traceEVENT_GROUP_CLEAR_BITS_FROM_ISR
N	#define traceEVENT_GROUP_CLEAR_BITS_FROM_ISR( xEventGroup, uxBitsToClear )
N#endif
N
N#ifndef traceEVENT_GROUP_SET_BITS
N	#define traceEVENT_GROUP_SET_BITS( xEventGroup, uxBitsToSet )
N#endif
N
N#ifndef traceEVENT_GROUP_SET_BITS_FROM_ISR
N	#define traceEVENT_GROUP_SET_BITS_FROM_ISR( xEventGroup, uxBitsToSet )
N#endif
N
N#ifndef traceEVENT_GROUP_DELETE
N	#define traceEVENT_GROUP_DELETE( xEventGroup )
N#endif
N
N#ifndef tracePEND_FUNC_CALL
N	#define tracePEND_FUNC_CALL(xFunctionToPend, pvParameter1, ulParameter2, ret)
N#endif
N
N#ifndef tracePEND_FUNC_CALL_FROM_ISR
N	#define tracePEND_FUNC_CALL_FROM_ISR(xFunctionToPend, pvParameter1, ulParameter2, ret)
N#endif
N
N#ifndef traceQUEUE_REGISTRY_ADD
N	#define traceQUEUE_REGISTRY_ADD(xQueue, pcQueueName)
N#endif
N
N#ifndef traceTASK_NOTIFY_TAKE_BLOCK
N	#define traceTASK_NOTIFY_TAKE_BLOCK()
N#endif
N
N#ifndef traceTASK_NOTIFY_TAKE
N	#define traceTASK_NOTIFY_TAKE()
N#endif
N
N#ifndef traceTASK_NOTIFY_WAIT_BLOCK
N	#define traceTASK_NOTIFY_WAIT_BLOCK()
N#endif
N
N#ifndef traceTASK_NOTIFY_WAIT
N	#define traceTASK_NOTIFY_WAIT()
N#endif
N
N#ifndef traceTASK_NOTIFY
N	#define traceTASK_NOTIFY()
N#endif
N
N#ifndef traceTASK_NOTIFY_FROM_ISR
N	#define traceTASK_NOTIFY_FROM_ISR()
N#endif
N
N#ifndef traceTASK_NOTIFY_GIVE_FROM_ISR
N	#define traceTASK_NOTIFY_GIVE_FROM_ISR()
N#endif
N
N#ifndef configGENERATE_RUN_TIME_STATS
S	#define configGENERATE_RUN_TIME_STATS 0
N#endif
N
N#if ( configGENERATE_RUN_TIME_STATS == 1 )
X#if ( 0 == 1 )
S
S	#ifndef portCONFIGURE_TIMER_FOR_RUN_TIME_STATS
S		#error If configGENERATE_RUN_TIME_STATS is defined then portCONFIGURE_TIMER_FOR_RUN_TIME_STATS must also be defined.  portCONFIGURE_TIMER_FOR_RUN_TIME_STATS should call a port layer function to setup a peripheral timer/counter that can then be used as the run time counter time base.
S	#endif /* portCONFIGURE_TIMER_FOR_RUN_TIME_STATS */
S
S	#ifndef portGET_RUN_TIME_COUNTER_VALUE
S		#ifndef portALT_GET_RUN_TIME_COUNTER_VALUE
S			#error If configGENERATE_RUN_TIME_STATS is defined then either portGET_RUN_TIME_COUNTER_VALUE or portALT_GET_RUN_TIME_COUNTER_VALUE must also be defined.  See the examples provided and the FreeRTOS web site for more information.
S		#endif /* portALT_GET_RUN_TIME_COUNTER_VALUE */
S	#endif /* portGET_RUN_TIME_COUNTER_VALUE */
S
N#endif /* configGENERATE_RUN_TIME_STATS */
N
N#ifndef portCONFIGURE_TIMER_FOR_RUN_TIME_STATS
N	#define portCONFIGURE_TIMER_FOR_RUN_TIME_STATS()
N#endif
N
N#ifndef configUSE_MALLOC_FAILED_HOOK
S	#define configUSE_MALLOC_FAILED_HOOK 0
N#endif
N
N#ifndef portPRIVILEGE_BIT
N	#define portPRIVILEGE_BIT ( ( UBaseType_t ) 0x00 )
N#endif
N
N#ifndef portYIELD_WITHIN_API
N	#define portYIELD_WITHIN_API portYIELD
N#endif
N
N#ifndef portSUPPRESS_TICKS_AND_SLEEP
S	#define portSUPPRESS_TICKS_AND_SLEEP( xExpectedIdleTime )
N#endif
N
N#ifndef configEXPECTED_IDLE_TIME_BEFORE_SLEEP
N	#define configEXPECTED_IDLE_TIME_BEFORE_SLEEP 2
N#endif
N
N#if configEXPECTED_IDLE_TIME_BEFORE_SLEEP < 2
X#if 2 < 2
S	#error configEXPECTED_IDLE_TIME_BEFORE_SLEEP must not be less than 2
N#endif
N
N#ifndef configUSE_TICKLESS_IDLE
S	#define configUSE_TICKLESS_IDLE 0
N#endif
N
N#ifndef configPRE_SLEEP_PROCESSING
N	#define configPRE_SLEEP_PROCESSING( x )
N#endif
N
N#ifndef configPOST_SLEEP_PROCESSING
N	#define configPOST_SLEEP_PROCESSING( x )
N#endif
N
N#ifndef configUSE_QUEUE_SETS
S	#define configUSE_QUEUE_SETS 0
N#endif
N
N#ifndef portTASK_USES_FLOATING_POINT
N	#define portTASK_USES_FLOATING_POINT()
N#endif
N
N#ifndef configUSE_TIME_SLICING
S	#define configUSE_TIME_SLICING 1
N#endif
N
N#ifndef configINCLUDE_APPLICATION_DEFINED_PRIVILEGED_FUNCTIONS
S	#define configINCLUDE_APPLICATION_DEFINED_PRIVILEGED_FUNCTIONS 0
N#endif
N
N#ifndef configUSE_STATS_FORMATTING_FUNCTIONS
S	#define configUSE_STATS_FORMATTING_FUNCTIONS 0
N#endif
N
N#ifndef portASSERT_IF_INTERRUPT_PRIORITY_INVALID
N	#define portASSERT_IF_INTERRUPT_PRIORITY_INVALID()
N#endif
N
N#ifndef configUSE_TRACE_FACILITY
S	#define configUSE_TRACE_FACILITY 0
N#endif
N
N#ifndef mtCOVERAGE_TEST_MARKER
N	#define mtCOVERAGE_TEST_MARKER()
N#endif
N
N#ifndef mtCOVERAGE_TEST_DELAY
N	#define mtCOVERAGE_TEST_DELAY()
N#endif
N
N#ifndef portASSERT_IF_IN_ISR
N	#define portASSERT_IF_IN_ISR()
N#endif
N
N#ifndef configUSE_PORT_OPTIMISED_TASK_SELECTION
S	#define configUSE_PORT_OPTIMISED_TASK_SELECTION 0
N#endif
N
N#ifndef configAPPLICATION_ALLOCATED_HEAP
S	#define configAPPLICATION_ALLOCATED_HEAP 0
N#endif
N
N#ifndef configUSE_TASK_NOTIFICATIONS
S	#define configUSE_TASK_NOTIFICATIONS 1
N#endif
N
N#ifndef portTICK_TYPE_IS_ATOMIC
S	#define portTICK_TYPE_IS_ATOMIC 0
N#endif
N
N#ifndef configSUPPORT_STATIC_ALLOCATION
N	/* Defaults to 0 for backward compatibility. */
N	#define configSUPPORT_STATIC_ALLOCATION 0
N#endif
N
N#ifndef configSUPPORT_DYNAMIC_ALLOCATION
N	/* Defaults to 1 for backward compatibility. */
N	#define configSUPPORT_DYNAMIC_ALLOCATION 1
N#endif
N
N/* Sanity check the configuration. */
N#if( configUSE_TICKLESS_IDLE != 0 )
X#if( 0 != 0 )
S	#if( INCLUDE_vTaskSuspend != 1 )
S		#error INCLUDE_vTaskSuspend must be set to 1 if configUSE_TICKLESS_IDLE is not set to 0
S	#endif /* INCLUDE_vTaskSuspend */
N#endif /* configUSE_TICKLESS_IDLE */
N
N#if( ( configSUPPORT_STATIC_ALLOCATION == 0 ) && ( configSUPPORT_DYNAMIC_ALLOCATION == 0 ) )
X#if( ( 0 == 0 ) && ( 1 == 0 ) )
S	#error configSUPPORT_STATIC_ALLOCATION and configSUPPORT_DYNAMIC_ALLOCATION cannot both be 0, but can both be 1.
N#endif
N
N#if( ( configUSE_RECURSIVE_MUTEXES == 1 ) && ( configUSE_MUTEXES != 1 ) )
X#if( ( 1 == 1 ) && ( 1 != 1 ) )
S	#error configUSE_MUTEXES must be set to 1 to use recursive mutexes
N#endif
N
N#if( portTICK_TYPE_IS_ATOMIC == 0 )
X#if( 1 == 0 )
S	/* Either variables of tick type cannot be read atomically, or
S	portTICK_TYPE_IS_ATOMIC was not set - map the critical sections used when
S	the tick count is returned to the standard critical section macros. */
S	#define portTICK_TYPE_ENTER_CRITICAL() portENTER_CRITICAL()
S	#define portTICK_TYPE_EXIT_CRITICAL() portEXIT_CRITICAL()
S	#define portTICK_TYPE_SET_INTERRUPT_MASK_FROM_ISR() portSET_INTERRUPT_MASK_FROM_ISR()
S	#define portTICK_TYPE_CLEAR_INTERRUPT_MASK_FROM_ISR( x ) portCLEAR_INTERRUPT_MASK_FROM_ISR( ( x ) )
N#else
N	/* The tick type can be read atomically, so critical sections used when the
N	tick count is returned can be defined away. */
N	#define portTICK_TYPE_ENTER_CRITICAL()
N	#define portTICK_TYPE_EXIT_CRITICAL()
N	#define portTICK_TYPE_SET_INTERRUPT_MASK_FROM_ISR() 0
N	#define portTICK_TYPE_CLEAR_INTERRUPT_MASK_FROM_ISR( x ) ( void ) x
N#endif
N
N/* Definitions to allow backward compatibility with FreeRTOS versions prior to
NV8 if desired. */
N#ifndef configENABLE_BACKWARD_COMPATIBILITY
S	#define configENABLE_BACKWARD_COMPATIBILITY 1
N#endif
N
N#if configENABLE_BACKWARD_COMPATIBILITY == 1
X#if 0 == 1
S	#define eTaskStateGet eTaskGetState
S	#define portTickType TickType_t
S	#define xTaskHandle TaskHandle_t
S	#define xQueueHandle QueueHandle_t
S	#define xSemaphoreHandle SemaphoreHandle_t
S	#define xQueueSetHandle QueueSetHandle_t
S	#define xQueueSetMemberHandle QueueSetMemberHandle_t
S	#define xTimeOutType TimeOut_t
S	#define xMemoryRegion MemoryRegion_t
S	#define xTaskParameters TaskParameters_t
S	#define xTaskStatusType	TaskStatus_t
S	#define xTimerHandle TimerHandle_t
S	#define xCoRoutineHandle CoRoutineHandle_t
S	#define pdTASK_HOOK_CODE TaskHookFunction_t
S	#define portTICK_RATE_MS portTICK_PERIOD_MS
S	#define pcTaskGetTaskName pcTaskGetName
S	#define pcTimerGetTimerName pcTimerGetName
S	#define pcQueueGetQueueName pcQueueGetName
S	#define vTaskGetTaskInfo vTaskGetInfo
S
S	/* Backward compatibility within the scheduler code only - these definitions
S	are not really required but are included for completeness. */
S	#define tmrTIMER_CALLBACK TimerCallbackFunction_t
S	#define pdTASK_CODE TaskFunction_t
S	#define xListItem ListItem_t
S	#define xList List_t
N#endif /* configENABLE_BACKWARD_COMPATIBILITY */
N
N#if( configUSE_ALTERNATIVE_API != 0 )
X#if( 0 != 0 )
S	#error The alternative API was deprecated some time ago, and was removed in FreeRTOS V9.0 0
N#endif
N
N/* Set configUSE_TASK_FPU_SUPPORT to 0 to omit floating point support even
Nif floating point hardware is otherwise supported by the FreeRTOS port in use.
NThis constant is not supported by all FreeRTOS ports that include floating
Npoint support. */
N#ifndef configUSE_TASK_FPU_SUPPORT
N	#define configUSE_TASK_FPU_SUPPORT 1
N#endif
N
N/*
N * In line with software engineering best practice, FreeRTOS implements a strict
N * data hiding policy, so the real structures used by FreeRTOS to maintain the
N * state of tasks, queues, semaphores, etc. are not accessible to the application
N * code.  However, if the application writer wants to statically allocate such
N * an object then the size of the object needs to be know.  Dummy structures
N * that are guaranteed to have the same size and alignment requirements of the
N * real objects are used for this purpose.  The dummy list and list item
N * structures below are used for inclusion in such a dummy structure.
N */
Nstruct xSTATIC_LIST_ITEM
N{
N	TickType_t xDummy1;
N	void *pvDummy2[ 4 ];
N};
Ntypedef struct xSTATIC_LIST_ITEM StaticListItem_t;
N
N/* See the comments above the struct xSTATIC_LIST_ITEM definition. */
Nstruct xSTATIC_MINI_LIST_ITEM
N{
N	TickType_t xDummy1;
N	void *pvDummy2[ 2 ];
N};
Ntypedef struct xSTATIC_MINI_LIST_ITEM StaticMiniListItem_t;
N
N/* See the comments above the struct xSTATIC_LIST_ITEM definition. */
Ntypedef struct xSTATIC_LIST
N{
N	UBaseType_t uxDummy1;
N	void *pvDummy2;
N	StaticMiniListItem_t xDummy3;
N} StaticList_t;
N
N/*
N * In line with software engineering best practice, especially when supplying a
N * library that is likely to change in future versions, FreeRTOS implements a
N * strict data hiding policy.  This means the Task structure used internally by
N * FreeRTOS is not accessible to application code.  However, if the application
N * writer wants to statically allocate the memory required to create a task then
N * the size of the task object needs to be know.  The StaticTask_t structure
N * below is provided for this purpose.  Its sizes and alignment requirements are
N * guaranteed to match those of the genuine structure, no matter which
N * architecture is being used, and no matter how the values in FreeRTOSConfig.h
N * are set.  Its contents are somewhat obfuscated in the hope users will
N * recognise that it would be unwise to make direct use of the structure members.
N */
Ntypedef struct xSTATIC_TCB
N{
N	void				*pxDummy1;
N	#if ( portUSING_MPU_WRAPPERS == 1 )
X	#if ( 0 == 1 )
S		xMPU_SETTINGS	xDummy2;
N	#endif
N	StaticListItem_t	xDummy3[ 2 ];
N	UBaseType_t			uxDummy5;
N	void				*pxDummy6;
N	uint8_t				ucDummy7[ configMAX_TASK_NAME_LEN ];
X	uint8_t				ucDummy7[ 16 ];
N	#if ( portSTACK_GROWTH > 0 )
X	#if ( ( -1 ) > 0 )
S		void			*pxDummy8;
N	#endif
N	#if ( portCRITICAL_NESTING_IN_TCB == 1 )
X	#if ( 0 == 1 )
S		UBaseType_t		uxDummy9;
N	#endif
N	#if ( configUSE_TRACE_FACILITY == 1 )
X	#if ( 0 == 1 )
S		UBaseType_t		uxDummy10[ 2 ];
N	#endif
N	#if ( configUSE_MUTEXES == 1 )
X	#if ( 1 == 1 )
N		UBaseType_t		uxDummy12[ 2 ];
N	#endif
N	#if ( configUSE_APPLICATION_TASK_TAG == 1 )
X	#if ( 0 == 1 )
S		void			*pxDummy14;
N	#endif
N	#if( configNUM_THREAD_LOCAL_STORAGE_POINTERS > 0 )
X	#if( 5 > 0 )
N		void			*pvDummy15[ configNUM_THREAD_LOCAL_STORAGE_POINTERS ];
X		void			*pvDummy15[ 5 ];
N	#endif
N	#if ( configGENERATE_RUN_TIME_STATS == 1 )
X	#if ( 0 == 1 )
S		uint32_t		ulDummy16;
N	#endif
N	#if ( configUSE_NEWLIB_REENTRANT == 1 )
X	#if ( 0 == 1 )
S		struct	_reent	xDummy17;
N	#endif
N	#if ( configUSE_TASK_NOTIFICATIONS == 1 )
X	#if ( 1 == 1 )
N		uint32_t 		ulDummy18;
N		uint8_t 		ucDummy19;
N	#endif
N	#if( ( configSUPPORT_STATIC_ALLOCATION == 1 ) && ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) )
X	#if( ( 0 == 1 ) && ( 1 == 1 ) )
S		uint8_t			uxDummy20;
N	#endif
N
N} StaticTask_t;
N
N/*
N * In line with software engineering best practice, especially when supplying a
N * library that is likely to change in future versions, FreeRTOS implements a
N * strict data hiding policy.  This means the Queue structure used internally by
N * FreeRTOS is not accessible to application code.  However, if the application
N * writer wants to statically allocate the memory required to create a queue
N * then the size of the queue object needs to be know.  The StaticQueue_t
N * structure below is provided for this purpose.  Its sizes and alignment
N * requirements are guaranteed to match those of the genuine structure, no
N * matter which architecture is being used, and no matter how the values in
N * FreeRTOSConfig.h are set.  Its contents are somewhat obfuscated in the hope
N * users will recognise that it would be unwise to make direct use of the
N * structure members.
N */
Ntypedef struct xSTATIC_QUEUE
N{
N	void *pvDummy1[ 3 ];
N
N	union
N	{
N		void *pvDummy2;
N		UBaseType_t uxDummy2;
N	} u;
N
N	StaticList_t xDummy3[ 2 ];
N	UBaseType_t uxDummy4[ 3 ];
N	uint8_t ucDummy5[ 2 ];
N
N	#if( ( configSUPPORT_STATIC_ALLOCATION == 1 ) && ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) )
X	#if( ( 0 == 1 ) && ( 1 == 1 ) )
S		uint8_t ucDummy6;
N	#endif
N
N	#if ( configUSE_QUEUE_SETS == 1 )
X	#if ( 0 == 1 )
S		void *pvDummy7;
N	#endif
N
N	#if ( configUSE_TRACE_FACILITY == 1 )
X	#if ( 0 == 1 )
S		UBaseType_t uxDummy8;
S		uint8_t ucDummy9;
N	#endif
N
N} StaticQueue_t;
Ntypedef StaticQueue_t StaticSemaphore_t;
N
N/*
N * In line with software engineering best practice, especially when supplying a
N * library that is likely to change in future versions, FreeRTOS implements a
N * strict data hiding policy.  This means the event group structure used
N * internally by FreeRTOS is not accessible to application code.  However, if
N * the application writer wants to statically allocate the memory required to
N * create an event group then the size of the event group object needs to be
N * know.  The StaticEventGroup_t structure below is provided for this purpose.
N * Its sizes and alignment requirements are guaranteed to match those of the
N * genuine structure, no matter which architecture is being used, and no matter
N * how the values in FreeRTOSConfig.h are set.  Its contents are somewhat
N * obfuscated in the hope users will recognise that it would be unwise to make
N * direct use of the structure members.
N */
Ntypedef struct xSTATIC_EVENT_GROUP
N{
N	TickType_t xDummy1;
N	StaticList_t xDummy2;
N
N	#if( configUSE_TRACE_FACILITY == 1 )
X	#if( 0 == 1 )
S		UBaseType_t uxDummy3;
N	#endif
N
N	#if( ( configSUPPORT_STATIC_ALLOCATION == 1 ) && ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) )
X	#if( ( 0 == 1 ) && ( 1 == 1 ) )
S			uint8_t ucDummy4;
N	#endif
N
N} StaticEventGroup_t;
N
N/*
N * In line with software engineering best practice, especially when supplying a
N * library that is likely to change in future versions, FreeRTOS implements a
N * strict data hiding policy.  This means the software timer structure used
N * internally by FreeRTOS is not accessible to application code.  However, if
N * the application writer wants to statically allocate the memory required to
N * create a software timer then the size of the queue object needs to be know.
N * The StaticTimer_t structure below is provided for this purpose.  Its sizes
N * and alignment requirements are guaranteed to match those of the genuine
N * structure, no matter which architecture is being used, and no matter how the
N * values in FreeRTOSConfig.h are set.  Its contents are somewhat obfuscated in
N * the hope users will recognise that it would be unwise to make direct use of
N * the structure members.
N */
Ntypedef struct xSTATIC_TIMER
N{
N	void				*pvDummy1;
N	StaticListItem_t	xDummy2;
N	TickType_t			xDummy3;
N	UBaseType_t			uxDummy4;
N	void 				*pvDummy5[ 2 ];
N	#if( configUSE_TRACE_FACILITY == 1 )
X	#if( 0 == 1 )
S		UBaseType_t		uxDummy6;
N	#endif
N
N	#if( ( configSUPPORT_STATIC_ALLOCATION == 1 ) && ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) )
X	#if( ( 0 == 1 ) && ( 1 == 1 ) )
S		uint8_t 		ucDummy7;
N	#endif
N
N} StaticTimer_t;
N
N#ifdef __cplusplus
S}
N#endif
N
N#endif /* INC_FREERTOS_H */
N
L 26 "adc.c" 2
N#include "task.h"
L 1 ".\rtos\include\task.h" 1
N/*
N    FreeRTOS V9.0.0 - Copyright (C) 2016 Real Time Engineers Ltd.
N    All rights reserved
N
N    VISIT http://www.FreeRTOS.org TO ENSURE YOU ARE USING THE LATEST VERSION.
N
N    This file is part of the FreeRTOS distribution.
N
N    FreeRTOS is free software; you can redistribute it and/or modify it under
N    the terms of the GNU General Public License (version 2) as published by the
N    Free Software Foundation >>>> AND MODIFIED BY <<<< the FreeRTOS exception.
N
N    ***************************************************************************
N    >>!   NOTE: The modification to the GPL is included to allow you to     !<<
N    >>!   distribute a combined work that includes FreeRTOS without being   !<<
N    >>!   obliged to provide the source code for proprietary components     !<<
N    >>!   outside of the FreeRTOS kernel.                                   !<<
N    ***************************************************************************
N
N    FreeRTOS is distributed in the hope that it will be useful, but WITHOUT ANY
N    WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
N    FOR A PARTICULAR PURPOSE.  Full license text is available on the following
N    link: http://www.freertos.org/a00114.html
N
N    ***************************************************************************
N     *                                                                       *
N     *    FreeRTOS provides completely free yet professionally developed,    *
N     *    robust, strictly quality controlled, supported, and cross          *
N     *    platform software that is more than just the market leader, it     *
N     *    is the industry's de facto standard.                               *
N     *                                                                       *
N     *    Help yourself get started quickly while simultaneously helping     *
N     *    to support the FreeRTOS project by purchasing a FreeRTOS           *
N     *    tutorial book, reference manual, or both:                          *
N     *    http://www.FreeRTOS.org/Documentation                              *
N     *                                                                       *
N    ***************************************************************************
N
N    http://www.FreeRTOS.org/FAQHelp.html - Having a problem?  Start by reading
N    the FAQ page "My application does not run, what could be wrong?".  Have you
N    defined configASSERT()?
N
N    http://www.FreeRTOS.org/support - In return for receiving this top quality
N    embedded software for free we request you assist our global community by
N    participating in the support forum.
N
N    http://www.FreeRTOS.org/training - Investing in training allows your team to
N    be as productive as possible as early as possible.  Now you can receive
N    FreeRTOS training directly from Richard Barry, CEO of Real Time Engineers
N    Ltd, and the world's leading authority on the world's leading RTOS.
N
N    http://www.FreeRTOS.org/plus - A selection of FreeRTOS ecosystem products,
N    including FreeRTOS+Trace - an indispensable productivity tool, a DOS
N    compatible FAT file system, and our tiny thread aware UDP/IP stack.
N
N    http://www.FreeRTOS.org/labs - Where new FreeRTOS products go to incubate.
N    Come and try FreeRTOS+TCP, our new open source TCP/IP stack for FreeRTOS.
N
N    http://www.OpenRTOS.com - Real Time Engineers ltd. license FreeRTOS to High
N    Integrity Systems ltd. to sell under the OpenRTOS brand.  Low cost OpenRTOS
N    licenses offer ticketed support, indemnification and commercial middleware.
N
N    http://www.SafeRTOS.com - High Integrity Systems also provide a safety
N    engineered and independently SIL3 certified version for use in safety and
N    mission critical applications that require provable dependability.
N
N    1 tab == 4 spaces!
N*/
N
N
N#ifndef INC_TASK_H
N#define INC_TASK_H
N
N#ifndef INC_FREERTOS_H
S	#error "include FreeRTOS.h must appear in source files before include task.h"
N#endif
N
N#include "list.h"
L 1 ".\rtos\include\list.h" 1
N/*
N    FreeRTOS V9.0.0 - Copyright (C) 2016 Real Time Engineers Ltd.
N    All rights reserved
N
N    VISIT http://www.FreeRTOS.org TO ENSURE YOU ARE USING THE LATEST VERSION.
N
N    This file is part of the FreeRTOS distribution.
N
N    FreeRTOS is free software; you can redistribute it and/or modify it under
N    the terms of the GNU General Public License (version 2) as published by the
N    Free Software Foundation >>>> AND MODIFIED BY <<<< the FreeRTOS exception.
N
N    ***************************************************************************
N    >>!   NOTE: The modification to the GPL is included to allow you to     !<<
N    >>!   distribute a combined work that includes FreeRTOS without being   !<<
N    >>!   obliged to provide the source code for proprietary components     !<<
N    >>!   outside of the FreeRTOS kernel.                                   !<<
N    ***************************************************************************
N
N    FreeRTOS is distributed in the hope that it will be useful, but WITHOUT ANY
N    WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
N    FOR A PARTICULAR PURPOSE.  Full license text is available on the following
N    link: http://www.freertos.org/a00114.html
N
N    ***************************************************************************
N     *                                                                       *
N     *    FreeRTOS provides completely free yet professionally developed,    *
N     *    robust, strictly quality controlled, supported, and cross          *
N     *    platform software that is more than just the market leader, it     *
N     *    is the industry's de facto standard.                               *
N     *                                                                       *
N     *    Help yourself get started quickly while simultaneously helping     *
N     *    to support the FreeRTOS project by purchasing a FreeRTOS           *
N     *    tutorial book, reference manual, or both:                          *
N     *    http://www.FreeRTOS.org/Documentation                              *
N     *                                                                       *
N    ***************************************************************************
N
N    http://www.FreeRTOS.org/FAQHelp.html - Having a problem?  Start by reading
N    the FAQ page "My application does not run, what could be wrong?".  Have you
N    defined configASSERT()?
N
N    http://www.FreeRTOS.org/support - In return for receiving this top quality
N    embedded software for free we request you assist our global community by
N    participating in the support forum.
N
N    http://www.FreeRTOS.org/training - Investing in training allows your team to
N    be as productive as possible as early as possible.  Now you can receive
N    FreeRTOS training directly from Richard Barry, CEO of Real Time Engineers
N    Ltd, and the world's leading authority on the world's leading RTOS.
N
N    http://www.FreeRTOS.org/plus - A selection of FreeRTOS ecosystem products,
N    including FreeRTOS+Trace - an indispensable productivity tool, a DOS
N    compatible FAT file system, and our tiny thread aware UDP/IP stack.
N
N    http://www.FreeRTOS.org/labs - Where new FreeRTOS products go to incubate.
N    Come and try FreeRTOS+TCP, our new open source TCP/IP stack for FreeRTOS.
N
N    http://www.OpenRTOS.com - Real Time Engineers ltd. license FreeRTOS to High
N    Integrity Systems ltd. to sell under the OpenRTOS brand.  Low cost OpenRTOS
N    licenses offer ticketed support, indemnification and commercial middleware.
N
N    http://www.SafeRTOS.com - High Integrity Systems also provide a safety
N    engineered and independently SIL3 certified version for use in safety and
N    mission critical applications that require provable dependability.
N
N    1 tab == 4 spaces!
N*/
N
N/*
N * This is the list implementation used by the scheduler.  While it is tailored
N * heavily for the schedulers needs, it is also available for use by
N * application code.
N *
N * list_ts can only store pointers to list_item_ts.  Each ListItem_t contains a
N * numeric value (xItemValue).  Most of the time the lists are sorted in
N * descending item value order.
N *
N * Lists are created already containing one list item.  The value of this
N * item is the maximum possible that can be stored, it is therefore always at
N * the end of the list and acts as a marker.  The list member pxHead always
N * points to this marker - even though it is at the tail of the list.  This
N * is because the tail contains a wrap back pointer to the true head of
N * the list.
N *
N * In addition to it's value, each list item contains a pointer to the next
N * item in the list (pxNext), a pointer to the list it is in (pxContainer)
N * and a pointer to back to the object that contains it.  These later two
N * pointers are included for efficiency of list manipulation.  There is
N * effectively a two way link between the object containing the list item and
N * the list item itself.
N *
N *
N * \page ListIntroduction List Implementation
N * \ingroup FreeRTOSIntro
N */
N
N#ifndef INC_FREERTOS_H
S	#error FreeRTOS.h must be included before list.h
N#endif
N
N#ifndef LIST_H
N#define LIST_H
N
N/*
N * The list structure members are modified from within interrupts, and therefore
N * by rights should be declared volatile.  However, they are only modified in a
N * functionally atomic way (within critical sections of with the scheduler
N * suspended) and are either passed by reference into a function or indexed via
N * a volatile variable.  Therefore, in all use cases tested so far, the volatile
N * qualifier can be omitted in order to provide a moderate performance
N * improvement without adversely affecting functional behaviour.  The assembly
N * instructions generated by the IAR, ARM and GCC compilers when the respective
N * compiler's options were set for maximum optimisation has been inspected and
N * deemed to be as intended.  That said, as compiler technology advances, and
N * especially if aggressive cross module optimisation is used (a use case that
N * has not been exercised to any great extend) then it is feasible that the
N * volatile qualifier will be needed for correct optimisation.  It is expected
N * that a compiler removing essential code because, without the volatile
N * qualifier on the list structure members and with aggressive cross module
N * optimisation, the compiler deemed the code unnecessary will result in
N * complete and obvious failure of the scheduler.  If this is ever experienced
N * then the volatile qualifier can be inserted in the relevant places within the
N * list structures by simply defining configLIST_VOLATILE to volatile in
N * FreeRTOSConfig.h (as per the example at the bottom of this comment block).
N * If configLIST_VOLATILE is not defined then the preprocessor directives below
N * will simply #define configLIST_VOLATILE away completely.
N *
N * To use volatile list structure members then add the following line to
N * FreeRTOSConfig.h (without the quotes):
N * "#define configLIST_VOLATILE volatile"
N */
N#ifndef configLIST_VOLATILE
N	#define configLIST_VOLATILE
N#endif /* configSUPPORT_CROSS_MODULE_OPTIMISATION */
N
N#ifdef __cplusplus
Sextern "C" {
N#endif
N
N/* Macros that can be used to place known values within the list structures,
Nthen check that the known values do not get corrupted during the execution of
Nthe application.   These may catch the list data structures being overwritten in
Nmemory.  They will not catch data errors caused by incorrect configuration or
Nuse of FreeRTOS.*/
N#if( configUSE_LIST_DATA_INTEGRITY_CHECK_BYTES == 0 )
X#if( 0 == 0 )
N	/* Define the macros to do nothing. */
N	#define listFIRST_LIST_ITEM_INTEGRITY_CHECK_VALUE
N	#define listSECOND_LIST_ITEM_INTEGRITY_CHECK_VALUE
N	#define listFIRST_LIST_INTEGRITY_CHECK_VALUE
N	#define listSECOND_LIST_INTEGRITY_CHECK_VALUE
N	#define listSET_FIRST_LIST_ITEM_INTEGRITY_CHECK_VALUE( pxItem )
N	#define listSET_SECOND_LIST_ITEM_INTEGRITY_CHECK_VALUE( pxItem )
N	#define listSET_LIST_INTEGRITY_CHECK_1_VALUE( pxList )
N	#define listSET_LIST_INTEGRITY_CHECK_2_VALUE( pxList )
N	#define listTEST_LIST_ITEM_INTEGRITY( pxItem )
N	#define listTEST_LIST_INTEGRITY( pxList )
N#else
S	/* Define macros that add new members into the list structures. */
S	#define listFIRST_LIST_ITEM_INTEGRITY_CHECK_VALUE				TickType_t xListItemIntegrityValue1;
S	#define listSECOND_LIST_ITEM_INTEGRITY_CHECK_VALUE				TickType_t xListItemIntegrityValue2;
S	#define listFIRST_LIST_INTEGRITY_CHECK_VALUE					TickType_t xListIntegrityValue1;
S	#define listSECOND_LIST_INTEGRITY_CHECK_VALUE					TickType_t xListIntegrityValue2;
S
S	/* Define macros that set the new structure members to known values. */
S	#define listSET_FIRST_LIST_ITEM_INTEGRITY_CHECK_VALUE( pxItem )		( pxItem )->xListItemIntegrityValue1 = pdINTEGRITY_CHECK_VALUE
S	#define listSET_SECOND_LIST_ITEM_INTEGRITY_CHECK_VALUE( pxItem )	( pxItem )->xListItemIntegrityValue2 = pdINTEGRITY_CHECK_VALUE
S	#define listSET_LIST_INTEGRITY_CHECK_1_VALUE( pxList )		( pxList )->xListIntegrityValue1 = pdINTEGRITY_CHECK_VALUE
S	#define listSET_LIST_INTEGRITY_CHECK_2_VALUE( pxList )		( pxList )->xListIntegrityValue2 = pdINTEGRITY_CHECK_VALUE
S
S	/* Define macros that will assert if one of the structure members does not
S	contain its expected value. */
S	#define listTEST_LIST_ITEM_INTEGRITY( pxItem )		configASSERT( ( ( pxItem )->xListItemIntegrityValue1 == pdINTEGRITY_CHECK_VALUE ) && ( ( pxItem )->xListItemIntegrityValue2 == pdINTEGRITY_CHECK_VALUE ) )
S	#define listTEST_LIST_INTEGRITY( pxList )			configASSERT( ( ( pxList )->xListIntegrityValue1 == pdINTEGRITY_CHECK_VALUE ) && ( ( pxList )->xListIntegrityValue2 == pdINTEGRITY_CHECK_VALUE ) )
N#endif /* configUSE_LIST_DATA_INTEGRITY_CHECK_BYTES */
N
N
N/*
N * Definition of the only type of object that a list can contain.
N */
Nstruct xLIST_ITEM
N{
N	listFIRST_LIST_ITEM_INTEGRITY_CHECK_VALUE			/*< Set to a known value if configUSE_LIST_DATA_INTEGRITY_CHECK_BYTES is set to 1. */
X				 
N	configLIST_VOLATILE TickType_t xItemValue;			/*< The value being listed.  In most cases this is used to sort the list in descending order. */
X	 TickType_t xItemValue;			 
N	struct xLIST_ITEM * configLIST_VOLATILE pxNext;		/*< Pointer to the next ListItem_t in the list. */
X	struct xLIST_ITEM *  pxNext;		 
N	struct xLIST_ITEM * configLIST_VOLATILE pxPrevious;	/*< Pointer to the previous ListItem_t in the list. */
X	struct xLIST_ITEM *  pxPrevious;	 
N	void * pvOwner;										/*< Pointer to the object (normally a TCB) that contains the list item.  There is therefore a two way link between the object containing the list item and the list item itself. */
N	void * configLIST_VOLATILE pvContainer;				/*< Pointer to the list in which this list item is placed (if any). */
X	void *  pvContainer;				 
N	listSECOND_LIST_ITEM_INTEGRITY_CHECK_VALUE			/*< Set to a known value if configUSE_LIST_DATA_INTEGRITY_CHECK_BYTES is set to 1. */
X				 
N};
Ntypedef struct xLIST_ITEM ListItem_t;					/* For some reason lint wants this as two separate definitions. */
N
Nstruct xMINI_LIST_ITEM
N{
N	listFIRST_LIST_ITEM_INTEGRITY_CHECK_VALUE			/*< Set to a known value if configUSE_LIST_DATA_INTEGRITY_CHECK_BYTES is set to 1. */
X				 
N	configLIST_VOLATILE TickType_t xItemValue;
X	 TickType_t xItemValue;
N	struct xLIST_ITEM * configLIST_VOLATILE pxNext;
X	struct xLIST_ITEM *  pxNext;
N	struct xLIST_ITEM * configLIST_VOLATILE pxPrevious;
X	struct xLIST_ITEM *  pxPrevious;
N};
Ntypedef struct xMINI_LIST_ITEM MiniListItem_t;
N
N/*
N * Definition of the type of queue used by the scheduler.
N */
Ntypedef struct xLIST
N{
N	listFIRST_LIST_INTEGRITY_CHECK_VALUE				/*< Set to a known value if configUSE_LIST_DATA_INTEGRITY_CHECK_BYTES is set to 1. */
X					 
N	configLIST_VOLATILE UBaseType_t uxNumberOfItems;
X	 UBaseType_t uxNumberOfItems;
N	ListItem_t * configLIST_VOLATILE pxIndex;			/*< Used to walk through the list.  Points to the last item returned by a call to listGET_OWNER_OF_NEXT_ENTRY (). */
X	ListItem_t *  pxIndex;			 
N	MiniListItem_t xListEnd;							/*< List item that contains the maximum possible item value meaning it is always at the end of the list and is therefore used as a marker. */
N	listSECOND_LIST_INTEGRITY_CHECK_VALUE				/*< Set to a known value if configUSE_LIST_DATA_INTEGRITY_CHECK_BYTES is set to 1. */
X					 
N} List_t;
N
N/*
N * Access macro to set the owner of a list item.  The owner of a list item
N * is the object (usually a TCB) that contains the list item.
N *
N * \page listSET_LIST_ITEM_OWNER listSET_LIST_ITEM_OWNER
N * \ingroup LinkedList
N */
N#define listSET_LIST_ITEM_OWNER( pxListItem, pxOwner )		( ( pxListItem )->pvOwner = ( void * ) ( pxOwner ) )
N
N/*
N * Access macro to get the owner of a list item.  The owner of a list item
N * is the object (usually a TCB) that contains the list item.
N *
N * \page listSET_LIST_ITEM_OWNER listSET_LIST_ITEM_OWNER
N * \ingroup LinkedList
N */
N#define listGET_LIST_ITEM_OWNER( pxListItem )	( ( pxListItem )->pvOwner )
N
N/*
N * Access macro to set the value of the list item.  In most cases the value is
N * used to sort the list in descending order.
N *
N * \page listSET_LIST_ITEM_VALUE listSET_LIST_ITEM_VALUE
N * \ingroup LinkedList
N */
N#define listSET_LIST_ITEM_VALUE( pxListItem, xValue )	( ( pxListItem )->xItemValue = ( xValue ) )
N
N/*
N * Access macro to retrieve the value of the list item.  The value can
N * represent anything - for example the priority of a task, or the time at
N * which a task should be unblocked.
N *
N * \page listGET_LIST_ITEM_VALUE listGET_LIST_ITEM_VALUE
N * \ingroup LinkedList
N */
N#define listGET_LIST_ITEM_VALUE( pxListItem )	( ( pxListItem )->xItemValue )
N
N/*
N * Access macro to retrieve the value of the list item at the head of a given
N * list.
N *
N * \page listGET_LIST_ITEM_VALUE listGET_LIST_ITEM_VALUE
N * \ingroup LinkedList
N */
N#define listGET_ITEM_VALUE_OF_HEAD_ENTRY( pxList )	( ( ( pxList )->xListEnd ).pxNext->xItemValue )
N
N/*
N * Return the list item at the head of the list.
N *
N * \page listGET_HEAD_ENTRY listGET_HEAD_ENTRY
N * \ingroup LinkedList
N */
N#define listGET_HEAD_ENTRY( pxList )	( ( ( pxList )->xListEnd ).pxNext )
N
N/*
N * Return the list item at the head of the list.
N *
N * \page listGET_NEXT listGET_NEXT
N * \ingroup LinkedList
N */
N#define listGET_NEXT( pxListItem )	( ( pxListItem )->pxNext )
N
N/*
N * Return the list item that marks the end of the list
N *
N * \page listGET_END_MARKER listGET_END_MARKER
N * \ingroup LinkedList
N */
N#define listGET_END_MARKER( pxList )	( ( ListItem_t const * ) ( &( ( pxList )->xListEnd ) ) )
N
N/*
N * Access macro to determine if a list contains any items.  The macro will
N * only have the value true if the list is empty.
N *
N * \page listLIST_IS_EMPTY listLIST_IS_EMPTY
N * \ingroup LinkedList
N */
N#define listLIST_IS_EMPTY( pxList )	( ( BaseType_t ) ( ( pxList )->uxNumberOfItems == ( UBaseType_t ) 0 ) )
N
N/*
N * Access macro to return the number of items in the list.
N */
N#define listCURRENT_LIST_LENGTH( pxList )	( ( pxList )->uxNumberOfItems )
N
N/*
N * Access function to obtain the owner of the next entry in a list.
N *
N * The list member pxIndex is used to walk through a list.  Calling
N * listGET_OWNER_OF_NEXT_ENTRY increments pxIndex to the next item in the list
N * and returns that entry's pxOwner parameter.  Using multiple calls to this
N * function it is therefore possible to move through every item contained in
N * a list.
N *
N * The pxOwner parameter of a list item is a pointer to the object that owns
N * the list item.  In the scheduler this is normally a task control block.
N * The pxOwner parameter effectively creates a two way link between the list
N * item and its owner.
N *
N * @param pxTCB pxTCB is set to the address of the owner of the next list item.
N * @param pxList The list from which the next item owner is to be returned.
N *
N * \page listGET_OWNER_OF_NEXT_ENTRY listGET_OWNER_OF_NEXT_ENTRY
N * \ingroup LinkedList
N */
N#define listGET_OWNER_OF_NEXT_ENTRY( pxTCB, pxList )										\
N{																							\
NList_t * const pxConstList = ( pxList );													\
N	/* Increment the index to the next item and return the item, ensuring */				\
N	/* we don't return the marker used at the end of the list.  */							\
N	( pxConstList )->pxIndex = ( pxConstList )->pxIndex->pxNext;							\
N	if( ( void * ) ( pxConstList )->pxIndex == ( void * ) &( ( pxConstList )->xListEnd ) )	\
N	{																						\
N		( pxConstList )->pxIndex = ( pxConstList )->pxIndex->pxNext;						\
N	}																						\
N	( pxTCB ) = ( pxConstList )->pxIndex->pvOwner;											\
N}
X#define listGET_OWNER_OF_NEXT_ENTRY( pxTCB, pxList )										{																							List_t * const pxConstList = ( pxList );														 					 								( pxConstList )->pxIndex = ( pxConstList )->pxIndex->pxNext;								if( ( void * ) ( pxConstList )->pxIndex == ( void * ) &( ( pxConstList )->xListEnd ) )		{																								( pxConstList )->pxIndex = ( pxConstList )->pxIndex->pxNext;							}																							( pxTCB ) = ( pxConstList )->pxIndex->pvOwner;											}
N
N
N/*
N * Access function to obtain the owner of the first entry in a list.  Lists
N * are normally sorted in ascending item value order.
N *
N * This function returns the pxOwner member of the first item in the list.
N * The pxOwner parameter of a list item is a pointer to the object that owns
N * the list item.  In the scheduler this is normally a task control block.
N * The pxOwner parameter effectively creates a two way link between the list
N * item and its owner.
N *
N * @param pxList The list from which the owner of the head item is to be
N * returned.
N *
N * \page listGET_OWNER_OF_HEAD_ENTRY listGET_OWNER_OF_HEAD_ENTRY
N * \ingroup LinkedList
N */
N#define listGET_OWNER_OF_HEAD_ENTRY( pxList )  ( (&( ( pxList )->xListEnd ))->pxNext->pvOwner )
N
N/*
N * Check to see if a list item is within a list.  The list item maintains a
N * "container" pointer that points to the list it is in.  All this macro does
N * is check to see if the container and the list match.
N *
N * @param pxList The list we want to know if the list item is within.
N * @param pxListItem The list item we want to know if is in the list.
N * @return pdTRUE if the list item is in the list, otherwise pdFALSE.
N */
N#define listIS_CONTAINED_WITHIN( pxList, pxListItem ) ( ( BaseType_t ) ( ( pxListItem )->pvContainer == ( void * ) ( pxList ) ) )
N
N/*
N * Return the list a list item is contained within (referenced from).
N *
N * @param pxListItem The list item being queried.
N * @return A pointer to the List_t object that references the pxListItem
N */
N#define listLIST_ITEM_CONTAINER( pxListItem ) ( ( pxListItem )->pvContainer )
N
N/*
N * This provides a crude means of knowing if a list has been initialised, as
N * pxList->xListEnd.xItemValue is set to portMAX_DELAY by the vListInitialise()
N * function.
N */
N#define listLIST_IS_INITIALISED( pxList ) ( ( pxList )->xListEnd.xItemValue == portMAX_DELAY )
N
N/*
N * Must be called before a list is used!  This initialises all the members
N * of the list structure and inserts the xListEnd item into the list as a
N * marker to the back of the list.
N *
N * @param pxList Pointer to the list being initialised.
N *
N * \page vListInitialise vListInitialise
N * \ingroup LinkedList
N */
Nvoid vListInitialise( List_t * const pxList ) PRIVILEGED_FUNCTION;
Xvoid vListInitialise( List_t * const pxList ) ;
N
N/*
N * Must be called before a list item is used.  This sets the list container to
N * null so the item does not think that it is already contained in a list.
N *
N * @param pxItem Pointer to the list item being initialised.
N *
N * \page vListInitialiseItem vListInitialiseItem
N * \ingroup LinkedList
N */
Nvoid vListInitialiseItem( ListItem_t * const pxItem ) PRIVILEGED_FUNCTION;
Xvoid vListInitialiseItem( ListItem_t * const pxItem ) ;
N
N/*
N * Insert a list item into a list.  The item will be inserted into the list in
N * a position determined by its item value (descending item value order).
N *
N * @param pxList The list into which the item is to be inserted.
N *
N * @param pxNewListItem The item that is to be placed in the list.
N *
N * \page vListInsert vListInsert
N * \ingroup LinkedList
N */
Nvoid vListInsert( List_t * const pxList, ListItem_t * const pxNewListItem ) PRIVILEGED_FUNCTION;
Xvoid vListInsert( List_t * const pxList, ListItem_t * const pxNewListItem ) ;
N
N/*
N * Insert a list item into a list.  The item will be inserted in a position
N * such that it will be the last item within the list returned by multiple
N * calls to listGET_OWNER_OF_NEXT_ENTRY.
N *
N * The list member pxIndex is used to walk through a list.  Calling
N * listGET_OWNER_OF_NEXT_ENTRY increments pxIndex to the next item in the list.
N * Placing an item in a list using vListInsertEnd effectively places the item
N * in the list position pointed to by pxIndex.  This means that every other
N * item within the list will be returned by listGET_OWNER_OF_NEXT_ENTRY before
N * the pxIndex parameter again points to the item being inserted.
N *
N * @param pxList The list into which the item is to be inserted.
N *
N * @param pxNewListItem The list item to be inserted into the list.
N *
N * \page vListInsertEnd vListInsertEnd
N * \ingroup LinkedList
N */
Nvoid vListInsertEnd( List_t * const pxList, ListItem_t * const pxNewListItem ) PRIVILEGED_FUNCTION;
Xvoid vListInsertEnd( List_t * const pxList, ListItem_t * const pxNewListItem ) ;
N
N/*
N * Remove an item from a list.  The list item has a pointer to the list that
N * it is in, so only the list item need be passed into the function.
N *
N * @param uxListRemove The item to be removed.  The item will remove itself from
N * the list pointed to by it's pxContainer parameter.
N *
N * @return The number of items that remain in the list after the list item has
N * been removed.
N *
N * \page uxListRemove uxListRemove
N * \ingroup LinkedList
N */
NUBaseType_t uxListRemove( ListItem_t * const pxItemToRemove ) PRIVILEGED_FUNCTION;
XUBaseType_t uxListRemove( ListItem_t * const pxItemToRemove ) ;
N
N#ifdef __cplusplus
S}
N#endif
N
N#endif
N
L 79 ".\rtos\include\task.h" 2
N
N#ifdef __cplusplus
Sextern "C" {
N#endif
N
N/*-----------------------------------------------------------
N * MACROS AND DEFINITIONS
N *----------------------------------------------------------*/
N
N#define tskKERNEL_VERSION_NUMBER "V9.0.0"
N#define tskKERNEL_VERSION_MAJOR 9
N#define tskKERNEL_VERSION_MINOR 0
N#define tskKERNEL_VERSION_BUILD 0
N
N/**
N * task. h
N *
N * Type by which tasks are referenced.  For example, a call to xTaskCreate
N * returns (via a pointer parameter) an TaskHandle_t variable that can then
N * be used as a parameter to vTaskDelete to delete the task.
N *
N * \defgroup TaskHandle_t TaskHandle_t
N * \ingroup Tasks
N */
Ntypedef void * TaskHandle_t;
N
N/*
N * Defines the prototype to which the application task hook function must
N * conform.
N */
Ntypedef BaseType_t (*TaskHookFunction_t)( void * );
N
N/* Task states returned by eTaskGetState. */
Ntypedef enum
N{
N	eRunning = 0,	/* A task is querying the state of itself, so must be running. */
N	eReady,			/* The task being queried is in a read or pending ready list. */
N	eBlocked,		/* The task being queried is in the Blocked state. */
N	eSuspended,		/* The task being queried is in the Suspended state, or is in the Blocked state with an infinite time out. */
N	eDeleted,		/* The task being queried has been deleted, but its TCB has not yet been freed. */
N	eInvalid			/* Used as an 'invalid state' value. */
N} eTaskState;
N
N/* Actions that can be performed when vTaskNotify() is called. */
Ntypedef enum
N{
N	eNoAction = 0,				/* Notify the task without updating its notify value. */
N	eSetBits,					/* Set bits in the task's notification value. */
N	eIncrement,					/* Increment the task's notification value. */
N	eSetValueWithOverwrite,		/* Set the task's notification value to a specific value even if the previous value has not yet been read by the task. */
N	eSetValueWithoutOverwrite	/* Set the task's notification value if the previous value has been read by the task. */
N} eNotifyAction;
N
N/*
N * Used internally only.
N */
Ntypedef struct xTIME_OUT
N{
N	BaseType_t xOverflowCount;
N	TickType_t xTimeOnEntering;
N} TimeOut_t;
N
N/*
N * Defines the memory ranges allocated to the task when an MPU is used.
N */
Ntypedef struct xMEMORY_REGION
N{
N	void *pvBaseAddress;
N	uint32_t ulLengthInBytes;
N	uint32_t ulParameters;
N} MemoryRegion_t;
N
N/*
N * Parameters required to create an MPU protected task.
N */
Ntypedef struct xTASK_PARAMETERS
N{
N	TaskFunction_t pvTaskCode;
N	const char * const pcName;	/*lint !e971 Unqualified char types are allowed for strings and single characters only. */
N	uint16_t usStackDepth;
N	void *pvParameters;
N	UBaseType_t uxPriority;
N	StackType_t *puxStackBuffer;
N	MemoryRegion_t xRegions[ portNUM_CONFIGURABLE_REGIONS ];
X	MemoryRegion_t xRegions[ 1 ];
N} TaskParameters_t;
N
N/* Used with the uxTaskGetSystemState() function to return the state of each task
Nin the system. */
Ntypedef struct xTASK_STATUS
N{
N	TaskHandle_t xHandle;			/* The handle of the task to which the rest of the information in the structure relates. */
N	const char *pcTaskName;			/* A pointer to the task's name.  This value will be invalid if the task was deleted since the structure was populated! */ /*lint !e971 Unqualified char types are allowed for strings and single characters only. */
N	UBaseType_t xTaskNumber;		/* A number unique to the task. */
N	eTaskState eCurrentState;		/* The state in which the task existed when the structure was populated. */
N	UBaseType_t uxCurrentPriority;	/* The priority at which the task was running (may be inherited) when the structure was populated. */
N	UBaseType_t uxBasePriority;		/* The priority to which the task will return if the task's current priority has been inherited to avoid unbounded priority inversion when obtaining a mutex.  Only valid if configUSE_MUTEXES is defined as 1 in FreeRTOSConfig.h. */
N	uint32_t ulRunTimeCounter;		/* The total run time allocated to the task so far, as defined by the run time stats clock.  See http://www.freertos.org/rtos-run-time-stats.html.  Only valid when configGENERATE_RUN_TIME_STATS is defined as 1 in FreeRTOSConfig.h. */
N	StackType_t *pxStackBase;		/* Points to the lowest address of the task's stack area. */
N	uint16_t usStackHighWaterMark;	/* The minimum amount of stack space that has remained for the task since the task was created.  The closer this value is to zero the closer the task has come to overflowing its stack. */
N} TaskStatus_t;
N
N/* Possible return values for eTaskConfirmSleepModeStatus(). */
Ntypedef enum
N{
N	eAbortSleep = 0,		/* A task has been made ready or a context switch pended since portSUPPORESS_TICKS_AND_SLEEP() was called - abort entering a sleep mode. */
N	eStandardSleep,			/* Enter a sleep mode that will not last any longer than the expected idle time. */
N	eNoTasksWaitingTimeout	/* No tasks are waiting for a timeout so it is safe to enter a sleep mode that can only be exited by an external interrupt. */
N} eSleepModeStatus;
N
N/**
N * Defines the priority used by the idle task.  This must not be modified.
N *
N * \ingroup TaskUtils
N */
N#define tskIDLE_PRIORITY			( ( UBaseType_t ) 0U )
N
N/**
N * task. h
N *
N * Macro for forcing a context switch.
N *
N * \defgroup taskYIELD taskYIELD
N * \ingroup SchedulerControl
N */
N#define taskYIELD()					portYIELD()
N
N/**
N * task. h
N *
N * Macro to mark the start of a critical code region.  Preemptive context
N * switches cannot occur when in a critical region.
N *
N * NOTE: This may alter the stack (depending on the portable implementation)
N * so must be used with care!
N *
N * \defgroup taskENTER_CRITICAL taskENTER_CRITICAL
N * \ingroup SchedulerControl
N */
N#define taskENTER_CRITICAL()		portENTER_CRITICAL()
N#define taskENTER_CRITICAL_FROM_ISR() portSET_INTERRUPT_MASK_FROM_ISR()
N
N/**
N * task. h
N *
N * Macro to mark the end of a critical code region.  Preemptive context
N * switches cannot occur when in a critical region.
N *
N * NOTE: This may alter the stack (depending on the portable implementation)
N * so must be used with care!
N *
N * \defgroup taskEXIT_CRITICAL taskEXIT_CRITICAL
N * \ingroup SchedulerControl
N */
N#define taskEXIT_CRITICAL()			portEXIT_CRITICAL()
N#define taskEXIT_CRITICAL_FROM_ISR( x ) portCLEAR_INTERRUPT_MASK_FROM_ISR( x )
N/**
N * task. h
N *
N * Macro to disable all maskable interrupts.
N *
N * \defgroup taskDISABLE_INTERRUPTS taskDISABLE_INTERRUPTS
N * \ingroup SchedulerControl
N */
N#define taskDISABLE_INTERRUPTS()	portDISABLE_INTERRUPTS()
N
N/**
N * task. h
N *
N * Macro to enable microcontroller interrupts.
N *
N * \defgroup taskENABLE_INTERRUPTS taskENABLE_INTERRUPTS
N * \ingroup SchedulerControl
N */
N#define taskENABLE_INTERRUPTS()		portENABLE_INTERRUPTS()
N
N/* Definitions returned by xTaskGetSchedulerState().  taskSCHEDULER_SUSPENDED is
N0 to generate more optimal code when configASSERT() is defined as the constant
Nis used in assert() statements. */
N#define taskSCHEDULER_SUSPENDED		( ( BaseType_t ) 0 )
N#define taskSCHEDULER_NOT_STARTED	( ( BaseType_t ) 1 )
N#define taskSCHEDULER_RUNNING		( ( BaseType_t ) 2 )
N
N
N/*-----------------------------------------------------------
N * TASK CREATION API
N *----------------------------------------------------------*/
N
N/**
N * task. h
N *<pre>
N BaseType_t xTaskCreate(
N							  TaskFunction_t pvTaskCode,
N							  const char * const pcName,
N							  uint16_t usStackDepth,
N							  void *pvParameters,
N							  UBaseType_t uxPriority,
N							  TaskHandle_t *pvCreatedTask
N						  );</pre>
N *
N * Create a new task and add it to the list of tasks that are ready to run.
N *
N * Internally, within the FreeRTOS implementation, tasks use two blocks of
N * memory.  The first block is used to hold the task's data structures.  The
N * second block is used by the task as its stack.  If a task is created using
N * xTaskCreate() then both blocks of memory are automatically dynamically
N * allocated inside the xTaskCreate() function.  (see
N * http://www.freertos.org/a00111.html).  If a task is created using
N * xTaskCreateStatic() then the application writer must provide the required
N * memory.  xTaskCreateStatic() therefore allows a task to be created without
N * using any dynamic memory allocation.
N *
N * See xTaskCreateStatic() for a version that does not use any dynamic memory
N * allocation.
N *
N * xTaskCreate() can only be used to create a task that has unrestricted
N * access to the entire microcontroller memory map.  Systems that include MPU
N * support can alternatively create an MPU constrained task using
N * xTaskCreateRestricted().
N *
N * @param pvTaskCode Pointer to the task entry function.  Tasks
N * must be implemented to never return (i.e. continuous loop).
N *
N * @param pcName A descriptive name for the task.  This is mainly used to
N * facilitate debugging.  Max length defined by configMAX_TASK_NAME_LEN - default
N * is 16.
N *
N * @param usStackDepth The size of the task stack specified as the number of
N * variables the stack can hold - not the number of bytes.  For example, if
N * the stack is 16 bits wide and usStackDepth is defined as 100, 200 bytes
N * will be allocated for stack storage.
N *
N * @param pvParameters Pointer that will be used as the parameter for the task
N * being created.
N *
N * @param uxPriority The priority at which the task should run.  Systems that
N * include MPU support can optionally create tasks in a privileged (system)
N * mode by setting bit portPRIVILEGE_BIT of the priority parameter.  For
N * example, to create a privileged task at priority 2 the uxPriority parameter
N * should be set to ( 2 | portPRIVILEGE_BIT ).
N *
N * @param pvCreatedTask Used to pass back a handle by which the created task
N * can be referenced.
N *
N * @return pdPASS if the task was successfully created and added to a ready
N * list, otherwise an error code defined in the file projdefs.h
N *
N * Example usage:
N   <pre>
N // Task to be created.
N void vTaskCode( void * pvParameters )
N {
N	 for( ;; )
N	 {
N		 // Task code goes here.
N	 }
N }
N
N // Function that creates a task.
N void vOtherFunction( void )
N {
N static uint8_t ucParameterToPass;
N TaskHandle_t xHandle = NULL;
N
N	 // Create the task, storing the handle.  Note that the passed parameter ucParameterToPass
N	 // must exist for the lifetime of the task, so in this case is declared static.  If it was just an
N	 // an automatic stack variable it might no longer exist, or at least have been corrupted, by the time
N	 // the new task attempts to access it.
N	 xTaskCreate( vTaskCode, "NAME", STACK_SIZE, &ucParameterToPass, tskIDLE_PRIORITY, &xHandle );
N     configASSERT( xHandle );
N
N	 // Use the handle to delete the task.
N     if( xHandle != NULL )
N     {
N	     vTaskDelete( xHandle );
N     }
N }
N   </pre>
N * \defgroup xTaskCreate xTaskCreate
N * \ingroup Tasks
N */
N#if( configSUPPORT_DYNAMIC_ALLOCATION == 1 )
X#if( 1 == 1 )
N	BaseType_t xTaskCreate(	TaskFunction_t pxTaskCode,
N							const char * const pcName,
N							const uint16_t usStackDepth,
N							void * const pvParameters,
N							UBaseType_t uxPriority,
N							TaskHandle_t * const pxCreatedTask ) PRIVILEGED_FUNCTION; /*lint !e971 Unqualified char types are allowed for strings and single characters only. */
X							TaskHandle_t * const pxCreatedTask ) ;  
N#endif
N
N/**
N * task. h
N *<pre>
N TaskHandle_t xTaskCreateStatic( TaskFunction_t pvTaskCode,
N								 const char * const pcName,
N								 uint32_t ulStackDepth,
N								 void *pvParameters,
N								 UBaseType_t uxPriority,
N								 StackType_t *pxStackBuffer,
N								 StaticTask_t *pxTaskBuffer );</pre>
N *
N * Create a new task and add it to the list of tasks that are ready to run.
N *
N * Internally, within the FreeRTOS implementation, tasks use two blocks of
N * memory.  The first block is used to hold the task's data structures.  The
N * second block is used by the task as its stack.  If a task is created using
N * xTaskCreate() then both blocks of memory are automatically dynamically
N * allocated inside the xTaskCreate() function.  (see
N * http://www.freertos.org/a00111.html).  If a task is created using
N * xTaskCreateStatic() then the application writer must provide the required
N * memory.  xTaskCreateStatic() therefore allows a task to be created without
N * using any dynamic memory allocation.
N *
N * @param pvTaskCode Pointer to the task entry function.  Tasks
N * must be implemented to never return (i.e. continuous loop).
N *
N * @param pcName A descriptive name for the task.  This is mainly used to
N * facilitate debugging.  The maximum length of the string is defined by
N * configMAX_TASK_NAME_LEN in FreeRTOSConfig.h.
N *
N * @param ulStackDepth The size of the task stack specified as the number of
N * variables the stack can hold - not the number of bytes.  For example, if
N * the stack is 32-bits wide and ulStackDepth is defined as 100 then 400 bytes
N * will be allocated for stack storage.
N *
N * @param pvParameters Pointer that will be used as the parameter for the task
N * being created.
N *
N * @param uxPriority The priority at which the task will run.
N *
N * @param pxStackBuffer Must point to a StackType_t array that has at least
N * ulStackDepth indexes - the array will then be used as the task's stack,
N * removing the need for the stack to be allocated dynamically.
N *
N * @param pxTaskBuffer Must point to a variable of type StaticTask_t, which will
N * then be used to hold the task's data structures, removing the need for the
N * memory to be allocated dynamically.
N *
N * @return If neither pxStackBuffer or pxTaskBuffer are NULL, then the task will
N * be created and pdPASS is returned.  If either pxStackBuffer or pxTaskBuffer
N * are NULL then the task will not be created and
N * errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY is returned.
N *
N * Example usage:
N   <pre>
N
N    // Dimensions the buffer that the task being created will use as its stack.
N    // NOTE:  This is the number of words the stack will hold, not the number of
N    // bytes.  For example, if each stack item is 32-bits, and this is set to 100,
N    // then 400 bytes (100 * 32-bits) will be allocated.
N    #define STACK_SIZE 200
N
N    // Structure that will hold the TCB of the task being created.
N    StaticTask_t xTaskBuffer;
N
N    // Buffer that the task being created will use as its stack.  Note this is
N    // an array of StackType_t variables.  The size of StackType_t is dependent on
N    // the RTOS port.
N    StackType_t xStack[ STACK_SIZE ];
N
N    // Function that implements the task being created.
N    void vTaskCode( void * pvParameters )
N    {
N        // The parameter value is expected to be 1 as 1 is passed in the
N        // pvParameters value in the call to xTaskCreateStatic().
N        configASSERT( ( uint32_t ) pvParameters == 1UL );
N
N        for( ;; )
N        {
N            // Task code goes here.
N        }
N    }
N
N    // Function that creates a task.
N    void vOtherFunction( void )
N    {
N        TaskHandle_t xHandle = NULL;
N
N        // Create the task without using any dynamic memory allocation.
N        xHandle = xTaskCreateStatic(
N                      vTaskCode,       // Function that implements the task.
N                      "NAME",          // Text name for the task.
N                      STACK_SIZE,      // Stack size in words, not bytes.
N                      ( void * ) 1,    // Parameter passed into the task.
N                      tskIDLE_PRIORITY,// Priority at which the task is created.
N                      xStack,          // Array to use as the task's stack.
N                      &xTaskBuffer );  // Variable to hold the task's data structure.
N
N        // puxStackBuffer and pxTaskBuffer were not NULL, so the task will have
N        // been created, and xHandle will be the task's handle.  Use the handle
N        // to suspend the task.
N        vTaskSuspend( xHandle );
N    }
N   </pre>
N * \defgroup xTaskCreateStatic xTaskCreateStatic
N * \ingroup Tasks
N */
N#if( configSUPPORT_STATIC_ALLOCATION == 1 )
X#if( 0 == 1 )
S	TaskHandle_t xTaskCreateStatic(	TaskFunction_t pxTaskCode,
S									const char * const pcName,
S									const uint32_t ulStackDepth,
S									void * const pvParameters,
S									UBaseType_t uxPriority,
S									StackType_t * const puxStackBuffer,
S									StaticTask_t * const pxTaskBuffer ) PRIVILEGED_FUNCTION; /*lint !e971 Unqualified char types are allowed for strings and single characters only. */
N#endif /* configSUPPORT_STATIC_ALLOCATION */
N
N/**
N * task. h
N *<pre>
N BaseType_t xTaskCreateRestricted( TaskParameters_t *pxTaskDefinition, TaskHandle_t *pxCreatedTask );</pre>
N *
N * xTaskCreateRestricted() should only be used in systems that include an MPU
N * implementation.
N *
N * Create a new task and add it to the list of tasks that are ready to run.
N * The function parameters define the memory regions and associated access
N * permissions allocated to the task.
N *
N * @param pxTaskDefinition Pointer to a structure that contains a member
N * for each of the normal xTaskCreate() parameters (see the xTaskCreate() API
N * documentation) plus an optional stack buffer and the memory region
N * definitions.
N *
N * @param pxCreatedTask Used to pass back a handle by which the created task
N * can be referenced.
N *
N * @return pdPASS if the task was successfully created and added to a ready
N * list, otherwise an error code defined in the file projdefs.h
N *
N * Example usage:
N   <pre>
N// Create an TaskParameters_t structure that defines the task to be created.
Nstatic const TaskParameters_t xCheckTaskParameters =
N{
N	vATask,		// pvTaskCode - the function that implements the task.
N	"ATask",	// pcName - just a text name for the task to assist debugging.
N	100,		// usStackDepth	- the stack size DEFINED IN WORDS.
N	NULL,		// pvParameters - passed into the task function as the function parameters.
N	( 1UL | portPRIVILEGE_BIT ),// uxPriority - task priority, set the portPRIVILEGE_BIT if the task should run in a privileged state.
N	cStackBuffer,// puxStackBuffer - the buffer to be used as the task stack.
N
N	// xRegions - Allocate up to three separate memory regions for access by
N	// the task, with appropriate access permissions.  Different processors have
N	// different memory alignment requirements - refer to the FreeRTOS documentation
N	// for full information.
N	{
N		// Base address					Length	Parameters
N        { cReadWriteArray,				32,		portMPU_REGION_READ_WRITE },
N        { cReadOnlyArray,				32,		portMPU_REGION_READ_ONLY },
N        { cPrivilegedOnlyAccessArray,	128,	portMPU_REGION_PRIVILEGED_READ_WRITE }
N	}
N};
N
Nint main( void )
N{
NTaskHandle_t xHandle;
N
N	// Create a task from the const structure defined above.  The task handle
N	// is requested (the second parameter is not NULL) but in this case just for
N	// demonstration purposes as its not actually used.
N	xTaskCreateRestricted( &xRegTest1Parameters, &xHandle );
N
N	// Start the scheduler.
N	vTaskStartScheduler();
N
N	// Will only get here if there was insufficient memory to create the idle
N	// and/or timer task.
N	for( ;; );
N}
N   </pre>
N * \defgroup xTaskCreateRestricted xTaskCreateRestricted
N * \ingroup Tasks
N */
N#if( portUSING_MPU_WRAPPERS == 1 )
X#if( 0 == 1 )
S	BaseType_t xTaskCreateRestricted( const TaskParameters_t * const pxTaskDefinition, TaskHandle_t *pxCreatedTask ) PRIVILEGED_FUNCTION;
N#endif
N
N/**
N * task. h
N *<pre>
N void vTaskAllocateMPURegions( TaskHandle_t xTask, const MemoryRegion_t * const pxRegions );</pre>
N *
N * Memory regions are assigned to a restricted task when the task is created by
N * a call to xTaskCreateRestricted().  These regions can be redefined using
N * vTaskAllocateMPURegions().
N *
N * @param xTask The handle of the task being updated.
N *
N * @param xRegions A pointer to an MemoryRegion_t structure that contains the
N * new memory region definitions.
N *
N * Example usage:
N   <pre>
N// Define an array of MemoryRegion_t structures that configures an MPU region
N// allowing read/write access for 1024 bytes starting at the beginning of the
N// ucOneKByte array.  The other two of the maximum 3 definable regions are
N// unused so set to zero.
Nstatic const MemoryRegion_t xAltRegions[ portNUM_CONFIGURABLE_REGIONS ] =
N{
N	// Base address		Length		Parameters
N	{ ucOneKByte,		1024,		portMPU_REGION_READ_WRITE },
N	{ 0,				0,			0 },
N	{ 0,				0,			0 }
N};
N
Nvoid vATask( void *pvParameters )
N{
N	// This task was created such that it has access to certain regions of
N	// memory as defined by the MPU configuration.  At some point it is
N	// desired that these MPU regions are replaced with that defined in the
N	// xAltRegions const struct above.  Use a call to vTaskAllocateMPURegions()
N	// for this purpose.  NULL is used as the task handle to indicate that this
N	// function should modify the MPU regions of the calling task.
N	vTaskAllocateMPURegions( NULL, xAltRegions );
N
N	// Now the task can continue its function, but from this point on can only
N	// access its stack and the ucOneKByte array (unless any other statically
N	// defined or shared regions have been declared elsewhere).
N}
N   </pre>
N * \defgroup xTaskCreateRestricted xTaskCreateRestricted
N * \ingroup Tasks
N */
Nvoid vTaskAllocateMPURegions( TaskHandle_t xTask, const MemoryRegion_t * const pxRegions ) PRIVILEGED_FUNCTION;
Xvoid vTaskAllocateMPURegions( TaskHandle_t xTask, const MemoryRegion_t * const pxRegions ) ;
N
N/**
N * task. h
N * <pre>void vTaskDelete( TaskHandle_t xTask );</pre>
N *
N * INCLUDE_vTaskDelete must be defined as 1 for this function to be available.
N * See the configuration section for more information.
N *
N * Remove a task from the RTOS real time kernel's management.  The task being
N * deleted will be removed from all ready, blocked, suspended and event lists.
N *
N * NOTE:  The idle task is responsible for freeing the kernel allocated
N * memory from tasks that have been deleted.  It is therefore important that
N * the idle task is not starved of microcontroller processing time if your
N * application makes any calls to vTaskDelete ().  Memory allocated by the
N * task code is not automatically freed, and should be freed before the task
N * is deleted.
N *
N * See the demo application file death.c for sample code that utilises
N * vTaskDelete ().
N *
N * @param xTask The handle of the task to be deleted.  Passing NULL will
N * cause the calling task to be deleted.
N *
N * Example usage:
N   <pre>
N void vOtherFunction( void )
N {
N TaskHandle_t xHandle;
N
N	 // Create the task, storing the handle.
N	 xTaskCreate( vTaskCode, "NAME", STACK_SIZE, NULL, tskIDLE_PRIORITY, &xHandle );
N
N	 // Use the handle to delete the task.
N	 vTaskDelete( xHandle );
N }
N   </pre>
N * \defgroup vTaskDelete vTaskDelete
N * \ingroup Tasks
N */
Nvoid vTaskDelete( TaskHandle_t xTaskToDelete ) PRIVILEGED_FUNCTION;
Xvoid vTaskDelete( TaskHandle_t xTaskToDelete ) ;
N
N/*-----------------------------------------------------------
N * TASK CONTROL API
N *----------------------------------------------------------*/
N
N/**
N * task. h
N * <pre>void vTaskDelay( const TickType_t xTicksToDelay );</pre>
N *
N * Delay a task for a given number of ticks.  The actual time that the
N * task remains blocked depends on the tick rate.  The constant
N * portTICK_PERIOD_MS can be used to calculate real time from the tick
N * rate - with the resolution of one tick period.
N *
N * INCLUDE_vTaskDelay must be defined as 1 for this function to be available.
N * See the configuration section for more information.
N *
N *
N * vTaskDelay() specifies a time at which the task wishes to unblock relative to
N * the time at which vTaskDelay() is called.  For example, specifying a block
N * period of 100 ticks will cause the task to unblock 100 ticks after
N * vTaskDelay() is called.  vTaskDelay() does not therefore provide a good method
N * of controlling the frequency of a periodic task as the path taken through the
N * code, as well as other task and interrupt activity, will effect the frequency
N * at which vTaskDelay() gets called and therefore the time at which the task
N * next executes.  See vTaskDelayUntil() for an alternative API function designed
N * to facilitate fixed frequency execution.  It does this by specifying an
N * absolute time (rather than a relative time) at which the calling task should
N * unblock.
N *
N * @param xTicksToDelay The amount of time, in tick periods, that
N * the calling task should block.
N *
N * Example usage:
N
N void vTaskFunction( void * pvParameters )
N {
N // Block for 500ms.
N const TickType_t xDelay = 500 / portTICK_PERIOD_MS;
N
N	 for( ;; )
N	 {
N		 // Simply toggle the LED every 500ms, blocking between each toggle.
N		 vToggleLED();
N		 vTaskDelay( xDelay );
N	 }
N }
N
N * \defgroup vTaskDelay vTaskDelay
N * \ingroup TaskCtrl
N */
Nvoid vTaskDelay( const TickType_t xTicksToDelay ) PRIVILEGED_FUNCTION;
Xvoid vTaskDelay( const TickType_t xTicksToDelay ) ;
N
N/**
N * task. h
N * <pre>void vTaskDelayUntil( TickType_t *pxPreviousWakeTime, const TickType_t xTimeIncrement );</pre>
N *
N * INCLUDE_vTaskDelayUntil must be defined as 1 for this function to be available.
N * See the configuration section for more information.
N *
N * Delay a task until a specified time.  This function can be used by periodic
N * tasks to ensure a constant execution frequency.
N *
N * This function differs from vTaskDelay () in one important aspect:  vTaskDelay () will
N * cause a task to block for the specified number of ticks from the time vTaskDelay () is
N * called.  It is therefore difficult to use vTaskDelay () by itself to generate a fixed
N * execution frequency as the time between a task starting to execute and that task
N * calling vTaskDelay () may not be fixed [the task may take a different path though the
N * code between calls, or may get interrupted or preempted a different number of times
N * each time it executes].
N *
N * Whereas vTaskDelay () specifies a wake time relative to the time at which the function
N * is called, vTaskDelayUntil () specifies the absolute (exact) time at which it wishes to
N * unblock.
N *
N * The constant portTICK_PERIOD_MS can be used to calculate real time from the tick
N * rate - with the resolution of one tick period.
N *
N * @param pxPreviousWakeTime Pointer to a variable that holds the time at which the
N * task was last unblocked.  The variable must be initialised with the current time
N * prior to its first use (see the example below).  Following this the variable is
N * automatically updated within vTaskDelayUntil ().
N *
N * @param xTimeIncrement The cycle time period.  The task will be unblocked at
N * time *pxPreviousWakeTime + xTimeIncrement.  Calling vTaskDelayUntil with the
N * same xTimeIncrement parameter value will cause the task to execute with
N * a fixed interface period.
N *
N * Example usage:
N   <pre>
N // Perform an action every 10 ticks.
N void vTaskFunction( void * pvParameters )
N {
N TickType_t xLastWakeTime;
N const TickType_t xFrequency = 10;
N
N	 // Initialise the xLastWakeTime variable with the current time.
N	 xLastWakeTime = xTaskGetTickCount ();
N	 for( ;; )
N	 {
N		 // Wait for the next cycle.
N		 vTaskDelayUntil( &xLastWakeTime, xFrequency );
N
N		 // Perform action here.
N	 }
N }
N   </pre>
N * \defgroup vTaskDelayUntil vTaskDelayUntil
N * \ingroup TaskCtrl
N */
Nvoid vTaskDelayUntil( TickType_t * const pxPreviousWakeTime, const TickType_t xTimeIncrement ) PRIVILEGED_FUNCTION;
Xvoid vTaskDelayUntil( TickType_t * const pxPreviousWakeTime, const TickType_t xTimeIncrement ) ;
N
N/**
N * task. h
N * <pre>BaseType_t xTaskAbortDelay( TaskHandle_t xTask );</pre>
N *
N * INCLUDE_xTaskAbortDelay must be defined as 1 in FreeRTOSConfig.h for this
N * function to be available.
N *
N * A task will enter the Blocked state when it is waiting for an event.  The
N * event it is waiting for can be a temporal event (waiting for a time), such
N * as when vTaskDelay() is called, or an event on an object, such as when
N * xQueueReceive() or ulTaskNotifyTake() is called.  If the handle of a task
N * that is in the Blocked state is used in a call to xTaskAbortDelay() then the
N * task will leave the Blocked state, and return from whichever function call
N * placed the task into the Blocked state.
N *
N * @param xTask The handle of the task to remove from the Blocked state.
N *
N * @return If the task referenced by xTask was not in the Blocked state then
N * pdFAIL is returned.  Otherwise pdPASS is returned.
N *
N * \defgroup xTaskAbortDelay xTaskAbortDelay
N * \ingroup TaskCtrl
N */
NBaseType_t xTaskAbortDelay( TaskHandle_t xTask ) PRIVILEGED_FUNCTION;
XBaseType_t xTaskAbortDelay( TaskHandle_t xTask ) ;
N
N/**
N * task. h
N * <pre>UBaseType_t uxTaskPriorityGet( TaskHandle_t xTask );</pre>
N *
N * INCLUDE_uxTaskPriorityGet must be defined as 1 for this function to be available.
N * See the configuration section for more information.
N *
N * Obtain the priority of any task.
N *
N * @param xTask Handle of the task to be queried.  Passing a NULL
N * handle results in the priority of the calling task being returned.
N *
N * @return The priority of xTask.
N *
N * Example usage:
N   <pre>
N void vAFunction( void )
N {
N TaskHandle_t xHandle;
N
N	 // Create a task, storing the handle.
N	 xTaskCreate( vTaskCode, "NAME", STACK_SIZE, NULL, tskIDLE_PRIORITY, &xHandle );
N
N	 // ...
N
N	 // Use the handle to obtain the priority of the created task.
N	 // It was created with tskIDLE_PRIORITY, but may have changed
N	 // it itself.
N	 if( uxTaskPriorityGet( xHandle ) != tskIDLE_PRIORITY )
N	 {
N		 // The task has changed it's priority.
N	 }
N
N	 // ...
N
N	 // Is our priority higher than the created task?
N	 if( uxTaskPriorityGet( xHandle ) < uxTaskPriorityGet( NULL ) )
N	 {
N		 // Our priority (obtained using NULL handle) is higher.
N	 }
N }
N   </pre>
N * \defgroup uxTaskPriorityGet uxTaskPriorityGet
N * \ingroup TaskCtrl
N */
NUBaseType_t uxTaskPriorityGet( TaskHandle_t xTask ) PRIVILEGED_FUNCTION;
XUBaseType_t uxTaskPriorityGet( TaskHandle_t xTask ) ;
N
N/**
N * task. h
N * <pre>UBaseType_t uxTaskPriorityGetFromISR( TaskHandle_t xTask );</pre>
N *
N * A version of uxTaskPriorityGet() that can be used from an ISR.
N */
NUBaseType_t uxTaskPriorityGetFromISR( TaskHandle_t xTask ) PRIVILEGED_FUNCTION;
XUBaseType_t uxTaskPriorityGetFromISR( TaskHandle_t xTask ) ;
N
N/**
N * task. h
N * <pre>eTaskState eTaskGetState( TaskHandle_t xTask );</pre>
N *
N * INCLUDE_eTaskGetState must be defined as 1 for this function to be available.
N * See the configuration section for more information.
N *
N * Obtain the state of any task.  States are encoded by the eTaskState
N * enumerated type.
N *
N * @param xTask Handle of the task to be queried.
N *
N * @return The state of xTask at the time the function was called.  Note the
N * state of the task might change between the function being called, and the
N * functions return value being tested by the calling task.
N */
NeTaskState eTaskGetState( TaskHandle_t xTask ) PRIVILEGED_FUNCTION;
XeTaskState eTaskGetState( TaskHandle_t xTask ) ;
N
N/**
N * task. h
N * <pre>void vTaskGetInfo( TaskHandle_t xTask, TaskStatus_t *pxTaskStatus, BaseType_t xGetFreeStackSpace, eTaskState eState );</pre>
N *
N * configUSE_TRACE_FACILITY must be defined as 1 for this function to be
N * available.  See the configuration section for more information.
N *
N * Populates a TaskStatus_t structure with information about a task.
N *
N * @param xTask Handle of the task being queried.  If xTask is NULL then
N * information will be returned about the calling task.
N *
N * @param pxTaskStatus A pointer to the TaskStatus_t structure that will be
N * filled with information about the task referenced by the handle passed using
N * the xTask parameter.
N *
N * @xGetFreeStackSpace The TaskStatus_t structure contains a member to report
N * the stack high water mark of the task being queried.  Calculating the stack
N * high water mark takes a relatively long time, and can make the system
N * temporarily unresponsive - so the xGetFreeStackSpace parameter is provided to
N * allow the high water mark checking to be skipped.  The high watermark value
N * will only be written to the TaskStatus_t structure if xGetFreeStackSpace is
N * not set to pdFALSE;
N *
N * @param eState The TaskStatus_t structure contains a member to report the
N * state of the task being queried.  Obtaining the task state is not as fast as
N * a simple assignment - so the eState parameter is provided to allow the state
N * information to be omitted from the TaskStatus_t structure.  To obtain state
N * information then set eState to eInvalid - otherwise the value passed in
N * eState will be reported as the task state in the TaskStatus_t structure.
N *
N * Example usage:
N   <pre>
N void vAFunction( void )
N {
N TaskHandle_t xHandle;
N TaskStatus_t xTaskDetails;
N
N    // Obtain the handle of a task from its name.
N    xHandle = xTaskGetHandle( "Task_Name" );
N
N    // Check the handle is not NULL.
N    configASSERT( xHandle );
N
N    // Use the handle to obtain further information about the task.
N    vTaskGetInfo( xHandle,
N                  &xTaskDetails,
N                  pdTRUE, // Include the high water mark in xTaskDetails.
N                  eInvalid ); // Include the task state in xTaskDetails.
N }
N   </pre>
N * \defgroup vTaskGetInfo vTaskGetInfo
N * \ingroup TaskCtrl
N */
Nvoid vTaskGetInfo( TaskHandle_t xTask, TaskStatus_t *pxTaskStatus, BaseType_t xGetFreeStackSpace, eTaskState eState ) PRIVILEGED_FUNCTION;
Xvoid vTaskGetInfo( TaskHandle_t xTask, TaskStatus_t *pxTaskStatus, BaseType_t xGetFreeStackSpace, eTaskState eState ) ;
N
N/**
N * task. h
N * <pre>void vTaskPrioritySet( TaskHandle_t xTask, UBaseType_t uxNewPriority );</pre>
N *
N * INCLUDE_vTaskPrioritySet must be defined as 1 for this function to be available.
N * See the configuration section for more information.
N *
N * Set the priority of any task.
N *
N * A context switch will occur before the function returns if the priority
N * being set is higher than the currently executing task.
N *
N * @param xTask Handle to the task for which the priority is being set.
N * Passing a NULL handle results in the priority of the calling task being set.
N *
N * @param uxNewPriority The priority to which the task will be set.
N *
N * Example usage:
N   <pre>
N void vAFunction( void )
N {
N TaskHandle_t xHandle;
N
N	 // Create a task, storing the handle.
N	 xTaskCreate( vTaskCode, "NAME", STACK_SIZE, NULL, tskIDLE_PRIORITY, &xHandle );
N
N	 // ...
N
N	 // Use the handle to raise the priority of the created task.
N	 vTaskPrioritySet( xHandle, tskIDLE_PRIORITY + 1 );
N
N	 // ...
N
N	 // Use a NULL handle to raise our priority to the same value.
N	 vTaskPrioritySet( NULL, tskIDLE_PRIORITY + 1 );
N }
N   </pre>
N * \defgroup vTaskPrioritySet vTaskPrioritySet
N * \ingroup TaskCtrl
N */
Nvoid vTaskPrioritySet( TaskHandle_t xTask, UBaseType_t uxNewPriority ) PRIVILEGED_FUNCTION;
Xvoid vTaskPrioritySet( TaskHandle_t xTask, UBaseType_t uxNewPriority ) ;
N
N/**
N * task. h
N * <pre>void vTaskSuspend( TaskHandle_t xTaskToSuspend );</pre>
N *
N * INCLUDE_vTaskSuspend must be defined as 1 for this function to be available.
N * See the configuration section for more information.
N *
N * Suspend any task.  When suspended a task will never get any microcontroller
N * processing time, no matter what its priority.
N *
N * Calls to vTaskSuspend are not accumulative -
N * i.e. calling vTaskSuspend () twice on the same task still only requires one
N * call to vTaskResume () to ready the suspended task.
N *
N * @param xTaskToSuspend Handle to the task being suspended.  Passing a NULL
N * handle will cause the calling task to be suspended.
N *
N * Example usage:
N   <pre>
N void vAFunction( void )
N {
N TaskHandle_t xHandle;
N
N	 // Create a task, storing the handle.
N	 xTaskCreate( vTaskCode, "NAME", STACK_SIZE, NULL, tskIDLE_PRIORITY, &xHandle );
N
N	 // ...
N
N	 // Use the handle to suspend the created task.
N	 vTaskSuspend( xHandle );
N
N	 // ...
N
N	 // The created task will not run during this period, unless
N	 // another task calls vTaskResume( xHandle ).
N
N	 //...
N
N
N	 // Suspend ourselves.
N	 vTaskSuspend( NULL );
N
N	 // We cannot get here unless another task calls vTaskResume
N	 // with our handle as the parameter.
N }
N   </pre>
N * \defgroup vTaskSuspend vTaskSuspend
N * \ingroup TaskCtrl
N */
Nvoid vTaskSuspend( TaskHandle_t xTaskToSuspend ) PRIVILEGED_FUNCTION;
Xvoid vTaskSuspend( TaskHandle_t xTaskToSuspend ) ;
N
N/**
N * task. h
N * <pre>void vTaskResume( TaskHandle_t xTaskToResume );</pre>
N *
N * INCLUDE_vTaskSuspend must be defined as 1 for this function to be available.
N * See the configuration section for more information.
N *
N * Resumes a suspended task.
N *
N * A task that has been suspended by one or more calls to vTaskSuspend ()
N * will be made available for running again by a single call to
N * vTaskResume ().
N *
N * @param xTaskToResume Handle to the task being readied.
N *
N * Example usage:
N   <pre>
N void vAFunction( void )
N {
N TaskHandle_t xHandle;
N
N	 // Create a task, storing the handle.
N	 xTaskCreate( vTaskCode, "NAME", STACK_SIZE, NULL, tskIDLE_PRIORITY, &xHandle );
N
N	 // ...
N
N	 // Use the handle to suspend the created task.
N	 vTaskSuspend( xHandle );
N
N	 // ...
N
N	 // The created task will not run during this period, unless
N	 // another task calls vTaskResume( xHandle ).
N
N	 //...
N
N
N	 // Resume the suspended task ourselves.
N	 vTaskResume( xHandle );
N
N	 // The created task will once again get microcontroller processing
N	 // time in accordance with its priority within the system.
N }
N   </pre>
N * \defgroup vTaskResume vTaskResume
N * \ingroup TaskCtrl
N */
Nvoid vTaskResume( TaskHandle_t xTaskToResume ) PRIVILEGED_FUNCTION;
Xvoid vTaskResume( TaskHandle_t xTaskToResume ) ;
N
N/**
N * task. h
N * <pre>void xTaskResumeFromISR( TaskHandle_t xTaskToResume );</pre>
N *
N * INCLUDE_xTaskResumeFromISR must be defined as 1 for this function to be
N * available.  See the configuration section for more information.
N *
N * An implementation of vTaskResume() that can be called from within an ISR.
N *
N * A task that has been suspended by one or more calls to vTaskSuspend ()
N * will be made available for running again by a single call to
N * xTaskResumeFromISR ().
N *
N * xTaskResumeFromISR() should not be used to synchronise a task with an
N * interrupt if there is a chance that the interrupt could arrive prior to the
N * task being suspended - as this can lead to interrupts being missed. Use of a
N * semaphore as a synchronisation mechanism would avoid this eventuality.
N *
N * @param xTaskToResume Handle to the task being readied.
N *
N * @return pdTRUE if resuming the task should result in a context switch,
N * otherwise pdFALSE. This is used by the ISR to determine if a context switch
N * may be required following the ISR.
N *
N * \defgroup vTaskResumeFromISR vTaskResumeFromISR
N * \ingroup TaskCtrl
N */
NBaseType_t xTaskResumeFromISR( TaskHandle_t xTaskToResume ) PRIVILEGED_FUNCTION;
XBaseType_t xTaskResumeFromISR( TaskHandle_t xTaskToResume ) ;
N
N/*-----------------------------------------------------------
N * SCHEDULER CONTROL
N *----------------------------------------------------------*/
N
N/**
N * task. h
N * <pre>void vTaskStartScheduler( void );</pre>
N *
N * Starts the real time kernel tick processing.  After calling the kernel
N * has control over which tasks are executed and when.
N *
N * See the demo application file main.c for an example of creating
N * tasks and starting the kernel.
N *
N * Example usage:
N   <pre>
N void vAFunction( void )
N {
N	 // Create at least one task before starting the kernel.
N	 xTaskCreate( vTaskCode, "NAME", STACK_SIZE, NULL, tskIDLE_PRIORITY, NULL );
N
N	 // Start the real time kernel with preemption.
N	 vTaskStartScheduler ();
N
N	 // Will not get here unless a task calls vTaskEndScheduler ()
N }
N   </pre>
N *
N * \defgroup vTaskStartScheduler vTaskStartScheduler
N * \ingroup SchedulerControl
N */
Nvoid vTaskStartScheduler( void ) PRIVILEGED_FUNCTION;
Xvoid vTaskStartScheduler( void ) ;
N
N/**
N * task. h
N * <pre>void vTaskEndScheduler( void );</pre>
N *
N * NOTE:  At the time of writing only the x86 real mode port, which runs on a PC
N * in place of DOS, implements this function.
N *
N * Stops the real time kernel tick.  All created tasks will be automatically
N * deleted and multitasking (either preemptive or cooperative) will
N * stop.  Execution then resumes from the point where vTaskStartScheduler ()
N * was called, as if vTaskStartScheduler () had just returned.
N *
N * See the demo application file main. c in the demo/PC directory for an
N * example that uses vTaskEndScheduler ().
N *
N * vTaskEndScheduler () requires an exit function to be defined within the
N * portable layer (see vPortEndScheduler () in port. c for the PC port).  This
N * performs hardware specific operations such as stopping the kernel tick.
N *
N * vTaskEndScheduler () will cause all of the resources allocated by the
N * kernel to be freed - but will not free resources allocated by application
N * tasks.
N *
N * Example usage:
N   <pre>
N void vTaskCode( void * pvParameters )
N {
N	 for( ;; )
N	 {
N		 // Task code goes here.
N
N		 // At some point we want to end the real time kernel processing
N		 // so call ...
N		 vTaskEndScheduler ();
N	 }
N }
N
N void vAFunction( void )
N {
N	 // Create at least one task before starting the kernel.
N	 xTaskCreate( vTaskCode, "NAME", STACK_SIZE, NULL, tskIDLE_PRIORITY, NULL );
N
N	 // Start the real time kernel with preemption.
N	 vTaskStartScheduler ();
N
N	 // Will only get here when the vTaskCode () task has called
N	 // vTaskEndScheduler ().  When we get here we are back to single task
N	 // execution.
N }
N   </pre>
N *
N * \defgroup vTaskEndScheduler vTaskEndScheduler
N * \ingroup SchedulerControl
N */
Nvoid vTaskEndScheduler( void ) PRIVILEGED_FUNCTION;
Xvoid vTaskEndScheduler( void ) ;
N
N/**
N * task. h
N * <pre>void vTaskSuspendAll( void );</pre>
N *
N * Suspends the scheduler without disabling interrupts.  Context switches will
N * not occur while the scheduler is suspended.
N *
N * After calling vTaskSuspendAll () the calling task will continue to execute
N * without risk of being swapped out until a call to xTaskResumeAll () has been
N * made.
N *
N * API functions that have the potential to cause a context switch (for example,
N * vTaskDelayUntil(), xQueueSend(), etc.) must not be called while the scheduler
N * is suspended.
N *
N * Example usage:
N   <pre>
N void vTask1( void * pvParameters )
N {
N	 for( ;; )
N	 {
N		 // Task code goes here.
N
N		 // ...
N
N		 // At some point the task wants to perform a long operation during
N		 // which it does not want to get swapped out.  It cannot use
N		 // taskENTER_CRITICAL ()/taskEXIT_CRITICAL () as the length of the
N		 // operation may cause interrupts to be missed - including the
N		 // ticks.
N
N		 // Prevent the real time kernel swapping out the task.
N		 vTaskSuspendAll ();
N
N		 // Perform the operation here.  There is no need to use critical
N		 // sections as we have all the microcontroller processing time.
N		 // During this time interrupts will still operate and the kernel
N		 // tick count will be maintained.
N
N		 // ...
N
N		 // The operation is complete.  Restart the kernel.
N		 xTaskResumeAll ();
N	 }
N }
N   </pre>
N * \defgroup vTaskSuspendAll vTaskSuspendAll
N * \ingroup SchedulerControl
N */
Nvoid vTaskSuspendAll( void ) PRIVILEGED_FUNCTION;
Xvoid vTaskSuspendAll( void ) ;
N
N/**
N * task. h
N * <pre>BaseType_t xTaskResumeAll( void );</pre>
N *
N * Resumes scheduler activity after it was suspended by a call to
N * vTaskSuspendAll().
N *
N * xTaskResumeAll() only resumes the scheduler.  It does not unsuspend tasks
N * that were previously suspended by a call to vTaskSuspend().
N *
N * @return If resuming the scheduler caused a context switch then pdTRUE is
N *		  returned, otherwise pdFALSE is returned.
N *
N * Example usage:
N   <pre>
N void vTask1( void * pvParameters )
N {
N	 for( ;; )
N	 {
N		 // Task code goes here.
N
N		 // ...
N
N		 // At some point the task wants to perform a long operation during
N		 // which it does not want to get swapped out.  It cannot use
N		 // taskENTER_CRITICAL ()/taskEXIT_CRITICAL () as the length of the
N		 // operation may cause interrupts to be missed - including the
N		 // ticks.
N
N		 // Prevent the real time kernel swapping out the task.
N		 vTaskSuspendAll ();
N
N		 // Perform the operation here.  There is no need to use critical
N		 // sections as we have all the microcontroller processing time.
N		 // During this time interrupts will still operate and the real
N		 // time kernel tick count will be maintained.
N
N		 // ...
N
N		 // The operation is complete.  Restart the kernel.  We want to force
N		 // a context switch - but there is no point if resuming the scheduler
N		 // caused a context switch already.
N		 if( !xTaskResumeAll () )
N		 {
N			  taskYIELD ();
N		 }
N	 }
N }
N   </pre>
N * \defgroup xTaskResumeAll xTaskResumeAll
N * \ingroup SchedulerControl
N */
NBaseType_t xTaskResumeAll( void ) PRIVILEGED_FUNCTION;
XBaseType_t xTaskResumeAll( void ) ;
N
N/*-----------------------------------------------------------
N * TASK UTILITIES
N *----------------------------------------------------------*/
N
N/**
N * task. h
N * <PRE>TickType_t xTaskGetTickCount( void );</PRE>
N *
N * @return The count of ticks since vTaskStartScheduler was called.
N *
N * \defgroup xTaskGetTickCount xTaskGetTickCount
N * \ingroup TaskUtils
N */
NTickType_t xTaskGetTickCount( void ) PRIVILEGED_FUNCTION;
XTickType_t xTaskGetTickCount( void ) ;
N
N/**
N * task. h
N * <PRE>TickType_t xTaskGetTickCountFromISR( void );</PRE>
N *
N * @return The count of ticks since vTaskStartScheduler was called.
N *
N * This is a version of xTaskGetTickCount() that is safe to be called from an
N * ISR - provided that TickType_t is the natural word size of the
N * microcontroller being used or interrupt nesting is either not supported or
N * not being used.
N *
N * \defgroup xTaskGetTickCountFromISR xTaskGetTickCountFromISR
N * \ingroup TaskUtils
N */
NTickType_t xTaskGetTickCountFromISR( void ) PRIVILEGED_FUNCTION;
XTickType_t xTaskGetTickCountFromISR( void ) ;
N
N/**
N * task. h
N * <PRE>uint16_t uxTaskGetNumberOfTasks( void );</PRE>
N *
N * @return The number of tasks that the real time kernel is currently managing.
N * This includes all ready, blocked and suspended tasks.  A task that
N * has been deleted but not yet freed by the idle task will also be
N * included in the count.
N *
N * \defgroup uxTaskGetNumberOfTasks uxTaskGetNumberOfTasks
N * \ingroup TaskUtils
N */
NUBaseType_t uxTaskGetNumberOfTasks( void ) PRIVILEGED_FUNCTION;
XUBaseType_t uxTaskGetNumberOfTasks( void ) ;
N
N/**
N * task. h
N * <PRE>char *pcTaskGetName( TaskHandle_t xTaskToQuery );</PRE>
N *
N * @return The text (human readable) name of the task referenced by the handle
N * xTaskToQuery.  A task can query its own name by either passing in its own
N * handle, or by setting xTaskToQuery to NULL.
N *
N * \defgroup pcTaskGetName pcTaskGetName
N * \ingroup TaskUtils
N */
Nchar *pcTaskGetName( TaskHandle_t xTaskToQuery ) PRIVILEGED_FUNCTION; /*lint !e971 Unqualified char types are allowed for strings and single characters only. */
Xchar *pcTaskGetName( TaskHandle_t xTaskToQuery ) ;  
N
N/**
N * task. h
N * <PRE>TaskHandle_t xTaskGetHandle( const char *pcNameToQuery );</PRE>
N *
N * NOTE:  This function takes a relatively long time to complete and should be
N * used sparingly.
N *
N * @return The handle of the task that has the human readable name pcNameToQuery.
N * NULL is returned if no matching name is found.  INCLUDE_xTaskGetHandle
N * must be set to 1 in FreeRTOSConfig.h for pcTaskGetHandle() to be available.
N *
N * \defgroup pcTaskGetHandle pcTaskGetHandle
N * \ingroup TaskUtils
N */
NTaskHandle_t xTaskGetHandle( const char *pcNameToQuery ) PRIVILEGED_FUNCTION; /*lint !e971 Unqualified char types are allowed for strings and single characters only. */
XTaskHandle_t xTaskGetHandle( const char *pcNameToQuery ) ;  
N
N/**
N * task.h
N * <PRE>UBaseType_t uxTaskGetStackHighWaterMark( TaskHandle_t xTask );</PRE>
N *
N * INCLUDE_uxTaskGetStackHighWaterMark must be set to 1 in FreeRTOSConfig.h for
N * this function to be available.
N *
N * Returns the high water mark of the stack associated with xTask.  That is,
N * the minimum free stack space there has been (in words, so on a 32 bit machine
N * a value of 1 means 4 bytes) since the task started.  The smaller the returned
N * number the closer the task has come to overflowing its stack.
N *
N * @param xTask Handle of the task associated with the stack to be checked.
N * Set xTask to NULL to check the stack of the calling task.
N *
N * @return The smallest amount of free stack space there has been (in words, so
N * actual spaces on the stack rather than bytes) since the task referenced by
N * xTask was created.
N */
NUBaseType_t uxTaskGetStackHighWaterMark( TaskHandle_t xTask ) PRIVILEGED_FUNCTION;
XUBaseType_t uxTaskGetStackHighWaterMark( TaskHandle_t xTask ) ;
N
N/* When using trace macros it is sometimes necessary to include task.h before
NFreeRTOS.h.  When this is done TaskHookFunction_t will not yet have been defined,
Nso the following two prototypes will cause a compilation error.  This can be
Nfixed by simply guarding against the inclusion of these two prototypes unless
Nthey are explicitly required by the configUSE_APPLICATION_TASK_TAG configuration
Nconstant. */
N#ifdef configUSE_APPLICATION_TASK_TAG
N	#if configUSE_APPLICATION_TASK_TAG == 1
X	#if 0 == 1
S		/**
S		 * task.h
S		 * <pre>void vTaskSetApplicationTaskTag( TaskHandle_t xTask, TaskHookFunction_t pxHookFunction );</pre>
S		 *
S		 * Sets pxHookFunction to be the task hook function used by the task xTask.
S		 * Passing xTask as NULL has the effect of setting the calling tasks hook
S		 * function.
S		 */
S		void vTaskSetApplicationTaskTag( TaskHandle_t xTask, TaskHookFunction_t pxHookFunction ) PRIVILEGED_FUNCTION;
S
S		/**
S		 * task.h
S		 * <pre>void xTaskGetApplicationTaskTag( TaskHandle_t xTask );</pre>
S		 *
S		 * Returns the pxHookFunction value assigned to the task xTask.
S		 */
S		TaskHookFunction_t xTaskGetApplicationTaskTag( TaskHandle_t xTask ) PRIVILEGED_FUNCTION;
N	#endif /* configUSE_APPLICATION_TASK_TAG ==1 */
N#endif /* ifdef configUSE_APPLICATION_TASK_TAG */
N
N#if( configNUM_THREAD_LOCAL_STORAGE_POINTERS > 0 )
X#if( 5 > 0 )
N
N	/* Each task contains an array of pointers that is dimensioned by the
N	configNUM_THREAD_LOCAL_STORAGE_POINTERS setting in FreeRTOSConfig.h.  The
N	kernel does not use the pointers itself, so the application writer can use
N	the pointers for any purpose they wish.  The following two functions are
N	used to set and query a pointer respectively. */
N	void vTaskSetThreadLocalStoragePointer( TaskHandle_t xTaskToSet, BaseType_t xIndex, void *pvValue ) PRIVILEGED_FUNCTION;
X	void vTaskSetThreadLocalStoragePointer( TaskHandle_t xTaskToSet, BaseType_t xIndex, void *pvValue ) ;
N	void *pvTaskGetThreadLocalStoragePointer( TaskHandle_t xTaskToQuery, BaseType_t xIndex ) PRIVILEGED_FUNCTION;
X	void *pvTaskGetThreadLocalStoragePointer( TaskHandle_t xTaskToQuery, BaseType_t xIndex ) ;
N
N#endif
N
N/**
N * task.h
N * <pre>BaseType_t xTaskCallApplicationTaskHook( TaskHandle_t xTask, void *pvParameter );</pre>
N *
N * Calls the hook function associated with xTask.  Passing xTask as NULL has
N * the effect of calling the Running tasks (the calling task) hook function.
N *
N * pvParameter is passed to the hook function for the task to interpret as it
N * wants.  The return value is the value returned by the task hook function
N * registered by the user.
N */
NBaseType_t xTaskCallApplicationTaskHook( TaskHandle_t xTask, void *pvParameter ) PRIVILEGED_FUNCTION;
XBaseType_t xTaskCallApplicationTaskHook( TaskHandle_t xTask, void *pvParameter ) ;
N
N/**
N * xTaskGetIdleTaskHandle() is only available if
N * INCLUDE_xTaskGetIdleTaskHandle is set to 1 in FreeRTOSConfig.h.
N *
N * Simply returns the handle of the idle task.  It is not valid to call
N * xTaskGetIdleTaskHandle() before the scheduler has been started.
N */
NTaskHandle_t xTaskGetIdleTaskHandle( void ) PRIVILEGED_FUNCTION;
XTaskHandle_t xTaskGetIdleTaskHandle( void ) ;
N
N/**
N * configUSE_TRACE_FACILITY must be defined as 1 in FreeRTOSConfig.h for
N * uxTaskGetSystemState() to be available.
N *
N * uxTaskGetSystemState() populates an TaskStatus_t structure for each task in
N * the system.  TaskStatus_t structures contain, among other things, members
N * for the task handle, task name, task priority, task state, and total amount
N * of run time consumed by the task.  See the TaskStatus_t structure
N * definition in this file for the full member list.
N *
N * NOTE:  This function is intended for debugging use only as its use results in
N * the scheduler remaining suspended for an extended period.
N *
N * @param pxTaskStatusArray A pointer to an array of TaskStatus_t structures.
N * The array must contain at least one TaskStatus_t structure for each task
N * that is under the control of the RTOS.  The number of tasks under the control
N * of the RTOS can be determined using the uxTaskGetNumberOfTasks() API function.
N *
N * @param uxArraySize The size of the array pointed to by the pxTaskStatusArray
N * parameter.  The size is specified as the number of indexes in the array, or
N * the number of TaskStatus_t structures contained in the array, not by the
N * number of bytes in the array.
N *
N * @param pulTotalRunTime If configGENERATE_RUN_TIME_STATS is set to 1 in
N * FreeRTOSConfig.h then *pulTotalRunTime is set by uxTaskGetSystemState() to the
N * total run time (as defined by the run time stats clock, see
N * http://www.freertos.org/rtos-run-time-stats.html) since the target booted.
N * pulTotalRunTime can be set to NULL to omit the total run time information.
N *
N * @return The number of TaskStatus_t structures that were populated by
N * uxTaskGetSystemState().  This should equal the number returned by the
N * uxTaskGetNumberOfTasks() API function, but will be zero if the value passed
N * in the uxArraySize parameter was too small.
N *
N * Example usage:
N   <pre>
N    // This example demonstrates how a human readable table of run time stats
N	// information is generated from raw data provided by uxTaskGetSystemState().
N	// The human readable table is written to pcWriteBuffer
N	void vTaskGetRunTimeStats( char *pcWriteBuffer )
N	{
N	TaskStatus_t *pxTaskStatusArray;
N	volatile UBaseType_t uxArraySize, x;
N	uint32_t ulTotalRunTime, ulStatsAsPercentage;
N
N		// Make sure the write buffer does not contain a string.
N		*pcWriteBuffer = 0x00;
N
N		// Take a snapshot of the number of tasks in case it changes while this
N		// function is executing.
N		uxArraySize = uxTaskGetNumberOfTasks();
N
N		// Allocate a TaskStatus_t structure for each task.  An array could be
N		// allocated statically at compile time.
N		pxTaskStatusArray = pvPortMalloc( uxArraySize * sizeof( TaskStatus_t ) );
N
N		if( pxTaskStatusArray != NULL )
N		{
N			// Generate raw status information about each task.
N			uxArraySize = uxTaskGetSystemState( pxTaskStatusArray, uxArraySize, &ulTotalRunTime );
N
N			// For percentage calculations.
N			ulTotalRunTime /= 100UL;
N
N			// Avoid divide by zero errors.
N			if( ulTotalRunTime > 0 )
N			{
N				// For each populated position in the pxTaskStatusArray array,
N				// format the raw data as human readable ASCII data
N				for( x = 0; x < uxArraySize; x++ )
N				{
N					// What percentage of the total run time has the task used?
N					// This will always be rounded down to the nearest integer.
N					// ulTotalRunTimeDiv100 has already been divided by 100.
N					ulStatsAsPercentage = pxTaskStatusArray[ x ].ulRunTimeCounter / ulTotalRunTime;
N
N					if( ulStatsAsPercentage > 0UL )
N					{
N						sprintf( pcWriteBuffer, "%s\t\t%lu\t\t%lu%%\r\n", pxTaskStatusArray[ x ].pcTaskName, pxTaskStatusArray[ x ].ulRunTimeCounter, ulStatsAsPercentage );
N					}
N					else
N					{
N						// If the percentage is zero here then the task has
N						// consumed less than 1% of the total run time.
N						sprintf( pcWriteBuffer, "%s\t\t%lu\t\t<1%%\r\n", pxTaskStatusArray[ x ].pcTaskName, pxTaskStatusArray[ x ].ulRunTimeCounter );
N					}
N
N					pcWriteBuffer += strlen( ( char * ) pcWriteBuffer );
N				}
N			}
N
N			// The array is no longer needed, free the memory it consumes.
N			vPortFree( pxTaskStatusArray );
N		}
N	}
N	</pre>
N */
NUBaseType_t uxTaskGetSystemState( TaskStatus_t * const pxTaskStatusArray, const UBaseType_t uxArraySize, uint32_t * const pulTotalRunTime ) PRIVILEGED_FUNCTION;
XUBaseType_t uxTaskGetSystemState( TaskStatus_t * const pxTaskStatusArray, const UBaseType_t uxArraySize, uint32_t * const pulTotalRunTime ) ;
N
N/**
N * task. h
N * <PRE>void vTaskList( char *pcWriteBuffer );</PRE>
N *
N * configUSE_TRACE_FACILITY and configUSE_STATS_FORMATTING_FUNCTIONS must
N * both be defined as 1 for this function to be available.  See the
N * configuration section of the FreeRTOS.org website for more information.
N *
N * NOTE 1: This function will disable interrupts for its duration.  It is
N * not intended for normal application runtime use but as a debug aid.
N *
N * Lists all the current tasks, along with their current state and stack
N * usage high water mark.
N *
N * Tasks are reported as blocked ('B'), ready ('R'), deleted ('D') or
N * suspended ('S').
N *
N * PLEASE NOTE:
N *
N * This function is provided for convenience only, and is used by many of the
N * demo applications.  Do not consider it to be part of the scheduler.
N *
N * vTaskList() calls uxTaskGetSystemState(), then formats part of the
N * uxTaskGetSystemState() output into a human readable table that displays task
N * names, states and stack usage.
N *
N * vTaskList() has a dependency on the sprintf() C library function that might
N * bloat the code size, use a lot of stack, and provide different results on
N * different platforms.  An alternative, tiny, third party, and limited
N * functionality implementation of sprintf() is provided in many of the
N * FreeRTOS/Demo sub-directories in a file called printf-stdarg.c (note
N * printf-stdarg.c does not provide a full snprintf() implementation!).
N *
N * It is recommended that production systems call uxTaskGetSystemState()
N * directly to get access to raw stats data, rather than indirectly through a
N * call to vTaskList().
N *
N * @param pcWriteBuffer A buffer into which the above mentioned details
N * will be written, in ASCII form.  This buffer is assumed to be large
N * enough to contain the generated report.  Approximately 40 bytes per
N * task should be sufficient.
N *
N * \defgroup vTaskList vTaskList
N * \ingroup TaskUtils
N */
Nvoid vTaskList( char * pcWriteBuffer ) PRIVILEGED_FUNCTION; /*lint !e971 Unqualified char types are allowed for strings and single characters only. */
Xvoid vTaskList( char * pcWriteBuffer ) ;  
N
N/**
N * task. h
N * <PRE>void vTaskGetRunTimeStats( char *pcWriteBuffer );</PRE>
N *
N * configGENERATE_RUN_TIME_STATS and configUSE_STATS_FORMATTING_FUNCTIONS
N * must both be defined as 1 for this function to be available.  The application
N * must also then provide definitions for
N * portCONFIGURE_TIMER_FOR_RUN_TIME_STATS() and portGET_RUN_TIME_COUNTER_VALUE()
N * to configure a peripheral timer/counter and return the timers current count
N * value respectively.  The counter should be at least 10 times the frequency of
N * the tick count.
N *
N * NOTE 1: This function will disable interrupts for its duration.  It is
N * not intended for normal application runtime use but as a debug aid.
N *
N * Setting configGENERATE_RUN_TIME_STATS to 1 will result in a total
N * accumulated execution time being stored for each task.  The resolution
N * of the accumulated time value depends on the frequency of the timer
N * configured by the portCONFIGURE_TIMER_FOR_RUN_TIME_STATS() macro.
N * Calling vTaskGetRunTimeStats() writes the total execution time of each
N * task into a buffer, both as an absolute count value and as a percentage
N * of the total system execution time.
N *
N * NOTE 2:
N *
N * This function is provided for convenience only, and is used by many of the
N * demo applications.  Do not consider it to be part of the scheduler.
N *
N * vTaskGetRunTimeStats() calls uxTaskGetSystemState(), then formats part of the
N * uxTaskGetSystemState() output into a human readable table that displays the
N * amount of time each task has spent in the Running state in both absolute and
N * percentage terms.
N *
N * vTaskGetRunTimeStats() has a dependency on the sprintf() C library function
N * that might bloat the code size, use a lot of stack, and provide different
N * results on different platforms.  An alternative, tiny, third party, and
N * limited functionality implementation of sprintf() is provided in many of the
N * FreeRTOS/Demo sub-directories in a file called printf-stdarg.c (note
N * printf-stdarg.c does not provide a full snprintf() implementation!).
N *
N * It is recommended that production systems call uxTaskGetSystemState() directly
N * to get access to raw stats data, rather than indirectly through a call to
N * vTaskGetRunTimeStats().
N *
N * @param pcWriteBuffer A buffer into which the execution times will be
N * written, in ASCII form.  This buffer is assumed to be large enough to
N * contain the generated report.  Approximately 40 bytes per task should
N * be sufficient.
N *
N * \defgroup vTaskGetRunTimeStats vTaskGetRunTimeStats
N * \ingroup TaskUtils
N */
Nvoid vTaskGetRunTimeStats( char *pcWriteBuffer ) PRIVILEGED_FUNCTION; /*lint !e971 Unqualified char types are allowed for strings and single characters only. */
Xvoid vTaskGetRunTimeStats( char *pcWriteBuffer ) ;  
N
N/**
N * task. h
N * <PRE>BaseType_t xTaskNotify( TaskHandle_t xTaskToNotify, uint32_t ulValue, eNotifyAction eAction );</PRE>
N *
N * configUSE_TASK_NOTIFICATIONS must be undefined or defined as 1 for this
N * function to be available.
N *
N * When configUSE_TASK_NOTIFICATIONS is set to one each task has its own private
N * "notification value", which is a 32-bit unsigned integer (uint32_t).
N *
N * Events can be sent to a task using an intermediary object.  Examples of such
N * objects are queues, semaphores, mutexes and event groups.  Task notifications
N * are a method of sending an event directly to a task without the need for such
N * an intermediary object.
N *
N * A notification sent to a task can optionally perform an action, such as
N * update, overwrite or increment the task's notification value.  In that way
N * task notifications can be used to send data to a task, or be used as light
N * weight and fast binary or counting semaphores.
N *
N * A notification sent to a task will remain pending until it is cleared by the
N * task calling xTaskNotifyWait() or ulTaskNotifyTake().  If the task was
N * already in the Blocked state to wait for a notification when the notification
N * arrives then the task will automatically be removed from the Blocked state
N * (unblocked) and the notification cleared.
N *
N * A task can use xTaskNotifyWait() to [optionally] block to wait for a
N * notification to be pending, or ulTaskNotifyTake() to [optionally] block
N * to wait for its notification value to have a non-zero value.  The task does
N * not consume any CPU time while it is in the Blocked state.
N *
N * See http://www.FreeRTOS.org/RTOS-task-notifications.html for details.
N *
N * @param xTaskToNotify The handle of the task being notified.  The handle to a
N * task can be returned from the xTaskCreate() API function used to create the
N * task, and the handle of the currently running task can be obtained by calling
N * xTaskGetCurrentTaskHandle().
N *
N * @param ulValue Data that can be sent with the notification.  How the data is
N * used depends on the value of the eAction parameter.
N *
N * @param eAction Specifies how the notification updates the task's notification
N * value, if at all.  Valid values for eAction are as follows:
N *
N * eSetBits -
N * The task's notification value is bitwise ORed with ulValue.  xTaskNofify()
N * always returns pdPASS in this case.
N *
N * eIncrement -
N * The task's notification value is incremented.  ulValue is not used and
N * xTaskNotify() always returns pdPASS in this case.
N *
N * eSetValueWithOverwrite -
N * The task's notification value is set to the value of ulValue, even if the
N * task being notified had not yet processed the previous notification (the
N * task already had a notification pending).  xTaskNotify() always returns
N * pdPASS in this case.
N *
N * eSetValueWithoutOverwrite -
N * If the task being notified did not already have a notification pending then
N * the task's notification value is set to ulValue and xTaskNotify() will
N * return pdPASS.  If the task being notified already had a notification
N * pending then no action is performed and pdFAIL is returned.
N *
N * eNoAction -
N * The task receives a notification without its notification value being
N * updated.  ulValue is not used and xTaskNotify() always returns pdPASS in
N * this case.
N *
N *  pulPreviousNotificationValue -
N *  Can be used to pass out the subject task's notification value before any
N *  bits are modified by the notify function.
N *
N * @return Dependent on the value of eAction.  See the description of the
N * eAction parameter.
N *
N * \defgroup xTaskNotify xTaskNotify
N * \ingroup TaskNotifications
N */
NBaseType_t xTaskGenericNotify( TaskHandle_t xTaskToNotify, uint32_t ulValue, eNotifyAction eAction, uint32_t *pulPreviousNotificationValue ) PRIVILEGED_FUNCTION;
XBaseType_t xTaskGenericNotify( TaskHandle_t xTaskToNotify, uint32_t ulValue, eNotifyAction eAction, uint32_t *pulPreviousNotificationValue ) ;
N#define xTaskNotify( xTaskToNotify, ulValue, eAction ) xTaskGenericNotify( ( xTaskToNotify ), ( ulValue ), ( eAction ), NULL )
N#define xTaskNotifyAndQuery( xTaskToNotify, ulValue, eAction, pulPreviousNotifyValue ) xTaskGenericNotify( ( xTaskToNotify ), ( ulValue ), ( eAction ), ( pulPreviousNotifyValue ) )
N
N/**
N * task. h
N * <PRE>BaseType_t xTaskNotifyFromISR( TaskHandle_t xTaskToNotify, uint32_t ulValue, eNotifyAction eAction, BaseType_t *pxHigherPriorityTaskWoken );</PRE>
N *
N * configUSE_TASK_NOTIFICATIONS must be undefined or defined as 1 for this
N * function to be available.
N *
N * When configUSE_TASK_NOTIFICATIONS is set to one each task has its own private
N * "notification value", which is a 32-bit unsigned integer (uint32_t).
N *
N * A version of xTaskNotify() that can be used from an interrupt service routine
N * (ISR).
N *
N * Events can be sent to a task using an intermediary object.  Examples of such
N * objects are queues, semaphores, mutexes and event groups.  Task notifications
N * are a method of sending an event directly to a task without the need for such
N * an intermediary object.
N *
N * A notification sent to a task can optionally perform an action, such as
N * update, overwrite or increment the task's notification value.  In that way
N * task notifications can be used to send data to a task, or be used as light
N * weight and fast binary or counting semaphores.
N *
N * A notification sent to a task will remain pending until it is cleared by the
N * task calling xTaskNotifyWait() or ulTaskNotifyTake().  If the task was
N * already in the Blocked state to wait for a notification when the notification
N * arrives then the task will automatically be removed from the Blocked state
N * (unblocked) and the notification cleared.
N *
N * A task can use xTaskNotifyWait() to [optionally] block to wait for a
N * notification to be pending, or ulTaskNotifyTake() to [optionally] block
N * to wait for its notification value to have a non-zero value.  The task does
N * not consume any CPU time while it is in the Blocked state.
N *
N * See http://www.FreeRTOS.org/RTOS-task-notifications.html for details.
N *
N * @param xTaskToNotify The handle of the task being notified.  The handle to a
N * task can be returned from the xTaskCreate() API function used to create the
N * task, and the handle of the currently running task can be obtained by calling
N * xTaskGetCurrentTaskHandle().
N *
N * @param ulValue Data that can be sent with the notification.  How the data is
N * used depends on the value of the eAction parameter.
N *
N * @param eAction Specifies how the notification updates the task's notification
N * value, if at all.  Valid values for eAction are as follows:
N *
N * eSetBits -
N * The task's notification value is bitwise ORed with ulValue.  xTaskNofify()
N * always returns pdPASS in this case.
N *
N * eIncrement -
N * The task's notification value is incremented.  ulValue is not used and
N * xTaskNotify() always returns pdPASS in this case.
N *
N * eSetValueWithOverwrite -
N * The task's notification value is set to the value of ulValue, even if the
N * task being notified had not yet processed the previous notification (the
N * task already had a notification pending).  xTaskNotify() always returns
N * pdPASS in this case.
N *
N * eSetValueWithoutOverwrite -
N * If the task being notified did not already have a notification pending then
N * the task's notification value is set to ulValue and xTaskNotify() will
N * return pdPASS.  If the task being notified already had a notification
N * pending then no action is performed and pdFAIL is returned.
N *
N * eNoAction -
N * The task receives a notification without its notification value being
N * updated.  ulValue is not used and xTaskNotify() always returns pdPASS in
N * this case.
N *
N * @param pxHigherPriorityTaskWoken  xTaskNotifyFromISR() will set
N * *pxHigherPriorityTaskWoken to pdTRUE if sending the notification caused the
N * task to which the notification was sent to leave the Blocked state, and the
N * unblocked task has a priority higher than the currently running task.  If
N * xTaskNotifyFromISR() sets this value to pdTRUE then a context switch should
N * be requested before the interrupt is exited.  How a context switch is
N * requested from an ISR is dependent on the port - see the documentation page
N * for the port in use.
N *
N * @return Dependent on the value of eAction.  See the description of the
N * eAction parameter.
N *
N * \defgroup xTaskNotify xTaskNotify
N * \ingroup TaskNotifications
N */
NBaseType_t xTaskGenericNotifyFromISR( TaskHandle_t xTaskToNotify, uint32_t ulValue, eNotifyAction eAction, uint32_t *pulPreviousNotificationValue, BaseType_t *pxHigherPriorityTaskWoken ) PRIVILEGED_FUNCTION;
XBaseType_t xTaskGenericNotifyFromISR( TaskHandle_t xTaskToNotify, uint32_t ulValue, eNotifyAction eAction, uint32_t *pulPreviousNotificationValue, BaseType_t *pxHigherPriorityTaskWoken ) ;
N#define xTaskNotifyFromISR( xTaskToNotify, ulValue, eAction, pxHigherPriorityTaskWoken ) xTaskGenericNotifyFromISR( ( xTaskToNotify ), ( ulValue ), ( eAction ), NULL, ( pxHigherPriorityTaskWoken ) )
N#define xTaskNotifyAndQueryFromISR( xTaskToNotify, ulValue, eAction, pulPreviousNotificationValue, pxHigherPriorityTaskWoken ) xTaskGenericNotifyFromISR( ( xTaskToNotify ), ( ulValue ), ( eAction ), ( pulPreviousNotificationValue ), ( pxHigherPriorityTaskWoken ) )
N
N/**
N * task. h
N * <PRE>BaseType_t xTaskNotifyWait( uint32_t ulBitsToClearOnEntry, uint32_t ulBitsToClearOnExit, uint32_t *pulNotificationValue, TickType_t xTicksToWait );</pre>
N *
N * configUSE_TASK_NOTIFICATIONS must be undefined or defined as 1 for this
N * function to be available.
N *
N * When configUSE_TASK_NOTIFICATIONS is set to one each task has its own private
N * "notification value", which is a 32-bit unsigned integer (uint32_t).
N *
N * Events can be sent to a task using an intermediary object.  Examples of such
N * objects are queues, semaphores, mutexes and event groups.  Task notifications
N * are a method of sending an event directly to a task without the need for such
N * an intermediary object.
N *
N * A notification sent to a task can optionally perform an action, such as
N * update, overwrite or increment the task's notification value.  In that way
N * task notifications can be used to send data to a task, or be used as light
N * weight and fast binary or counting semaphores.
N *
N * A notification sent to a task will remain pending until it is cleared by the
N * task calling xTaskNotifyWait() or ulTaskNotifyTake().  If the task was
N * already in the Blocked state to wait for a notification when the notification
N * arrives then the task will automatically be removed from the Blocked state
N * (unblocked) and the notification cleared.
N *
N * A task can use xTaskNotifyWait() to [optionally] block to wait for a
N * notification to be pending, or ulTaskNotifyTake() to [optionally] block
N * to wait for its notification value to have a non-zero value.  The task does
N * not consume any CPU time while it is in the Blocked state.
N *
N * See http://www.FreeRTOS.org/RTOS-task-notifications.html for details.
N *
N * @param ulBitsToClearOnEntry Bits that are set in ulBitsToClearOnEntry value
N * will be cleared in the calling task's notification value before the task
N * checks to see if any notifications are pending, and optionally blocks if no
N * notifications are pending.  Setting ulBitsToClearOnEntry to ULONG_MAX (if
N * limits.h is included) or 0xffffffffUL (if limits.h is not included) will have
N * the effect of resetting the task's notification value to 0.  Setting
N * ulBitsToClearOnEntry to 0 will leave the task's notification value unchanged.
N *
N * @param ulBitsToClearOnExit If a notification is pending or received before
N * the calling task exits the xTaskNotifyWait() function then the task's
N * notification value (see the xTaskNotify() API function) is passed out using
N * the pulNotificationValue parameter.  Then any bits that are set in
N * ulBitsToClearOnExit will be cleared in the task's notification value (note
N * *pulNotificationValue is set before any bits are cleared).  Setting
N * ulBitsToClearOnExit to ULONG_MAX (if limits.h is included) or 0xffffffffUL
N * (if limits.h is not included) will have the effect of resetting the task's
N * notification value to 0 before the function exits.  Setting
N * ulBitsToClearOnExit to 0 will leave the task's notification value unchanged
N * when the function exits (in which case the value passed out in
N * pulNotificationValue will match the task's notification value).
N *
N * @param pulNotificationValue Used to pass the task's notification value out
N * of the function.  Note the value passed out will not be effected by the
N * clearing of any bits caused by ulBitsToClearOnExit being non-zero.
N *
N * @param xTicksToWait The maximum amount of time that the task should wait in
N * the Blocked state for a notification to be received, should a notification
N * not already be pending when xTaskNotifyWait() was called.  The task
N * will not consume any processing time while it is in the Blocked state.  This
N * is specified in kernel ticks, the macro pdMS_TO_TICSK( value_in_ms ) can be
N * used to convert a time specified in milliseconds to a time specified in
N * ticks.
N *
N * @return If a notification was received (including notifications that were
N * already pending when xTaskNotifyWait was called) then pdPASS is
N * returned.  Otherwise pdFAIL is returned.
N *
N * \defgroup xTaskNotifyWait xTaskNotifyWait
N * \ingroup TaskNotifications
N */
NBaseType_t xTaskNotifyWait( uint32_t ulBitsToClearOnEntry, uint32_t ulBitsToClearOnExit, uint32_t *pulNotificationValue, TickType_t xTicksToWait ) PRIVILEGED_FUNCTION;
XBaseType_t xTaskNotifyWait( uint32_t ulBitsToClearOnEntry, uint32_t ulBitsToClearOnExit, uint32_t *pulNotificationValue, TickType_t xTicksToWait ) ;
N
N/**
N * task. h
N * <PRE>BaseType_t xTaskNotifyGive( TaskHandle_t xTaskToNotify );</PRE>
N *
N * configUSE_TASK_NOTIFICATIONS must be undefined or defined as 1 for this macro
N * to be available.
N *
N * When configUSE_TASK_NOTIFICATIONS is set to one each task has its own private
N * "notification value", which is a 32-bit unsigned integer (uint32_t).
N *
N * Events can be sent to a task using an intermediary object.  Examples of such
N * objects are queues, semaphores, mutexes and event groups.  Task notifications
N * are a method of sending an event directly to a task without the need for such
N * an intermediary object.
N *
N * A notification sent to a task can optionally perform an action, such as
N * update, overwrite or increment the task's notification value.  In that way
N * task notifications can be used to send data to a task, or be used as light
N * weight and fast binary or counting semaphores.
N *
N * xTaskNotifyGive() is a helper macro intended for use when task notifications
N * are used as light weight and faster binary or counting semaphore equivalents.
N * Actual FreeRTOS semaphores are given using the xSemaphoreGive() API function,
N * the equivalent action that instead uses a task notification is
N * xTaskNotifyGive().
N *
N * When task notifications are being used as a binary or counting semaphore
N * equivalent then the task being notified should wait for the notification
N * using the ulTaskNotificationTake() API function rather than the
N * xTaskNotifyWait() API function.
N *
N * See http://www.FreeRTOS.org/RTOS-task-notifications.html for more details.
N *
N * @param xTaskToNotify The handle of the task being notified.  The handle to a
N * task can be returned from the xTaskCreate() API function used to create the
N * task, and the handle of the currently running task can be obtained by calling
N * xTaskGetCurrentTaskHandle().
N *
N * @return xTaskNotifyGive() is a macro that calls xTaskNotify() with the
N * eAction parameter set to eIncrement - so pdPASS is always returned.
N *
N * \defgroup xTaskNotifyGive xTaskNotifyGive
N * \ingroup TaskNotifications
N */
N#define xTaskNotifyGive( xTaskToNotify ) xTaskGenericNotify( ( xTaskToNotify ), ( 0 ), eIncrement, NULL )
N
N/**
N * task. h
N * <PRE>void vTaskNotifyGiveFromISR( TaskHandle_t xTaskHandle, BaseType_t *pxHigherPriorityTaskWoken );
N *
N * configUSE_TASK_NOTIFICATIONS must be undefined or defined as 1 for this macro
N * to be available.
N *
N * When configUSE_TASK_NOTIFICATIONS is set to one each task has its own private
N * "notification value", which is a 32-bit unsigned integer (uint32_t).
N *
N * A version of xTaskNotifyGive() that can be called from an interrupt service
N * routine (ISR).
N *
N * Events can be sent to a task using an intermediary object.  Examples of such
N * objects are queues, semaphores, mutexes and event groups.  Task notifications
N * are a method of sending an event directly to a task without the need for such
N * an intermediary object.
N *
N * A notification sent to a task can optionally perform an action, such as
N * update, overwrite or increment the task's notification value.  In that way
N * task notifications can be used to send data to a task, or be used as light
N * weight and fast binary or counting semaphores.
N *
N * vTaskNotifyGiveFromISR() is intended for use when task notifications are
N * used as light weight and faster binary or counting semaphore equivalents.
N * Actual FreeRTOS semaphores are given from an ISR using the
N * xSemaphoreGiveFromISR() API function, the equivalent action that instead uses
N * a task notification is vTaskNotifyGiveFromISR().
N *
N * When task notifications are being used as a binary or counting semaphore
N * equivalent then the task being notified should wait for the notification
N * using the ulTaskNotificationTake() API function rather than the
N * xTaskNotifyWait() API function.
N *
N * See http://www.FreeRTOS.org/RTOS-task-notifications.html for more details.
N *
N * @param xTaskToNotify The handle of the task being notified.  The handle to a
N * task can be returned from the xTaskCreate() API function used to create the
N * task, and the handle of the currently running task can be obtained by calling
N * xTaskGetCurrentTaskHandle().
N *
N * @param pxHigherPriorityTaskWoken  vTaskNotifyGiveFromISR() will set
N * *pxHigherPriorityTaskWoken to pdTRUE if sending the notification caused the
N * task to which the notification was sent to leave the Blocked state, and the
N * unblocked task has a priority higher than the currently running task.  If
N * vTaskNotifyGiveFromISR() sets this value to pdTRUE then a context switch
N * should be requested before the interrupt is exited.  How a context switch is
N * requested from an ISR is dependent on the port - see the documentation page
N * for the port in use.
N *
N * \defgroup xTaskNotifyWait xTaskNotifyWait
N * \ingroup TaskNotifications
N */
Nvoid vTaskNotifyGiveFromISR( TaskHandle_t xTaskToNotify, BaseType_t *pxHigherPriorityTaskWoken ) PRIVILEGED_FUNCTION;
Xvoid vTaskNotifyGiveFromISR( TaskHandle_t xTaskToNotify, BaseType_t *pxHigherPriorityTaskWoken ) ;
N
N/**
N * task. h
N * <PRE>uint32_t ulTaskNotifyTake( BaseType_t xClearCountOnExit, TickType_t xTicksToWait );</pre>
N *
N * configUSE_TASK_NOTIFICATIONS must be undefined or defined as 1 for this
N * function to be available.
N *
N * When configUSE_TASK_NOTIFICATIONS is set to one each task has its own private
N * "notification value", which is a 32-bit unsigned integer (uint32_t).
N *
N * Events can be sent to a task using an intermediary object.  Examples of such
N * objects are queues, semaphores, mutexes and event groups.  Task notifications
N * are a method of sending an event directly to a task without the need for such
N * an intermediary object.
N *
N * A notification sent to a task can optionally perform an action, such as
N * update, overwrite or increment the task's notification value.  In that way
N * task notifications can be used to send data to a task, or be used as light
N * weight and fast binary or counting semaphores.
N *
N * ulTaskNotifyTake() is intended for use when a task notification is used as a
N * faster and lighter weight binary or counting semaphore alternative.  Actual
N * FreeRTOS semaphores are taken using the xSemaphoreTake() API function, the
N * equivalent action that instead uses a task notification is
N * ulTaskNotifyTake().
N *
N * When a task is using its notification value as a binary or counting semaphore
N * other tasks should send notifications to it using the xTaskNotifyGive()
N * macro, or xTaskNotify() function with the eAction parameter set to
N * eIncrement.
N *
N * ulTaskNotifyTake() can either clear the task's notification value to
N * zero on exit, in which case the notification value acts like a binary
N * semaphore, or decrement the task's notification value on exit, in which case
N * the notification value acts like a counting semaphore.
N *
N * A task can use ulTaskNotifyTake() to [optionally] block to wait for a
N * the task's notification value to be non-zero.  The task does not consume any
N * CPU time while it is in the Blocked state.
N *
N * Where as xTaskNotifyWait() will return when a notification is pending,
N * ulTaskNotifyTake() will return when the task's notification value is
N * not zero.
N *
N * See http://www.FreeRTOS.org/RTOS-task-notifications.html for details.
N *
N * @param xClearCountOnExit if xClearCountOnExit is pdFALSE then the task's
N * notification value is decremented when the function exits.  In this way the
N * notification value acts like a counting semaphore.  If xClearCountOnExit is
N * not pdFALSE then the task's notification value is cleared to zero when the
N * function exits.  In this way the notification value acts like a binary
N * semaphore.
N *
N * @param xTicksToWait The maximum amount of time that the task should wait in
N * the Blocked state for the task's notification value to be greater than zero,
N * should the count not already be greater than zero when
N * ulTaskNotifyTake() was called.  The task will not consume any processing
N * time while it is in the Blocked state.  This is specified in kernel ticks,
N * the macro pdMS_TO_TICSK( value_in_ms ) can be used to convert a time
N * specified in milliseconds to a time specified in ticks.
N *
N * @return The task's notification count before it is either cleared to zero or
N * decremented (see the xClearCountOnExit parameter).
N *
N * \defgroup ulTaskNotifyTake ulTaskNotifyTake
N * \ingroup TaskNotifications
N */
Nuint32_t ulTaskNotifyTake( BaseType_t xClearCountOnExit, TickType_t xTicksToWait ) PRIVILEGED_FUNCTION;
Xuint32_t ulTaskNotifyTake( BaseType_t xClearCountOnExit, TickType_t xTicksToWait ) ;
N
N/**
N * task. h
N * <PRE>BaseType_t xTaskNotifyStateClear( TaskHandle_t xTask );</pre>
N *
N * If the notification state of the task referenced by the handle xTask is
N * eNotified, then set the task's notification state to eNotWaitingNotification.
N * The task's notification value is not altered.  Set xTask to NULL to clear the
N * notification state of the calling task.
N *
N * @return pdTRUE if the task's notification state was set to
N * eNotWaitingNotification, otherwise pdFALSE.
N * \defgroup xTaskNotifyStateClear xTaskNotifyStateClear
N * \ingroup TaskNotifications
N */
NBaseType_t xTaskNotifyStateClear( TaskHandle_t xTask );
N
N/*-----------------------------------------------------------
N * SCHEDULER INTERNALS AVAILABLE FOR PORTING PURPOSES
N *----------------------------------------------------------*/
N
N/*
N * THIS FUNCTION MUST NOT BE USED FROM APPLICATION CODE.  IT IS ONLY
N * INTENDED FOR USE WHEN IMPLEMENTING A PORT OF THE SCHEDULER AND IS
N * AN INTERFACE WHICH IS FOR THE EXCLUSIVE USE OF THE SCHEDULER.
N *
N * Called from the real time kernel tick (either preemptive or cooperative),
N * this increments the tick count and checks if any tasks that are blocked
N * for a finite period required removing from a blocked list and placing on
N * a ready list.  If a non-zero value is returned then a context switch is
N * required because either:
N *   + A task was removed from a blocked list because its timeout had expired,
N *     or
N *   + Time slicing is in use and there is a task of equal priority to the
N *     currently running task.
N */
NBaseType_t xTaskIncrementTick( void ) PRIVILEGED_FUNCTION;
XBaseType_t xTaskIncrementTick( void ) ;
N
N/*
N * THIS FUNCTION MUST NOT BE USED FROM APPLICATION CODE.  IT IS AN
N * INTERFACE WHICH IS FOR THE EXCLUSIVE USE OF THE SCHEDULER.
N *
N * THIS FUNCTION MUST BE CALLED WITH INTERRUPTS DISABLED.
N *
N * Removes the calling task from the ready list and places it both
N * on the list of tasks waiting for a particular event, and the
N * list of delayed tasks.  The task will be removed from both lists
N * and replaced on the ready list should either the event occur (and
N * there be no higher priority tasks waiting on the same event) or
N * the delay period expires.
N *
N * The 'unordered' version replaces the event list item value with the
N * xItemValue value, and inserts the list item at the end of the list.
N *
N * The 'ordered' version uses the existing event list item value (which is the
N * owning tasks priority) to insert the list item into the event list is task
N * priority order.
N *
N * @param pxEventList The list containing tasks that are blocked waiting
N * for the event to occur.
N *
N * @param xItemValue The item value to use for the event list item when the
N * event list is not ordered by task priority.
N *
N * @param xTicksToWait The maximum amount of time that the task should wait
N * for the event to occur.  This is specified in kernel ticks,the constant
N * portTICK_PERIOD_MS can be used to convert kernel ticks into a real time
N * period.
N */
Nvoid vTaskPlaceOnEventList( List_t * const pxEventList, const TickType_t xTicksToWait ) PRIVILEGED_FUNCTION;
Xvoid vTaskPlaceOnEventList( List_t * const pxEventList, const TickType_t xTicksToWait ) ;
Nvoid vTaskPlaceOnUnorderedEventList( List_t * pxEventList, const TickType_t xItemValue, const TickType_t xTicksToWait ) PRIVILEGED_FUNCTION;
Xvoid vTaskPlaceOnUnorderedEventList( List_t * pxEventList, const TickType_t xItemValue, const TickType_t xTicksToWait ) ;
N
N/*
N * THIS FUNCTION MUST NOT BE USED FROM APPLICATION CODE.  IT IS AN
N * INTERFACE WHICH IS FOR THE EXCLUSIVE USE OF THE SCHEDULER.
N *
N * THIS FUNCTION MUST BE CALLED WITH INTERRUPTS DISABLED.
N *
N * This function performs nearly the same function as vTaskPlaceOnEventList().
N * The difference being that this function does not permit tasks to block
N * indefinitely, whereas vTaskPlaceOnEventList() does.
N *
N */
Nvoid vTaskPlaceOnEventListRestricted( List_t * const pxEventList, TickType_t xTicksToWait, const BaseType_t xWaitIndefinitely ) PRIVILEGED_FUNCTION;
Xvoid vTaskPlaceOnEventListRestricted( List_t * const pxEventList, TickType_t xTicksToWait, const BaseType_t xWaitIndefinitely ) ;
N
N/*
N * THIS FUNCTION MUST NOT BE USED FROM APPLICATION CODE.  IT IS AN
N * INTERFACE WHICH IS FOR THE EXCLUSIVE USE OF THE SCHEDULER.
N *
N * THIS FUNCTION MUST BE CALLED WITH INTERRUPTS DISABLED.
N *
N * Removes a task from both the specified event list and the list of blocked
N * tasks, and places it on a ready queue.
N *
N * xTaskRemoveFromEventList()/xTaskRemoveFromUnorderedEventList() will be called
N * if either an event occurs to unblock a task, or the block timeout period
N * expires.
N *
N * xTaskRemoveFromEventList() is used when the event list is in task priority
N * order.  It removes the list item from the head of the event list as that will
N * have the highest priority owning task of all the tasks on the event list.
N * xTaskRemoveFromUnorderedEventList() is used when the event list is not
N * ordered and the event list items hold something other than the owning tasks
N * priority.  In this case the event list item value is updated to the value
N * passed in the xItemValue parameter.
N *
N * @return pdTRUE if the task being removed has a higher priority than the task
N * making the call, otherwise pdFALSE.
N */
NBaseType_t xTaskRemoveFromEventList( const List_t * const pxEventList ) PRIVILEGED_FUNCTION;
XBaseType_t xTaskRemoveFromEventList( const List_t * const pxEventList ) ;
NBaseType_t xTaskRemoveFromUnorderedEventList( ListItem_t * pxEventListItem, const TickType_t xItemValue ) PRIVILEGED_FUNCTION;
XBaseType_t xTaskRemoveFromUnorderedEventList( ListItem_t * pxEventListItem, const TickType_t xItemValue ) ;
N
N/*
N * THIS FUNCTION MUST NOT BE USED FROM APPLICATION CODE.  IT IS ONLY
N * INTENDED FOR USE WHEN IMPLEMENTING A PORT OF THE SCHEDULER AND IS
N * AN INTERFACE WHICH IS FOR THE EXCLUSIVE USE OF THE SCHEDULER.
N *
N * Sets the pointer to the current TCB to the TCB of the highest priority task
N * that is ready to run.
N */
Nvoid vTaskSwitchContext( void ) PRIVILEGED_FUNCTION;
Xvoid vTaskSwitchContext( void ) ;
N
N/*
N * THESE FUNCTIONS MUST NOT BE USED FROM APPLICATION CODE.  THEY ARE USED BY
N * THE EVENT BITS MODULE.
N */
NTickType_t uxTaskResetEventItemValue( void ) PRIVILEGED_FUNCTION;
XTickType_t uxTaskResetEventItemValue( void ) ;
N
N/*
N * Return the handle of the calling task.
N */
NTaskHandle_t xTaskGetCurrentTaskHandle( void ) PRIVILEGED_FUNCTION;
XTaskHandle_t xTaskGetCurrentTaskHandle( void ) ;
N
N/*
N * Capture the current time status for future reference.
N */
Nvoid vTaskSetTimeOutState( TimeOut_t * const pxTimeOut ) PRIVILEGED_FUNCTION;
Xvoid vTaskSetTimeOutState( TimeOut_t * const pxTimeOut ) ;
N
N/*
N * Compare the time status now with that previously captured to see if the
N * timeout has expired.
N */
NBaseType_t xTaskCheckForTimeOut( TimeOut_t * const pxTimeOut, TickType_t * const pxTicksToWait ) PRIVILEGED_FUNCTION;
XBaseType_t xTaskCheckForTimeOut( TimeOut_t * const pxTimeOut, TickType_t * const pxTicksToWait ) ;
N
N/*
N * Shortcut used by the queue implementation to prevent unnecessary call to
N * taskYIELD();
N */
Nvoid vTaskMissedYield( void ) PRIVILEGED_FUNCTION;
Xvoid vTaskMissedYield( void ) ;
N
N/*
N * Returns the scheduler state as taskSCHEDULER_RUNNING,
N * taskSCHEDULER_NOT_STARTED or taskSCHEDULER_SUSPENDED.
N */
NBaseType_t xTaskGetSchedulerState( void ) PRIVILEGED_FUNCTION;
XBaseType_t xTaskGetSchedulerState( void ) ;
N
N/*
N * Raises the priority of the mutex holder to that of the calling task should
N * the mutex holder have a priority less than the calling task.
N */
Nvoid vTaskPriorityInherit( TaskHandle_t const pxMutexHolder ) PRIVILEGED_FUNCTION;
Xvoid vTaskPriorityInherit( TaskHandle_t const pxMutexHolder ) ;
N
N/*
N * Set the priority of a task back to its proper priority in the case that it
N * inherited a higher priority while it was holding a semaphore.
N */
NBaseType_t xTaskPriorityDisinherit( TaskHandle_t const pxMutexHolder ) PRIVILEGED_FUNCTION;
XBaseType_t xTaskPriorityDisinherit( TaskHandle_t const pxMutexHolder ) ;
N
N/*
N * Get the uxTCBNumber assigned to the task referenced by the xTask parameter.
N */
NUBaseType_t uxTaskGetTaskNumber( TaskHandle_t xTask ) PRIVILEGED_FUNCTION;
XUBaseType_t uxTaskGetTaskNumber( TaskHandle_t xTask ) ;
N
N/*
N * Set the uxTaskNumber of the task referenced by the xTask parameter to
N * uxHandle.
N */
Nvoid vTaskSetTaskNumber( TaskHandle_t xTask, const UBaseType_t uxHandle ) PRIVILEGED_FUNCTION;
Xvoid vTaskSetTaskNumber( TaskHandle_t xTask, const UBaseType_t uxHandle ) ;
N
N/*
N * Only available when configUSE_TICKLESS_IDLE is set to 1.
N * If tickless mode is being used, or a low power mode is implemented, then
N * the tick interrupt will not execute during idle periods.  When this is the
N * case, the tick count value maintained by the scheduler needs to be kept up
N * to date with the actual execution time by being skipped forward by a time
N * equal to the idle period.
N */
Nvoid vTaskStepTick( const TickType_t xTicksToJump ) PRIVILEGED_FUNCTION;
Xvoid vTaskStepTick( const TickType_t xTicksToJump ) ;
N
N/*
N * Only avilable when configUSE_TICKLESS_IDLE is set to 1.
N * Provided for use within portSUPPRESS_TICKS_AND_SLEEP() to allow the port
N * specific sleep function to determine if it is ok to proceed with the sleep,
N * and if it is ok to proceed, if it is ok to sleep indefinitely.
N *
N * This function is necessary because portSUPPRESS_TICKS_AND_SLEEP() is only
N * called with the scheduler suspended, not from within a critical section.  It
N * is therefore possible for an interrupt to request a context switch between
N * portSUPPRESS_TICKS_AND_SLEEP() and the low power mode actually being
N * entered.  eTaskConfirmSleepModeStatus() should be called from a short
N * critical section between the timer being stopped and the sleep mode being
N * entered to ensure it is ok to proceed into the sleep mode.
N */
NeSleepModeStatus eTaskConfirmSleepModeStatus( void ) PRIVILEGED_FUNCTION;
XeSleepModeStatus eTaskConfirmSleepModeStatus( void ) ;
N
N/*
N * For internal use only.  Increment the mutex held count when a mutex is
N * taken and return the handle of the task that has taken the mutex.
N */
Nvoid *pvTaskIncrementMutexHeldCount( void ) PRIVILEGED_FUNCTION;
Xvoid *pvTaskIncrementMutexHeldCount( void ) ;
N
N#ifdef __cplusplus
S}
N#endif
N#endif /* INC_TASK_H */
N
N
N
L 27 "adc.c" 2
N#include "queue.h"
L 1 ".\rtos\include\queue.h" 1
N/*
N    FreeRTOS V9.0.0 - Copyright (C) 2016 Real Time Engineers Ltd.
N    All rights reserved
N
N    VISIT http://www.FreeRTOS.org TO ENSURE YOU ARE USING THE LATEST VERSION.
N
N    This file is part of the FreeRTOS distribution.
N
N    FreeRTOS is free software; you can redistribute it and/or modify it under
N    the terms of the GNU General Public License (version 2) as published by the
N    Free Software Foundation >>>> AND MODIFIED BY <<<< the FreeRTOS exception.
N
N    ***************************************************************************
N    >>!   NOTE: The modification to the GPL is included to allow you to     !<<
N    >>!   distribute a combined work that includes FreeRTOS without being   !<<
N    >>!   obliged to provide the source code for proprietary components     !<<
N    >>!   outside of the FreeRTOS kernel.                                   !<<
N    ***************************************************************************
N
N    FreeRTOS is distributed in the hope that it will be useful, but WITHOUT ANY
N    WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
N    FOR A PARTICULAR PURPOSE.  Full license text is available on the following
N    link: http://www.freertos.org/a00114.html
N
N    ***************************************************************************
N     *                                                                       *
N     *    FreeRTOS provides completely free yet professionally developed,    *
N     *    robust, strictly quality controlled, supported, and cross          *
N     *    platform software that is more than just the market leader, it     *
N     *    is the industry's de facto standard.                               *
N     *                                                                       *
N     *    Help yourself get started quickly while simultaneously helping     *
N     *    to support the FreeRTOS project by purchasing a FreeRTOS           *
N     *    tutorial book, reference manual, or both:                          *
N     *    http://www.FreeRTOS.org/Documentation                              *
N     *                                                                       *
N    ***************************************************************************
N
N    http://www.FreeRTOS.org/FAQHelp.html - Having a problem?  Start by reading
N    the FAQ page "My application does not run, what could be wrong?".  Have you
N    defined configASSERT()?
N
N    http://www.FreeRTOS.org/support - In return for receiving this top quality
N    embedded software for free we request you assist our global community by
N    participating in the support forum.
N
N    http://www.FreeRTOS.org/training - Investing in training allows your team to
N    be as productive as possible as early as possible.  Now you can receive
N    FreeRTOS training directly from Richard Barry, CEO of Real Time Engineers
N    Ltd, and the world's leading authority on the world's leading RTOS.
N
N    http://www.FreeRTOS.org/plus - A selection of FreeRTOS ecosystem products,
N    including FreeRTOS+Trace - an indispensable productivity tool, a DOS
N    compatible FAT file system, and our tiny thread aware UDP/IP stack.
N
N    http://www.FreeRTOS.org/labs - Where new FreeRTOS products go to incubate.
N    Come and try FreeRTOS+TCP, our new open source TCP/IP stack for FreeRTOS.
N
N    http://www.OpenRTOS.com - Real Time Engineers ltd. license FreeRTOS to High
N    Integrity Systems ltd. to sell under the OpenRTOS brand.  Low cost OpenRTOS
N    licenses offer ticketed support, indemnification and commercial middleware.
N
N    http://www.SafeRTOS.com - High Integrity Systems also provide a safety
N    engineered and independently SIL3 certified version for use in safety and
N    mission critical applications that require provable dependability.
N
N    1 tab == 4 spaces!
N*/
N
N
N#ifndef QUEUE_H
N#define QUEUE_H
N
N#ifndef INC_FREERTOS_H
S	#error "include FreeRTOS.h" must appear in source files before "include queue.h"
N#endif
N
N#ifdef __cplusplus
Sextern "C" {
N#endif
N
N
N/**
N * Type by which queues are referenced.  For example, a call to xQueueCreate()
N * returns an QueueHandle_t variable that can then be used as a parameter to
N * xQueueSend(), xQueueReceive(), etc.
N */
Ntypedef void * QueueHandle_t;
Ntypedef void * xQueueHandle;
N
N
N/**
N * Type by which queue sets are referenced.  For example, a call to
N * xQueueCreateSet() returns an xQueueSet variable that can then be used as a
N * parameter to xQueueSelectFromSet(), xQueueAddToSet(), etc.
N */
Ntypedef void * QueueSetHandle_t;
N	
N
N/**
N * Queue sets can contain both queues and semaphores, so the
N * QueueSetMemberHandle_t is defined as a type to be used where a parameter or
N * return value can be either an QueueHandle_t or an SemaphoreHandle_t.
N */
Ntypedef void * QueueSetMemberHandle_t;
N
N/* For internal use only. */
N#define	queueSEND_TO_BACK		( ( BaseType_t ) 0 )
N#define	queueSEND_TO_FRONT		( ( BaseType_t ) 1 )
N#define queueOVERWRITE			( ( BaseType_t ) 2 )
N
N/* For internal use only.  These definitions *must* match those in queue.c. */
N#define queueQUEUE_TYPE_BASE				( ( uint8_t ) 0U )
N#define queueQUEUE_TYPE_SET					( ( uint8_t ) 0U )
N#define queueQUEUE_TYPE_MUTEX 				( ( uint8_t ) 1U )
N#define queueQUEUE_TYPE_COUNTING_SEMAPHORE	( ( uint8_t ) 2U )
N#define queueQUEUE_TYPE_BINARY_SEMAPHORE	( ( uint8_t ) 3U )
N#define queueQUEUE_TYPE_RECURSIVE_MUTEX		( ( uint8_t ) 4U )
N
N/**
N * queue. h
N * <pre>
N QueueHandle_t xQueueCreate(
N							  UBaseType_t uxQueueLength,
N							  UBaseType_t uxItemSize
N						  );
N * </pre>
N *
N * Creates a new queue instance, and returns a handle by which the new queue
N * can be referenced.
N *
N * Internally, within the FreeRTOS implementation, queues use two blocks of
N * memory.  The first block is used to hold the queue's data structures.  The
N * second block is used to hold items placed into the queue.  If a queue is
N * created using xQueueCreate() then both blocks of memory are automatically
N * dynamically allocated inside the xQueueCreate() function.  (see
N * http://www.freertos.org/a00111.html).  If a queue is created using
N * xQueueCreateStatic() then the application writer must provide the memory that
N * will get used by the queue.  xQueueCreateStatic() therefore allows a queue to
N * be created without using any dynamic memory allocation.
N *
N * http://www.FreeRTOS.org/Embedded-RTOS-Queues.html
N *
N * @param uxQueueLength The maximum number of items that the queue can contain.
N *
N * @param uxItemSize The number of bytes each item in the queue will require.
N * Items are queued by copy, not by reference, so this is the number of bytes
N * that will be copied for each posted item.  Each item on the queue must be
N * the same size.
N *
N * @return If the queue is successfully create then a handle to the newly
N * created queue is returned.  If the queue cannot be created then 0 is
N * returned.
N *
N * Example usage:
N   <pre>
N struct AMessage
N {
N	char ucMessageID;
N	char ucData[ 20 ];
N };
N
N void vATask( void *pvParameters )
N {
N QueueHandle_t xQueue1, xQueue2;
N
N	// Create a queue capable of containing 10 uint32_t values.
N	xQueue1 = xQueueCreate( 10, sizeof( uint32_t ) );
N	if( xQueue1 == 0 )
N	{
N		// Queue was not created and must not be used.
N	}
N
N	// Create a queue capable of containing 10 pointers to AMessage structures.
N	// These should be passed by pointer as they contain a lot of data.
N	xQueue2 = xQueueCreate( 10, sizeof( struct AMessage * ) );
N	if( xQueue2 == 0 )
N	{
N		// Queue was not created and must not be used.
N	}
N
N	// ... Rest of task code.
N }
N </pre>
N * \defgroup xQueueCreate xQueueCreate
N * \ingroup QueueManagement
N */
N#if( configSUPPORT_DYNAMIC_ALLOCATION == 1 )
X#if( 1 == 1 )
N	#define xQueueCreate( uxQueueLength, uxItemSize ) xQueueGenericCreate( ( uxQueueLength ), ( uxItemSize ), ( queueQUEUE_TYPE_BASE ) )
N#endif
N
N/**
N * queue. h
N * <pre>
N QueueHandle_t xQueueCreateStatic(
N							  UBaseType_t uxQueueLength,
N							  UBaseType_t uxItemSize,
N							  uint8_t *pucQueueStorageBuffer,
N							  StaticQueue_t *pxQueueBuffer
N						  );
N * </pre>
N *
N * Creates a new queue instance, and returns a handle by which the new queue
N * can be referenced.
N *
N * Internally, within the FreeRTOS implementation, queues use two blocks of
N * memory.  The first block is used to hold the queue's data structures.  The
N * second block is used to hold items placed into the queue.  If a queue is
N * created using xQueueCreate() then both blocks of memory are automatically
N * dynamically allocated inside the xQueueCreate() function.  (see
N * http://www.freertos.org/a00111.html).  If a queue is created using
N * xQueueCreateStatic() then the application writer must provide the memory that
N * will get used by the queue.  xQueueCreateStatic() therefore allows a queue to
N * be created without using any dynamic memory allocation.
N *
N * http://www.FreeRTOS.org/Embedded-RTOS-Queues.html
N *
N * @param uxQueueLength The maximum number of items that the queue can contain.
N *
N * @param uxItemSize The number of bytes each item in the queue will require.
N * Items are queued by copy, not by reference, so this is the number of bytes
N * that will be copied for each posted item.  Each item on the queue must be
N * the same size.
N *
N * @param pucQueueStorageBuffer If uxItemSize is not zero then
N * pucQueueStorageBuffer must point to a uint8_t array that is at least large
N * enough to hold the maximum number of items that can be in the queue at any
N * one time - which is ( uxQueueLength * uxItemsSize ) bytes.  If uxItemSize is
N * zero then pucQueueStorageBuffer can be NULL.
N *
N * @param pxQueueBuffer Must point to a variable of type StaticQueue_t, which
N * will be used to hold the queue's data structure.
N *
N * @return If the queue is created then a handle to the created queue is
N * returned.  If pxQueueBuffer is NULL then NULL is returned.
N *
N * Example usage:
N   <pre>
N struct AMessage
N {
N	char ucMessageID;
N	char ucData[ 20 ];
N };
N
N #define QUEUE_LENGTH 10
N #define ITEM_SIZE sizeof( uint32_t )
N
N // xQueueBuffer will hold the queue structure.
N StaticQueue_t xQueueBuffer;
N
N // ucQueueStorage will hold the items posted to the queue.  Must be at least
N // [(queue length) * ( queue item size)] bytes long.
N uint8_t ucQueueStorage[ QUEUE_LENGTH * ITEM_SIZE ];
N
N void vATask( void *pvParameters )
N {
N QueueHandle_t xQueue1;
N
N	// Create a queue capable of containing 10 uint32_t values.
N	xQueue1 = xQueueCreate( QUEUE_LENGTH, // The number of items the queue can hold.
N							ITEM_SIZE	  // The size of each item in the queue
N							&( ucQueueStorage[ 0 ] ), // The buffer that will hold the items in the queue.
N							&xQueueBuffer ); // The buffer that will hold the queue structure.
N
N	// The queue is guaranteed to be created successfully as no dynamic memory
N	// allocation is used.  Therefore xQueue1 is now a handle to a valid queue.
N
N	// ... Rest of task code.
N }
N </pre>
N * \defgroup xQueueCreateStatic xQueueCreateStatic
N * \ingroup QueueManagement
N */
N#if( configSUPPORT_STATIC_ALLOCATION == 1 )
X#if( 0 == 1 )
S	#define xQueueCreateStatic( uxQueueLength, uxItemSize, pucQueueStorage, pxQueueBuffer ) xQueueGenericCreateStatic( ( uxQueueLength ), ( uxItemSize ), ( pucQueueStorage ), ( pxQueueBuffer ), ( queueQUEUE_TYPE_BASE ) )
N#endif /* configSUPPORT_STATIC_ALLOCATION */
N
N/**
N * queue. h
N * <pre>
N BaseType_t xQueueSendToToFront(
N								   QueueHandle_t	xQueue,
N								   const void		*pvItemToQueue,
N								   TickType_t		xTicksToWait
N							   );
N * </pre>
N *
N * This is a macro that calls xQueueGenericSend().
N *
N * Post an item to the front of a queue.  The item is queued by copy, not by
N * reference.  This function must not be called from an interrupt service
N * routine.  See xQueueSendFromISR () for an alternative which may be used
N * in an ISR.
N *
N * @param xQueue The handle to the queue on which the item is to be posted.
N *
N * @param pvItemToQueue A pointer to the item that is to be placed on the
N * queue.  The size of the items the queue will hold was defined when the
N * queue was created, so this many bytes will be copied from pvItemToQueue
N * into the queue storage area.
N *
N * @param xTicksToWait The maximum amount of time the task should block
N * waiting for space to become available on the queue, should it already
N * be full.  The call will return immediately if this is set to 0 and the
N * queue is full.  The time is defined in tick periods so the constant
N * portTICK_PERIOD_MS should be used to convert to real time if this is required.
N *
N * @return pdTRUE if the item was successfully posted, otherwise errQUEUE_FULL.
N *
N * Example usage:
N   <pre>
N struct AMessage
N {
N	char ucMessageID;
N	char ucData[ 20 ];
N } xMessage;
N
N uint32_t ulVar = 10UL;
N
N void vATask( void *pvParameters )
N {
N QueueHandle_t xQueue1, xQueue2;
N struct AMessage *pxMessage;
N
N	// Create a queue capable of containing 10 uint32_t values.
N	xQueue1 = xQueueCreate( 10, sizeof( uint32_t ) );
N
N	// Create a queue capable of containing 10 pointers to AMessage structures.
N	// These should be passed by pointer as they contain a lot of data.
N	xQueue2 = xQueueCreate( 10, sizeof( struct AMessage * ) );
N
N	// ...
N
N	if( xQueue1 != 0 )
N	{
N		// Send an uint32_t.  Wait for 10 ticks for space to become
N		// available if necessary.
N		if( xQueueSendToFront( xQueue1, ( void * ) &ulVar, ( TickType_t ) 10 ) != pdPASS )
N		{
N			// Failed to post the message, even after 10 ticks.
N		}
N	}
N
N	if( xQueue2 != 0 )
N	{
N		// Send a pointer to a struct AMessage object.  Don't block if the
N		// queue is already full.
N		pxMessage = & xMessage;
N		xQueueSendToFront( xQueue2, ( void * ) &pxMessage, ( TickType_t ) 0 );
N	}
N
N	// ... Rest of task code.
N }
N </pre>
N * \defgroup xQueueSend xQueueSend
N * \ingroup QueueManagement
N */
N#define xQueueSendToFront( xQueue, pvItemToQueue, xTicksToWait ) xQueueGenericSend( ( xQueue ), ( pvItemToQueue ), ( xTicksToWait ), queueSEND_TO_FRONT )
N
N/**
N * queue. h
N * <pre>
N BaseType_t xQueueSendToBack(
N								   QueueHandle_t	xQueue,
N								   const void		*pvItemToQueue,
N								   TickType_t		xTicksToWait
N							   );
N * </pre>
N *
N * This is a macro that calls xQueueGenericSend().
N *
N * Post an item to the back of a queue.  The item is queued by copy, not by
N * reference.  This function must not be called from an interrupt service
N * routine.  See xQueueSendFromISR () for an alternative which may be used
N * in an ISR.
N *
N * @param xQueue The handle to the queue on which the item is to be posted.
N *
N * @param pvItemToQueue A pointer to the item that is to be placed on the
N * queue.  The size of the items the queue will hold was defined when the
N * queue was created, so this many bytes will be copied from pvItemToQueue
N * into the queue storage area.
N *
N * @param xTicksToWait The maximum amount of time the task should block
N * waiting for space to become available on the queue, should it already
N * be full.  The call will return immediately if this is set to 0 and the queue
N * is full.  The  time is defined in tick periods so the constant
N * portTICK_PERIOD_MS should be used to convert to real time if this is required.
N *
N * @return pdTRUE if the item was successfully posted, otherwise errQUEUE_FULL.
N *
N * Example usage:
N   <pre>
N struct AMessage
N {
N	char ucMessageID;
N	char ucData[ 20 ];
N } xMessage;
N
N uint32_t ulVar = 10UL;
N
N void vATask( void *pvParameters )
N {
N QueueHandle_t xQueue1, xQueue2;
N struct AMessage *pxMessage;
N
N	// Create a queue capable of containing 10 uint32_t values.
N	xQueue1 = xQueueCreate( 10, sizeof( uint32_t ) );
N
N	// Create a queue capable of containing 10 pointers to AMessage structures.
N	// These should be passed by pointer as they contain a lot of data.
N	xQueue2 = xQueueCreate( 10, sizeof( struct AMessage * ) );
N
N	// ...
N
N	if( xQueue1 != 0 )
N	{
N		// Send an uint32_t.  Wait for 10 ticks for space to become
N		// available if necessary.
N		if( xQueueSendToBack( xQueue1, ( void * ) &ulVar, ( TickType_t ) 10 ) != pdPASS )
N		{
N			// Failed to post the message, even after 10 ticks.
N		}
N	}
N
N	if( xQueue2 != 0 )
N	{
N		// Send a pointer to a struct AMessage object.  Don't block if the
N		// queue is already full.
N		pxMessage = & xMessage;
N		xQueueSendToBack( xQueue2, ( void * ) &pxMessage, ( TickType_t ) 0 );
N	}
N
N	// ... Rest of task code.
N }
N </pre>
N * \defgroup xQueueSend xQueueSend
N * \ingroup QueueManagement
N */
N#define xQueueSendToBack( xQueue, pvItemToQueue, xTicksToWait ) xQueueGenericSend( ( xQueue ), ( pvItemToQueue ), ( xTicksToWait ), queueSEND_TO_BACK )
N
N/**
N * queue. h
N * <pre>
N BaseType_t xQueueSend(
N							  QueueHandle_t xQueue,
N							  const void * pvItemToQueue,
N							  TickType_t xTicksToWait
N						 );
N * </pre>
N *
N * This is a macro that calls xQueueGenericSend().  It is included for
N * backward compatibility with versions of FreeRTOS.org that did not
N * include the xQueueSendToFront() and xQueueSendToBack() macros.  It is
N * equivalent to xQueueSendToBack().
N *
N * Post an item on a queue.  The item is queued by copy, not by reference.
N * This function must not be called from an interrupt service routine.
N * See xQueueSendFromISR () for an alternative which may be used in an ISR.
N *
N * @param xQueue The handle to the queue on which the item is to be posted.
N *
N * @param pvItemToQueue A pointer to the item that is to be placed on the
N * queue.  The size of the items the queue will hold was defined when the
N * queue was created, so this many bytes will be copied from pvItemToQueue
N * into the queue storage area.
N *
N * @param xTicksToWait The maximum amount of time the task should block
N * waiting for space to become available on the queue, should it already
N * be full.  The call will return immediately if this is set to 0 and the
N * queue is full.  The time is defined in tick periods so the constant
N * portTICK_PERIOD_MS should be used to convert to real time if this is required.
N *
N * @return pdTRUE if the item was successfully posted, otherwise errQUEUE_FULL.
N *
N * Example usage:
N   <pre>
N struct AMessage
N {
N	char ucMessageID;
N	char ucData[ 20 ];
N } xMessage;
N
N uint32_t ulVar = 10UL;
N
N void vATask( void *pvParameters )
N {
N QueueHandle_t xQueue1, xQueue2;
N struct AMessage *pxMessage;
N
N	// Create a queue capable of containing 10 uint32_t values.
N	xQueue1 = xQueueCreate( 10, sizeof( uint32_t ) );
N
N	// Create a queue capable of containing 10 pointers to AMessage structures.
N	// These should be passed by pointer as they contain a lot of data.
N	xQueue2 = xQueueCreate( 10, sizeof( struct AMessage * ) );
N
N	// ...
N
N	if( xQueue1 != 0 )
N	{
N		// Send an uint32_t.  Wait for 10 ticks for space to become
N		// available if necessary.
N		if( xQueueSend( xQueue1, ( void * ) &ulVar, ( TickType_t ) 10 ) != pdPASS )
N		{
N			// Failed to post the message, even after 10 ticks.
N		}
N	}
N
N	if( xQueue2 != 0 )
N	{
N		// Send a pointer to a struct AMessage object.  Don't block if the
N		// queue is already full.
N		pxMessage = & xMessage;
N		xQueueSend( xQueue2, ( void * ) &pxMessage, ( TickType_t ) 0 );
N	}
N
N	// ... Rest of task code.
N }
N </pre>
N * \defgroup xQueueSend xQueueSend
N * \ingroup QueueManagement
N */
N#define xQueueSend( xQueue, pvItemToQueue, xTicksToWait ) xQueueGenericSend( ( xQueue ), ( pvItemToQueue ), ( xTicksToWait ), queueSEND_TO_BACK )
N
N/**
N * queue. h
N * <pre>
N BaseType_t xQueueOverwrite(
N							  QueueHandle_t xQueue,
N							  const void * pvItemToQueue
N						 );
N * </pre>
N *
N * Only for use with queues that have a length of one - so the queue is either
N * empty or full.
N *
N * Post an item on a queue.  If the queue is already full then overwrite the
N * value held in the queue.  The item is queued by copy, not by reference.
N *
N * This function must not be called from an interrupt service routine.
N * See xQueueOverwriteFromISR () for an alternative which may be used in an ISR.
N *
N * @param xQueue The handle of the queue to which the data is being sent.
N *
N * @param pvItemToQueue A pointer to the item that is to be placed on the
N * queue.  The size of the items the queue will hold was defined when the
N * queue was created, so this many bytes will be copied from pvItemToQueue
N * into the queue storage area.
N *
N * @return xQueueOverwrite() is a macro that calls xQueueGenericSend(), and
N * therefore has the same return values as xQueueSendToFront().  However, pdPASS
N * is the only value that can be returned because xQueueOverwrite() will write
N * to the queue even when the queue is already full.
N *
N * Example usage:
N   <pre>
N
N void vFunction( void *pvParameters )
N {
N QueueHandle_t xQueue;
N uint32_t ulVarToSend, ulValReceived;
N
N	// Create a queue to hold one uint32_t value.  It is strongly
N	// recommended *not* to use xQueueOverwrite() on queues that can
N	// contain more than one value, and doing so will trigger an assertion
N	// if configASSERT() is defined.
N	xQueue = xQueueCreate( 1, sizeof( uint32_t ) );
N
N	// Write the value 10 to the queue using xQueueOverwrite().
N	ulVarToSend = 10;
N	xQueueOverwrite( xQueue, &ulVarToSend );
N
N	// Peeking the queue should now return 10, but leave the value 10 in
N	// the queue.  A block time of zero is used as it is known that the
N	// queue holds a value.
N	ulValReceived = 0;
N	xQueuePeek( xQueue, &ulValReceived, 0 );
N
N	if( ulValReceived != 10 )
N	{
N		// Error unless the item was removed by a different task.
N	}
N
N	// The queue is still full.  Use xQueueOverwrite() to overwrite the
N	// value held in the queue with 100.
N	ulVarToSend = 100;
N	xQueueOverwrite( xQueue, &ulVarToSend );
N
N	// This time read from the queue, leaving the queue empty once more.
N	// A block time of 0 is used again.
N	xQueueReceive( xQueue, &ulValReceived, 0 );
N
N	// The value read should be the last value written, even though the
N	// queue was already full when the value was written.
N	if( ulValReceived != 100 )
N	{
N		// Error!
N	}
N
N	// ...
N}
N </pre>
N * \defgroup xQueueOverwrite xQueueOverwrite
N * \ingroup QueueManagement
N */
N#define xQueueOverwrite( xQueue, pvItemToQueue ) xQueueGenericSend( ( xQueue ), ( pvItemToQueue ), 0, queueOVERWRITE )
N
N
N/**
N * queue. h
N * <pre>
N BaseType_t xQueueGenericSend(
N									QueueHandle_t xQueue,
N									const void * pvItemToQueue,
N									TickType_t xTicksToWait
N									BaseType_t xCopyPosition
N								);
N * </pre>
N *
N * It is preferred that the macros xQueueSend(), xQueueSendToFront() and
N * xQueueSendToBack() are used in place of calling this function directly.
N *
N * Post an item on a queue.  The item is queued by copy, not by reference.
N * This function must not be called from an interrupt service routine.
N * See xQueueSendFromISR () for an alternative which may be used in an ISR.
N *
N * @param xQueue The handle to the queue on which the item is to be posted.
N *
N * @param pvItemToQueue A pointer to the item that is to be placed on the
N * queue.  The size of the items the queue will hold was defined when the
N * queue was created, so this many bytes will be copied from pvItemToQueue
N * into the queue storage area.
N *
N * @param xTicksToWait The maximum amount of time the task should block
N * waiting for space to become available on the queue, should it already
N * be full.  The call will return immediately if this is set to 0 and the
N * queue is full.  The time is defined in tick periods so the constant
N * portTICK_PERIOD_MS should be used to convert to real time if this is required.
N *
N * @param xCopyPosition Can take the value queueSEND_TO_BACK to place the
N * item at the back of the queue, or queueSEND_TO_FRONT to place the item
N * at the front of the queue (for high priority messages).
N *
N * @return pdTRUE if the item was successfully posted, otherwise errQUEUE_FULL.
N *
N * Example usage:
N   <pre>
N struct AMessage
N {
N	char ucMessageID;
N	char ucData[ 20 ];
N } xMessage;
N
N uint32_t ulVar = 10UL;
N
N void vATask( void *pvParameters )
N {
N QueueHandle_t xQueue1, xQueue2;
N struct AMessage *pxMessage;
N
N	// Create a queue capable of containing 10 uint32_t values.
N	xQueue1 = xQueueCreate( 10, sizeof( uint32_t ) );
N
N	// Create a queue capable of containing 10 pointers to AMessage structures.
N	// These should be passed by pointer as they contain a lot of data.
N	xQueue2 = xQueueCreate( 10, sizeof( struct AMessage * ) );
N
N	// ...
N
N	if( xQueue1 != 0 )
N	{
N		// Send an uint32_t.  Wait for 10 ticks for space to become
N		// available if necessary.
N		if( xQueueGenericSend( xQueue1, ( void * ) &ulVar, ( TickType_t ) 10, queueSEND_TO_BACK ) != pdPASS )
N		{
N			// Failed to post the message, even after 10 ticks.
N		}
N	}
N
N	if( xQueue2 != 0 )
N	{
N		// Send a pointer to a struct AMessage object.  Don't block if the
N		// queue is already full.
N		pxMessage = & xMessage;
N		xQueueGenericSend( xQueue2, ( void * ) &pxMessage, ( TickType_t ) 0, queueSEND_TO_BACK );
N	}
N
N	// ... Rest of task code.
N }
N </pre>
N * \defgroup xQueueSend xQueueSend
N * \ingroup QueueManagement
N */
NBaseType_t xQueueGenericSend( QueueHandle_t xQueue, const void * const pvItemToQueue, TickType_t xTicksToWait, const BaseType_t xCopyPosition ) PRIVILEGED_FUNCTION;
XBaseType_t xQueueGenericSend( QueueHandle_t xQueue, const void * const pvItemToQueue, TickType_t xTicksToWait, const BaseType_t xCopyPosition ) ;
N
N/**
N * queue. h
N * <pre>
N BaseType_t xQueuePeek(
N							 QueueHandle_t xQueue,
N							 void *pvBuffer,
N							 TickType_t xTicksToWait
N						 );</pre>
N *
N * This is a macro that calls the xQueueGenericReceive() function.
N *
N * Receive an item from a queue without removing the item from the queue.
N * The item is received by copy so a buffer of adequate size must be
N * provided.  The number of bytes copied into the buffer was defined when
N * the queue was created.
N *
N * Successfully received items remain on the queue so will be returned again
N * by the next call, or a call to xQueueReceive().
N *
N * This macro must not be used in an interrupt service routine.  See
N * xQueuePeekFromISR() for an alternative that can be called from an interrupt
N * service routine.
N *
N * @param xQueue The handle to the queue from which the item is to be
N * received.
N *
N * @param pvBuffer Pointer to the buffer into which the received item will
N * be copied.
N *
N * @param xTicksToWait The maximum amount of time the task should block
N * waiting for an item to receive should the queue be empty at the time
N * of the call.	 The time is defined in tick periods so the constant
N * portTICK_PERIOD_MS should be used to convert to real time if this is required.
N * xQueuePeek() will return immediately if xTicksToWait is 0 and the queue
N * is empty.
N *
N * @return pdTRUE if an item was successfully received from the queue,
N * otherwise pdFALSE.
N *
N * Example usage:
N   <pre>
N struct AMessage
N {
N	char ucMessageID;
N	char ucData[ 20 ];
N } xMessage;
N
N QueueHandle_t xQueue;
N
N // Task to create a queue and post a value.
N void vATask( void *pvParameters )
N {
N struct AMessage *pxMessage;
N
N	// Create a queue capable of containing 10 pointers to AMessage structures.
N	// These should be passed by pointer as they contain a lot of data.
N	xQueue = xQueueCreate( 10, sizeof( struct AMessage * ) );
N	if( xQueue == 0 )
N	{
N		// Failed to create the queue.
N	}
N
N	// ...
N
N	// Send a pointer to a struct AMessage object.  Don't block if the
N	// queue is already full.
N	pxMessage = & xMessage;
N	xQueueSend( xQueue, ( void * ) &pxMessage, ( TickType_t ) 0 );
N
N	// ... Rest of task code.
N }
N
N // Task to peek the data from the queue.
N void vADifferentTask( void *pvParameters )
N {
N struct AMessage *pxRxedMessage;
N
N	if( xQueue != 0 )
N	{
N		// Peek a message on the created queue.  Block for 10 ticks if a
N		// message is not immediately available.
N		if( xQueuePeek( xQueue, &( pxRxedMessage ), ( TickType_t ) 10 ) )
N		{
N			// pcRxedMessage now points to the struct AMessage variable posted
N			// by vATask, but the item still remains on the queue.
N		}
N	}
N
N	// ... Rest of task code.
N }
N </pre>
N * \defgroup xQueueReceive xQueueReceive
N * \ingroup QueueManagement
N */
N#define xQueuePeek( xQueue, pvBuffer, xTicksToWait ) xQueueGenericReceive( ( xQueue ), ( pvBuffer ), ( xTicksToWait ), pdTRUE )
N
N/**
N * queue. h
N * <pre>
N BaseType_t xQueuePeekFromISR(
N									QueueHandle_t xQueue,
N									void *pvBuffer,
N								);</pre>
N *
N * A version of xQueuePeek() that can be called from an interrupt service
N * routine (ISR).
N *
N * Receive an item from a queue without removing the item from the queue.
N * The item is received by copy so a buffer of adequate size must be
N * provided.  The number of bytes copied into the buffer was defined when
N * the queue was created.
N *
N * Successfully received items remain on the queue so will be returned again
N * by the next call, or a call to xQueueReceive().
N *
N * @param xQueue The handle to the queue from which the item is to be
N * received.
N *
N * @param pvBuffer Pointer to the buffer into which the received item will
N * be copied.
N *
N * @return pdTRUE if an item was successfully received from the queue,
N * otherwise pdFALSE.
N *
N * \defgroup xQueuePeekFromISR xQueuePeekFromISR
N * \ingroup QueueManagement
N */
NBaseType_t xQueuePeekFromISR( QueueHandle_t xQueue, void * const pvBuffer ) PRIVILEGED_FUNCTION;
XBaseType_t xQueuePeekFromISR( QueueHandle_t xQueue, void * const pvBuffer ) ;
N
N/**
N * queue. h
N * <pre>
N BaseType_t xQueueReceive(
N								 QueueHandle_t xQueue,
N								 void *pvBuffer,
N								 TickType_t xTicksToWait
N							);</pre>
N *
N * This is a macro that calls the xQueueGenericReceive() function.
N *
N * Receive an item from a queue.  The item is received by copy so a buffer of
N * adequate size must be provided.  The number of bytes copied into the buffer
N * was defined when the queue was created.
N *
N * Successfully received items are removed from the queue.
N *
N * This function must not be used in an interrupt service routine.  See
N * xQueueReceiveFromISR for an alternative that can.
N *
N * @param xQueue The handle to the queue from which the item is to be
N * received.
N *
N * @param pvBuffer Pointer to the buffer into which the received item will
N * be copied.
N *
N * @param xTicksToWait The maximum amount of time the task should block
N * waiting for an item to receive should the queue be empty at the time
N * of the call.	 xQueueReceive() will return immediately if xTicksToWait
N * is zero and the queue is empty.  The time is defined in tick periods so the
N * constant portTICK_PERIOD_MS should be used to convert to real time if this is
N * required.
N *
N * @return pdTRUE if an item was successfully received from the queue,
N * otherwise pdFALSE.
N *
N * Example usage:
N   <pre>
N struct AMessage
N {
N	char ucMessageID;
N	char ucData[ 20 ];
N } xMessage;
N
N QueueHandle_t xQueue;
N
N // Task to create a queue and post a value.
N void vATask( void *pvParameters )
N {
N struct AMessage *pxMessage;
N
N	// Create a queue capable of containing 10 pointers to AMessage structures.
N	// These should be passed by pointer as they contain a lot of data.
N	xQueue = xQueueCreate( 10, sizeof( struct AMessage * ) );
N	if( xQueue == 0 )
N	{
N		// Failed to create the queue.
N	}
N
N	// ...
N
N	// Send a pointer to a struct AMessage object.  Don't block if the
N	// queue is already full.
N	pxMessage = & xMessage;
N	xQueueSend( xQueue, ( void * ) &pxMessage, ( TickType_t ) 0 );
N
N	// ... Rest of task code.
N }
N
N // Task to receive from the queue.
N void vADifferentTask( void *pvParameters )
N {
N struct AMessage *pxRxedMessage;
N
N	if( xQueue != 0 )
N	{
N		// Receive a message on the created queue.  Block for 10 ticks if a
N		// message is not immediately available.
N		if( xQueueReceive( xQueue, &( pxRxedMessage ), ( TickType_t ) 10 ) )
N		{
N			// pcRxedMessage now points to the struct AMessage variable posted
N			// by vATask.
N		}
N	}
N
N	// ... Rest of task code.
N }
N </pre>
N * \defgroup xQueueReceive xQueueReceive
N * \ingroup QueueManagement
N */
N#define xQueueReceive( xQueue, pvBuffer, xTicksToWait ) xQueueGenericReceive( ( xQueue ), ( pvBuffer ), ( xTicksToWait ), pdFALSE )
N
N
N/**
N * queue. h
N * <pre>
N BaseType_t xQueueGenericReceive(
N									   QueueHandle_t	xQueue,
N									   void	*pvBuffer,
N									   TickType_t	xTicksToWait
N									   BaseType_t	xJustPeek
N									);</pre>
N *
N * It is preferred that the macro xQueueReceive() be used rather than calling
N * this function directly.
N *
N * Receive an item from a queue.  The item is received by copy so a buffer of
N * adequate size must be provided.  The number of bytes copied into the buffer
N * was defined when the queue was created.
N *
N * This function must not be used in an interrupt service routine.  See
N * xQueueReceiveFromISR for an alternative that can.
N *
N * @param xQueue The handle to the queue from which the item is to be
N * received.
N *
N * @param pvBuffer Pointer to the buffer into which the received item will
N * be copied.
N *
N * @param xTicksToWait The maximum amount of time the task should block
N * waiting for an item to receive should the queue be empty at the time
N * of the call.	 The time is defined in tick periods so the constant
N * portTICK_PERIOD_MS should be used to convert to real time if this is required.
N * xQueueGenericReceive() will return immediately if the queue is empty and
N * xTicksToWait is 0.
N *
N * @param xJustPeek When set to true, the item received from the queue is not
N * actually removed from the queue - meaning a subsequent call to
N * xQueueReceive() will return the same item.  When set to false, the item
N * being received from the queue is also removed from the queue.
N *
N * @return pdTRUE if an item was successfully received from the queue,
N * otherwise pdFALSE.
N *
N * Example usage:
N   <pre>
N struct AMessage
N {
N	char ucMessageID;
N	char ucData[ 20 ];
N } xMessage;
N
N QueueHandle_t xQueue;
N
N // Task to create a queue and post a value.
N void vATask( void *pvParameters )
N {
N struct AMessage *pxMessage;
N
N	// Create a queue capable of containing 10 pointers to AMessage structures.
N	// These should be passed by pointer as they contain a lot of data.
N	xQueue = xQueueCreate( 10, sizeof( struct AMessage * ) );
N	if( xQueue == 0 )
N	{
N		// Failed to create the queue.
N	}
N
N	// ...
N
N	// Send a pointer to a struct AMessage object.  Don't block if the
N	// queue is already full.
N	pxMessage = & xMessage;
N	xQueueSend( xQueue, ( void * ) &pxMessage, ( TickType_t ) 0 );
N
N	// ... Rest of task code.
N }
N
N // Task to receive from the queue.
N void vADifferentTask( void *pvParameters )
N {
N struct AMessage *pxRxedMessage;
N
N	if( xQueue != 0 )
N	{
N		// Receive a message on the created queue.  Block for 10 ticks if a
N		// message is not immediately available.
N		if( xQueueGenericReceive( xQueue, &( pxRxedMessage ), ( TickType_t ) 10 ) )
N		{
N			// pcRxedMessage now points to the struct AMessage variable posted
N			// by vATask.
N		}
N	}
N
N	// ... Rest of task code.
N }
N </pre>
N * \defgroup xQueueReceive xQueueReceive
N * \ingroup QueueManagement
N */
NBaseType_t xQueueGenericReceive( QueueHandle_t xQueue, void * const pvBuffer, TickType_t xTicksToWait, const BaseType_t xJustPeek ) PRIVILEGED_FUNCTION;
XBaseType_t xQueueGenericReceive( QueueHandle_t xQueue, void * const pvBuffer, TickType_t xTicksToWait, const BaseType_t xJustPeek ) ;
N
N/**
N * queue. h
N * <pre>UBaseType_t uxQueueMessagesWaiting( const QueueHandle_t xQueue );</pre>
N *
N * Return the number of messages stored in a queue.
N *
N * @param xQueue A handle to the queue being queried.
N *
N * @return The number of messages available in the queue.
N *
N * \defgroup uxQueueMessagesWaiting uxQueueMessagesWaiting
N * \ingroup QueueManagement
N */
NUBaseType_t uxQueueMessagesWaiting( const QueueHandle_t xQueue ) PRIVILEGED_FUNCTION;
XUBaseType_t uxQueueMessagesWaiting( const QueueHandle_t xQueue ) ;
N
N/**
N * queue. h
N * <pre>UBaseType_t uxQueueSpacesAvailable( const QueueHandle_t xQueue );</pre>
N *
N * Return the number of free spaces available in a queue.  This is equal to the
N * number of items that can be sent to the queue before the queue becomes full
N * if no items are removed.
N *
N * @param xQueue A handle to the queue being queried.
N *
N * @return The number of spaces available in the queue.
N *
N * \defgroup uxQueueMessagesWaiting uxQueueMessagesWaiting
N * \ingroup QueueManagement
N */
NUBaseType_t uxQueueSpacesAvailable( const QueueHandle_t xQueue ) PRIVILEGED_FUNCTION;
XUBaseType_t uxQueueSpacesAvailable( const QueueHandle_t xQueue ) ;
N
N/**
N * queue. h
N * <pre>void vQueueDelete( QueueHandle_t xQueue );</pre>
N *
N * Delete a queue - freeing all the memory allocated for storing of items
N * placed on the queue.
N *
N * @param xQueue A handle to the queue to be deleted.
N *
N * \defgroup vQueueDelete vQueueDelete
N * \ingroup QueueManagement
N */
Nvoid vQueueDelete( QueueHandle_t xQueue ) PRIVILEGED_FUNCTION;
Xvoid vQueueDelete( QueueHandle_t xQueue ) ;
N
N/**
N * queue. h
N * <pre>
N BaseType_t xQueueSendToFrontFromISR(
N										 QueueHandle_t xQueue,
N										 const void *pvItemToQueue,
N										 BaseType_t *pxHigherPriorityTaskWoken
N									  );
N </pre>
N *
N * This is a macro that calls xQueueGenericSendFromISR().
N *
N * Post an item to the front of a queue.  It is safe to use this macro from
N * within an interrupt service routine.
N *
N * Items are queued by copy not reference so it is preferable to only
N * queue small items, especially when called from an ISR.  In most cases
N * it would be preferable to store a pointer to the item being queued.
N *
N * @param xQueue The handle to the queue on which the item is to be posted.
N *
N * @param pvItemToQueue A pointer to the item that is to be placed on the
N * queue.  The size of the items the queue will hold was defined when the
N * queue was created, so this many bytes will be copied from pvItemToQueue
N * into the queue storage area.
N *
N * @param pxHigherPriorityTaskWoken xQueueSendToFrontFromISR() will set
N * *pxHigherPriorityTaskWoken to pdTRUE if sending to the queue caused a task
N * to unblock, and the unblocked task has a priority higher than the currently
N * running task.  If xQueueSendToFromFromISR() sets this value to pdTRUE then
N * a context switch should be requested before the interrupt is exited.
N *
N * @return pdTRUE if the data was successfully sent to the queue, otherwise
N * errQUEUE_FULL.
N *
N * Example usage for buffered IO (where the ISR can obtain more than one value
N * per call):
N   <pre>
N void vBufferISR( void )
N {
N char cIn;
N BaseType_t xHigherPrioritTaskWoken;
N
N	// We have not woken a task at the start of the ISR.
N	xHigherPriorityTaskWoken = pdFALSE;
N
N	// Loop until the buffer is empty.
N	do
N	{
N		// Obtain a byte from the buffer.
N		cIn = portINPUT_BYTE( RX_REGISTER_ADDRESS );
N
N		// Post the byte.
N		xQueueSendToFrontFromISR( xRxQueue, &cIn, &xHigherPriorityTaskWoken );
N
N	} while( portINPUT_BYTE( BUFFER_COUNT ) );
N
N	// Now the buffer is empty we can switch context if necessary.
N	if( xHigherPriorityTaskWoken )
N	{
N		taskYIELD ();
N	}
N }
N </pre>
N *
N * \defgroup xQueueSendFromISR xQueueSendFromISR
N * \ingroup QueueManagement
N */
N#define xQueueSendToFrontFromISR( xQueue, pvItemToQueue, pxHigherPriorityTaskWoken ) xQueueGenericSendFromISR( ( xQueue ), ( pvItemToQueue ), ( pxHigherPriorityTaskWoken ), queueSEND_TO_FRONT )
N
N
N/**
N * queue. h
N * <pre>
N BaseType_t xQueueSendToBackFromISR(
N										 QueueHandle_t xQueue,
N										 const void *pvItemToQueue,
N										 BaseType_t *pxHigherPriorityTaskWoken
N									  );
N </pre>
N *
N * This is a macro that calls xQueueGenericSendFromISR().
N *
N * Post an item to the back of a queue.  It is safe to use this macro from
N * within an interrupt service routine.
N *
N * Items are queued by copy not reference so it is preferable to only
N * queue small items, especially when called from an ISR.  In most cases
N * it would be preferable to store a pointer to the item being queued.
N *
N * @param xQueue The handle to the queue on which the item is to be posted.
N *
N * @param pvItemToQueue A pointer to the item that is to be placed on the
N * queue.  The size of the items the queue will hold was defined when the
N * queue was created, so this many bytes will be copied from pvItemToQueue
N * into the queue storage area.
N *
N * @param pxHigherPriorityTaskWoken xQueueSendToBackFromISR() will set
N * *pxHigherPriorityTaskWoken to pdTRUE if sending to the queue caused a task
N * to unblock, and the unblocked task has a priority higher than the currently
N * running task.  If xQueueSendToBackFromISR() sets this value to pdTRUE then
N * a context switch should be requested before the interrupt is exited.
N *
N * @return pdTRUE if the data was successfully sent to the queue, otherwise
N * errQUEUE_FULL.
N *
N * Example usage for buffered IO (where the ISR can obtain more than one value
N * per call):
N   <pre>
N void vBufferISR( void )
N {
N char cIn;
N BaseType_t xHigherPriorityTaskWoken;
N
N	// We have not woken a task at the start of the ISR.
N	xHigherPriorityTaskWoken = pdFALSE;
N
N	// Loop until the buffer is empty.
N	do
N	{
N		// Obtain a byte from the buffer.
N		cIn = portINPUT_BYTE( RX_REGISTER_ADDRESS );
N
N		// Post the byte.
N		xQueueSendToBackFromISR( xRxQueue, &cIn, &xHigherPriorityTaskWoken );
N
N	} while( portINPUT_BYTE( BUFFER_COUNT ) );
N
N	// Now the buffer is empty we can switch context if necessary.
N	if( xHigherPriorityTaskWoken )
N	{
N		taskYIELD ();
N	}
N }
N </pre>
N *
N * \defgroup xQueueSendFromISR xQueueSendFromISR
N * \ingroup QueueManagement
N */
N#define xQueueSendToBackFromISR( xQueue, pvItemToQueue, pxHigherPriorityTaskWoken ) xQueueGenericSendFromISR( ( xQueue ), ( pvItemToQueue ), ( pxHigherPriorityTaskWoken ), queueSEND_TO_BACK )
N
N/**
N * queue. h
N * <pre>
N BaseType_t xQueueOverwriteFromISR(
N							  QueueHandle_t xQueue,
N							  const void * pvItemToQueue,
N							  BaseType_t *pxHigherPriorityTaskWoken
N						 );
N * </pre>
N *
N * A version of xQueueOverwrite() that can be used in an interrupt service
N * routine (ISR).
N *
N * Only for use with queues that can hold a single item - so the queue is either
N * empty or full.
N *
N * Post an item on a queue.  If the queue is already full then overwrite the
N * value held in the queue.  The item is queued by copy, not by reference.
N *
N * @param xQueue The handle to the queue on which the item is to be posted.
N *
N * @param pvItemToQueue A pointer to the item that is to be placed on the
N * queue.  The size of the items the queue will hold was defined when the
N * queue was created, so this many bytes will be copied from pvItemToQueue
N * into the queue storage area.
N *
N * @param pxHigherPriorityTaskWoken xQueueOverwriteFromISR() will set
N * *pxHigherPriorityTaskWoken to pdTRUE if sending to the queue caused a task
N * to unblock, and the unblocked task has a priority higher than the currently
N * running task.  If xQueueOverwriteFromISR() sets this value to pdTRUE then
N * a context switch should be requested before the interrupt is exited.
N *
N * @return xQueueOverwriteFromISR() is a macro that calls
N * xQueueGenericSendFromISR(), and therefore has the same return values as
N * xQueueSendToFrontFromISR().  However, pdPASS is the only value that can be
N * returned because xQueueOverwriteFromISR() will write to the queue even when
N * the queue is already full.
N *
N * Example usage:
N   <pre>
N
N QueueHandle_t xQueue;
N
N void vFunction( void *pvParameters )
N {
N 	// Create a queue to hold one uint32_t value.  It is strongly
N	// recommended *not* to use xQueueOverwriteFromISR() on queues that can
N	// contain more than one value, and doing so will trigger an assertion
N	// if configASSERT() is defined.
N	xQueue = xQueueCreate( 1, sizeof( uint32_t ) );
N}
N
Nvoid vAnInterruptHandler( void )
N{
N// xHigherPriorityTaskWoken must be set to pdFALSE before it is used.
NBaseType_t xHigherPriorityTaskWoken = pdFALSE;
Nuint32_t ulVarToSend, ulValReceived;
N
N	// Write the value 10 to the queue using xQueueOverwriteFromISR().
N	ulVarToSend = 10;
N	xQueueOverwriteFromISR( xQueue, &ulVarToSend, &xHigherPriorityTaskWoken );
N
N	// The queue is full, but calling xQueueOverwriteFromISR() again will still
N	// pass because the value held in the queue will be overwritten with the
N	// new value.
N	ulVarToSend = 100;
N	xQueueOverwriteFromISR( xQueue, &ulVarToSend, &xHigherPriorityTaskWoken );
N
N	// Reading from the queue will now return 100.
N
N	// ...
N
N	if( xHigherPrioritytaskWoken == pdTRUE )
N	{
N		// Writing to the queue caused a task to unblock and the unblocked task
N		// has a priority higher than or equal to the priority of the currently
N		// executing task (the task this interrupt interrupted).  Perform a context
N		// switch so this interrupt returns directly to the unblocked task.
N		portYIELD_FROM_ISR(); // or portEND_SWITCHING_ISR() depending on the port.
N	}
N}
N </pre>
N * \defgroup xQueueOverwriteFromISR xQueueOverwriteFromISR
N * \ingroup QueueManagement
N */
N#define xQueueOverwriteFromISR( xQueue, pvItemToQueue, pxHigherPriorityTaskWoken ) xQueueGenericSendFromISR( ( xQueue ), ( pvItemToQueue ), ( pxHigherPriorityTaskWoken ), queueOVERWRITE )
N
N/**
N * queue. h
N * <pre>
N BaseType_t xQueueSendFromISR(
N									 QueueHandle_t xQueue,
N									 const void *pvItemToQueue,
N									 BaseType_t *pxHigherPriorityTaskWoken
N								);
N </pre>
N *
N * This is a macro that calls xQueueGenericSendFromISR().  It is included
N * for backward compatibility with versions of FreeRTOS.org that did not
N * include the xQueueSendToBackFromISR() and xQueueSendToFrontFromISR()
N * macros.
N *
N * Post an item to the back of a queue.  It is safe to use this function from
N * within an interrupt service routine.
N *
N * Items are queued by copy not reference so it is preferable to only
N * queue small items, especially when called from an ISR.  In most cases
N * it would be preferable to store a pointer to the item being queued.
N *
N * @param xQueue The handle to the queue on which the item is to be posted.
N *
N * @param pvItemToQueue A pointer to the item that is to be placed on the
N * queue.  The size of the items the queue will hold was defined when the
N * queue was created, so this many bytes will be copied from pvItemToQueue
N * into the queue storage area.
N *
N * @param pxHigherPriorityTaskWoken xQueueSendFromISR() will set
N * *pxHigherPriorityTaskWoken to pdTRUE if sending to the queue caused a task
N * to unblock, and the unblocked task has a priority higher than the currently
N * running task.  If xQueueSendFromISR() sets this value to pdTRUE then
N * a context switch should be requested before the interrupt is exited.
N *
N * @return pdTRUE if the data was successfully sent to the queue, otherwise
N * errQUEUE_FULL.
N *
N * Example usage for buffered IO (where the ISR can obtain more than one value
N * per call):
N   <pre>
N void vBufferISR( void )
N {
N char cIn;
N BaseType_t xHigherPriorityTaskWoken;
N
N	// We have not woken a task at the start of the ISR.
N	xHigherPriorityTaskWoken = pdFALSE;
N
N	// Loop until the buffer is empty.
N	do
N	{
N		// Obtain a byte from the buffer.
N		cIn = portINPUT_BYTE( RX_REGISTER_ADDRESS );
N
N		// Post the byte.
N		xQueueSendFromISR( xRxQueue, &cIn, &xHigherPriorityTaskWoken );
N
N	} while( portINPUT_BYTE( BUFFER_COUNT ) );
N
N	// Now the buffer is empty we can switch context if necessary.
N	if( xHigherPriorityTaskWoken )
N	{
N		// Actual macro used here is port specific.
N		portYIELD_FROM_ISR ();
N	}
N }
N </pre>
N *
N * \defgroup xQueueSendFromISR xQueueSendFromISR
N * \ingroup QueueManagement
N */
N#define xQueueSendFromISR( xQueue, pvItemToQueue, pxHigherPriorityTaskWoken ) xQueueGenericSendFromISR( ( xQueue ), ( pvItemToQueue ), ( pxHigherPriorityTaskWoken ), queueSEND_TO_BACK )
N
N/**
N * queue. h
N * <pre>
N BaseType_t xQueueGenericSendFromISR(
N										   QueueHandle_t		xQueue,
N										   const	void	*pvItemToQueue,
N										   BaseType_t	*pxHigherPriorityTaskWoken,
N										   BaseType_t	xCopyPosition
N									   );
N </pre>
N *
N * It is preferred that the macros xQueueSendFromISR(),
N * xQueueSendToFrontFromISR() and xQueueSendToBackFromISR() be used in place
N * of calling this function directly.  xQueueGiveFromISR() is an
N * equivalent for use by semaphores that don't actually copy any data.
N *
N * Post an item on a queue.  It is safe to use this function from within an
N * interrupt service routine.
N *
N * Items are queued by copy not reference so it is preferable to only
N * queue small items, especially when called from an ISR.  In most cases
N * it would be preferable to store a pointer to the item being queued.
N *
N * @param xQueue The handle to the queue on which the item is to be posted.
N *
N * @param pvItemToQueue A pointer to the item that is to be placed on the
N * queue.  The size of the items the queue will hold was defined when the
N * queue was created, so this many bytes will be copied from pvItemToQueue
N * into the queue storage area.
N *
N * @param pxHigherPriorityTaskWoken xQueueGenericSendFromISR() will set
N * *pxHigherPriorityTaskWoken to pdTRUE if sending to the queue caused a task
N * to unblock, and the unblocked task has a priority higher than the currently
N * running task.  If xQueueGenericSendFromISR() sets this value to pdTRUE then
N * a context switch should be requested before the interrupt is exited.
N *
N * @param xCopyPosition Can take the value queueSEND_TO_BACK to place the
N * item at the back of the queue, or queueSEND_TO_FRONT to place the item
N * at the front of the queue (for high priority messages).
N *
N * @return pdTRUE if the data was successfully sent to the queue, otherwise
N * errQUEUE_FULL.
N *
N * Example usage for buffered IO (where the ISR can obtain more than one value
N * per call):
N   <pre>
N void vBufferISR( void )
N {
N char cIn;
N BaseType_t xHigherPriorityTaskWokenByPost;
N
N	// We have not woken a task at the start of the ISR.
N	xHigherPriorityTaskWokenByPost = pdFALSE;
N
N	// Loop until the buffer is empty.
N	do
N	{
N		// Obtain a byte from the buffer.
N		cIn = portINPUT_BYTE( RX_REGISTER_ADDRESS );
N
N		// Post each byte.
N		xQueueGenericSendFromISR( xRxQueue, &cIn, &xHigherPriorityTaskWokenByPost, queueSEND_TO_BACK );
N
N	} while( portINPUT_BYTE( BUFFER_COUNT ) );
N
N	// Now the buffer is empty we can switch context if necessary.  Note that the
N	// name of the yield function required is port specific.
N	if( xHigherPriorityTaskWokenByPost )
N	{
N		taskYIELD_YIELD_FROM_ISR();
N	}
N }
N </pre>
N *
N * \defgroup xQueueSendFromISR xQueueSendFromISR
N * \ingroup QueueManagement
N */
NBaseType_t xQueueGenericSendFromISR( QueueHandle_t xQueue, const void * const pvItemToQueue, BaseType_t * const pxHigherPriorityTaskWoken, const BaseType_t xCopyPosition ) PRIVILEGED_FUNCTION;
XBaseType_t xQueueGenericSendFromISR( QueueHandle_t xQueue, const void * const pvItemToQueue, BaseType_t * const pxHigherPriorityTaskWoken, const BaseType_t xCopyPosition ) ;
NBaseType_t xQueueGiveFromISR( QueueHandle_t xQueue, BaseType_t * const pxHigherPriorityTaskWoken ) PRIVILEGED_FUNCTION;
XBaseType_t xQueueGiveFromISR( QueueHandle_t xQueue, BaseType_t * const pxHigherPriorityTaskWoken ) ;
N
N/**
N * queue. h
N * <pre>
N BaseType_t xQueueReceiveFromISR(
N									   QueueHandle_t	xQueue,
N									   void	*pvBuffer,
N									   BaseType_t *pxTaskWoken
N								   );
N * </pre>
N *
N * Receive an item from a queue.  It is safe to use this function from within an
N * interrupt service routine.
N *
N * @param xQueue The handle to the queue from which the item is to be
N * received.
N *
N * @param pvBuffer Pointer to the buffer into which the received item will
N * be copied.
N *
N * @param pxTaskWoken A task may be blocked waiting for space to become
N * available on the queue.  If xQueueReceiveFromISR causes such a task to
N * unblock *pxTaskWoken will get set to pdTRUE, otherwise *pxTaskWoken will
N * remain unchanged.
N *
N * @return pdTRUE if an item was successfully received from the queue,
N * otherwise pdFALSE.
N *
N * Example usage:
N   <pre>
N
N QueueHandle_t xQueue;
N
N // Function to create a queue and post some values.
N void vAFunction( void *pvParameters )
N {
N char cValueToPost;
N const TickType_t xTicksToWait = ( TickType_t )0xff;
N
N	// Create a queue capable of containing 10 characters.
N	xQueue = xQueueCreate( 10, sizeof( char ) );
N	if( xQueue == 0 )
N	{
N		// Failed to create the queue.
N	}
N
N	// ...
N
N	// Post some characters that will be used within an ISR.  If the queue
N	// is full then this task will block for xTicksToWait ticks.
N	cValueToPost = 'a';
N	xQueueSend( xQueue, ( void * ) &cValueToPost, xTicksToWait );
N	cValueToPost = 'b';
N	xQueueSend( xQueue, ( void * ) &cValueToPost, xTicksToWait );
N
N	// ... keep posting characters ... this task may block when the queue
N	// becomes full.
N
N	cValueToPost = 'c';
N	xQueueSend( xQueue, ( void * ) &cValueToPost, xTicksToWait );
N }
N
N // ISR that outputs all the characters received on the queue.
N void vISR_Routine( void )
N {
N BaseType_t xTaskWokenByReceive = pdFALSE;
N char cRxedChar;
N
N	while( xQueueReceiveFromISR( xQueue, ( void * ) &cRxedChar, &xTaskWokenByReceive) )
N	{
N		// A character was received.  Output the character now.
N		vOutputCharacter( cRxedChar );
N
N		// If removing the character from the queue woke the task that was
N		// posting onto the queue cTaskWokenByReceive will have been set to
N		// pdTRUE.  No matter how many times this loop iterates only one
N		// task will be woken.
N	}
N
N	if( cTaskWokenByPost != ( char ) pdFALSE;
N	{
N		taskYIELD ();
N	}
N }
N </pre>
N * \defgroup xQueueReceiveFromISR xQueueReceiveFromISR
N * \ingroup QueueManagement
N */
NBaseType_t xQueueReceiveFromISR( QueueHandle_t xQueue, void * const pvBuffer, BaseType_t * const pxHigherPriorityTaskWoken ) PRIVILEGED_FUNCTION;
XBaseType_t xQueueReceiveFromISR( QueueHandle_t xQueue, void * const pvBuffer, BaseType_t * const pxHigherPriorityTaskWoken ) ;
N
N/*
N * Utilities to query queues that are safe to use from an ISR.  These utilities
N * should be used only from witin an ISR, or within a critical section.
N */
NBaseType_t xQueueIsQueueEmptyFromISR( const QueueHandle_t xQueue ) PRIVILEGED_FUNCTION;
XBaseType_t xQueueIsQueueEmptyFromISR( const QueueHandle_t xQueue ) ;
NBaseType_t xQueueIsQueueFullFromISR( const QueueHandle_t xQueue ) PRIVILEGED_FUNCTION;
XBaseType_t xQueueIsQueueFullFromISR( const QueueHandle_t xQueue ) ;
NUBaseType_t uxQueueMessagesWaitingFromISR( const QueueHandle_t xQueue ) PRIVILEGED_FUNCTION;
XUBaseType_t uxQueueMessagesWaitingFromISR( const QueueHandle_t xQueue ) ;
N
N/*
N * The functions defined above are for passing data to and from tasks.  The
N * functions below are the equivalents for passing data to and from
N * co-routines.
N *
N * These functions are called from the co-routine macro implementation and
N * should not be called directly from application code.  Instead use the macro
N * wrappers defined within croutine.h.
N */
NBaseType_t xQueueCRSendFromISR( QueueHandle_t xQueue, const void *pvItemToQueue, BaseType_t xCoRoutinePreviouslyWoken );
NBaseType_t xQueueCRReceiveFromISR( QueueHandle_t xQueue, void *pvBuffer, BaseType_t *pxTaskWoken );
NBaseType_t xQueueCRSend( QueueHandle_t xQueue, const void *pvItemToQueue, TickType_t xTicksToWait );
NBaseType_t xQueueCRReceive( QueueHandle_t xQueue, void *pvBuffer, TickType_t xTicksToWait );
N
N/*
N * For internal use only.  Use xSemaphoreCreateMutex(),
N * xSemaphoreCreateCounting() or xSemaphoreGetMutexHolder() instead of calling
N * these functions directly.
N */
NQueueHandle_t xQueueCreateMutex( const uint8_t ucQueueType ) PRIVILEGED_FUNCTION;
XQueueHandle_t xQueueCreateMutex( const uint8_t ucQueueType ) ;
NQueueHandle_t xQueueCreateMutexStatic( const uint8_t ucQueueType, StaticQueue_t *pxStaticQueue ) PRIVILEGED_FUNCTION;
XQueueHandle_t xQueueCreateMutexStatic( const uint8_t ucQueueType, StaticQueue_t *pxStaticQueue ) ;
NQueueHandle_t xQueueCreateCountingSemaphore( const UBaseType_t uxMaxCount, const UBaseType_t uxInitialCount ) PRIVILEGED_FUNCTION;
XQueueHandle_t xQueueCreateCountingSemaphore( const UBaseType_t uxMaxCount, const UBaseType_t uxInitialCount ) ;
NQueueHandle_t xQueueCreateCountingSemaphoreStatic( const UBaseType_t uxMaxCount, const UBaseType_t uxInitialCount, StaticQueue_t *pxStaticQueue ) PRIVILEGED_FUNCTION;
XQueueHandle_t xQueueCreateCountingSemaphoreStatic( const UBaseType_t uxMaxCount, const UBaseType_t uxInitialCount, StaticQueue_t *pxStaticQueue ) ;
Nvoid* xQueueGetMutexHolder( QueueHandle_t xSemaphore ) PRIVILEGED_FUNCTION;
Xvoid* xQueueGetMutexHolder( QueueHandle_t xSemaphore ) ;
N
N/*
N * For internal use only.  Use xSemaphoreTakeMutexRecursive() or
N * xSemaphoreGiveMutexRecursive() instead of calling these functions directly.
N */
NBaseType_t xQueueTakeMutexRecursive( QueueHandle_t xMutex, TickType_t xTicksToWait ) PRIVILEGED_FUNCTION;
XBaseType_t xQueueTakeMutexRecursive( QueueHandle_t xMutex, TickType_t xTicksToWait ) ;
NBaseType_t xQueueGiveMutexRecursive( QueueHandle_t pxMutex ) PRIVILEGED_FUNCTION;
XBaseType_t xQueueGiveMutexRecursive( QueueHandle_t pxMutex ) ;
N
N/*
N * Reset a queue back to its original empty state.  The return value is now
N * obsolete and is always set to pdPASS.
N */
N#define xQueueReset( xQueue ) xQueueGenericReset( xQueue, pdFALSE )
N
N/*
N * The registry is provided as a means for kernel aware debuggers to
N * locate queues, semaphores and mutexes.  Call vQueueAddToRegistry() add
N * a queue, semaphore or mutex handle to the registry if you want the handle
N * to be available to a kernel aware debugger.  If you are not using a kernel
N * aware debugger then this function can be ignored.
N *
N * configQUEUE_REGISTRY_SIZE defines the maximum number of handles the
N * registry can hold.  configQUEUE_REGISTRY_SIZE must be greater than 0
N * within FreeRTOSConfig.h for the registry to be available.  Its value
N * does not effect the number of queues, semaphores and mutexes that can be
N * created - just the number that the registry can hold.
N *
N * @param xQueue The handle of the queue being added to the registry.  This
N * is the handle returned by a call to xQueueCreate().  Semaphore and mutex
N * handles can also be passed in here.
N *
N * @param pcName The name to be associated with the handle.  This is the
N * name that the kernel aware debugger will display.  The queue registry only
N * stores a pointer to the string - so the string must be persistent (global or
N * preferably in ROM/Flash), not on the stack.
N */
N#if( configQUEUE_REGISTRY_SIZE > 0 )
X#if( 10 > 0 )
N	void vQueueAddToRegistry( QueueHandle_t xQueue, const char *pcName ) PRIVILEGED_FUNCTION; /*lint !e971 Unqualified char types are allowed for strings and single characters only. */
X	void vQueueAddToRegistry( QueueHandle_t xQueue, const char *pcName ) ;  
N#endif
N
N/*
N * The registry is provided as a means for kernel aware debuggers to
N * locate queues, semaphores and mutexes.  Call vQueueAddToRegistry() add
N * a queue, semaphore or mutex handle to the registry if you want the handle
N * to be available to a kernel aware debugger, and vQueueUnregisterQueue() to
N * remove the queue, semaphore or mutex from the register.  If you are not using
N * a kernel aware debugger then this function can be ignored.
N *
N * @param xQueue The handle of the queue being removed from the registry.
N */
N#if( configQUEUE_REGISTRY_SIZE > 0 )
X#if( 10 > 0 )
N	void vQueueUnregisterQueue( QueueHandle_t xQueue ) PRIVILEGED_FUNCTION;
X	void vQueueUnregisterQueue( QueueHandle_t xQueue ) ;
N#endif
N
N/*
N * The queue registry is provided as a means for kernel aware debuggers to
N * locate queues, semaphores and mutexes.  Call pcQueueGetName() to look
N * up and return the name of a queue in the queue registry from the queue's
N * handle.
N *
N * @param xQueue The handle of the queue the name of which will be returned.
N * @return If the queue is in the registry then a pointer to the name of the
N * queue is returned.  If the queue is not in the registry then NULL is
N * returned.
N */
N#if( configQUEUE_REGISTRY_SIZE > 0 )
X#if( 10 > 0 )
N	const char *pcQueueGetName( QueueHandle_t xQueue ) PRIVILEGED_FUNCTION; /*lint !e971 Unqualified char types are allowed for strings and single characters only. */
X	const char *pcQueueGetName( QueueHandle_t xQueue ) ;  
N#endif
N
N/*
N * Generic version of the function used to creaet a queue using dynamic memory
N * allocation.  This is called by other functions and macros that create other
N * RTOS objects that use the queue structure as their base.
N */
N#if( configSUPPORT_DYNAMIC_ALLOCATION == 1 )
X#if( 1 == 1 )
N	QueueHandle_t xQueueGenericCreate( const UBaseType_t uxQueueLength, const UBaseType_t uxItemSize, const uint8_t ucQueueType ) PRIVILEGED_FUNCTION;
X	QueueHandle_t xQueueGenericCreate( const UBaseType_t uxQueueLength, const UBaseType_t uxItemSize, const uint8_t ucQueueType ) ;
N#endif
N
N/*
N * Generic version of the function used to creaet a queue using dynamic memory
N * allocation.  This is called by other functions and macros that create other
N * RTOS objects that use the queue structure as their base.
N */
N#if( configSUPPORT_STATIC_ALLOCATION == 1 )
X#if( 0 == 1 )
S	QueueHandle_t xQueueGenericCreateStatic( const UBaseType_t uxQueueLength, const UBaseType_t uxItemSize, uint8_t *pucQueueStorage, StaticQueue_t *pxStaticQueue, const uint8_t ucQueueType ) PRIVILEGED_FUNCTION;
N#endif
N
N/*
N * Queue sets provide a mechanism to allow a task to block (pend) on a read
N * operation from multiple queues or semaphores simultaneously.
N *
N * See FreeRTOS/Source/Demo/Common/Minimal/QueueSet.c for an example using this
N * function.
N *
N * A queue set must be explicitly created using a call to xQueueCreateSet()
N * before it can be used.  Once created, standard FreeRTOS queues and semaphores
N * can be added to the set using calls to xQueueAddToSet().
N * xQueueSelectFromSet() is then used to determine which, if any, of the queues
N * or semaphores contained in the set is in a state where a queue read or
N * semaphore take operation would be successful.
N *
N * Note 1:  See the documentation on http://wwwFreeRTOS.org/RTOS-queue-sets.html
N * for reasons why queue sets are very rarely needed in practice as there are
N * simpler methods of blocking on multiple objects.
N *
N * Note 2:  Blocking on a queue set that contains a mutex will not cause the
N * mutex holder to inherit the priority of the blocked task.
N *
N * Note 3:  An additional 4 bytes of RAM is required for each space in a every
N * queue added to a queue set.  Therefore counting semaphores that have a high
N * maximum count value should not be added to a queue set.
N *
N * Note 4:  A receive (in the case of a queue) or take (in the case of a
N * semaphore) operation must not be performed on a member of a queue set unless
N * a call to xQueueSelectFromSet() has first returned a handle to that set member.
N *
N * @param uxEventQueueLength Queue sets store events that occur on
N * the queues and semaphores contained in the set.  uxEventQueueLength specifies
N * the maximum number of events that can be queued at once.  To be absolutely
N * certain that events are not lost uxEventQueueLength should be set to the
N * total sum of the length of the queues added to the set, where binary
N * semaphores and mutexes have a length of 1, and counting semaphores have a
N * length set by their maximum count value.  Examples:
N *  + If a queue set is to hold a queue of length 5, another queue of length 12,
N *    and a binary semaphore, then uxEventQueueLength should be set to
N *    (5 + 12 + 1), or 18.
N *  + If a queue set is to hold three binary semaphores then uxEventQueueLength
N *    should be set to (1 + 1 + 1 ), or 3.
N *  + If a queue set is to hold a counting semaphore that has a maximum count of
N *    5, and a counting semaphore that has a maximum count of 3, then
N *    uxEventQueueLength should be set to (5 + 3), or 8.
N *
N * @return If the queue set is created successfully then a handle to the created
N * queue set is returned.  Otherwise NULL is returned.
N */
NQueueSetHandle_t xQueueCreateSet( const UBaseType_t uxEventQueueLength ) PRIVILEGED_FUNCTION;
XQueueSetHandle_t xQueueCreateSet( const UBaseType_t uxEventQueueLength ) ;
N
N/*
N * Adds a queue or semaphore to a queue set that was previously created by a
N * call to xQueueCreateSet().
N *
N * See FreeRTOS/Source/Demo/Common/Minimal/QueueSet.c for an example using this
N * function.
N *
N * Note 1:  A receive (in the case of a queue) or take (in the case of a
N * semaphore) operation must not be performed on a member of a queue set unless
N * a call to xQueueSelectFromSet() has first returned a handle to that set member.
N *
N * @param xQueueOrSemaphore The handle of the queue or semaphore being added to
N * the queue set (cast to an QueueSetMemberHandle_t type).
N *
N * @param xQueueSet The handle of the queue set to which the queue or semaphore
N * is being added.
N *
N * @return If the queue or semaphore was successfully added to the queue set
N * then pdPASS is returned.  If the queue could not be successfully added to the
N * queue set because it is already a member of a different queue set then pdFAIL
N * is returned.
N */
NBaseType_t xQueueAddToSet( QueueSetMemberHandle_t xQueueOrSemaphore, QueueSetHandle_t xQueueSet ) PRIVILEGED_FUNCTION;
XBaseType_t xQueueAddToSet( QueueSetMemberHandle_t xQueueOrSemaphore, QueueSetHandle_t xQueueSet ) ;
N
N/*
N * Removes a queue or semaphore from a queue set.  A queue or semaphore can only
N * be removed from a set if the queue or semaphore is empty.
N *
N * See FreeRTOS/Source/Demo/Common/Minimal/QueueSet.c for an example using this
N * function.
N *
N * @param xQueueOrSemaphore The handle of the queue or semaphore being removed
N * from the queue set (cast to an QueueSetMemberHandle_t type).
N *
N * @param xQueueSet The handle of the queue set in which the queue or semaphore
N * is included.
N *
N * @return If the queue or semaphore was successfully removed from the queue set
N * then pdPASS is returned.  If the queue was not in the queue set, or the
N * queue (or semaphore) was not empty, then pdFAIL is returned.
N */
NBaseType_t xQueueRemoveFromSet( QueueSetMemberHandle_t xQueueOrSemaphore, QueueSetHandle_t xQueueSet ) PRIVILEGED_FUNCTION;
XBaseType_t xQueueRemoveFromSet( QueueSetMemberHandle_t xQueueOrSemaphore, QueueSetHandle_t xQueueSet ) ;
N
N/*
N * xQueueSelectFromSet() selects from the members of a queue set a queue or
N * semaphore that either contains data (in the case of a queue) or is available
N * to take (in the case of a semaphore).  xQueueSelectFromSet() effectively
N * allows a task to block (pend) on a read operation on all the queues and
N * semaphores in a queue set simultaneously.
N *
N * See FreeRTOS/Source/Demo/Common/Minimal/QueueSet.c for an example using this
N * function.
N *
N * Note 1:  See the documentation on http://wwwFreeRTOS.org/RTOS-queue-sets.html
N * for reasons why queue sets are very rarely needed in practice as there are
N * simpler methods of blocking on multiple objects.
N *
N * Note 2:  Blocking on a queue set that contains a mutex will not cause the
N * mutex holder to inherit the priority of the blocked task.
N *
N * Note 3:  A receive (in the case of a queue) or take (in the case of a
N * semaphore) operation must not be performed on a member of a queue set unless
N * a call to xQueueSelectFromSet() has first returned a handle to that set member.
N *
N * @param xQueueSet The queue set on which the task will (potentially) block.
N *
N * @param xTicksToWait The maximum time, in ticks, that the calling task will
N * remain in the Blocked state (with other tasks executing) to wait for a member
N * of the queue set to be ready for a successful queue read or semaphore take
N * operation.
N *
N * @return xQueueSelectFromSet() will return the handle of a queue (cast to
N * a QueueSetMemberHandle_t type) contained in the queue set that contains data,
N * or the handle of a semaphore (cast to a QueueSetMemberHandle_t type) contained
N * in the queue set that is available, or NULL if no such queue or semaphore
N * exists before before the specified block time expires.
N */
NQueueSetMemberHandle_t xQueueSelectFromSet( QueueSetHandle_t xQueueSet, const TickType_t xTicksToWait ) PRIVILEGED_FUNCTION;
XQueueSetMemberHandle_t xQueueSelectFromSet( QueueSetHandle_t xQueueSet, const TickType_t xTicksToWait ) ;
N
N/*
N * A version of xQueueSelectFromSet() that can be used from an ISR.
N */
NQueueSetMemberHandle_t xQueueSelectFromSetFromISR( QueueSetHandle_t xQueueSet ) PRIVILEGED_FUNCTION;
XQueueSetMemberHandle_t xQueueSelectFromSetFromISR( QueueSetHandle_t xQueueSet ) ;
N
N/* Not public API functions. */
Nvoid vQueueWaitForMessageRestricted( QueueHandle_t xQueue, TickType_t xTicksToWait, const BaseType_t xWaitIndefinitely ) PRIVILEGED_FUNCTION;
Xvoid vQueueWaitForMessageRestricted( QueueHandle_t xQueue, TickType_t xTicksToWait, const BaseType_t xWaitIndefinitely ) ;
NBaseType_t xQueueGenericReset( QueueHandle_t xQueue, BaseType_t xNewQueue ) PRIVILEGED_FUNCTION;
XBaseType_t xQueueGenericReset( QueueHandle_t xQueue, BaseType_t xNewQueue ) ;
Nvoid vQueueSetQueueNumber( QueueHandle_t xQueue, UBaseType_t uxQueueNumber ) PRIVILEGED_FUNCTION;
Xvoid vQueueSetQueueNumber( QueueHandle_t xQueue, UBaseType_t uxQueueNumber ) ;
NUBaseType_t uxQueueGetQueueNumber( QueueHandle_t xQueue ) PRIVILEGED_FUNCTION;
XUBaseType_t uxQueueGetQueueNumber( QueueHandle_t xQueue ) ;
Nuint8_t ucQueueGetQueueType( QueueHandle_t xQueue ) PRIVILEGED_FUNCTION;
Xuint8_t ucQueueGetQueueType( QueueHandle_t xQueue ) ;
N
N
N#ifdef __cplusplus
S}
N#endif
N
N#endif /* QUEUE_H */
N
L 28 "adc.c" 2
N#include "semphr.h"
L 1 ".\rtos\include\semphr.h" 1
N/*
N    FreeRTOS V9.0.0 - Copyright (C) 2016 Real Time Engineers Ltd.
N    All rights reserved
N
N    VISIT http://www.FreeRTOS.org TO ENSURE YOU ARE USING THE LATEST VERSION.
N
N    This file is part of the FreeRTOS distribution.
N
N    FreeRTOS is free software; you can redistribute it and/or modify it under
N    the terms of the GNU General Public License (version 2) as published by the
N    Free Software Foundation >>>> AND MODIFIED BY <<<< the FreeRTOS exception.
N
N    ***************************************************************************
N    >>!   NOTE: The modification to the GPL is included to allow you to     !<<
N    >>!   distribute a combined work that includes FreeRTOS without being   !<<
N    >>!   obliged to provide the source code for proprietary components     !<<
N    >>!   outside of the FreeRTOS kernel.                                   !<<
N    ***************************************************************************
N
N    FreeRTOS is distributed in the hope that it will be useful, but WITHOUT ANY
N    WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
N    FOR A PARTICULAR PURPOSE.  Full license text is available on the following
N    link: http://www.freertos.org/a00114.html
N
N    ***************************************************************************
N     *                                                                       *
N     *    FreeRTOS provides completely free yet professionally developed,    *
N     *    robust, strictly quality controlled, supported, and cross          *
N     *    platform software that is more than just the market leader, it     *
N     *    is the industry's de facto standard.                               *
N     *                                                                       *
N     *    Help yourself get started quickly while simultaneously helping     *
N     *    to support the FreeRTOS project by purchasing a FreeRTOS           *
N     *    tutorial book, reference manual, or both:                          *
N     *    http://www.FreeRTOS.org/Documentation                              *
N     *                                                                       *
N    ***************************************************************************
N
N    http://www.FreeRTOS.org/FAQHelp.html - Having a problem?  Start by reading
N    the FAQ page "My application does not run, what could be wrong?".  Have you
N    defined configASSERT()?
N
N    http://www.FreeRTOS.org/support - In return for receiving this top quality
N    embedded software for free we request you assist our global community by
N    participating in the support forum.
N
N    http://www.FreeRTOS.org/training - Investing in training allows your team to
N    be as productive as possible as early as possible.  Now you can receive
N    FreeRTOS training directly from Richard Barry, CEO of Real Time Engineers
N    Ltd, and the world's leading authority on the world's leading RTOS.
N
N    http://www.FreeRTOS.org/plus - A selection of FreeRTOS ecosystem products,
N    including FreeRTOS+Trace - an indispensable productivity tool, a DOS
N    compatible FAT file system, and our tiny thread aware UDP/IP stack.
N
N    http://www.FreeRTOS.org/labs - Where new FreeRTOS products go to incubate.
N    Come and try FreeRTOS+TCP, our new open source TCP/IP stack for FreeRTOS.
N
N    http://www.OpenRTOS.com - Real Time Engineers ltd. license FreeRTOS to High
N    Integrity Systems ltd. to sell under the OpenRTOS brand.  Low cost OpenRTOS
N    licenses offer ticketed support, indemnification and commercial middleware.
N
N    http://www.SafeRTOS.com - High Integrity Systems also provide a safety
N    engineered and independently SIL3 certified version for use in safety and
N    mission critical applications that require provable dependability.
N
N    1 tab == 4 spaces!
N*/
N
N#ifndef SEMAPHORE_H
N#define SEMAPHORE_H
N
N#ifndef INC_FREERTOS_H
S	#error "include FreeRTOS.h" must appear in source files before "include semphr.h"
N#endif
N
N#include "queue.h"
N
Ntypedef QueueHandle_t SemaphoreHandle_t;
Ntypedef QueueHandle_t xSemaphoreHandle;
N#define semBINARY_SEMAPHORE_QUEUE_LENGTH	( ( uint8_t ) 1U )
N#define semSEMAPHORE_QUEUE_ITEM_LENGTH		( ( uint8_t ) 0U )
N#define semGIVE_BLOCK_TIME					( ( TickType_t ) 0U )
N
N
N/**
N * semphr. h
N * <pre>vSemaphoreCreateBinary( SemaphoreHandle_t xSemaphore )</pre>
N *
N * In many usage scenarios it is faster and more memory efficient to use a
N * direct to task notification in place of a binary semaphore!
N * http://www.freertos.org/RTOS-task-notifications.html
N *
N * This old vSemaphoreCreateBinary() macro is now deprecated in favour of the
N * xSemaphoreCreateBinary() function.  Note that binary semaphores created using
N * the vSemaphoreCreateBinary() macro are created in a state such that the
N * first call to 'take' the semaphore would pass, whereas binary semaphores
N * created using xSemaphoreCreateBinary() are created in a state such that the
N * the semaphore must first be 'given' before it can be 'taken'.
N *
N * <i>Macro</i> that implements a semaphore by using the existing queue mechanism.
N * The queue length is 1 as this is a binary semaphore.  The data size is 0
N * as we don't want to actually store any data - we just want to know if the
N * queue is empty or full.
N *
N * This type of semaphore can be used for pure synchronisation between tasks or
N * between an interrupt and a task.  The semaphore need not be given back once
N * obtained, so one task/interrupt can continuously 'give' the semaphore while
N * another continuously 'takes' the semaphore.  For this reason this type of
N * semaphore does not use a priority inheritance mechanism.  For an alternative
N * that does use priority inheritance see xSemaphoreCreateMutex().
N *
N * @param xSemaphore Handle to the created semaphore.  Should be of type SemaphoreHandle_t.
N *
N * Example usage:
N <pre>
N SemaphoreHandle_t xSemaphore = NULL;
N
N void vATask( void * pvParameters )
N {
N    // Semaphore cannot be used before a call to vSemaphoreCreateBinary ().
N    // This is a macro so pass the variable in directly.
N    vSemaphoreCreateBinary( xSemaphore );
N
N    if( xSemaphore != NULL )
N    {
N        // The semaphore was created successfully.
N        // The semaphore can now be used.
N    }
N }
N </pre>
N * \defgroup vSemaphoreCreateBinary vSemaphoreCreateBinary
N * \ingroup Semaphores
N */
N#if( configSUPPORT_DYNAMIC_ALLOCATION == 1 )
X#if( 1 == 1 )
N	#define vSemaphoreCreateBinary( xSemaphore )																							\
N		{																																	\
N			( xSemaphore ) = xQueueGenericCreate( ( UBaseType_t ) 1, semSEMAPHORE_QUEUE_ITEM_LENGTH, queueQUEUE_TYPE_BINARY_SEMAPHORE );	\
N			if( ( xSemaphore ) != NULL )																									\
N			{																																\
N				( void ) xSemaphoreGive( ( xSemaphore ) );																					\
N			}																																\
N		}
X	#define vSemaphoreCreateBinary( xSemaphore )																									{																																				( xSemaphore ) = xQueueGenericCreate( ( UBaseType_t ) 1, semSEMAPHORE_QUEUE_ITEM_LENGTH, queueQUEUE_TYPE_BINARY_SEMAPHORE );				if( ( xSemaphore ) != NULL )																												{																																				( void ) xSemaphoreGive( ( xSemaphore ) );																								}																																		}
N#endif
N
N/**
N * semphr. h
N * <pre>SemaphoreHandle_t xSemaphoreCreateBinary( void )</pre>
N *
N * Creates a new binary semaphore instance, and returns a handle by which the
N * new semaphore can be referenced.
N *
N * In many usage scenarios it is faster and more memory efficient to use a
N * direct to task notification in place of a binary semaphore!
N * http://www.freertos.org/RTOS-task-notifications.html
N *
N * Internally, within the FreeRTOS implementation, binary semaphores use a block
N * of memory, in which the semaphore structure is stored.  If a binary semaphore
N * is created using xSemaphoreCreateBinary() then the required memory is
N * automatically dynamically allocated inside the xSemaphoreCreateBinary()
N * function.  (see http://www.freertos.org/a00111.html).  If a binary semaphore
N * is created using xSemaphoreCreateBinaryStatic() then the application writer
N * must provide the memory.  xSemaphoreCreateBinaryStatic() therefore allows a
N * binary semaphore to be created without using any dynamic memory allocation.
N *
N * The old vSemaphoreCreateBinary() macro is now deprecated in favour of this
N * xSemaphoreCreateBinary() function.  Note that binary semaphores created using
N * the vSemaphoreCreateBinary() macro are created in a state such that the
N * first call to 'take' the semaphore would pass, whereas binary semaphores
N * created using xSemaphoreCreateBinary() are created in a state such that the
N * the semaphore must first be 'given' before it can be 'taken'.
N *
N * This type of semaphore can be used for pure synchronisation between tasks or
N * between an interrupt and a task.  The semaphore need not be given back once
N * obtained, so one task/interrupt can continuously 'give' the semaphore while
N * another continuously 'takes' the semaphore.  For this reason this type of
N * semaphore does not use a priority inheritance mechanism.  For an alternative
N * that does use priority inheritance see xSemaphoreCreateMutex().
N *
N * @return Handle to the created semaphore, or NULL if the memory required to
N * hold the semaphore's data structures could not be allocated.
N *
N * Example usage:
N <pre>
N SemaphoreHandle_t xSemaphore = NULL;
N
N void vATask( void * pvParameters )
N {
N    // Semaphore cannot be used before a call to xSemaphoreCreateBinary().
N    // This is a macro so pass the variable in directly.
N    xSemaphore = xSemaphoreCreateBinary();
N
N    if( xSemaphore != NULL )
N    {
N        // The semaphore was created successfully.
N        // The semaphore can now be used.
N    }
N }
N </pre>
N * \defgroup xSemaphoreCreateBinary xSemaphoreCreateBinary
N * \ingroup Semaphores
N */
N#if( configSUPPORT_DYNAMIC_ALLOCATION == 1 )
X#if( 1 == 1 )
N	#define xSemaphoreCreateBinary() xQueueGenericCreate( ( UBaseType_t ) 1, semSEMAPHORE_QUEUE_ITEM_LENGTH, queueQUEUE_TYPE_BINARY_SEMAPHORE )
N#endif
N
N/**
N * semphr. h
N * <pre>SemaphoreHandle_t xSemaphoreCreateBinaryStatic( StaticSemaphore_t *pxSemaphoreBuffer )</pre>
N *
N * Creates a new binary semaphore instance, and returns a handle by which the
N * new semaphore can be referenced.
N *
N * NOTE: In many usage scenarios it is faster and more memory efficient to use a
N * direct to task notification in place of a binary semaphore!
N * http://www.freertos.org/RTOS-task-notifications.html
N *
N * Internally, within the FreeRTOS implementation, binary semaphores use a block
N * of memory, in which the semaphore structure is stored.  If a binary semaphore
N * is created using xSemaphoreCreateBinary() then the required memory is
N * automatically dynamically allocated inside the xSemaphoreCreateBinary()
N * function.  (see http://www.freertos.org/a00111.html).  If a binary semaphore
N * is created using xSemaphoreCreateBinaryStatic() then the application writer
N * must provide the memory.  xSemaphoreCreateBinaryStatic() therefore allows a
N * binary semaphore to be created without using any dynamic memory allocation.
N *
N * This type of semaphore can be used for pure synchronisation between tasks or
N * between an interrupt and a task.  The semaphore need not be given back once
N * obtained, so one task/interrupt can continuously 'give' the semaphore while
N * another continuously 'takes' the semaphore.  For this reason this type of
N * semaphore does not use a priority inheritance mechanism.  For an alternative
N * that does use priority inheritance see xSemaphoreCreateMutex().
N *
N * @param pxSemaphoreBuffer Must point to a variable of type StaticSemaphore_t,
N * which will then be used to hold the semaphore's data structure, removing the
N * need for the memory to be allocated dynamically.
N *
N * @return If the semaphore is created then a handle to the created semaphore is
N * returned.  If pxSemaphoreBuffer is NULL then NULL is returned.
N *
N * Example usage:
N <pre>
N SemaphoreHandle_t xSemaphore = NULL;
N StaticSemaphore_t xSemaphoreBuffer;
N
N void vATask( void * pvParameters )
N {
N    // Semaphore cannot be used before a call to xSemaphoreCreateBinary().
N    // The semaphore's data structures will be placed in the xSemaphoreBuffer
N    // variable, the address of which is passed into the function.  The
N    // function's parameter is not NULL, so the function will not attempt any
N    // dynamic memory allocation, and therefore the function will not return
N    // return NULL.
N    xSemaphore = xSemaphoreCreateBinary( &xSemaphoreBuffer );
N
N    // Rest of task code goes here.
N }
N </pre>
N * \defgroup xSemaphoreCreateBinaryStatic xSemaphoreCreateBinaryStatic
N * \ingroup Semaphores
N */
N#if( configSUPPORT_STATIC_ALLOCATION == 1 )
X#if( 0 == 1 )
S	#define xSemaphoreCreateBinaryStatic( pxStaticSemaphore ) xQueueGenericCreateStatic( ( UBaseType_t ) 1, semSEMAPHORE_QUEUE_ITEM_LENGTH, NULL, pxStaticSemaphore, queueQUEUE_TYPE_BINARY_SEMAPHORE )
N#endif /* configSUPPORT_STATIC_ALLOCATION */
N
N/**
N * semphr. h
N * <pre>xSemaphoreTake(
N *                   SemaphoreHandle_t xSemaphore,
N *                   TickType_t xBlockTime
N *               )</pre>
N *
N * <i>Macro</i> to obtain a semaphore.  The semaphore must have previously been
N * created with a call to xSemaphoreCreateBinary(), xSemaphoreCreateMutex() or
N * xSemaphoreCreateCounting().
N *
N * @param xSemaphore A handle to the semaphore being taken - obtained when
N * the semaphore was created.
N *
N * @param xBlockTime The time in ticks to wait for the semaphore to become
N * available.  The macro portTICK_PERIOD_MS can be used to convert this to a
N * real time.  A block time of zero can be used to poll the semaphore.  A block
N * time of portMAX_DELAY can be used to block indefinitely (provided
N * INCLUDE_vTaskSuspend is set to 1 in FreeRTOSConfig.h).
N *
N * @return pdTRUE if the semaphore was obtained.  pdFALSE
N * if xBlockTime expired without the semaphore becoming available.
N *
N * Example usage:
N <pre>
N SemaphoreHandle_t xSemaphore = NULL;
N
N // A task that creates a semaphore.
N void vATask( void * pvParameters )
N {
N    // Create the semaphore to guard a shared resource.
N    xSemaphore = xSemaphoreCreateBinary();
N }
N
N // A task that uses the semaphore.
N void vAnotherTask( void * pvParameters )
N {
N    // ... Do other things.
N
N    if( xSemaphore != NULL )
N    {
N        // See if we can obtain the semaphore.  If the semaphore is not available
N        // wait 10 ticks to see if it becomes free.
N        if( xSemaphoreTake( xSemaphore, ( TickType_t ) 10 ) == pdTRUE )
N        {
N            // We were able to obtain the semaphore and can now access the
N            // shared resource.
N
N            // ...
N
N            // We have finished accessing the shared resource.  Release the
N            // semaphore.
N            xSemaphoreGive( xSemaphore );
N        }
N        else
N        {
N            // We could not obtain the semaphore and can therefore not access
N            // the shared resource safely.
N        }
N    }
N }
N </pre>
N * \defgroup xSemaphoreTake xSemaphoreTake
N * \ingroup Semaphores
N */
N#define xSemaphoreTake( xSemaphore, xBlockTime )		xQueueGenericReceive( ( QueueHandle_t ) ( xSemaphore ), NULL, ( xBlockTime ), pdFALSE )
N
N/**
N * semphr. h
N * xSemaphoreTakeRecursive(
N *                          SemaphoreHandle_t xMutex,
N *                          TickType_t xBlockTime
N *                        )
N *
N * <i>Macro</i> to recursively obtain, or 'take', a mutex type semaphore.
N * The mutex must have previously been created using a call to
N * xSemaphoreCreateRecursiveMutex();
N *
N * configUSE_RECURSIVE_MUTEXES must be set to 1 in FreeRTOSConfig.h for this
N * macro to be available.
N *
N * This macro must not be used on mutexes created using xSemaphoreCreateMutex().
N *
N * A mutex used recursively can be 'taken' repeatedly by the owner. The mutex
N * doesn't become available again until the owner has called
N * xSemaphoreGiveRecursive() for each successful 'take' request.  For example,
N * if a task successfully 'takes' the same mutex 5 times then the mutex will
N * not be available to any other task until it has also  'given' the mutex back
N * exactly five times.
N *
N * @param xMutex A handle to the mutex being obtained.  This is the
N * handle returned by xSemaphoreCreateRecursiveMutex();
N *
N * @param xBlockTime The time in ticks to wait for the semaphore to become
N * available.  The macro portTICK_PERIOD_MS can be used to convert this to a
N * real time.  A block time of zero can be used to poll the semaphore.  If
N * the task already owns the semaphore then xSemaphoreTakeRecursive() will
N * return immediately no matter what the value of xBlockTime.
N *
N * @return pdTRUE if the semaphore was obtained.  pdFALSE if xBlockTime
N * expired without the semaphore becoming available.
N *
N * Example usage:
N <pre>
N SemaphoreHandle_t xMutex = NULL;
N
N // A task that creates a mutex.
N void vATask( void * pvParameters )
N {
N    // Create the mutex to guard a shared resource.
N    xMutex = xSemaphoreCreateRecursiveMutex();
N }
N
N // A task that uses the mutex.
N void vAnotherTask( void * pvParameters )
N {
N    // ... Do other things.
N
N    if( xMutex != NULL )
N    {
N        // See if we can obtain the mutex.  If the mutex is not available
N        // wait 10 ticks to see if it becomes free.
N        if( xSemaphoreTakeRecursive( xSemaphore, ( TickType_t ) 10 ) == pdTRUE )
N        {
N            // We were able to obtain the mutex and can now access the
N            // shared resource.
N
N            // ...
N            // For some reason due to the nature of the code further calls to
N			// xSemaphoreTakeRecursive() are made on the same mutex.  In real
N			// code these would not be just sequential calls as this would make
N			// no sense.  Instead the calls are likely to be buried inside
N			// a more complex call structure.
N            xSemaphoreTakeRecursive( xMutex, ( TickType_t ) 10 );
N            xSemaphoreTakeRecursive( xMutex, ( TickType_t ) 10 );
N
N            // The mutex has now been 'taken' three times, so will not be
N			// available to another task until it has also been given back
N			// three times.  Again it is unlikely that real code would have
N			// these calls sequentially, but instead buried in a more complex
N			// call structure.  This is just for illustrative purposes.
N            xSemaphoreGiveRecursive( xMutex );
N			xSemaphoreGiveRecursive( xMutex );
N			xSemaphoreGiveRecursive( xMutex );
N
N			// Now the mutex can be taken by other tasks.
N        }
N        else
N        {
N            // We could not obtain the mutex and can therefore not access
N            // the shared resource safely.
N        }
N    }
N }
N </pre>
N * \defgroup xSemaphoreTakeRecursive xSemaphoreTakeRecursive
N * \ingroup Semaphores
N */
N#if( configUSE_RECURSIVE_MUTEXES == 1 )
X#if( 1 == 1 )
N	#define xSemaphoreTakeRecursive( xMutex, xBlockTime )	xQueueTakeMutexRecursive( ( xMutex ), ( xBlockTime ) )
N#endif
N
N/**
N * semphr. h
N * <pre>xSemaphoreGive( SemaphoreHandle_t xSemaphore )</pre>
N *
N * <i>Macro</i> to release a semaphore.  The semaphore must have previously been
N * created with a call to xSemaphoreCreateBinary(), xSemaphoreCreateMutex() or
N * xSemaphoreCreateCounting(). and obtained using sSemaphoreTake().
N *
N * This macro must not be used from an ISR.  See xSemaphoreGiveFromISR () for
N * an alternative which can be used from an ISR.
N *
N * This macro must also not be used on semaphores created using
N * xSemaphoreCreateRecursiveMutex().
N *
N * @param xSemaphore A handle to the semaphore being released.  This is the
N * handle returned when the semaphore was created.
N *
N * @return pdTRUE if the semaphore was released.  pdFALSE if an error occurred.
N * Semaphores are implemented using queues.  An error can occur if there is
N * no space on the queue to post a message - indicating that the
N * semaphore was not first obtained correctly.
N *
N * Example usage:
N <pre>
N SemaphoreHandle_t xSemaphore = NULL;
N
N void vATask( void * pvParameters )
N {
N    // Create the semaphore to guard a shared resource.
N    xSemaphore = vSemaphoreCreateBinary();
N
N    if( xSemaphore != NULL )
N    {
N        if( xSemaphoreGive( xSemaphore ) != pdTRUE )
N        {
N            // We would expect this call to fail because we cannot give
N            // a semaphore without first "taking" it!
N        }
N
N        // Obtain the semaphore - don't block if the semaphore is not
N        // immediately available.
N        if( xSemaphoreTake( xSemaphore, ( TickType_t ) 0 ) )
N        {
N            // We now have the semaphore and can access the shared resource.
N
N            // ...
N
N            // We have finished accessing the shared resource so can free the
N            // semaphore.
N            if( xSemaphoreGive( xSemaphore ) != pdTRUE )
N            {
N                // We would not expect this call to fail because we must have
N                // obtained the semaphore to get here.
N            }
N        }
N    }
N }
N </pre>
N * \defgroup xSemaphoreGive xSemaphoreGive
N * \ingroup Semaphores
N */
N#define xSemaphoreGive( xSemaphore )		xQueueGenericSend( ( QueueHandle_t ) ( xSemaphore ), NULL, semGIVE_BLOCK_TIME, queueSEND_TO_BACK )
N
N/**
N * semphr. h
N * <pre>xSemaphoreGiveRecursive( SemaphoreHandle_t xMutex )</pre>
N *
N * <i>Macro</i> to recursively release, or 'give', a mutex type semaphore.
N * The mutex must have previously been created using a call to
N * xSemaphoreCreateRecursiveMutex();
N *
N * configUSE_RECURSIVE_MUTEXES must be set to 1 in FreeRTOSConfig.h for this
N * macro to be available.
N *
N * This macro must not be used on mutexes created using xSemaphoreCreateMutex().
N *
N * A mutex used recursively can be 'taken' repeatedly by the owner. The mutex
N * doesn't become available again until the owner has called
N * xSemaphoreGiveRecursive() for each successful 'take' request.  For example,
N * if a task successfully 'takes' the same mutex 5 times then the mutex will
N * not be available to any other task until it has also  'given' the mutex back
N * exactly five times.
N *
N * @param xMutex A handle to the mutex being released, or 'given'.  This is the
N * handle returned by xSemaphoreCreateMutex();
N *
N * @return pdTRUE if the semaphore was given.
N *
N * Example usage:
N <pre>
N SemaphoreHandle_t xMutex = NULL;
N
N // A task that creates a mutex.
N void vATask( void * pvParameters )
N {
N    // Create the mutex to guard a shared resource.
N    xMutex = xSemaphoreCreateRecursiveMutex();
N }
N
N // A task that uses the mutex.
N void vAnotherTask( void * pvParameters )
N {
N    // ... Do other things.
N
N    if( xMutex != NULL )
N    {
N        // See if we can obtain the mutex.  If the mutex is not available
N        // wait 10 ticks to see if it becomes free.
N        if( xSemaphoreTakeRecursive( xMutex, ( TickType_t ) 10 ) == pdTRUE )
N        {
N            // We were able to obtain the mutex and can now access the
N            // shared resource.
N
N            // ...
N            // For some reason due to the nature of the code further calls to
N			// xSemaphoreTakeRecursive() are made on the same mutex.  In real
N			// code these would not be just sequential calls as this would make
N			// no sense.  Instead the calls are likely to be buried inside
N			// a more complex call structure.
N            xSemaphoreTakeRecursive( xMutex, ( TickType_t ) 10 );
N            xSemaphoreTakeRecursive( xMutex, ( TickType_t ) 10 );
N
N            // The mutex has now been 'taken' three times, so will not be
N			// available to another task until it has also been given back
N			// three times.  Again it is unlikely that real code would have
N			// these calls sequentially, it would be more likely that the calls
N			// to xSemaphoreGiveRecursive() would be called as a call stack
N			// unwound.  This is just for demonstrative purposes.
N            xSemaphoreGiveRecursive( xMutex );
N			xSemaphoreGiveRecursive( xMutex );
N			xSemaphoreGiveRecursive( xMutex );
N
N			// Now the mutex can be taken by other tasks.
N        }
N        else
N        {
N            // We could not obtain the mutex and can therefore not access
N            // the shared resource safely.
N        }
N    }
N }
N </pre>
N * \defgroup xSemaphoreGiveRecursive xSemaphoreGiveRecursive
N * \ingroup Semaphores
N */
N#if( configUSE_RECURSIVE_MUTEXES == 1 )
X#if( 1 == 1 )
N	#define xSemaphoreGiveRecursive( xMutex )	xQueueGiveMutexRecursive( ( xMutex ) )
N#endif
N
N/**
N * semphr. h
N * <pre>
N xSemaphoreGiveFromISR(
N                          SemaphoreHandle_t xSemaphore,
N                          BaseType_t *pxHigherPriorityTaskWoken
N                      )</pre>
N *
N * <i>Macro</i> to  release a semaphore.  The semaphore must have previously been
N * created with a call to xSemaphoreCreateBinary() or xSemaphoreCreateCounting().
N *
N * Mutex type semaphores (those created using a call to xSemaphoreCreateMutex())
N * must not be used with this macro.
N *
N * This macro can be used from an ISR.
N *
N * @param xSemaphore A handle to the semaphore being released.  This is the
N * handle returned when the semaphore was created.
N *
N * @param pxHigherPriorityTaskWoken xSemaphoreGiveFromISR() will set
N * *pxHigherPriorityTaskWoken to pdTRUE if giving the semaphore caused a task
N * to unblock, and the unblocked task has a priority higher than the currently
N * running task.  If xSemaphoreGiveFromISR() sets this value to pdTRUE then
N * a context switch should be requested before the interrupt is exited.
N *
N * @return pdTRUE if the semaphore was successfully given, otherwise errQUEUE_FULL.
N *
N * Example usage:
N <pre>
N \#define LONG_TIME 0xffff
N \#define TICKS_TO_WAIT	10
N SemaphoreHandle_t xSemaphore = NULL;
N
N // Repetitive task.
N void vATask( void * pvParameters )
N {
N    for( ;; )
N    {
N        // We want this task to run every 10 ticks of a timer.  The semaphore
N        // was created before this task was started.
N
N        // Block waiting for the semaphore to become available.
N        if( xSemaphoreTake( xSemaphore, LONG_TIME ) == pdTRUE )
N        {
N            // It is time to execute.
N
N            // ...
N
N            // We have finished our task.  Return to the top of the loop where
N            // we will block on the semaphore until it is time to execute
N            // again.  Note when using the semaphore for synchronisation with an
N			// ISR in this manner there is no need to 'give' the semaphore back.
N        }
N    }
N }
N
N // Timer ISR
N void vTimerISR( void * pvParameters )
N {
N static uint8_t ucLocalTickCount = 0;
N static BaseType_t xHigherPriorityTaskWoken;
N
N    // A timer tick has occurred.
N
N    // ... Do other time functions.
N
N    // Is it time for vATask () to run?
N	xHigherPriorityTaskWoken = pdFALSE;
N    ucLocalTickCount++;
N    if( ucLocalTickCount >= TICKS_TO_WAIT )
N    {
N        // Unblock the task by releasing the semaphore.
N        xSemaphoreGiveFromISR( xSemaphore, &xHigherPriorityTaskWoken );
N
N        // Reset the count so we release the semaphore again in 10 ticks time.
N        ucLocalTickCount = 0;
N    }
N
N    if( xHigherPriorityTaskWoken != pdFALSE )
N    {
N        // We can force a context switch here.  Context switching from an
N        // ISR uses port specific syntax.  Check the demo task for your port
N        // to find the syntax required.
N    }
N }
N </pre>
N * \defgroup xSemaphoreGiveFromISR xSemaphoreGiveFromISR
N * \ingroup Semaphores
N */
N#define xSemaphoreGiveFromISR( xSemaphore, pxHigherPriorityTaskWoken )	xQueueGiveFromISR( ( QueueHandle_t ) ( xSemaphore ), ( pxHigherPriorityTaskWoken ) )
N
N/**
N * semphr. h
N * <pre>
N xSemaphoreTakeFromISR(
N                          SemaphoreHandle_t xSemaphore,
N                          BaseType_t *pxHigherPriorityTaskWoken
N                      )</pre>
N *
N * <i>Macro</i> to  take a semaphore from an ISR.  The semaphore must have
N * previously been created with a call to xSemaphoreCreateBinary() or
N * xSemaphoreCreateCounting().
N *
N * Mutex type semaphores (those created using a call to xSemaphoreCreateMutex())
N * must not be used with this macro.
N *
N * This macro can be used from an ISR, however taking a semaphore from an ISR
N * is not a common operation.  It is likely to only be useful when taking a
N * counting semaphore when an interrupt is obtaining an object from a resource
N * pool (when the semaphore count indicates the number of resources available).
N *
N * @param xSemaphore A handle to the semaphore being taken.  This is the
N * handle returned when the semaphore was created.
N *
N * @param pxHigherPriorityTaskWoken xSemaphoreTakeFromISR() will set
N * *pxHigherPriorityTaskWoken to pdTRUE if taking the semaphore caused a task
N * to unblock, and the unblocked task has a priority higher than the currently
N * running task.  If xSemaphoreTakeFromISR() sets this value to pdTRUE then
N * a context switch should be requested before the interrupt is exited.
N *
N * @return pdTRUE if the semaphore was successfully taken, otherwise
N * pdFALSE
N */
N#define xSemaphoreTakeFromISR( xSemaphore, pxHigherPriorityTaskWoken )	xQueueReceiveFromISR( ( QueueHandle_t ) ( xSemaphore ), NULL, ( pxHigherPriorityTaskWoken ) )
N
N/**
N * semphr. h
N * <pre>SemaphoreHandle_t xSemaphoreCreateMutex( void )</pre>
N *
N * Creates a new mutex type semaphore instance, and returns a handle by which
N * the new mutex can be referenced.
N *
N * Internally, within the FreeRTOS implementation, mutex semaphores use a block
N * of memory, in which the mutex structure is stored.  If a mutex is created
N * using xSemaphoreCreateMutex() then the required memory is automatically
N * dynamically allocated inside the xSemaphoreCreateMutex() function.  (see
N * http://www.freertos.org/a00111.html).  If a mutex is created using
N * xSemaphoreCreateMutexStatic() then the application writer must provided the
N * memory.  xSemaphoreCreateMutexStatic() therefore allows a mutex to be created
N * without using any dynamic memory allocation.
N *
N * Mutexes created using this function can be accessed using the xSemaphoreTake()
N * and xSemaphoreGive() macros.  The xSemaphoreTakeRecursive() and
N * xSemaphoreGiveRecursive() macros must not be used.
N *
N * This type of semaphore uses a priority inheritance mechanism so a task
N * 'taking' a semaphore MUST ALWAYS 'give' the semaphore back once the
N * semaphore it is no longer required.
N *
N * Mutex type semaphores cannot be used from within interrupt service routines.
N *
N * See xSemaphoreCreateBinary() for an alternative implementation that can be
N * used for pure synchronisation (where one task or interrupt always 'gives' the
N * semaphore and another always 'takes' the semaphore) and from within interrupt
N * service routines.
N *
N * @return If the mutex was successfully created then a handle to the created
N * semaphore is returned.  If there was not enough heap to allocate the mutex
N * data structures then NULL is returned.
N *
N * Example usage:
N <pre>
N SemaphoreHandle_t xSemaphore;
N
N void vATask( void * pvParameters )
N {
N    // Semaphore cannot be used before a call to xSemaphoreCreateMutex().
N    // This is a macro so pass the variable in directly.
N    xSemaphore = xSemaphoreCreateMutex();
N
N    if( xSemaphore != NULL )
N    {
N        // The semaphore was created successfully.
N        // The semaphore can now be used.
N    }
N }
N </pre>
N * \defgroup xSemaphoreCreateMutex xSemaphoreCreateMutex
N * \ingroup Semaphores
N */
N#if( configSUPPORT_DYNAMIC_ALLOCATION == 1 )
X#if( 1 == 1 )
N	#define xSemaphoreCreateMutex() xQueueCreateMutex( queueQUEUE_TYPE_MUTEX )
N#endif
N
N/**
N * semphr. h
N * <pre>SemaphoreHandle_t xSemaphoreCreateMutexStatic( StaticSemaphore_t *pxMutexBuffer )</pre>
N *
N * Creates a new mutex type semaphore instance, and returns a handle by which
N * the new mutex can be referenced.
N *
N * Internally, within the FreeRTOS implementation, mutex semaphores use a block
N * of memory, in which the mutex structure is stored.  If a mutex is created
N * using xSemaphoreCreateMutex() then the required memory is automatically
N * dynamically allocated inside the xSemaphoreCreateMutex() function.  (see
N * http://www.freertos.org/a00111.html).  If a mutex is created using
N * xSemaphoreCreateMutexStatic() then the application writer must provided the
N * memory.  xSemaphoreCreateMutexStatic() therefore allows a mutex to be created
N * without using any dynamic memory allocation.
N *
N * Mutexes created using this function can be accessed using the xSemaphoreTake()
N * and xSemaphoreGive() macros.  The xSemaphoreTakeRecursive() and
N * xSemaphoreGiveRecursive() macros must not be used.
N *
N * This type of semaphore uses a priority inheritance mechanism so a task
N * 'taking' a semaphore MUST ALWAYS 'give' the semaphore back once the
N * semaphore it is no longer required.
N *
N * Mutex type semaphores cannot be used from within interrupt service routines.
N *
N * See xSemaphoreCreateBinary() for an alternative implementation that can be
N * used for pure synchronisation (where one task or interrupt always 'gives' the
N * semaphore and another always 'takes' the semaphore) and from within interrupt
N * service routines.
N *
N * @param pxMutexBuffer Must point to a variable of type StaticSemaphore_t,
N * which will be used to hold the mutex's data structure, removing the need for
N * the memory to be allocated dynamically.
N *
N * @return If the mutex was successfully created then a handle to the created
N * mutex is returned.  If pxMutexBuffer was NULL then NULL is returned.
N *
N * Example usage:
N <pre>
N SemaphoreHandle_t xSemaphore;
N StaticSemaphore_t xMutexBuffer;
N
N void vATask( void * pvParameters )
N {
N    // A mutex cannot be used before it has been created.  xMutexBuffer is
N    // into xSemaphoreCreateMutexStatic() so no dynamic memory allocation is
N    // attempted.
N    xSemaphore = xSemaphoreCreateMutexStatic( &xMutexBuffer );
N
N    // As no dynamic memory allocation was performed, xSemaphore cannot be NULL,
N    // so there is no need to check it.
N }
N </pre>
N * \defgroup xSemaphoreCreateMutexStatic xSemaphoreCreateMutexStatic
N * \ingroup Semaphores
N */
N #if( configSUPPORT_STATIC_ALLOCATION == 1 )
X #if( 0 == 1 )
S	#define xSemaphoreCreateMutexStatic( pxMutexBuffer ) xQueueCreateMutexStatic( queueQUEUE_TYPE_MUTEX, ( pxMutexBuffer ) )
N#endif /* configSUPPORT_STATIC_ALLOCATION */
N
N
N/**
N * semphr. h
N * <pre>SemaphoreHandle_t xSemaphoreCreateRecursiveMutex( void )</pre>
N *
N * Creates a new recursive mutex type semaphore instance, and returns a handle
N * by which the new recursive mutex can be referenced.
N *
N * Internally, within the FreeRTOS implementation, recursive mutexs use a block
N * of memory, in which the mutex structure is stored.  If a recursive mutex is
N * created using xSemaphoreCreateRecursiveMutex() then the required memory is
N * automatically dynamically allocated inside the
N * xSemaphoreCreateRecursiveMutex() function.  (see
N * http://www.freertos.org/a00111.html).  If a recursive mutex is created using
N * xSemaphoreCreateRecursiveMutexStatic() then the application writer must
N * provide the memory that will get used by the mutex.
N * xSemaphoreCreateRecursiveMutexStatic() therefore allows a recursive mutex to
N * be created without using any dynamic memory allocation.
N *
N * Mutexes created using this macro can be accessed using the
N * xSemaphoreTakeRecursive() and xSemaphoreGiveRecursive() macros.  The
N * xSemaphoreTake() and xSemaphoreGive() macros must not be used.
N *
N * A mutex used recursively can be 'taken' repeatedly by the owner. The mutex
N * doesn't become available again until the owner has called
N * xSemaphoreGiveRecursive() for each successful 'take' request.  For example,
N * if a task successfully 'takes' the same mutex 5 times then the mutex will
N * not be available to any other task until it has also  'given' the mutex back
N * exactly five times.
N *
N * This type of semaphore uses a priority inheritance mechanism so a task
N * 'taking' a semaphore MUST ALWAYS 'give' the semaphore back once the
N * semaphore it is no longer required.
N *
N * Mutex type semaphores cannot be used from within interrupt service routines.
N *
N * See xSemaphoreCreateBinary() for an alternative implementation that can be
N * used for pure synchronisation (where one task or interrupt always 'gives' the
N * semaphore and another always 'takes' the semaphore) and from within interrupt
N * service routines.
N *
N * @return xSemaphore Handle to the created mutex semaphore.  Should be of type
N * SemaphoreHandle_t.
N *
N * Example usage:
N <pre>
N SemaphoreHandle_t xSemaphore;
N
N void vATask( void * pvParameters )
N {
N    // Semaphore cannot be used before a call to xSemaphoreCreateMutex().
N    // This is a macro so pass the variable in directly.
N    xSemaphore = xSemaphoreCreateRecursiveMutex();
N
N    if( xSemaphore != NULL )
N    {
N        // The semaphore was created successfully.
N        // The semaphore can now be used.
N    }
N }
N </pre>
N * \defgroup xSemaphoreCreateRecursiveMutex xSemaphoreCreateRecursiveMutex
N * \ingroup Semaphores
N */
N#if( ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) && ( configUSE_RECURSIVE_MUTEXES == 1 ) )
X#if( ( 1 == 1 ) && ( 1 == 1 ) )
N	#define xSemaphoreCreateRecursiveMutex() xQueueCreateMutex( queueQUEUE_TYPE_RECURSIVE_MUTEX )
N#endif
N
N/**
N * semphr. h
N * <pre>SemaphoreHandle_t xSemaphoreCreateRecursiveMutexStatic( StaticSemaphore_t *pxMutexBuffer )</pre>
N *
N * Creates a new recursive mutex type semaphore instance, and returns a handle
N * by which the new recursive mutex can be referenced.
N *
N * Internally, within the FreeRTOS implementation, recursive mutexs use a block
N * of memory, in which the mutex structure is stored.  If a recursive mutex is
N * created using xSemaphoreCreateRecursiveMutex() then the required memory is
N * automatically dynamically allocated inside the
N * xSemaphoreCreateRecursiveMutex() function.  (see
N * http://www.freertos.org/a00111.html).  If a recursive mutex is created using
N * xSemaphoreCreateRecursiveMutexStatic() then the application writer must
N * provide the memory that will get used by the mutex.
N * xSemaphoreCreateRecursiveMutexStatic() therefore allows a recursive mutex to
N * be created without using any dynamic memory allocation.
N *
N * Mutexes created using this macro can be accessed using the
N * xSemaphoreTakeRecursive() and xSemaphoreGiveRecursive() macros.  The
N * xSemaphoreTake() and xSemaphoreGive() macros must not be used.
N *
N * A mutex used recursively can be 'taken' repeatedly by the owner. The mutex
N * doesn't become available again until the owner has called
N * xSemaphoreGiveRecursive() for each successful 'take' request.  For example,
N * if a task successfully 'takes' the same mutex 5 times then the mutex will
N * not be available to any other task until it has also  'given' the mutex back
N * exactly five times.
N *
N * This type of semaphore uses a priority inheritance mechanism so a task
N * 'taking' a semaphore MUST ALWAYS 'give' the semaphore back once the
N * semaphore it is no longer required.
N *
N * Mutex type semaphores cannot be used from within interrupt service routines.
N *
N * See xSemaphoreCreateBinary() for an alternative implementation that can be
N * used for pure synchronisation (where one task or interrupt always 'gives' the
N * semaphore and another always 'takes' the semaphore) and from within interrupt
N * service routines.
N *
N * @param pxMutexBuffer Must point to a variable of type StaticSemaphore_t,
N * which will then be used to hold the recursive mutex's data structure,
N * removing the need for the memory to be allocated dynamically.
N *
N * @return If the recursive mutex was successfully created then a handle to the
N * created recursive mutex is returned.  If pxMutexBuffer was NULL then NULL is
N * returned.
N *
N * Example usage:
N <pre>
N SemaphoreHandle_t xSemaphore;
N StaticSemaphore_t xMutexBuffer;
N
N void vATask( void * pvParameters )
N {
N    // A recursive semaphore cannot be used before it is created.  Here a
N    // recursive mutex is created using xSemaphoreCreateRecursiveMutexStatic().
N    // The address of xMutexBuffer is passed into the function, and will hold
N    // the mutexes data structures - so no dynamic memory allocation will be
N    // attempted.
N    xSemaphore = xSemaphoreCreateRecursiveMutexStatic( &xMutexBuffer );
N
N    // As no dynamic memory allocation was performed, xSemaphore cannot be NULL,
N    // so there is no need to check it.
N }
N </pre>
N * \defgroup xSemaphoreCreateRecursiveMutexStatic xSemaphoreCreateRecursiveMutexStatic
N * \ingroup Semaphores
N */
N#if( ( configSUPPORT_STATIC_ALLOCATION == 1 ) && ( configUSE_RECURSIVE_MUTEXES == 1 ) )
X#if( ( 0 == 1 ) && ( 1 == 1 ) )
S	#define xSemaphoreCreateRecursiveMutexStatic( pxStaticSemaphore ) xQueueCreateMutexStatic( queueQUEUE_TYPE_RECURSIVE_MUTEX, pxStaticSemaphore )
N#endif /* configSUPPORT_STATIC_ALLOCATION */
N
N/**
N * semphr. h
N * <pre>SemaphoreHandle_t xSemaphoreCreateCounting( UBaseType_t uxMaxCount, UBaseType_t uxInitialCount )</pre>
N *
N * Creates a new counting semaphore instance, and returns a handle by which the
N * new counting semaphore can be referenced.
N *
N * In many usage scenarios it is faster and more memory efficient to use a
N * direct to task notification in place of a counting semaphore!
N * http://www.freertos.org/RTOS-task-notifications.html
N *
N * Internally, within the FreeRTOS implementation, counting semaphores use a
N * block of memory, in which the counting semaphore structure is stored.  If a
N * counting semaphore is created using xSemaphoreCreateCounting() then the
N * required memory is automatically dynamically allocated inside the
N * xSemaphoreCreateCounting() function.  (see
N * http://www.freertos.org/a00111.html).  If a counting semaphore is created
N * using xSemaphoreCreateCountingStatic() then the application writer can
N * instead optionally provide the memory that will get used by the counting
N * semaphore.  xSemaphoreCreateCountingStatic() therefore allows a counting
N * semaphore to be created without using any dynamic memory allocation.
N *
N * Counting semaphores are typically used for two things:
N *
N * 1) Counting events.
N *
N *    In this usage scenario an event handler will 'give' a semaphore each time
N *    an event occurs (incrementing the semaphore count value), and a handler
N *    task will 'take' a semaphore each time it processes an event
N *    (decrementing the semaphore count value).  The count value is therefore
N *    the difference between the number of events that have occurred and the
N *    number that have been processed.  In this case it is desirable for the
N *    initial count value to be zero.
N *
N * 2) Resource management.
N *
N *    In this usage scenario the count value indicates the number of resources
N *    available.  To obtain control of a resource a task must first obtain a
N *    semaphore - decrementing the semaphore count value.  When the count value
N *    reaches zero there are no free resources.  When a task finishes with the
N *    resource it 'gives' the semaphore back - incrementing the semaphore count
N *    value.  In this case it is desirable for the initial count value to be
N *    equal to the maximum count value, indicating that all resources are free.
N *
N * @param uxMaxCount The maximum count value that can be reached.  When the
N *        semaphore reaches this value it can no longer be 'given'.
N *
N * @param uxInitialCount The count value assigned to the semaphore when it is
N *        created.
N *
N * @return Handle to the created semaphore.  Null if the semaphore could not be
N *         created.
N *
N * Example usage:
N <pre>
N SemaphoreHandle_t xSemaphore;
N
N void vATask( void * pvParameters )
N {
N SemaphoreHandle_t xSemaphore = NULL;
N
N    // Semaphore cannot be used before a call to xSemaphoreCreateCounting().
N    // The max value to which the semaphore can count should be 10, and the
N    // initial value assigned to the count should be 0.
N    xSemaphore = xSemaphoreCreateCounting( 10, 0 );
N
N    if( xSemaphore != NULL )
N    {
N        // The semaphore was created successfully.
N        // The semaphore can now be used.
N    }
N }
N </pre>
N * \defgroup xSemaphoreCreateCounting xSemaphoreCreateCounting
N * \ingroup Semaphores
N */
N#if( configSUPPORT_DYNAMIC_ALLOCATION == 1 )
X#if( 1 == 1 )
N	#define xSemaphoreCreateCounting( uxMaxCount, uxInitialCount ) xQueueCreateCountingSemaphore( ( uxMaxCount ), ( uxInitialCount ) )
N#endif
N
N/**
N * semphr. h
N * <pre>SemaphoreHandle_t xSemaphoreCreateCountingStatic( UBaseType_t uxMaxCount, UBaseType_t uxInitialCount, StaticSemaphore_t *pxSemaphoreBuffer )</pre>
N *
N * Creates a new counting semaphore instance, and returns a handle by which the
N * new counting semaphore can be referenced.
N *
N * In many usage scenarios it is faster and more memory efficient to use a
N * direct to task notification in place of a counting semaphore!
N * http://www.freertos.org/RTOS-task-notifications.html
N *
N * Internally, within the FreeRTOS implementation, counting semaphores use a
N * block of memory, in which the counting semaphore structure is stored.  If a
N * counting semaphore is created using xSemaphoreCreateCounting() then the
N * required memory is automatically dynamically allocated inside the
N * xSemaphoreCreateCounting() function.  (see
N * http://www.freertos.org/a00111.html).  If a counting semaphore is created
N * using xSemaphoreCreateCountingStatic() then the application writer must
N * provide the memory.  xSemaphoreCreateCountingStatic() therefore allows a
N * counting semaphore to be created without using any dynamic memory allocation.
N *
N * Counting semaphores are typically used for two things:
N *
N * 1) Counting events.
N *
N *    In this usage scenario an event handler will 'give' a semaphore each time
N *    an event occurs (incrementing the semaphore count value), and a handler
N *    task will 'take' a semaphore each time it processes an event
N *    (decrementing the semaphore count value).  The count value is therefore
N *    the difference between the number of events that have occurred and the
N *    number that have been processed.  In this case it is desirable for the
N *    initial count value to be zero.
N *
N * 2) Resource management.
N *
N *    In this usage scenario the count value indicates the number of resources
N *    available.  To obtain control of a resource a task must first obtain a
N *    semaphore - decrementing the semaphore count value.  When the count value
N *    reaches zero there are no free resources.  When a task finishes with the
N *    resource it 'gives' the semaphore back - incrementing the semaphore count
N *    value.  In this case it is desirable for the initial count value to be
N *    equal to the maximum count value, indicating that all resources are free.
N *
N * @param uxMaxCount The maximum count value that can be reached.  When the
N *        semaphore reaches this value it can no longer be 'given'.
N *
N * @param uxInitialCount The count value assigned to the semaphore when it is
N *        created.
N *
N * @param pxSemaphoreBuffer Must point to a variable of type StaticSemaphore_t,
N * which will then be used to hold the semaphore's data structure, removing the
N * need for the memory to be allocated dynamically.
N *
N * @return If the counting semaphore was successfully created then a handle to
N * the created counting semaphore is returned.  If pxSemaphoreBuffer was NULL
N * then NULL is returned.
N *
N * Example usage:
N <pre>
N SemaphoreHandle_t xSemaphore;
N StaticSemaphore_t xSemaphoreBuffer;
N
N void vATask( void * pvParameters )
N {
N SemaphoreHandle_t xSemaphore = NULL;
N
N    // Counting semaphore cannot be used before they have been created.  Create
N    // a counting semaphore using xSemaphoreCreateCountingStatic().  The max
N    // value to which the semaphore can count is 10, and the initial value
N    // assigned to the count will be 0.  The address of xSemaphoreBuffer is
N    // passed in and will be used to hold the semaphore structure, so no dynamic
N    // memory allocation will be used.
N    xSemaphore = xSemaphoreCreateCounting( 10, 0, &xSemaphoreBuffer );
N
N    // No memory allocation was attempted so xSemaphore cannot be NULL, so there
N    // is no need to check its value.
N }
N </pre>
N * \defgroup xSemaphoreCreateCountingStatic xSemaphoreCreateCountingStatic
N * \ingroup Semaphores
N */
N#if( configSUPPORT_STATIC_ALLOCATION == 1 )
X#if( 0 == 1 )
S	#define xSemaphoreCreateCountingStatic( uxMaxCount, uxInitialCount, pxSemaphoreBuffer ) xQueueCreateCountingSemaphoreStatic( ( uxMaxCount ), ( uxInitialCount ), ( pxSemaphoreBuffer ) )
N#endif /* configSUPPORT_STATIC_ALLOCATION */
N
N/**
N * semphr. h
N * <pre>void vSemaphoreDelete( SemaphoreHandle_t xSemaphore );</pre>
N *
N * Delete a semaphore.  This function must be used with care.  For example,
N * do not delete a mutex type semaphore if the mutex is held by a task.
N *
N * @param xSemaphore A handle to the semaphore to be deleted.
N *
N * \defgroup vSemaphoreDelete vSemaphoreDelete
N * \ingroup Semaphores
N */
N#define vSemaphoreDelete( xSemaphore ) vQueueDelete( ( QueueHandle_t ) ( xSemaphore ) )
N
N/**
N * semphr.h
N * <pre>TaskHandle_t xSemaphoreGetMutexHolder( SemaphoreHandle_t xMutex );</pre>
N *
N * If xMutex is indeed a mutex type semaphore, return the current mutex holder.
N * If xMutex is not a mutex type semaphore, or the mutex is available (not held
N * by a task), return NULL.
N *
N * Note: This is a good way of determining if the calling task is the mutex
N * holder, but not a good way of determining the identity of the mutex holder as
N * the holder may change between the function exiting and the returned value
N * being tested.
N */
N#define xSemaphoreGetMutexHolder( xSemaphore ) xQueueGetMutexHolder( ( xSemaphore ) )
N
N/**
N * semphr.h
N * <pre>UBaseType_t uxSemaphoreGetCount( SemaphoreHandle_t xSemaphore );</pre>
N *
N * If the semaphore is a counting semaphore then uxSemaphoreGetCount() returns
N * its current count value.  If the semaphore is a binary semaphore then
N * uxSemaphoreGetCount() returns 1 if the semaphore is available, and 0 if the
N * semaphore is not available.
N *
N */
N#define uxSemaphoreGetCount( xSemaphore ) uxQueueMessagesWaiting( ( QueueHandle_t ) ( xSemaphore ) )
N
N#endif /* SEMAPHORE_H */
N
N
L 29 "adc.c" 2
N
Nvoid ADC_init(void)
N{
N	ADC_InitTypeDef ADC_InitStructure; //Общая инициализацинная структура подсистемы АЦП
N	ADCx_InitTypeDef ADC1_InitStructure; //Инициализацинная структура для АЦП1
N	// Структура для инициализации портов	
N	PORT_InitTypeDef PortInitStructure;
N    /* Инициализация выводов АЦП  */
N    /* Разрешение тактирования портов с выводами АЦП (PORTD)*/
N   RST_CLK_PCLKcmd (RST_CLK_PCLK_ADC | RST_CLK_PCLK_PORTD, ENABLE);
X   RST_CLK_PCLKcmd (((uint32_t)(1U << ((((uint32_t)(0x40088000)) >> 15) & 0x1F))) | ((uint32_t)(1U << ((((uint32_t)(0x400C0000)) >> 15) & 0x1F))), ENABLE);
N   // Cделать вывод U_ADC_U_PIN=PD7 аналоговым:
N	PORT_StructInit (&PortInitStructure);
N	PortInitStructure.PORT_Pin = U_ADC_U_PIN;
X	PortInitStructure.PORT_Pin = 0x0080U;
N	PortInitStructure.PORT_MODE = PORT_MODE_ANALOG;
N	PORT_Init (MDR_PORTD, &PortInitStructure);
X	PORT_Init (((MDR_PORT_TypeDef *) (0x400C0000)), &PortInitStructure);
N	
N    /* Заполнение общих полей структуры ADC_InitStructure */
N	/*Режим независимого запуска двух АЦП*/
N	ADC_InitStructure.ADC_SynchronousMode = ADC_SyncMode_Independent;
X	ADC_InitStructure.ADC_SynchronousMode = (((uint32_t)0x0) << 16);
N	/*Задержка между запусками двух АЦП*/
N	ADC_InitStructure.ADC_StartDelay = 0;
N	// Отключение встроенного температурного датчика
N	ADC_InitStructure.ADC_TempSensor = ADC_TEMP_SENSOR_Disable;
X	ADC_InitStructure.ADC_TempSensor = (((uint32_t)0x0) << 17);
N	ADC_InitStructure.ADC_TempSensorAmplifier = ADC_TEMP_SENSOR_AMPLIFIER_Disable;
X	ADC_InitStructure.ADC_TempSensorAmplifier = (((uint32_t)0x0) << 18);
N	ADC_InitStructure.ADC_TempSensorConversion = ADC_TEMP_SENSOR_CONVERSION_Disable;
X	ADC_InitStructure.ADC_TempSensorConversion = (((uint32_t)0x0) << 19);
N	//Отключение внутреннего датчика опорного напряжения
N	ADC_InitStructure.ADC_IntVRefConversion = ADC_VREF_CONVERSION_Disable;
X	ADC_InitStructure.ADC_IntVRefConversion = (((uint32_t)0x0) << 20);
N	ADC_InitStructure.ADC_IntVRefTrimming = 0;
N	ADC_Init (&ADC_InitStructure);
N     
N		 /* Заполнение полей структуры ADC1_InitStructure */
N		 // Источник тактирования для АЦП от частоты ЦП
N	ADC1_InitStructure.ADC_ClockSource = ADC_CLOCK_SOURCE_CPU;
X	ADC1_InitStructure.ADC_ClockSource = (((uint32_t)0x0) << 2);
N	// Делитель частоты 16, fadc=fcpu/16=80МГц/16=5 МГц, максимально возможная частота 14МГц
N	ADC1_InitStructure.ADC_Prescaler = ADC_CLK_div_16;
X	ADC1_InitStructure.ADC_Prescaler = (((uint32_t)0x4) << 12);
N	// Режим одиночного преобразования
N	ADC1_InitStructure.ADC_SamplingMode = ADC_SAMPLING_MODE_SINGLE_CONV;
X	ADC1_InitStructure.ADC_SamplingMode = (((uint32_t)0x0) << 3);
N	// Автоматическое переключение каналов выключено
N	ADC1_InitStructure.ADC_ChannelSwitching = ADC_CH_SWITCHING_Disable;
X	ADC1_InitStructure.ADC_ChannelSwitching = (((uint32_t)0x0) << 9);
N	// Канал для оцифровки=7
N	ADC1_InitStructure.ADC_ChannelNumber = ADC_CH_ADC7;
X	ADC1_InitStructure.ADC_ChannelNumber = ((uint32_t)0x07);
N	// В автоматичиском режиме количество используемых каналов
N	ADC1_InitStructure.ADC_Channels = 0;
N	// В автоматическом режиме задержка между переключением каналов
N	ADC1_InitStructure.ADC_DelayGo = 7;
N	// Контроль за уровнем напряжения выключен
N	ADC1_InitStructure.ADC_LevelControl = ADC_LEVEL_CONTROL_Disable;
X	ADC1_InitStructure.ADC_LevelControl = (((uint32_t)0x0) << 10);
N	ADC1_InitStructure.ADC_LowLevel = 0;
N	ADC1_InitStructure.ADC_HighLevel = 0;
N	// Источник опорного напряжения - внутренний
N	ADC1_InitStructure.ADC_VRefSource = ADC_VREF_SOURCE_INTERNAL;
X	ADC1_InitStructure.ADC_VRefSource = (((uint32_t)0x0) << 11);
N	// Источник опорного напряжения без температурной компенсации
N	ADC1_InitStructure.ADC_IntVRefSource = ADC_INT_VREF_SOURCE_INEXACT;
X	ADC1_InitStructure.ADC_IntVRefSource = ((uint32_t)0x0);
N	ADC1_Init (&ADC1_InitStructure);
N
N    /* Разрешение работы АЦП1 */
N    ADC1_Cmd (ENABLE);
N}
N
N
N
N
N
N
N
N
